/*! mobile - v1.0.0 - 2017-06-19
* Copyright (c) 2017 ; Licensed  */

//! Source: node_modules/jquery/dist/jquery.js

try{
/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/underscore/underscore-min.js

try{
console.log('starting parsing underscore-min.js');
(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,v=e.reduce,h=e.reduceRight,g=e.filter,d=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,_=Object.keys,j=i.bind,w=function(n){return n instanceof w?n:this instanceof w?(this._wrapped=n,void 0):new w(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=w),exports._=w):n._=w,w.VERSION="1.4.3";var A=w.each=w.forEach=function(n,t,e){if(null!=n)if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a in n)if(w.has(n,a)&&t.call(e,n[a],a,n)===r)return};w.map=w.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e[e.length]=t.call(r,n,u,i)}),e)};var O="Reduce of empty array with no initial value";w.reduce=w.foldl=w.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduce===v)return e&&(t=w.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(O);return r},w.reduceRight=w.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduceRight===h)return e&&(t=w.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=w.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(O);return r},w.find=w.detect=function(n,t,r){var e;return E(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},w.filter=w.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&(e[e.length]=n)}),e)},w.reject=function(n,t,r){return w.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},w.every=w.all=function(n,t,e){t||(t=w.identity);var u=!0;return null==n?u:d&&n.every===d?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var E=w.some=w.any=function(n,t,e){t||(t=w.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};w.contains=w.include=function(n,t){return null==n?!1:y&&n.indexOf===y?-1!=n.indexOf(t):E(n,function(n){return n===t})},w.invoke=function(n,t){var r=o.call(arguments,2);return w.map(n,function(n){return(w.isFunction(t)?t:n[t]).apply(n,r)})},w.pluck=function(n,t){return w.map(n,function(n){return n[t]})},w.where=function(n,t){return w.isEmpty(t)?[]:w.filter(n,function(n){for(var r in t)if(t[r]!==n[r])return!1;return!0})},w.max=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.max.apply(Math,n);if(!t&&w.isEmpty(n))return-1/0;var e={computed:-1/0,value:-1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a>=e.computed&&(e={value:n,computed:a})}),e.value},w.min=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.min.apply(Math,n);if(!t&&w.isEmpty(n))return 1/0;var e={computed:1/0,value:1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;e.computed>a&&(e={value:n,computed:a})}),e.value},w.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=w.random(r++),e[r-1]=e[t],e[t]=n}),e};var F=function(n){return w.isFunction(n)?n:function(t){return t[n]}};w.sortBy=function(n,t,r){var e=F(t);return w.pluck(w.map(n,function(n,t,u){return{value:n,index:t,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||void 0===r)return 1;if(e>r||void 0===e)return-1}return n.index<t.index?-1:1}),"value")};var k=function(n,t,r,e){var u={},i=F(t||w.identity);return A(n,function(t,a){var o=i.call(r,t,a,n);e(u,o,t)}),u};w.groupBy=function(n,t,r){return k(n,t,r,function(n,t,r){(w.has(n,t)?n[t]:n[t]=[]).push(r)})},w.countBy=function(n,t,r){return k(n,t,r,function(n,t){w.has(n,t)||(n[t]=0),n[t]++})},w.sortedIndex=function(n,t,r,e){r=null==r?w.identity:F(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;u>r.call(e,n[o])?i=o+1:a=o}return i},w.toArray=function(n){return n?w.isArray(n)?o.call(n):n.length===+n.length?w.map(n,w.identity):w.values(n):[]},w.size=function(n){return null==n?0:n.length===+n.length?n.length:w.keys(n).length},w.first=w.head=w.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:o.call(n,0,t)},w.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},w.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},w.rest=w.tail=w.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},w.compact=function(n){return w.filter(n,w.identity)};var R=function(n,t,r){return A(n,function(n){w.isArray(n)?t?a.apply(r,n):R(n,t,r):r.push(n)}),r};w.flatten=function(n,t){return R(n,t,[])},w.without=function(n){return w.difference(n,o.call(arguments,1))},w.uniq=w.unique=function(n,t,r,e){w.isFunction(t)&&(e=r,r=t,t=!1);var u=r?w.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:w.contains(a,r))||(a.push(r),i.push(n[e]))}),i},w.union=function(){return w.uniq(c.apply(e,arguments))},w.intersection=function(n){var t=o.call(arguments,1);return w.filter(w.uniq(n),function(n){return w.every(t,function(t){return w.indexOf(t,n)>=0})})},w.difference=function(n){var t=c.apply(e,o.call(arguments,1));return w.filter(n,function(n){return!w.contains(t,n)})},w.zip=function(){for(var n=o.call(arguments),t=w.max(w.pluck(n,"length")),r=Array(t),e=0;t>e;e++)r[e]=w.pluck(n,""+e);return r},w.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},w.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=w.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},w.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},w.range=function(n,t,r){1>=arguments.length&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=Array(e);e>u;)i[u++]=n,n+=r;return i};var I=function(){};w.bind=function(n,t){var r,e;if(n.bind===j&&j)return j.apply(n,o.call(arguments,1));if(!w.isFunction(n))throw new TypeError;return r=o.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(o.call(arguments)));I.prototype=n.prototype;var u=new I;I.prototype=null;var i=n.apply(u,r.concat(o.call(arguments)));return Object(i)===i?i:u}},w.bindAll=function(n){var t=o.call(arguments,1);return 0==t.length&&(t=w.functions(n)),A(t,function(t){n[t]=w.bind(n[t],n)}),n},w.memoize=function(n,t){var r={};return t||(t=w.identity),function(){var e=t.apply(this,arguments);return w.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},w.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},w.defer=function(n){return w.delay.apply(w,[n,1].concat(o.call(arguments,1)))},w.throttle=function(n,t){var r,e,u,i,a=0,o=function(){a=new Date,u=null,i=n.apply(r,e)};return function(){var c=new Date,l=t-(c-a);return r=this,e=arguments,0>=l?(clearTimeout(u),u=null,a=c,i=n.apply(r,e)):u||(u=setTimeout(o,l)),i}},w.debounce=function(n,t,r){var e,u;return function(){var i=this,a=arguments,o=function(){e=null,r||(u=n.apply(i,a))},c=r&&!e;return clearTimeout(e),e=setTimeout(o,t),c&&(u=n.apply(i,a)),u}},w.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},w.wrap=function(n,t){return function(){var r=[n];return a.apply(r,arguments),t.apply(this,r)}},w.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},w.after=function(n,t){return 0>=n?t():function(){return 1>--n?t.apply(this,arguments):void 0}},w.keys=_||function(n){if(n!==Object(n))throw new TypeError("Invalid object");var t=[];for(var r in n)w.has(n,r)&&(t[t.length]=r);return t},w.values=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push(n[r]);return t},w.pairs=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push([r,n[r]]);return t},w.invert=function(n){var t={};for(var r in n)w.has(n,r)&&(t[n[r]]=r);return t},w.functions=w.methods=function(n){var t=[];for(var r in n)w.isFunction(n[r])&&t.push(r);return t.sort()},w.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},w.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},w.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)w.contains(r,u)||(t[u]=n[u]);return t},w.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)null==n[r]&&(n[r]=t[r])}),n},w.clone=function(n){return w.isObject(n)?w.isArray(n)?n.slice():w.extend({},n):n},w.tap=function(n,t){return t(n),n};var S=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof w&&(n=n._wrapped),t instanceof w&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case"[object String]":return n==t+"";case"[object Number]":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case"[object Date]":case"[object Boolean]":return+n==+t;case"[object RegExp]":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;r.push(n),e.push(t);var a=0,o=!0;if("[object Array]"==u){if(a=n.length,o=a==t.length)for(;a--&&(o=S(n[a],t[a],r,e)););}else{var c=n.constructor,f=t.constructor;if(c!==f&&!(w.isFunction(c)&&c instanceof c&&w.isFunction(f)&&f instanceof f))return!1;for(var s in n)if(w.has(n,s)&&(a++,!(o=w.has(t,s)&&S(n[s],t[s],r,e))))break;if(o){for(s in t)if(w.has(t,s)&&!a--)break;o=!a}}return r.pop(),e.pop(),o};w.isEqual=function(n,t){return S(n,t,[],[])},w.isEmpty=function(n){if(null==n)return!0;if(w.isArray(n)||w.isString(n))return 0===n.length;for(var t in n)if(w.has(n,t))return!1;return!0},w.isElement=function(n){return!(!n||1!==n.nodeType)},w.isArray=x||function(n){return"[object Array]"==l.call(n)},w.isObject=function(n){return n===Object(n)},A(["Arguments","Function","String","Number","Date","RegExp"],function(n){w["is"+n]=function(t){return l.call(t)=="[object "+n+"]"}}),w.isArguments(arguments)||(w.isArguments=function(n){return!(!n||!w.has(n,"callee"))}),w.isFunction=function(n){return"function"==typeof n},w.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},w.isNaN=function(n){return w.isNumber(n)&&n!=+n},w.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==l.call(n)},w.isNull=function(n){return null===n},w.isUndefined=function(n){return void 0===n},w.has=function(n,t){return f.call(n,t)},w.noConflict=function(){return n._=t,this},w.identity=function(n){return n},w.times=function(n,t,r){for(var e=Array(n),u=0;n>u;u++)e[u]=t.call(r,u);return e},w.random=function(n,t){return null==t&&(t=n,n=0),n+(0|Math.random()*(t-n+1))};var T={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};T.unescape=w.invert(T.escape);var M={escape:RegExp("["+w.keys(T.escape).join("")+"]","g"),unescape:RegExp("("+w.keys(T.unescape).join("|")+")","g")};w.each(["escape","unescape"],function(n){w[n]=function(t){return null==t?"":(""+t).replace(M[n],function(t){return T[n][t]})}}),w.result=function(n,t){if(null==n)return null;var r=n[t];return w.isFunction(r)?r.call(n):r},w.mixin=function(n){A(w.functions(n),function(t){var r=w[t]=n[t];w.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),z.call(this,r.apply(w,n))}})};var N=0;w.uniqueId=function(n){var t=""+ ++N;return n?n+t:t},w.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var q=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\t|\u2028|\u2029/g;w.template=function(n,t,r){r=w.defaults({},r,w.templateSettings);var e=RegExp([(r.escape||q).source,(r.interpolate||q).source,(r.evaluate||q).source].join("|")+"|$","g"),u=0,i="__p+='";n.replace(e,function(t,r,e,a,o){return i+=n.slice(u,o).replace(D,function(n){return"\\"+B[n]}),r&&(i+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'"),e&&(i+="'+\n((__t=("+e+"))==null?'':__t)+\n'"),a&&(i+="';\n"+a+"\n__p+='"),u=o+t.length,t}),i+="';\n",r.variable||(i="with(obj||{}){\n"+i+"}\n"),i="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+i+"return __p;\n";try{var a=Function(r.variable||"obj","_",i)}catch(o){throw o.source=i,o}if(t)return a(t,w);var c=function(n){return a.call(this,n,w)};return c.source="function("+(r.variable||"obj")+"){\n"+i+"}",c},w.chain=function(n){return w(n).chain()};var z=function(n){return this._chain?w(n).chain():n};w.mixin(w),A(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=e[n];w.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!=n&&"splice"!=n||0!==r.length||delete r[0],z.call(this,r)}}),A(["concat","join","slice"],function(n){var t=e[n];w.prototype[n]=function(){return z.call(this,t.apply(this._wrapped,arguments))}}),w.extend(w.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
console.log('ending parsing underscore-min.js');
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/backbone/backbone-min.js

try{
console.log('starting parsing backbone-min.js');
// Backbone.js 0.9.9

// (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
// Backbone may be freely distributed under the MIT license.
// For all details and documentation:
// http://backbonejs.org
(function(){var k=this,y=k.Backbone,h=[],z=h.push,r=h.slice,A=h.splice,g;g="undefined"!==typeof exports?exports:k.Backbone={};g.VERSION="0.9.9";var e=k._;!e&&"undefined"!==typeof require&&(e=require("underscore"));g.$=k.jQuery||k.Zepto||k.ender;g.noConflict=function(){k.Backbone=y;return this};g.emulateHTTP=!1;g.emulateJSON=!1;var s=/\s+/,n=function(a,b,c,d){if(!c)return!0;if("object"===typeof c)for(var f in c)a[b].apply(a,[f,c[f]].concat(d));else if(s.test(c)){c=c.split(s);f=0;for(var e=c.length;f<
e;f++)a[b].apply(a,[c[f]].concat(d))}else return!0},t=function(a,b,c){var d,a=-1,f=b.length;switch(c.length){case 0:for(;++a<f;)(d=b[a]).callback.call(d.ctx);break;case 1:for(;++a<f;)(d=b[a]).callback.call(d.ctx,c[0]);break;case 2:for(;++a<f;)(d=b[a]).callback.call(d.ctx,c[0],c[1]);break;case 3:for(;++a<f;)(d=b[a]).callback.call(d.ctx,c[0],c[1],c[2]);break;default:for(;++a<f;)(d=b[a]).callback.apply(d.ctx,c)}},h=g.Events={on:function(a,b,c){if(!n(this,"on",a,[b,c])||!b)return this;this._events||(this._events=
{});(this._events[a]||(this._events[a]=[])).push({callback:b,context:c,ctx:c||this});return this},once:function(a,b,c){if(!n(this,"once",a,[b,c])||!b)return this;var d=this,f=e.once(function(){d.off(a,f);b.apply(this,arguments)});f._callback=b;this.on(a,f,c);return this},off:function(a,b,c){var d,f,l,g,i,m,h,j;if(!this._events||!n(this,"off",a,[b,c]))return this;if(!a&&!b&&!c)return this._events={},this;g=a?[a]:e.keys(this._events);i=0;for(m=g.length;i<m;i++)if(a=g[i],d=this._events[a]){l=[];if(b||
c){h=0;for(j=d.length;h<j;h++)f=d[h],(b&&b!==(f.callback._callback||f.callback)||c&&c!==f.context)&&l.push(f)}this._events[a]=l}return this},trigger:function(a){if(!this._events)return this;var b=r.call(arguments,1);if(!n(this,"trigger",a,b))return this;var c=this._events[a],d=this._events.all;c&&t(this,c,b);d&&t(this,d,arguments);return this},listenTo:function(a,b,c){var d=this._listeners||(this._listeners={}),f=a._listenerId||(a._listenerId=e.uniqueId("l"));d[f]=a;a.on(b,c||this,this);return this},
stopListening:function(a,b,c){var d=this._listeners;if(d){if(a)a.off(b,c,this),!b&&!c&&delete d[a._listenerId];else{for(var f in d)d[f].off(null,null,this);this._listeners={}}return this}}};h.bind=h.on;h.unbind=h.off;e.extend(g,h);var o=g.Model=function(a,b){var c,d=a||{};this.cid=e.uniqueId("c");this.changed={};this.attributes={};this._changes=[];b&&b.collection&&(this.collection=b.collection);b&&b.parse&&(d=this.parse(d));(c=e.result(this,"defaults"))&&e.defaults(d,c);this.set(d,{silent:!0});this._currentAttributes=
e.clone(this.attributes);this._previousAttributes=e.clone(this.attributes);this.initialize.apply(this,arguments)};e.extend(o.prototype,h,{changed:null,idAttribute:"id",initialize:function(){},toJSON:function(){return e.clone(this.attributes)},sync:function(){return g.sync.apply(this,arguments)},get:function(a){return this.attributes[a]},escape:function(a){return e.escape(this.get(a))},has:function(a){return null!=this.get(a)},set:function(a,b,c){var d,f;if(null==a)return this;e.isObject(a)?(f=a,c=
b):(f={})[a]=b;var a=c&&c.silent,l=c&&c.unset;if(!this._validate(f,c))return!1;this.idAttribute in f&&(this.id=f[this.idAttribute]);var g=this.attributes;for(d in f)b=f[d],l?delete g[d]:g[d]=b,this._changes.push(d,b);this._hasComputed=!1;a||this.change(c);return this},unset:function(a,b){return this.set(a,void 0,e.extend({},b,{unset:!0}))},clear:function(a){var b={},c;for(c in this.attributes)b[c]=void 0;return this.set(b,e.extend({},a,{unset:!0}))},fetch:function(a){a=a?e.clone(a):{};void 0===a.parse&&
(a.parse=!0);var b=this,c=a.success;a.success=function(d){if(!b.set(b.parse(d),a))return false;c&&c(b,d,a)};return this.sync("read",this,a)},save:function(a,b,c){var d,f,g;null==a||e.isObject(a)?(d=a,c=b):null!=a&&((d={})[a]=b);c=c?e.clone(c):{};if(c.wait){if(d&&!this._validate(d,c))return!1;f=e.clone(this.attributes)}a=e.extend({},c,{silent:!0});if(d&&!this.set(d,c.wait?a:c)||!d&&!this._validate(null,c))return!1;var q=this,i=c.success;c.success=function(a){g=true;var b=q.parse(a);c.wait&&(b=e.extend(d||
{},b));if(!q.set(b,c))return false;i&&i(q,a,c)};b=this.isNew()?"create":c.patch?"patch":"update";"patch"==b&&(c.attrs=d);b=this.sync(b,this,c);!g&&c.wait&&(this.clear(a),this.set(f,a));return b},destroy:function(a){var a=a?e.clone(a):{},b=this,c=a.success,d=function(){b.trigger("destroy",b,b.collection,a)};a.success=function(f){(a.wait||b.isNew())&&d();c&&c(b,f,a)};if(this.isNew())return a.success(),!1;var f=this.sync("delete",this,a);a.wait||d();return f},url:function(){var a=e.result(this,"urlRoot")||
e.result(this.collection,"url")||u();return this.isNew()?a:a+("/"===a.charAt(a.length-1)?"":"/")+encodeURIComponent(this.id)},parse:function(a){return a},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return null==this.id},change:function(a){var b=this._changing;this._changing=!0;var c=this._computeChanges(!0);this._pending=!!c.length;for(var d=c.length-2;0<=d;d-=2)this.trigger("change:"+c[d],this,c[d+1],a);if(b)return this;for(;this._pending;)this._pending=!1,this.trigger("change",
this,a),this._previousAttributes=e.clone(this.attributes);this._changing=!1;return this},hasChanged:function(a){this._hasComputed||this._computeChanges();return null==a?!e.isEmpty(this.changed):e.has(this.changed,a)},changedAttributes:function(a){if(!a)return this.hasChanged()?e.clone(this.changed):!1;var b,c=!1,d=this._previousAttributes,f;for(f in a)if(!e.isEqual(d[f],b=a[f]))(c||(c={}))[f]=b;return c},_computeChanges:function(a){this.changed={};for(var b={},c=[],d=this._currentAttributes,f=this._changes,
e=f.length-2;0<=e;e-=2){var g=f[e],i=f[e+1];b[g]||(b[g]=!0,d[g]!==i&&(this.changed[g]=i,a&&(c.push(g,i),d[g]=i)))}a&&(this._changes=[]);this._hasComputed=!0;return c},previous:function(a){return null==a||!this._previousAttributes?null:this._previousAttributes[a]},previousAttributes:function(){return e.clone(this._previousAttributes)},_validate:function(a,b){if(!this.validate)return!0;var a=e.extend({},this.attributes,a),c=this.validate(a,b);if(!c)return!0;b&&b.error&&b.error(this,c,b);this.trigger("error",
this,c,b);return!1}});var p=g.Collection=function(a,b){b||(b={});b.model&&(this.model=b.model);void 0!==b.comparator&&(this.comparator=b.comparator);this._reset();this.initialize.apply(this,arguments);a&&this.reset(a,e.extend({silent:!0},b))};e.extend(p.prototype,h,{model:o,initialize:function(){},toJSON:function(a){return this.map(function(b){return b.toJSON(a)})},sync:function(){return g.sync.apply(this,arguments)},add:function(a,b){var c,d,f,g,h=b&&b.at,i=null==(b&&b.sort)?!0:b.sort,a=e.isArray(a)?
a.slice():[a];for(c=a.length-1;0<=c;c--)(d=this._prepareModel(a[c],b))?(a[c]=d,(f=null!=d.id&&this._byId[d.id])||this._byCid[d.cid]?(b&&(b.merge&&f)&&(f.set(d.attributes,b),g=i),a.splice(c,1)):(d.on("all",this._onModelEvent,this),this._byCid[d.cid]=d,null!=d.id&&(this._byId[d.id]=d))):(this.trigger("error",this,a[c],b),a.splice(c,1));a.length&&(g=i);this.length+=a.length;c=[null!=h?h:this.models.length,0];z.apply(c,a);A.apply(this.models,c);g&&(this.comparator&&null==h)&&this.sort({silent:!0});if(b&&
b.silent)return this;for(;d=a.shift();)d.trigger("add",d,this,b);return this},remove:function(a,b){var c,d,f,g;b||(b={});a=e.isArray(a)?a.slice():[a];c=0;for(d=a.length;c<d;c++)if(g=this.get(a[c]))delete this._byId[g.id],delete this._byCid[g.cid],f=this.indexOf(g),this.models.splice(f,1),this.length--,b.silent||(b.index=f,g.trigger("remove",g,this,b)),this._removeReference(g);return this},push:function(a,b){a=this._prepareModel(a,b);this.add(a,e.extend({at:this.length},b));return a},pop:function(a){var b=
this.at(this.length-1);this.remove(b,a);return b},unshift:function(a,b){a=this._prepareModel(a,b);this.add(a,e.extend({at:0},b));return a},shift:function(a){var b=this.at(0);this.remove(b,a);return b},slice:function(a,b){return this.models.slice(a,b)},get:function(a){return null==a?void 0:this._byId[null!=a.id?a.id:a]||this._byCid[a.cid||a]},at:function(a){return this.models[a]},where:function(a){return e.isEmpty(a)?[]:this.filter(function(b){for(var c in a)if(a[c]!==b.get(c))return!1;return!0})},
sort:function(a){if(!this.comparator)throw Error("Cannot sort a set without a comparator");e.isString(this.comparator)||1===this.comparator.length?this.models=this.sortBy(this.comparator,this):this.models.sort(e.bind(this.comparator,this));(!a||!a.silent)&&this.trigger("sort",this,a);return this},pluck:function(a){return e.invoke(this.models,"get",a)},update:function(a,b){var c,d,f,g,h=[],i=[],m={},j=this.model.prototype.idAttribute,b=e.extend({add:!0,merge:!0,remove:!0},b);b.parse&&(a=this.parse(a));
e.isArray(a)||(a=a?[a]:[]);if(b.add&&!b.remove)return this.add(a,b);d=0;for(f=a.length;d<f;d++)c=a[d],g=this.get(c.id||c.cid||c[j]),b.remove&&g&&(m[g.cid]=!0),(b.add&&!g||b.merge&&g)&&h.push(c);if(b.remove){d=0;for(f=this.models.length;d<f;d++)c=this.models[d],m[c.cid]||i.push(c)}i.length&&this.remove(i,b);h.length&&this.add(h,b);return this},reset:function(a,b){b||(b={});b.parse&&(a=this.parse(a));for(var c=0,d=this.models.length;c<d;c++)this._removeReference(this.models[c]);b.previousModels=this.models;
this._reset();a&&this.add(a,e.extend({silent:!0},b));b.silent||this.trigger("reset",this,b);return this},fetch:function(a){a=a?e.clone(a):{};void 0===a.parse&&(a.parse=!0);var b=this,c=a.success;a.success=function(d){b[a.update?"update":"reset"](d,a);c&&c(b,d,a)};return this.sync("read",this,a)},create:function(a,b){var c=this,b=b?e.clone(b):{},a=this._prepareModel(a,b);if(!a)return!1;b.wait||c.add(a,b);var d=b.success;b.success=function(a,b,e){e.wait&&c.add(a,e);d&&d(a,b,e)};a.save(null,b);return a},
parse:function(a){return a},clone:function(){return new this.constructor(this.models)},chain:function(){return e(this.models).chain()},_reset:function(){this.length=0;this.models=[];this._byId={};this._byCid={}},_prepareModel:function(a,b){if(a instanceof o)return a.collection||(a.collection=this),a;b||(b={});b.collection=this;var c=new this.model(a,b);return!c._validate(a,b)?!1:c},_removeReference:function(a){this===a.collection&&delete a.collection;a.off("all",this._onModelEvent,this)},_onModelEvent:function(a,
b,c,d){("add"===a||"remove"===a)&&c!==this||("destroy"===a&&this.remove(b,d),b&&a==="change:"+b.idAttribute&&(delete this._byId[b.previous(b.idAttribute)],null!=b.id&&(this._byId[b.id]=b)),this.trigger.apply(this,arguments))}});e.each("forEach each map collect reduce foldl inject reduceRight foldr find detect filter select reject every all some any include contains invoke max min sortedIndex toArray size first head take initial rest tail last without indexOf shuffle lastIndexOf isEmpty".split(" "),
function(a){p.prototype[a]=function(){var b=r.call(arguments);b.unshift(this.models);return e[a].apply(e,b)}});e.each(["groupBy","countBy","sortBy"],function(a){p.prototype[a]=function(b,c){var d=e.isFunction(b)?b:function(a){return a.get(b)};return e[a](this.models,d,c)}});var v=g.Router=function(a){a||(a={});a.routes&&(this.routes=a.routes);this._bindRoutes();this.initialize.apply(this,arguments)},B=/\((.*?)\)/g,C=/:\w+/g,D=/\*\w+/g,E=/[\-{}\[\]+?.,\\\^$|#\s]/g;e.extend(v.prototype,h,{initialize:function(){},
route:function(a,b,c){e.isRegExp(a)||(a=this._routeToRegExp(a));c||(c=this[b]);g.history.route(a,e.bind(function(d){d=this._extractParameters(a,d);c&&c.apply(this,d);this.trigger.apply(this,["route:"+b].concat(d));g.history.trigger("route",this,b,d)},this));return this},navigate:function(a,b){g.history.navigate(a,b);return this},_bindRoutes:function(){if(this.routes)for(var a,b=e.keys(this.routes);null!=(a=b.pop());)this.route(a,this.routes[a])},_routeToRegExp:function(a){a=a.replace(E,"\\$&").replace(B,
"(?:$1)?").replace(C,"([^/]+)").replace(D,"(.*?)");return RegExp("^"+a+"$")},_extractParameters:function(a,b){return a.exec(b).slice(1)}});var j=g.History=function(){this.handlers=[];e.bindAll(this,"checkUrl");"undefined"!==typeof window&&(this.location=window.location,this.history=window.history)},w=/^[#\/]|\s+$/g,F=/^\/+|\/+$/g,G=/msie [\w.]+/,H=/\/$/;j.started=!1;e.extend(j.prototype,h,{interval:50,getHash:function(a){return(a=(a||this).location.href.match(/#(.*)$/))?a[1]:""},getFragment:function(a,
b){if(null==a)if(this._hasPushState||!this._wantsHashChange||b){var a=this.location.pathname,c=this.root.replace(H,"");a.indexOf(c)||(a=a.substr(c.length))}else a=this.getHash();return a.replace(w,"")},start:function(a){if(j.started)throw Error("Backbone.history has already been started");j.started=!0;this.options=e.extend({},{root:"/"},this.options,a);this.root=this.options.root;this._wantsHashChange=!1!==this.options.hashChange;this._wantsPushState=!!this.options.pushState;this._hasPushState=!(!this.options.pushState||
!this.history||!this.history.pushState);var a=this.getFragment(),b=document.documentMode,b=G.exec(navigator.userAgent.toLowerCase())&&(!b||7>=b);this.root=("/"+this.root+"/").replace(F,"/");b&&this._wantsHashChange&&(this.iframe=g.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow,this.navigate(a));this._hasPushState?g.$(window).bind("popstate",this.checkUrl):this._wantsHashChange&&"onhashchange"in window&&!b?g.$(window).bind("hashchange",this.checkUrl):this._wantsHashChange&&
(this._checkUrlInterval=setInterval(this.checkUrl,this.interval));this.fragment=a;a=this.location;b=a.pathname.replace(/[^\/]$/,"$&/")===this.root;if(this._wantsHashChange&&this._wantsPushState&&!this._hasPushState&&!b)return this.fragment=this.getFragment(null,!0),this.location.replace(this.root+this.location.search+"#"+this.fragment),!0;this._wantsPushState&&(this._hasPushState&&b&&a.hash)&&(this.fragment=this.getHash().replace(w,""),this.history.replaceState({},document.title,this.root+this.fragment+
a.search));if(!this.options.silent)return this.loadUrl()},stop:function(){g.$(window).unbind("popstate",this.checkUrl).unbind("hashchange",this.checkUrl);clearInterval(this._checkUrlInterval);j.started=!1},route:function(a,b){this.handlers.unshift({route:a,callback:b})},checkUrl:function(){var a=this.getFragment();a===this.fragment&&this.iframe&&(a=this.getFragment(this.getHash(this.iframe)));if(a===this.fragment)return!1;this.iframe&&this.navigate(a);this.loadUrl()||this.loadUrl(this.getHash())},
loadUrl:function(a){var b=this.fragment=this.getFragment(a);return e.any(this.handlers,function(a){if(a.route.test(b))return a.callback(b),!0})},navigate:function(a,b){if(!j.started)return!1;if(!b||!0===b)b={trigger:b};a=this.getFragment(a||"");if(this.fragment!==a){this.fragment=a;var c=this.root+a;if(this._hasPushState)this.history[b.replace?"replaceState":"pushState"]({},document.title,c);else if(this._wantsHashChange)this._updateHash(this.location,a,b.replace),this.iframe&&a!==this.getFragment(this.getHash(this.iframe))&&
(b.replace||this.iframe.document.open().close(),this._updateHash(this.iframe.location,a,b.replace));else return this.location.assign(c);b.trigger&&this.loadUrl(a)}},_updateHash:function(a,b,c){c?(c=a.href.replace(/(javascript:|#).*$/,""),a.replace(c+"#"+b)):a.hash="#"+b}});g.history=new j;var x=g.View=function(a){this.cid=e.uniqueId("view");this._configure(a||{});this._ensureElement();this.initialize.apply(this,arguments);this.delegateEvents()},I=/^(\S+)\s*(.*)$/,J="model collection el id attributes className tagName events".split(" ");
e.extend(x.prototype,h,{tagName:"div",$:function(a){return this.$el.find(a)},initialize:function(){},render:function(){return this},remove:function(){this.$el.remove();this.stopListening();return this},make:function(a,b,c){a=document.createElement(a);b&&g.$(a).attr(b);null!=c&&g.$(a).html(c);return a},setElement:function(a,b){this.$el&&this.undelegateEvents();this.$el=a instanceof g.$?a:g.$(a);this.el=this.$el[0];!1!==b&&this.delegateEvents();return this},delegateEvents:function(a){if(a||(a=e.result(this,
"events"))){this.undelegateEvents();for(var b in a){var c=a[b];e.isFunction(c)||(c=this[a[b]]);if(!c)throw Error('Method "'+a[b]+'" does not exist');var d=b.match(I),f=d[1],d=d[2],c=e.bind(c,this),f=f+(".delegateEvents"+this.cid);""===d?this.$el.bind(f,c):this.$el.delegate(d,f,c)}}},undelegateEvents:function(){this.$el.unbind(".delegateEvents"+this.cid)},_configure:function(a){this.options&&(a=e.extend({},e.result(this,"options"),a));e.extend(this,e.pick(a,J));this.options=a},_ensureElement:function(){if(this.el)this.setElement(e.result(this,
"el"),!1);else{var a=e.extend({},e.result(this,"attributes"));this.id&&(a.id=e.result(this,"id"));this.className&&(a["class"]=e.result(this,"className"));this.setElement(this.make(e.result(this,"tagName"),a),!1)}}});var K={create:"POST",update:"PUT",patch:"PATCH","delete":"DELETE",read:"GET"};g.sync=function(a,b,c){var d=K[a];e.defaults(c||(c={}),{emulateHTTP:g.emulateHTTP,emulateJSON:g.emulateJSON});var f={type:d,dataType:"json"};c.url||(f.url=e.result(b,"url")||u());if(null==c.data&&b&&("create"===
a||"update"===a||"patch"===a))f.contentType="application/json",f.data=JSON.stringify(c.attrs||b.toJSON(c));c.emulateJSON&&(f.contentType="application/x-www-form-urlencoded",f.data=f.data?{model:f.data}:{});if(c.emulateHTTP&&("PUT"===d||"DELETE"===d||"PATCH"===d)){f.type="POST";c.emulateJSON&&(f.data._method=d);var h=c.beforeSend;c.beforeSend=function(a){a.setRequestHeader("X-HTTP-Method-Override",d);if(h)return h.apply(this,arguments)}}"GET"!==f.type&&!c.emulateJSON&&(f.processData=!1);var j=c.success;
c.success=function(a,d,e){j&&j(a,d,e);b.trigger("sync",b,a,c)};var i=c.error;c.error=function(a){i&&i(b,a,c);b.trigger("error",b,a,c)};a=g.ajax(e.extend(f,c));b.trigger("request",b,a,c);return a};g.ajax=function(){return g.$.ajax.apply(g.$,arguments)};o.extend=p.extend=v.extend=x.extend=j.extend=function(a,b){var c=this,d;d=a&&e.has(a,"constructor")?a.constructor:function(){c.apply(this,arguments)};e.extend(d,c,b);var f=function(){this.constructor=d};f.prototype=c.prototype;d.prototype=new f;a&&e.extend(d.prototype,
a);d.__super__=c.prototype;return d};var u=function(){throw Error('A "url" property or function must be specified');}}).call(this);
console.log('ending parsing backbone-min.js');
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/handlebars/2.0.0/handlebars.runtime.min.js

/*!

 handlebars v2.0.0

Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
!function(a,b){"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?module.exports=b():a.Handlebars=a.Handlebars||b()}(this,function(){var a=function(){"use strict";function a(a){this.string=a}var b;return a.prototype.toString=function(){return""+this.string},b=a}(),b=function(a){"use strict";function b(a){return i[a]}function c(a){for(var b=1;b<arguments.length;b++)for(var c in arguments[b])Object.prototype.hasOwnProperty.call(arguments[b],c)&&(a[c]=arguments[b][c]);return a}function d(a){return a instanceof h?a.toString():null==a?"":a?(a=""+a,k.test(a)?a.replace(j,b):a):a+""}function e(a){return a||0===a?n(a)&&0===a.length?!0:!1:!0}function f(a,b){return(a?a+".":"")+b}var g={},h=a,i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},j=/[&<>"'`]/g,k=/[&<>"'`]/;g.extend=c;var l=Object.prototype.toString;g.toString=l;var m=function(a){return"function"==typeof a};m(/x/)&&(m=function(a){return"function"==typeof a&&"[object Function]"===l.call(a)});var m;g.isFunction=m;var n=Array.isArray||function(a){return a&&"object"==typeof a?"[object Array]"===l.call(a):!1};return g.isArray=n,g.escapeExpression=d,g.isEmpty=e,g.appendContextPath=f,g}(a),c=function(){"use strict";function a(a,b){var d;b&&b.firstLine&&(d=b.firstLine,a+=" - "+d+":"+b.firstColumn);for(var e=Error.prototype.constructor.call(this,a),f=0;f<c.length;f++)this[c[f]]=e[c[f]];d&&(this.lineNumber=d,this.column=b.firstColumn)}var b,c=["description","fileName","lineNumber","message","name","number","stack"];return a.prototype=new Error,b=a}(),d=function(a,b){"use strict";function c(a,b){this.helpers=a||{},this.partials=b||{},d(this)}function d(a){a.registerHelper("helperMissing",function(){if(1===arguments.length)return void 0;throw new g("Missing helper: '"+arguments[arguments.length-1].name+"'")}),a.registerHelper("blockHelperMissing",function(b,c){var d=c.inverse,e=c.fn;if(b===!0)return e(this);if(b===!1||null==b)return d(this);if(k(b))return b.length>0?(c.ids&&(c.ids=[c.name]),a.helpers.each(b,c)):d(this);if(c.data&&c.ids){var g=q(c.data);g.contextPath=f.appendContextPath(c.data.contextPath,c.name),c={data:g}}return e(b,c)}),a.registerHelper("each",function(a,b){if(!b)throw new g("Must pass iterator to #each");var c,d,e=b.fn,h=b.inverse,i=0,j="";if(b.data&&b.ids&&(d=f.appendContextPath(b.data.contextPath,b.ids[0])+"."),l(a)&&(a=a.call(this)),b.data&&(c=q(b.data)),a&&"object"==typeof a)if(k(a))for(var m=a.length;m>i;i++)c&&(c.index=i,c.first=0===i,c.last=i===a.length-1,d&&(c.contextPath=d+i)),j+=e(a[i],{data:c});else for(var n in a)a.hasOwnProperty(n)&&(c&&(c.key=n,c.index=i,c.first=0===i,d&&(c.contextPath=d+n)),j+=e(a[n],{data:c}),i++);return 0===i&&(j=h(this)),j}),a.registerHelper("if",function(a,b){return l(a)&&(a=a.call(this)),!b.hash.includeZero&&!a||f.isEmpty(a)?b.inverse(this):b.fn(this)}),a.registerHelper("unless",function(b,c){return a.helpers["if"].call(this,b,{fn:c.inverse,inverse:c.fn,hash:c.hash})}),a.registerHelper("with",function(a,b){l(a)&&(a=a.call(this));var c=b.fn;if(f.isEmpty(a))return b.inverse(this);if(b.data&&b.ids){var d=q(b.data);d.contextPath=f.appendContextPath(b.data.contextPath,b.ids[0]),b={data:d}}return c(a,b)}),a.registerHelper("log",function(b,c){var d=c.data&&null!=c.data.level?parseInt(c.data.level,10):1;a.log(d,b)}),a.registerHelper("lookup",function(a,b){return a&&a[b]})}var e={},f=a,g=b,h="2.0.0";e.VERSION=h;var i=6;e.COMPILER_REVISION=i;var j={1:"<= 1.0.rc.2",2:"== 1.0.0-rc.3",3:"== 1.0.0-rc.4",4:"== 1.x.x",5:"== 2.0.0-alpha.x",6:">= 2.0.0-beta.1"};e.REVISION_CHANGES=j;var k=f.isArray,l=f.isFunction,m=f.toString,n="[object Object]";e.HandlebarsEnvironment=c,c.prototype={constructor:c,logger:o,log:p,registerHelper:function(a,b){if(m.call(a)===n){if(b)throw new g("Arg not supported with multiple helpers");f.extend(this.helpers,a)}else this.helpers[a]=b},unregisterHelper:function(a){delete this.helpers[a]},registerPartial:function(a,b){m.call(a)===n?f.extend(this.partials,a):this.partials[a]=b},unregisterPartial:function(a){delete this.partials[a]}};var o={methodMap:{0:"debug",1:"info",2:"warn",3:"error"},DEBUG:0,INFO:1,WARN:2,ERROR:3,level:3,log:function(a,b){if(o.level<=a){var c=o.methodMap[a];"undefined"!=typeof console&&console[c]&&console[c].call(console,b)}}};e.logger=o;var p=o.log;e.log=p;var q=function(a){var b=f.extend({},a);return b._parent=a,b};return e.createFrame=q,e}(b,c),e=function(a,b,c){"use strict";function d(a){var b=a&&a[0]||1,c=m;if(b!==c){if(c>b){var d=n[c],e=n[b];throw new l("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version ("+d+") or downgrade your runtime to an older version ("+e+").")}throw new l("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version ("+a[1]+").")}}function e(a,b){if(!b)throw new l("No environment passed to template");if(!a||!a.main)throw new l("Unknown template object: "+typeof a);b.VM.checkRevision(a.compiler);var c=function(c,d,e,f,g,h,i,j,m){g&&(f=k.extend({},f,g));var n=b.VM.invokePartial.call(this,c,e,f,h,i,j,m);if(null==n&&b.compile){var o={helpers:h,partials:i,data:j,depths:m};i[e]=b.compile(c,{data:void 0!==j,compat:a.compat},b),n=i[e](f,o)}if(null!=n){if(d){for(var p=n.split("\n"),q=0,r=p.length;r>q&&(p[q]||q+1!==r);q++)p[q]=d+p[q];n=p.join("\n")}return n}throw new l("The partial "+e+" could not be compiled when running in runtime-only mode")},d={lookup:function(a,b){for(var c=a.length,d=0;c>d;d++)if(a[d]&&null!=a[d][b])return a[d][b]},lambda:function(a,b){return"function"==typeof a?a.call(b):a},escapeExpression:k.escapeExpression,invokePartial:c,fn:function(b){return a[b]},programs:[],program:function(a,b,c){var d=this.programs[a],e=this.fn(a);return b||c?d=f(this,a,e,b,c):d||(d=this.programs[a]=f(this,a,e)),d},data:function(a,b){for(;a&&b--;)a=a._parent;return a},merge:function(a,b){var c=a||b;return a&&b&&a!==b&&(c=k.extend({},b,a)),c},noop:b.VM.noop,compilerInfo:a.compiler},e=function(b,c){c=c||{};var f=c.data;e._setup(c),!c.partial&&a.useData&&(f=i(b,f));var g;return a.useDepths&&(g=c.depths?[b].concat(c.depths):[b]),a.main.call(d,b,d.helpers,d.partials,f,g)};return e.isTop=!0,e._setup=function(c){c.partial?(d.helpers=c.helpers,d.partials=c.partials):(d.helpers=d.merge(c.helpers,b.helpers),a.usePartial&&(d.partials=d.merge(c.partials,b.partials)))},e._child=function(b,c,e){if(a.useDepths&&!e)throw new l("must pass parent depths");return f(d,b,a[b],c,e)},e}function f(a,b,c,d,e){var f=function(b,f){return f=f||{},c.call(a,b,a.helpers,a.partials,f.data||d,e&&[b].concat(e))};return f.program=b,f.depth=e?e.length:0,f}function g(a,b,c,d,e,f,g){var h={partial:!0,helpers:d,partials:e,data:f,depths:g};if(void 0===a)throw new l("The partial "+b+" could not be found");return a instanceof Function?a(c,h):void 0}function h(){return""}function i(a,b){return b&&"root"in b||(b=b?o(b):{},b.root=a),b}var j={},k=a,l=b,m=c.COMPILER_REVISION,n=c.REVISION_CHANGES,o=c.createFrame;return j.checkRevision=d,j.template=e,j.program=f,j.invokePartial=g,j.noop=h,j}(b,c,d),f=function(a,b,c,d,e){"use strict";var f,g=a,h=b,i=c,j=d,k=e,l=function(){var a=new g.HandlebarsEnvironment;return j.extend(a,g),a.SafeString=h,a.Exception=i,a.Utils=j,a.escapeExpression=j.escapeExpression,a.VM=k,a.template=function(b){return k.template(b,a)},a},m=l();return m.create=l,m["default"]=m,f=m}(d,a,c,b,e);return f});

//! Source: vendor/jquery-ui/jquery-ui.js

try{
/*! jQuery UI - v1.12.1 - 2017-05-17
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Focusable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
	var map, mapName, img, focusableIfVisible, fieldset,
		nodeName = element.nodeName.toLowerCase();

	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" );
		return img.length > 0 && img.is( ":visible" );
	}

	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
		focusableIfVisible = !element.disabled;

		if ( focusableIfVisible ) {

			// Form controls within a disabled fieldset are disabled.
			// However, controls within the fieldset's legend do not get disabled.
			// Since controls generally aren't placed inside legends, we skip
			// this portion of the check.
			fieldset = $( element ).closest( "fieldset" )[ 0 ];
			if ( fieldset ) {
				focusableIfVisible = !fieldset.disabled;
			}
		}
	} else if ( "a" === nodeName ) {
		focusableIfVisible = element.href || hasTabindex;
	} else {
		focusableIfVisible = hasTabindex;
	}

	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
	var visibility = element.css( "visibility" );
	while ( visibility === "inherit" ) {
		element = element.parent();
		visibility = element.css( "visibility" );
	}
	return visibility !== "hidden";
}

$.extend( $.expr[ ":" ], {
	focusable: function( element ) {
		return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
	}
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
	_formResetHandler: function() {
		var form = $( this );

		// Wait for the form reset to actually happen before refreshing
		setTimeout( function() {
			var instances = form.data( "ui-form-reset-instances" );
			$.each( instances, function() {
				this.refresh();
			} );
		} );
	},

	_bindFormResetHandler: function() {
		this.form = this.element.form();
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" ) || [];
		if ( !instances.length ) {

			// We don't use _on() here because we use a single event handler per form
			this.form.on( "reset.ui-form-reset", this._formResetHandler );
		}
		instances.push( this );
		this.form.data( "ui-form-reset-instances", instances );
	},

	_unbindFormResetHandler: function() {
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" );
		instances.splice( $.inArray( this, instances ), 1 );
		if ( instances.length ) {
			this.form.data( "ui-form-reset-instances", instances );
		} else {
			this.form
				.removeData( "ui-form-reset-instances" )
				.off( "reset.ui-form-reset" );
		}
	}
};


/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
	var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
	return function( selector ) {
		return selector.replace( selectorEscape, "\\$1" );
	};
} )();


/*!
 * jQuery UI Labels 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
	var ancestor, selector, id, labels, ancestors;

	// Check control.labels first
	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
		return this.pushStack( this[ 0 ].labels );
	}

	// Support: IE <= 11, FF <= 37, Android <= 2.3 only
	// Above browsers do not support control.labels. Everything below is to support them
	// as well as document fragments. control.labels does not work on document fragments
	labels = this.eq( 0 ).parents( "label" );

	// Look for the label based on the id
	id = this.attr( "id" );
	if ( id ) {

		// We don't search against the document in case the element
		// is disconnected from the DOM
		ancestor = this.eq( 0 ).parents().last();

		// Get a full set of top level ancestors
		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

		// Create a selector for the label based on the id
		selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

		labels = labels.add( ancestors.find( selector ).addBack( selector ) );

	}

	// Return whatever we have found for labels
	return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr[ ":" ], {
	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			hasTabindex = tabIndex != null;
		return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
	}
} );


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );




}));
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/output/plugins.js

try{
/*! mobile - v1.0.0 - 2017-05-15
* Copyright (c) 2017 ; Licensed  */

//! Source: vendor/plugins/h5bp-console-shim.js

try{
// Avoid `console` errors in browsers that lack a console.
(function() {
    var method;
    var noop = function noop() {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var length = methods.length;
    var console = (window.console = window.console || {});

    while (length--) {
        method = methods[length];

        // Only stub undefined methods.
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());


}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/humane.js

try{
/*
 * Javascript Humane Dates
 * Copyright (c) 2008 Dean Landolt (deanlandolt.com)
 * Re-write by Zach Leatherman (zachleat.com)
 *
 * Adopted from the John Resig's pretty.js
 * at http://ejohn.org/blog/javascript-pretty-date
 * and henrah's proposed modification
 * at http://ejohn.org/blog/javascript-pretty-date/#comment-297458
 *
 * Licensed under the MIT license.
 */

window.humaneDate=function humaneDate(date, compareTo){

    if(!date) {
        return;
    }

    var lang = {
            ago: 'Ago',
            from: '',
            now: 'Just Now',
            minute: 'Minute',
            minutes: 'Minutes',
            hour: 'Hour',
            hours: 'Hours',
            day: 'Day',
            days: 'Days',
            week: 'Week',
            weeks: 'Weeks',
            month: 'Month',
            months: 'Months',
            year: 'Year',
            years: 'Years'
        },
        formats = [
            [60, lang.now],
            [3600, lang.minute, lang.minutes, 60], // 60 minutes, 1 minute
            [86400, lang.hour, lang.hours, 3600], // 24 hours, 1 hour
            [604800, lang.day, lang.days, 86400], // 7 days, 1 day
            [2628000, lang.week, lang.weeks, 604800], // ~1 month, 1 week
            [31536000, lang.month, lang.months, 2628000], // 1 year, ~1 month
            [Infinity, lang.year, lang.years, 31536000] // Infinity, 1 year
        ],
        isString = typeof date == 'string',
        date = isString ?
                    new Date(('' + date).replace(/-/g,"/").replace(/[TZ]/g," ")) :
                    date,
        compareTo = compareTo || new Date,
        seconds = (compareTo - date +
                        (compareTo.getTimezoneOffset() -
                            // if we received a GMT time from a string, doesn't include time zone bias
                            // if we got a date object, the time zone is built in, we need to remove it.
                            (isString ? 0 : date.getTimezoneOffset())
                        ) * 60000
                    ) / 1000,
        token;

    if(seconds < 0) {
        seconds = Math.abs(seconds);
        token = lang.from ? ' ' + lang.from : '';
    } else {
        token = lang.ago ? ' ' + lang.ago : '';
    }

    /*
     * 0 seconds && < 60 seconds        Now
     * 60 seconds                       1 Minute
     * > 60 seconds && < 60 minutes     X Minutes
     * 60 minutes                       1 Hour
     * > 60 minutes && < 24 hours       X Hours
     * 24 hours                         1 Day
     * > 24 hours && < 7 days           X Days
     * 7 days                           1 Week
     * > 7 days && < ~ 1 Month          X Weeks
     * ~ 1 Month                        1 Month
     * > ~ 1 Month && < 1 Year          X Months
     * 1 Year                           1 Year
     * > 1 Year                         X Years
     *
     * Single units are +10%. 1 Year shows first at 1 Year + 10%
     */

    function normalize(val, single)
    {
        var margin = 0.1;
        if(val >= single && val <= single * (1+margin)) {
            return single;
        }
        return val;
    }

    for(var i = 0, format = formats[0]; formats[i]; format = formats[++i]) {
        if(seconds < format[0]) {
            if(i === 0) {
                // Now
                return format[1];
            }

            var val = Math.ceil(normalize(seconds, format[3]) / (format[3]));
            return val +
                    ' ' +
                    (val != 1 ? format[2] : format[1]) +
                    (i > 0 ? token : '');
        }
    }
};

if(typeof jQuery != 'undefined') {
    jQuery.fn.humaneDates = function(options)
    {
        var settings = jQuery.extend({
            'lowercase': false
        }, options);

        return this.each(function()
        {
            var $t = jQuery(this),
                date = $t.attr('datetime') || $t.attr('title');

            date = humaneDate(date);

            if(date && settings['lowercase']) {
                date = date.toLowerCase();
            }

            if(date && $t.html() != date) {
                // don't modify the dom if we don't have to
                $t.html(date);
            }
        });
    };
}

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/jquery.autosize.js

try{
/*
	jQuery Autosize v1.16.4
	(c) 2013 Jack Moore - jacklmoore.com
	updated: 2013-01-29
	license: http://www.opensource.org/licenses/mit-license.php
*/

(function ($) {
	var
	defaults = {
		className: 'autosizejs',
		append: '',
		callback: false
	},
	hidden = 'hidden',
	borderBox = 'border-box',
	lineHeight = 'lineHeight',

	// border:0 is unnecessary, but avoids a bug in FireFox on OSX (http://www.jacklmoore.com/autosize#comment-851)
	copy = '<textarea tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden;"/>',

	// line-height is conditionally included because IE7/IE8/old Opera do not return the correct value.
	copyStyle = [
		'fontFamily',
		'fontSize',
		'fontWeight',
		'fontStyle',
		'letterSpacing',
		'textTransform',
		'wordSpacing',
		'textIndent'
	],
	oninput = 'oninput',
	onpropertychange = 'onpropertychange',

	// to keep track which textarea is being mirrored when adjust() is called.
	mirrored,

	// the mirror element, which is used to calculate what size the mirrored element should be.
	mirror = $(copy).data('autosize', true)[0];

	// test that line-height can be accurately copied.
	mirror.style.lineHeight = '99px';
	if ($(mirror).css(lineHeight) === '99px') {
		copyStyle.push(lineHeight);
	}
	mirror.style.lineHeight = '';

	$.fn.autosize = function (options) {
		options = $.extend({}, defaults, options || {});

		if (mirror.parentNode !== document.body) {
			$(document.body).append(mirror);
		}

		return this.each(function () {
			var
			ta = this,
			$ta = $(ta),
			minHeight,
			active,
			resize,
			boxOffset = 0,
			callback = $.isFunction(options.callback);

			if ($ta.data('autosize')) {
				// exit if autosize has already been applied, or if the textarea is the mirror element.
				return;
			}

			if ($ta.css('box-sizing') === borderBox || $ta.css('-moz-box-sizing') === borderBox || $ta.css('-webkit-box-sizing') === borderBox){
				boxOffset = $ta.outerHeight() - $ta.height();
			}

			minHeight = Math.max(parseInt($ta.css('minHeight'), 10) - boxOffset, $ta.height());

			resize = ($ta.css('resize') === 'none' || $ta.css('resize') === 'vertical') ? 'none' : 'horizontal';

			$ta.css({
				overflow: hidden,
				overflowY: hidden,
				wordWrap: 'break-word',
				resize: resize
			}).data('autosize', true);

			function initMirror() {
				mirrored = ta;
				mirror.className = options.className;

				// mirror is a duplicate textarea located off-screen that
				// is automatically updated to contain the same text as the
				// original textarea.  mirror always has a height of 0.
				// This gives a cross-browser supported way getting the actual
				// height of the text, through the scrollTop property.
				$.each(copyStyle, function(i, val){
					mirror.style[val] = $ta.css(val);
				});
			}

			// Using mainly bare JS in this function because it is going
			// to fire very often while typing, and needs to very efficient.
			function adjust() {
				var height, overflow, original;

				if (mirrored !== ta) {
					initMirror();
				}

				// the active flag keeps IE from tripping all over itself.  Otherwise
				// actions in the adjust function will cause IE to call adjust again.
				if (!active) {
					active = true;
					mirror.value = ta.value + options.append;
					mirror.style.overflowY = ta.style.overflowY;
					original = parseInt(ta.style.height,10);

					// Update the width in case the original textarea width has changed
					// A floor of 0 is needed because IE8 returns a negative value for hidden textareas, raising an error.
					mirror.style.width = Math.max($ta.width(), 0) + 'px';

					// The following three lines can be replaced with `height = mirror.scrollHeight` when dropping IE7 support.

					height = mirror.scrollHeight;

					var maxHeight = parseInt($ta.css('maxHeight'), 10);
					// Opera returns '-1px' when max-height is set to 'none'.
					maxHeight = maxHeight && maxHeight > 0 ? maxHeight : 9e4;
					if (height > maxHeight) {
						height = maxHeight;
						overflow = 'scroll';
					} else if (height < minHeight) {
						height = minHeight;
					}
					height += boxOffset;
					ta.style.overflowY = overflow || hidden;

					if (original !== height) {
						ta.style.height = height + 'px';
						if (callback) {
							options.callback.call(ta);
						}
					}

					// This small timeout gives IE a chance to draw it's scrollbar
					// before adjust can be run again (prevents an infinite loop).
					setTimeout(function () {
						active = false;
					}, 1);
				}
			}

			if (onpropertychange in ta) {
				if (oninput in ta) {
					// Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,
					// so binding to onkeyup to catch most of those occassions.  There is no way that I
					// know of to detect something like 'cut' in IE9.
					ta[oninput] = ta.onkeyup = adjust;
				} else {
					// IE7 / IE8
					ta[onpropertychange] = adjust;
				}
			} else {
				// Modern Browsers
				ta[oninput] = adjust;
			}

			$(window).on("resize", adjust);

			$ta.on("remove", function(){
				$(window).off("resize", adjust);
				var $allTextArea = $(".textarea textarea");
				if (!$allTextArea.length || ($allTextArea.length == 1 && $allTextArea[0] == ta)) {
					mirror && mirror.remove();
				}
			});
			// Allow for manual triggering if needed.
			$ta.bind('autosize', adjust);

			// Call adjust in case the textarea already contains text.
			adjust();
		});
	};
}(window.jQuery || window.Zepto));

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/jquery.swipebox.js

try{
/*---------------------------------------------------------------------------------------------

@author       Constantin Saguin - @brutaldesign
@link            http://csag.co
@github        http://github.com/brutaldesign/swipebox
@version     1.2.1
@license      MIT License

----------------------------------------------------------------------------------------------*/

;(function (window, document, $, undefined) {
	
	$.swipebox = function(elem, options) {

		var defaults = {
			useCSS : true,
			initialIndexOnArray : 0,
			hideBarsDelay : 3000,
			videoMaxWidth : 1140,
			vimeoColor : 'CCCCCC',
			beforeOpen: null,
		      	afterClose: null
		},
		
		plugin = this,
		elements = [], // slides array [{href:'...', title:'...'}, ...],
		elem = elem,
		selector = elem.selector,
		$selector = $(selector),
		isTouch = document.createTouch !== undefined || ('ontouchstart' in window) || ('onmsgesturechange' in window) || navigator.msMaxTouchPoints,
		supportSVG = !!(window.SVGSVGElement),
		winWidth = window.innerWidth ? window.innerWidth : $(window).width(),
		winHeight = window.innerHeight ? window.innerHeight : $(window).height(),
		html = '<div id="swipebox-overlay">\
				<div id="swipebox-slider"></div>\
				<div id="swipebox-caption"></div>\
				<div id="swipebox-action">\
					<a id="swipebox-close"></a>\
					<a id="swipebox-prev"></a>\
					<a id="swipebox-next"></a>\
				</div>\
		</div>';

		plugin.settings = {}

		plugin.init = function(){

			plugin.settings = $.extend({}, defaults, options);

			if ($.isArray(elem)) {

				elements = elem;
				ui.target = $(window);
				ui.init(plugin.settings.initialIndexOnArray);

			}else{

				$selector.click(function(e){
					elements = [];
					var index , relType, relVal;

					if (!relVal) {
						relType = 'rel';
						relVal  = $(this).attr(relType);
					}

					if (relVal && relVal !== '' && relVal !== 'nofollow') {
						$elem = $selector.filter('[' + relType + '="' + relVal + '"]');
					}else{
						$elem = $(selector);
					}

					$elem.each(function(){

						var title = null, href = null;
						
						if( $(this).attr('title') )
							title = $(this).attr('title');

						if( $(this).attr('href') )
							href = $(this).attr('href');

						elements.push({
							href: href,
							title: title
						});
					});
					
					index = $elem.index($(this));
					e.preventDefault();
					e.stopPropagation();
					ui.target = $(e.target);
					ui.init(index);
				});
			}
		}

		plugin.refresh = function() {
			if (!$.isArray(elem)) {
				ui.destroy();
				$elem = $(selector);
				ui.actions();
			}
		}

		var ui = {

			init : function(index){
				if (plugin.settings.beforeOpen) 
					plugin.settings.beforeOpen();
				this.target.trigger('swipebox-start');
				$.swipebox.isOpen = true;
				this.build();
				this.openSlide(index);
				this.openMedia(index);
				this.preloadMedia(index+1);
				this.preloadMedia(index-1);
			},

			build : function(){
				var $this = this;

				$('body').append(html);

				if($this.doCssTrans()){
					$('#swipebox-slider').css({
						'-webkit-transition' : 'left 0.4s ease',
						'-moz-transition' : 'left 0.4s ease',
						'-o-transition' : 'left 0.4s ease',
						'-khtml-transition' : 'left 0.4s ease',
						'transition' : 'left 0.4s ease'
					});
					$('#swipebox-overlay').css({
						'-webkit-transition' : 'opacity 1s ease',
						'-moz-transition' : 'opacity 1s ease',
						'-o-transition' : 'opacity 1s ease',
						'-khtml-transition' : 'opacity 1s ease',
						'transition' : 'opacity 1s ease'
					});
					$('#swipebox-action, #swipebox-caption').css({
						'-webkit-transition' : '0.5s',
						'-moz-transition' : '0.5s',
						'-o-transition' : '0.5s',
						'-khtml-transition' : '0.5s',
						'transition' : '0.5s'
					});
				}


				if(supportSVG){
					var bg = $('#swipebox-action #swipebox-close').css('background-image');
					bg = bg.replace('png', 'svg');
					$('#swipebox-action #swipebox-prev,#swipebox-action #swipebox-next,#swipebox-action #swipebox-close').css({
						'background-image' : bg
					});
				}
				
				$.each( elements,  function(){
					$('#swipebox-slider').append('<div class="slide"></div>');
				});

				$this.setDim();
				$this.actions();
				$this.keyboard();
				$this.gesture();
				$this.animBars();
				$this.resize();
				
			},

			setDim : function(){

				var width, height, sliderCss = {};
				
				if( "onorientationchange" in window ){

					window.addEventListener("orientationchange", function() {
						if( window.orientation == 0 ){
							width = winWidth;
							height = winHeight;
						}else if( window.orientation == 90 || window.orientation == -90 ){
							width = winHeight;
							height = winWidth;
						}
					}, false);
					
				
				}else{

					width = window.innerWidth ? window.innerWidth : $(window).width();
					height = window.innerHeight ? window.innerHeight : $(window).height();
				}

				sliderCss = {
					width : width,
					height : height
				}


				$('#swipebox-overlay').css(sliderCss);

			},

			resize : function (){
				var $this = this;
				
				$(window).resize(function() {
					$this.setDim();
				}).resize();
			},

			supportTransition : function() {
				var prefixes = 'transition WebkitTransition MozTransition OTransition msTransition KhtmlTransition'.split(' ');
				for(var i = 0; i < prefixes.length; i++) {
					if(document.createElement('div').style[prefixes[i]] !== undefined) {
						return prefixes[i];
					}
				}
				return false;
			},

			doCssTrans : function(){
				if(plugin.settings.useCSS && this.supportTransition() ){
					return true;
				}
			},

			gesture : function(){
//				if ( isTouch ){
//					var $this = this,
//					distance = null,
//					swipMinDistance = 10,
//					startCoords = {},
//					endCoords = {};
//					var bars = $('#swipebox-caption, #swipebox-action');
//
//					bars.addClass('visible-bars');
//					$this.setTimeout();
//
//					$('body').bind('touchstart', function(e){
//
//						$(this).addClass('touching');
//
//		  				endCoords = e.originalEvent.targetTouches[0];
//		    				startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
//
//						$('.touching').bind('touchmove',function(e){
//							e.preventDefault();
//							e.stopPropagation();
//		    					endCoords = e.originalEvent.targetTouches[0];
//
//						});
//
//			           			return false;
//
//	           			}).bind('touchend',function(e){
//	           				e.preventDefault();
//					e.stopPropagation();
//
//   					distance = endCoords.pageX - startCoords.pageX;
//
//	       				if( distance >= swipMinDistance ){
//
//	       					// swipeLeft
//	       					$this.getPrev();
//
//	       				}else if( distance <= - swipMinDistance ){
//
//	       					// swipeRight
//	       					$this.getNext();
//
//	       				}else{
//	       					// tap
//	       					if(!bars.hasClass('visible-bars')){
//							$this.showBars();
//							$this.setTimeout();
//						}else{
//							$this.clearTimeout();
//							$this.hideBars();
//						}
//
//	       				}
//
//	       				$('.touching').off('touchmove').removeClass('touching');
//
//					});
//
//           				}
			},

			setTimeout: function(){
				if(plugin.settings.hideBarsDelay > 0){
					var $this = this;
					$this.clearTimeout();
					$this.timeout = window.setTimeout( function(){
						$this.hideBars() },
						plugin.settings.hideBarsDelay
					);
				}
			},
			
			clearTimeout: function(){	
				window.clearTimeout(this.timeout);
				this.timeout = null;
			},

			showBars : function(){
				var bars = $('#swipebox-caption, #swipebox-action');
				if(this.doCssTrans()){
					bars.addClass('visible-bars');
				}else{
					$('#swipebox-caption').animate({ top : 0 }, 500);
					$('#swipebox-action').animate({ bottom : 0 }, 500);
					setTimeout(function(){
						bars.addClass('visible-bars');
					}, 1000);
				}
			},

			hideBars : function(){
				var bars = $('#swipebox-caption, #swipebox-action');
				if(this.doCssTrans()){
					bars.removeClass('visible-bars');
				}else{
					$('#swipebox-caption').animate({ top : '-50px' }, 500);
					$('#swipebox-action').animate({ bottom : '-50px' }, 500);
					setTimeout(function(){
						bars.removeClass('visible-bars');
					}, 1000);
				}
			},

			animBars : function(){
				var $this = this;
				var bars = $('#swipebox-caption, #swipebox-action');
					
				bars.addClass('visible-bars');
				$this.setTimeout();
				
				$('#swipebox-slider').click(function(e){
					if(!bars.hasClass('visible-bars')){
						$this.showBars();
						$this.setTimeout();
					}
				});

				$('#swipebox-action').hover(function() {
				  		$this.showBars();
						bars.addClass('force-visible-bars');
						$this.clearTimeout();
					
					},function() { 
						bars.removeClass('force-visible-bars');
						$this.setTimeout();

				});
			},

			keyboard : function(){
				var $this = this;
				$(window).bind('keyup', function(e){
					e.preventDefault();
					e.stopPropagation();
					if (e.keyCode == 37){
						$this.getPrev();
					}
					else if (e.keyCode==39){
						$this.getNext();
					}
					else if (e.keyCode == 27) {
						$this.closeSlide();
					}
				});
			},

			actions : function(){
				var $this = this;
				
				if( elements.length < 2 ){
					$('#swipebox-prev, #swipebox-next').hide();
				}else{
					$('#swipebox-prev').bind('click touchend', function(e){
						e.preventDefault();
						e.stopPropagation();
						$this.getPrev();
						$this.setTimeout();
					});
					
					$('#swipebox-next').bind('click touchend', function(e){
						e.preventDefault();
						e.stopPropagation();
						$this.getNext();
						$this.setTimeout();
					});
				}

				$('#swipebox-close').bind('click touchend', function(e){
					$this.closeSlide();
				});
			},
			
			setSlide : function (index, isFirst){
				isFirst = isFirst || false;
				
				var slider = $('#swipebox-slider');
				
				if(this.doCssTrans()){
					slider.css({ left : (-index*100)+'%' });
				}else{
					slider.animate({ left : (-index*100)+'%' });
				}
				
				$('#swipebox-slider .slide').removeClass('current');
				$('#swipebox-slider .slide').eq(index).addClass('current');
				this.setTitle(index);

				if( isFirst ){
					slider.fadeIn();
				}

				$('#swipebox-prev, #swipebox-next').removeClass('disabled');
				if(index == 0){
					$('#swipebox-prev').addClass('disabled');
				}else if( index == elements.length - 1 ){
					$('#swipebox-next').addClass('disabled');
				}
			},
		
			openSlide : function (index){
				$('html').addClass('swipebox');
				$(window).trigger('resize'); // fix scroll bar visibility on desktop
				this.setSlide(index, true);
			},
		
			preloadMedia : function (index){
				var $this = this, src = null;

				if( elements[index] !== undefined )
					src = elements[index].href;

				if( !$this.isVideo(src) ){
					setTimeout(function(){
						$this.openMedia(index);
					}, 1000);
				}else{
					$this.openMedia(index);
				}
			},
			
			openMedia : function (index){
				var $this = this, src = null;

				if( elements[index] !== undefined )
					src = elements[index].href;

				if(index < 0 || index >= elements.length){
					return false;
				}

				if( !$this.isVideo(src) ){
					$this.loadMedia(src, function(){
						$('#swipebox-slider .slide').eq(index).html(this);
					});
				}else{
					$('#swipebox-slider .slide').eq(index).html($this.getVideo(src));
				}
				
			},

			setTitle : function (index, isFirst){
				var title = null;

				$('#swipebox-caption').empty();

				if( elements[index] !== undefined )
					title = elements[index].title;
				
				if(title){
					$('#swipebox-caption').append(title);
				}
			},

			isVideo : function (src){

				if( src ){
					if( 
						src.match(/youtube\.com\/watch\?v=([a-zA-Z0-9\-_]+)/) 
						|| src.match(/vimeo\.com\/([0-9]*)/) 
					){
						return true;
					}
				}
					
			},

			getVideo : function(url){
				var iframe = '';
				var output = '';
				var youtubeUrl = url.match(/watch\?v=([a-zA-Z0-9\-_]+)/);
				var vimeoUrl = url.match(/vimeo\.com\/([0-9]*)/);
				if( youtubeUrl ){

					iframe = '<iframe width="560" height="315" src="//www.youtube.com/embed/'+youtubeUrl[1]+'" frameborder="0" allowfullscreen></iframe>';
				
				}else if(vimeoUrl){

					iframe = '<iframe width="560" height="315"  src="http://player.vimeo.com/video/'+vimeoUrl[1]+'?byline=0&amp;portrait=0&amp;color='+plugin.settings.vimeoColor+'" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';
				
				}

				return '<div class="swipebox-video-container" style="max-width:'+plugin.settings.videomaxWidth+'px"><div class="swipebox-video">'+iframe+'</div></div>';
			},
			
			loadMedia : function (src, callback){
				if( !this.isVideo(src) ){
					var img = $('<img>').on('load', function(){
						callback.call(img);
					});
					
					img.attr('src',src);
				}	
			},
			
			getNext : function (){
				var $this = this;
				index = $('#swipebox-slider .slide').index($('#swipebox-slider .slide.current'));
				if(index+1 < elements.length){
					index++;
					$this.setSlide(index);
					$this.preloadMedia(index+1);
				}
				else{
					
					$('#swipebox-slider').addClass('rightSpring');
					setTimeout(function(){
						$('#swipebox-slider').removeClass('rightSpring');
					},500);
				}
			},
			
			getPrev : function (){
				index = $('#swipebox-slider .slide').index($('#swipebox-slider .slide.current'));
				if(index > 0){
					index--;
					this.setSlide(index);
					this.preloadMedia(index-1);
				}
				else{
					
					$('#swipebox-slider').addClass('leftSpring');
					setTimeout(function(){
						$('#swipebox-slider').removeClass('leftSpring');
					},500);
				}
			},


			closeSlide : function (){
				$('html').removeClass('swipebox');
				$(window).trigger('resize');
				this.destroy();
			},

			destroy : function(){
				$(window).unbind('keyup');
				$('body').unbind('touchstart');
				$('body').unbind('touchmove');
				$('body').unbind('touchend');
				$('#swipebox-slider').unbind();
				$('#swipebox-overlay').remove();
				if (!$.isArray(elem))
					elem.removeData('_swipebox');
				if ( this.target )
					this.target.trigger('swipebox-destroy');
				$.swipebox.isOpen = false;
				if (plugin.settings.afterClose) 
					plugin.settings.afterClose();
 			}

		};

		plugin.init();
		
	};

	$.fn.swipebox = function(options){
		if (!$.data(this, "_swipebox")) {
			var swipebox = new $.swipebox(this, options);
			this.data('_swipebox', swipebox);
		}
		return this.data('_swipebox');
	}

}(window, document, jQuery));
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/jquery.transit-tweaked.js

try{
/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */

(function($) {
  $.transit = {
    version: "0.9.9",

    // Map of $.css() keys to values for 'transitionProperty'.
    // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
    propertyMap: {
      marginLeft    : 'margin',
      marginRight   : 'margin',
      marginBottom  : 'margin',
      marginTop     : 'margin',
      paddingLeft   : 'padding',
      paddingRight  : 'padding',
      paddingBottom : 'padding',
      paddingTop    : 'padding'
    },

    // Will simply transition "instantly" if false
    enabled: true,

    // Set this to false if you don't want to use the transition end property.
    useTransitionEnd: false
  };

  var div = document.createElement('div');
  var support = {};

  // Helper function to get the proper vendor property name.
  // (`transition` => `WebkitTransition`)
  function getVendorPropertyName(prop) {
    // Handle unprefixed versions (FF16+, for example)
    if (prop in div.style) return prop;

    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

    if (prop in div.style) { return prop; }

    for (var i=0; i<prefixes.length; ++i) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in div.style) { return vendorProp; }
    }
  }

  // Helper function to check if transform3D is supported.
  // Should return true for Webkits and Firefox 10+.
  function checkTransform3dSupport() {
    div.style[support.transform] = '';
    div.style[support.transform] = 'rotateY(90deg)';
    return div.style[support.transform] !== '';
  }

  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

  // Check for the browser's transitions support.
  support.transition      = getVendorPropertyName('transition');
  support.transitionDelay = getVendorPropertyName('transitionDelay');
  support.transform       = getVendorPropertyName('transform');
  support.transformOrigin = getVendorPropertyName('transformOrigin');
  support.transform3d     = checkTransform3dSupport();

  var eventNames = {
    'transition':       'transitionEnd',
    'MozTransition':    'transitionend',
    'OTransition':      'oTransitionEnd',
    'WebkitTransition': 'webkitTransitionEnd',
    'msTransition':     'MSTransitionEnd'
  };

  // Detect the 'transitionend' event needed.
  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

  // Populate jQuery's `$.support` with the vendor prefixes we know.
  // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
  // we set $.support.transition to a string of the actual property name used.
  for (var key in support) {
    if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
      $.support[key] = support[key];
    }
  }

  // Avoid memory leak in IE.
  div = null;

  // ## $.cssEase
  // List of easing aliases that you can use with `$.fn.transition`.
  $.cssEase = {
    '_default':       'ease',
    'in':             'ease-in',
    'out':            'ease-out',
    'in-out':         'ease-in-out',
    'snap':           'cubic-bezier(0,1,.5,1)',
    // Penner equations
    'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',
    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
    'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',
    'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',
    'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',
    'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',
    'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',
    'easeInOutExpo':  'cubic-bezier(1,0,0,1)',
    'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',
    'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',
    'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',
    'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',
    'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',
    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
    'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',
    'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',
    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
    'easeInSine':     'cubic-bezier(.47,0,.745,.715)',
    'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',
    'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',
    'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',
    'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',
    'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'
  };

  // ## 'transform' CSS hook
  // Allows you to use the `transform` property in CSS.
  //
  //     $("#hello").css({ transform: "rotate(90deg)" });
  //
  //     $("#hello").css('transform');
  //     //=> { rotate: '90deg' }
  //
  $.cssHooks['transit:transform'] = {
    // The getter returns a `Transform` object.
    get: function(elem) {
      return $(elem).data('transform') || new Transform();
    },

    // The setter accepts a `Transform` object or a string.
    set: function(elem, v) {
      var value = v;

      if (!(value instanceof Transform)) {
        value = new Transform(value);
      }

      if (support.transform === 'WebkitTransform') {
        elem.style[support.transform] = value.toString(true);
      } else {
        elem.style[support.transform] = value.toString();
      }

      $(elem).data('transform', value);
    }
  };

  // Add a CSS hook for `.css({ transform: '...' })`.
  // In jQuery 1.8+, this will intentionally override the default `transform`
  // CSS hook so it'll play well with Transit. (see issue #62)
  $.cssHooks.transform = {
    set: $.cssHooks['transit:transform'].set
  };

  // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
  // be necessary.
  if ($.fn.jquery < "1.8") {
    // ## 'transformOrigin' CSS hook
    // Allows the use for `transformOrigin` to define where scaling and rotation
    // is pivoted.
    //
    //     $("#hello").css({ transformOrigin: '0 0' });
    //
    $.cssHooks.transformOrigin = {
      get: function(elem) {
        return elem.style[support.transformOrigin];
      },
      set: function(elem, value) {
        elem.style[support.transformOrigin] = value;
      }
    };

    // ## 'transition' CSS hook
    // Allows you to use the `transition` property in CSS.
    //
    //     $("#hello").css({ transition: 'all 0 ease 0' });
    //
    $.cssHooks.transition = {
      get: function(elem) {
        return elem.style[support.transition];
      },
      set: function(elem, value) {
        elem.style[support.transition] = value;
      }
    };
  }

  // ## Other CSS hooks
  // Allows you to rotate, scale and translate.
  registerCssHook('scale');
  registerCssHook('translate');
  registerCssHook('rotate');
  registerCssHook('rotateX');
  registerCssHook('rotateY');
  registerCssHook('rotate3d');
  registerCssHook('perspective');
  registerCssHook('skewX');
  registerCssHook('skewY');
  registerCssHook('x', true);
  registerCssHook('y', true);

  // ## Transform class
  // This is the main class of a transformation property that powers
  // `$.fn.css({ transform: '...' })`.
  //
  // This is, in essence, a dictionary object with key/values as `-transform`
  // properties.
  //
  //     var t = new Transform("rotate(90) scale(4)");
  //
  //     t.rotate             //=> "90deg"
  //     t.scale              //=> "4,4"
  //
  // Setters are accounted for.
  //
  //     t.set('rotate', 4)
  //     t.rotate             //=> "4deg"
  //
  // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
  // functions.
  //
  //     t.toString()         //=> "rotate(90deg) scale(4,4)"
  //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
  //
  function Transform(str) {
    if (typeof str === 'string') { this.parse(str); }
    return this;
  }

  Transform.prototype = {
    // ### setFromString()
    // Sets a property from a string.
    //
    //     t.setFromString('scale', '2,4');
    //     // Same as set('scale', '2', '4');
    //
    setFromString: function(prop, val) {
      var args =
        (typeof val === 'string')  ? val.split(',') :
        (val.constructor === Array) ? val :
        [ val ];

      args.unshift(prop);

      Transform.prototype.set.apply(this, args);
    },

    // ### set()
    // Sets a property.
    //
    //     t.set('scale', 2, 4);
    //
    set: function(prop) {
      var args = Array.prototype.slice.apply(arguments, [1]);
      if (this.setter[prop]) {
        this.setter[prop].apply(this, args);
      } else {
        this[prop] = args.join(',');
      }
    },

    get: function(prop) {
      if (this.getter[prop]) {
        return this.getter[prop].apply(this);
      } else {
        return this[prop] || 0;
      }
    },

    setter: {
      // ### rotate
      //
      //     .css({ rotate: 30 })
      //     .css({ rotate: "30" })
      //     .css({ rotate: "30deg" })
      //     .css({ rotate: "30deg" })
      //
      rotate: function(theta) {
        this.rotate = unit(theta, 'deg');
      },

      rotateX: function(theta) {
        this.rotateX = unit(theta, 'deg');
      },

      rotateY: function(theta) {
        this.rotateY = unit(theta, 'deg');
      },

      // ### scale
      //
      //     .css({ scale: 9 })      //=> "scale(9,9)"
      //     .css({ scale: '3,2' })  //=> "scale(3,2)"
      //
      scale: function(x, y) {
        if (y === undefined) { y = x; }
        this.scale = x + "," + y;
      },

      // ### skewX + skewY
      skewX: function(x) {
        this.skewX = unit(x, 'deg');
      },

      skewY: function(y) {
        this.skewY = unit(y, 'deg');
      },

      // ### perspectvie
      perspective: function(dist) {
        this.perspective = unit(dist, 'px');
      },

      // ### x / y
      // Translations. Notice how this keeps the other value.
      //
      //     .css({ x: 4 })       //=> "translate(4px, 0)"
      //     .css({ y: 10 })      //=> "translate(4px, 10px)"
      //
      x: function(x) {
        this.set('translate', x, null);
      },

      y: function(y) {
        this.set('translate', null, y);
      },

      // ### translate
      // Notice how this keeps the other value.
      //
      //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
      //
      translate: function(x, y) {
        if (this._translateX === undefined) { this._translateX = 0; }
        if (this._translateY === undefined) { this._translateY = 0; }

        if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
        if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

        this.translate = this._translateX + "," + this._translateY;
      }
    },

    getter: {
      x: function() {
        return this._translateX || 0;
      },

      y: function() {
        return this._translateY || 0;
      },

      scale: function() {
        var s = (this.scale || "1,1").split(',');
        if (s[0]) { s[0] = parseFloat(s[0]); }
        if (s[1]) { s[1] = parseFloat(s[1]); }

        // "2.5,2.5" => 2.5
        // "2.5,1" => [2.5,1]
        return (s[0] === s[1]) ? s[0] : s;
      },

      rotate3d: function() {
        var s = (this.rotate3d || "0,0,0,0deg").split(',');
        for (var i=0; i<=3; ++i) {
          if (s[i]) { s[i] = parseFloat(s[i]); }
        }
        if (s[3]) { s[3] = unit(s[3], 'deg'); }

        return s;
      }
    },

    // ### parse()
    // Parses from a string. Called on constructor.
    parse: function(str) {
      var self = this;
      str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
        self.setFromString(prop, val);
      });
    },

    // ### toString()
    // Converts to a `transition` CSS property string. If `use3d` is given,
    // it converts to a `-webkit-transition` CSS property string instead.
    toString: function(use3d) {
      var re = [];

      for (var i in this) {
        if (this.hasOwnProperty(i)) {
          // Don't use 3D transformations if the browser can't support it.
          if ((!support.transform3d) && (
            (i === 'rotateX') ||
            (i === 'rotateY') ||
            (i === 'perspective') ||
            (i === 'transformOrigin'))) { continue; }

          if (i[0] !== '_') {
            if (use3d && (i === 'scale')) {
              re.push(i + "3d(" + this[i] + ",1)");
            } else if (use3d && (i === 'translate')) {
              re.push(i + "3d(" + this[i] + ",0)");
            } else {
              re.push(i + "(" + this[i] + ")");
            }
          }
        }
      }

      return re.join(" ");
    }
  };

  function callOrQueue(self, queue, fn) {
    if (queue === true) {
      self.queue(fn);
    } else if (queue) {
      self.queue(queue, fn);
    } else {
      fn();
    }
  }

  // ### getProperties(dict)
  // Returns properties (for `transition-property`) for dictionary `props`. The
  // value of `props` is what you would expect in `$.css(...)`.
  function getProperties(props) {
    var re = [];

    $.each(props, function(key) {
      key = $.camelCase(key); // Convert "text-align" => "textAlign"
      key = $.transit.propertyMap[key] || $.cssProps[key] || key;
      key = uncamel(key); // Convert back to dasherized

      if ($.inArray(key, re) === -1) { re.push(key); }
    });

    return re;
  }

  // ### getTransition()
  // Returns the transition string to be used for the `transition` CSS property.
  //
  // Example:
  //
  //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
  //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
  //
  function getTransition(properties, duration, easing, delay) {
    // Get the CSS properties needed.
    var props = getProperties(properties);

    // Account for aliases (`in` => `ease-in`).
    if ($.cssEase[easing]) { easing = $.cssEase[easing]; }

    // Build the duration/easing/delay attributes for it.
    var attribs = '' + toMS(duration) + ' ' + easing;
    if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

    // For more properties, add them this way:
    // "margin 200ms ease, padding 200ms ease, ..."
    var transitions = [];
    $.each(props, function(i, name) {
      transitions.push(name + ' ' + attribs);
    });

    return transitions.join(', ');
  }

  // ## $.fn.transition
  // Works like $.fn.animate(), but uses CSS transitions.
  //
  //     $("...").transition({ opacity: 0.1, scale: 0.3 });
  //
  //     // Specific duration
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
  //
  //     // With duration and easing
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
  //
  //     // With callback
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
  //
  //     // With everything
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
  //
  //     // Alternate syntax
  //     $("...").transition({
  //       opacity: 0.1,
  //       duration: 200,
  //       delay: 40,
  //       easing: 'in',
  //       complete: function() { /* ... */ }
  //      });
  //
  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
    var self  = this;
    var delay = 0;
    var queue = true;

    // Account for `.transition(properties, callback)`.
    if (typeof duration === 'function') {
      callback = duration;
      duration = undefined;
    }

    // Account for `.transition(properties, duration, callback)`.
    if (typeof easing === 'function') {
      callback = easing;
      easing = undefined;
    }

    // Alternate syntax.
    if (typeof properties.easing !== 'undefined') {
      easing = properties.easing;
      delete properties.easing;
    }

    if (typeof properties.duration !== 'undefined') {
      duration = properties.duration;
      delete properties.duration;
    }

    if (typeof properties.complete !== 'undefined') {
      callback = properties.complete;
      delete properties.complete;
    }

    if (typeof properties.queue !== 'undefined') {
      queue = properties.queue;
      delete properties.queue;
    }

    if (typeof properties.delay !== 'undefined') {
      delay = properties.delay;
      delete properties.delay;
    }

    // Set defaults. (`400` duration, `ease` easing)
    if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }
    if (typeof easing === 'undefined')   { easing = $.cssEase._default; }

    duration = toMS(duration);

    // Build the `transition` property.
    var transitionValue = getTransition(properties, duration, easing, delay);

    // Compute delay until callback.
    // If this becomes 0, don't bother setting the transition property.
    var work = $.transit.enabled && support.transition;
    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

    // If there's nothing to do...
    if (i === 0) {
      var fn = function(next) {
        self.css(properties);
        if (callback) { callback.apply(self); }
        if (next) { next(); }
      };

      callOrQueue(self, queue, fn);
      return self;
    }

    // Save the old transitions of each element so we can restore it later.
    var oldTransitions = {};

    var run = function(nextCall) {
      var bound = false;

      // Prepare the callback.
      var cb = function() {
        if (bound) { self.unbind(transitionEnd, cb); }

        if (i > 0) {
          self.each(function() {
            this.style[support.transition] = (oldTransitions[this] || null);
          });
        }

        if (typeof callback === 'function') { callback.apply(self); }
        if (typeof nextCall === 'function') { nextCall(); }
      };

      if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
        // Use the 'transitionend' event if it's available.
        bound = true;
        self.bind(transitionEnd, cb);
      } else {
        // Fallback to timers if the 'transitionend' event isn't supported.
        window.setTimeout(cb, i);
      }

      // Apply transitions.
      self.each(function() {
        if (i > 0) {
          this.style[support.transition] = transitionValue;
        }
        $(this).css(properties);
      });
    };

    // Defer running. This allows the browser to paint any pending CSS it hasn't
    // painted yet before doing the transitions.
    var deferredRun = function(next) {
        this.offsetWidth; // force a repaint
        run(next);
    };

    // Use jQuery's fx queue.
    callOrQueue(self, queue, deferredRun);

    // Chainability.
    return this;
  };

  function registerCssHook(prop, isPixels) {
    // For certain properties, the 'px' should not be implied.
    if (!isPixels) { $.cssNumber[prop] = true; }

    $.transit.propertyMap[prop] = support.transform;

    $.cssHooks[prop] = {
      get: function(elem) {
        var t = $(elem).css('transit:transform');
        return t.get(prop);
      },

      set: function(elem, value) {
        var t = $(elem).css('transit:transform');
        t.setFromString(prop, value);

        $(elem).css({ 'transit:transform': t });
      }
    };

  }

  // ### uncamel(str)
  // Converts a camelcase string to a dasherized string.
  // (`marginLeft` => `margin-left`)
  function uncamel(str) {
    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
  }

  // ### unit(number, unit)
  // Ensures that number `number` has a unit. If no unit is found, assume the
  // default is `unit`.
  //
  //     unit(2, 'px')          //=> "2px"
  //     unit("30deg", 'rad')   //=> "30deg"
  //
  function unit(i, units) {
    if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
      return i;
    } else {
      return "" + i + units;
    }
  }

  // ### toMS(duration)
  // Converts given `duration` to a millisecond string.
  //
  //     toMS('fast')   //=> '400ms'
  //     toMS(10)       //=> '10ms'
  //
  function toMS(duration) {
    var i = duration;

    // Allow for string durations like 'fast'.
    if ($.fx.speeds[i]) { i = $.fx.speeds[i]; }

    return unit(i, 'ms');
  }

  // Export some functions for testable-ness.
  $.transit.getTransitionValue = getTransition;
})(jQuery);

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/plugins/moment.min.js

try{
//! moment.js
//! version : 2.9.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(a,b,c){switch(arguments.length){case 2:return null!=a?a:b;case 3:return null!=a?a:null!=b?b:c;default:throw new Error("Implement me")}}function c(a,b){return Bb.call(a,b)}function d(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function e(a){vb.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+a)}function f(a,b){var c=!0;return o(function(){return c&&(e(a),c=!1),b.apply(this,arguments)},b)}function g(a,b){sc[a]||(e(b),sc[a]=!0)}function h(a,b){return function(c){return r(a.call(this,c),b)}}function i(a,b){return function(c){return this.localeData().ordinal(a.call(this,c),b)}}function j(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,"months");return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)}function k(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function l(){}function m(a,b){b!==!1&&H(a),p(this,a),this._d=new Date(+a._d),uc===!1&&(uc=!0,vb.updateOffset(this),uc=!1)}function n(a){var b=A(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=vb.localeData(),this._bubble()}function o(a,b){for(var d in b)c(b,d)&&(a[d]=b[d]);return c(b,"toString")&&(a.toString=b.toString),c(b,"valueOf")&&(a.valueOf=b.valueOf),a}function p(a,b){var c,d,e;if("undefined"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),"undefined"!=typeof b._i&&(a._i=b._i),"undefined"!=typeof b._f&&(a._f=b._f),"undefined"!=typeof b._l&&(a._l=b._l),"undefined"!=typeof b._strict&&(a._strict=b._strict),"undefined"!=typeof b._tzm&&(a._tzm=b._tzm),"undefined"!=typeof b._isUTC&&(a._isUTC=b._isUTC),"undefined"!=typeof b._offset&&(a._offset=b._offset),"undefined"!=typeof b._pf&&(a._pf=b._pf),"undefined"!=typeof b._locale&&(a._locale=b._locale),Kb.length>0)for(c in Kb)d=Kb[c],e=b[d],"undefined"!=typeof e&&(a[d]=e);return a}function q(a){return 0>a?Math.ceil(a):Math.floor(a)}function r(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function s(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function t(a,b){var c;return b=M(b,a),a.isBefore(b)?c=s(a,b):(c=s(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function u(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(g(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=vb.duration(c,d),v(this,e,a),this}}function v(a,b,c,d){var e=b._milliseconds,f=b._days,g=b._months;d=null==d?!0:d,e&&a._d.setTime(+a._d+e*c),f&&pb(a,"Date",ob(a,"Date")+f*c),g&&nb(a,ob(a,"Month")+g*c),d&&vb.updateOffset(a,f||g)}function w(a){return"[object Array]"===Object.prototype.toString.call(a)}function x(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function y(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&C(a[d])!==C(b[d]))&&g++;return g+f}function z(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=lc[a]||mc[b]||b}return a}function A(a){var b,d,e={};for(d in a)c(a,d)&&(b=z(d),b&&(e[b]=a[d]));return e}function B(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}vb[b]=function(e,f){var g,h,i=vb._locale[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=vb().utc().set(d,a);return i.call(vb._locale,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function C(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function D(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function E(a,b,c){return jb(vb([a,11,31+b-c]),b,c).week}function F(a){return G(a)?366:365}function G(a){return a%4===0&&a%100!==0||a%400===0}function H(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[Db]<0||a._a[Db]>11?Db:a._a[Eb]<1||a._a[Eb]>D(a._a[Cb],a._a[Db])?Eb:a._a[Fb]<0||a._a[Fb]>24||24===a._a[Fb]&&(0!==a._a[Gb]||0!==a._a[Hb]||0!==a._a[Ib])?Fb:a._a[Gb]<0||a._a[Gb]>59?Gb:a._a[Hb]<0||a._a[Hb]>59?Hb:a._a[Ib]<0||a._a[Ib]>999?Ib:-1,a._pf._overflowDayOfYear&&(Cb>b||b>Eb)&&(b=Eb),a._pf.overflow=b)}function I(b){return null==b._isValid&&(b._isValid=!isNaN(b._d.getTime())&&b._pf.overflow<0&&!b._pf.empty&&!b._pf.invalidMonth&&!b._pf.nullInput&&!b._pf.invalidFormat&&!b._pf.userInvalidated,b._strict&&(b._isValid=b._isValid&&0===b._pf.charsLeftOver&&0===b._pf.unusedTokens.length&&b._pf.bigHour===a)),b._isValid}function J(a){return a?a.toLowerCase().replace("_","-"):a}function K(a){for(var b,c,d,e,f=0;f<a.length;){for(e=J(a[f]).split("-"),b=e.length,c=J(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=L(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&y(e,c,!0)>=b-1)break;b--}f++}return null}function L(a){var b=null;if(!Jb[a]&&Lb)try{b=vb.locale(),require("./locale/"+a),vb.locale(b)}catch(c){}return Jb[a]}function M(a,b){var c,d;return b._isUTC?(c=b.clone(),d=(vb.isMoment(a)||x(a)?+a:+vb(a))-+c,c._d.setTime(+c._d+d),vb.updateOffset(c,!1),c):vb(a).local()}function N(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function O(a){var b,c,d=a.match(Pb);for(b=0,c=d.length;c>b;b++)d[b]=rc[d[b]]?rc[d[b]]:N(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function P(a,b){return a.isValid()?(b=Q(b,a.localeData()),nc[b]||(nc[b]=O(b)),nc[b](a)):a.localeData().invalidDate()}function Q(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Qb.lastIndex=0;d>=0&&Qb.test(a);)a=a.replace(Qb,c),Qb.lastIndex=0,d-=1;return a}function R(a,b){var c,d=b._strict;switch(a){case"Q":return _b;case"DDDD":return bc;case"YYYY":case"GGGG":case"gggg":return d?cc:Tb;case"Y":case"G":case"g":return ec;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?dc:Ub;case"S":if(d)return _b;case"SS":if(d)return ac;case"SSS":if(d)return bc;case"DDD":return Sb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Wb;case"a":case"A":return b._locale._meridiemParse;case"x":return Zb;case"X":return $b;case"Z":case"ZZ":return Xb;case"T":return Yb;case"SSSS":return Vb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?ac:Rb;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return Rb;case"Do":return d?b._locale._ordinalParse:b._locale._ordinalParseLenient;default:return c=new RegExp($(Z(a.replace("\\","")),"i"))}}function S(a){a=a||"";var b=a.match(Xb)||[],c=b[b.length-1]||[],d=(c+"").match(jc)||["-",0,0],e=+(60*d[1])+C(d[2]);return"+"===d[0]?e:-e}function T(a,b,c){var d,e=c._a;switch(a){case"Q":null!=b&&(e[Db]=3*(C(b)-1));break;case"M":case"MM":null!=b&&(e[Db]=C(b)-1);break;case"MMM":case"MMMM":d=c._locale.monthsParse(b,a,c._strict),null!=d?e[Db]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[Eb]=C(b));break;case"Do":null!=b&&(e[Eb]=C(parseInt(b.match(/\d{1,2}/)[0],10)));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=C(b));break;case"YY":e[Cb]=vb.parseTwoDigitYear(b);break;case"YYYY":case"YYYYY":case"YYYYYY":e[Cb]=C(b);break;case"a":case"A":c._meridiem=b;break;case"h":case"hh":c._pf.bigHour=!0;case"H":case"HH":e[Fb]=C(b);break;case"m":case"mm":e[Gb]=C(b);break;case"s":case"ss":e[Hb]=C(b);break;case"S":case"SS":case"SSS":case"SSSS":e[Ib]=C(1e3*("0."+b));break;case"x":c._d=new Date(C(b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=S(b);break;case"dd":case"ddd":case"dddd":d=c._locale.weekdaysParse(b),null!=d?(c._w=c._w||{},c._w.d=d):c._pf.invalidWeekday=b;break;case"w":case"ww":case"W":case"WW":case"d":case"e":case"E":a=a.substr(0,1);case"gggg":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=C(b));break;case"gg":case"GG":c._w=c._w||{},c._w[a]=vb.parseTwoDigitYear(b)}}function U(a){var c,d,e,f,g,h,i;c=a._w,null!=c.GG||null!=c.W||null!=c.E?(g=1,h=4,d=b(c.GG,a._a[Cb],jb(vb(),1,4).year),e=b(c.W,1),f=b(c.E,1)):(g=a._locale._week.dow,h=a._locale._week.doy,d=b(c.gg,a._a[Cb],jb(vb(),g,h).year),e=b(c.w,1),null!=c.d?(f=c.d,g>f&&++e):f=null!=c.e?c.e+g:g),i=kb(d,e,f,h,g),a._a[Cb]=i.year,a._dayOfYear=i.dayOfYear}function V(a){var c,d,e,f,g=[];if(!a._d){for(e=X(a),a._w&&null==a._a[Eb]&&null==a._a[Db]&&U(a),a._dayOfYear&&(f=b(a._a[Cb],e[Cb]),a._dayOfYear>F(f)&&(a._pf._overflowDayOfYear=!0),d=fb(f,0,a._dayOfYear),a._a[Db]=d.getUTCMonth(),a._a[Eb]=d.getUTCDate()),c=0;3>c&&null==a._a[c];++c)a._a[c]=g[c]=e[c];for(;7>c;c++)a._a[c]=g[c]=null==a._a[c]?2===c?1:0:a._a[c];24===a._a[Fb]&&0===a._a[Gb]&&0===a._a[Hb]&&0===a._a[Ib]&&(a._nextDay=!0,a._a[Fb]=0),a._d=(a._useUTC?fb:eb).apply(null,g),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[Fb]=24)}}function W(a){var b;a._d||(b=A(a._i),a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],V(a))}function X(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function Y(b){if(b._f===vb.ISO_8601)return void ab(b);b._a=[],b._pf.empty=!0;var c,d,e,f,g,h=""+b._i,i=h.length,j=0;for(e=Q(b._f,b._locale).match(Pb)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(R(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&b._pf.unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),rc[f]?(d?b._pf.empty=!1:b._pf.unusedTokens.push(f),T(f,d,b)):b._strict&&!d&&b._pf.unusedTokens.push(f);b._pf.charsLeftOver=i-j,h.length>0&&b._pf.unusedInput.push(h),b._pf.bigHour===!0&&b._a[Fb]<=12&&(b._pf.bigHour=a),b._a[Fb]=k(b._locale,b._a[Fb],b._meridiem),V(b),H(b)}function Z(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function $(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function _(a){var b,c,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,void(a._d=new Date(0/0));for(f=0;f<a._f.length;f++)g=0,b=p({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._pf=d(),b._f=a._f[f],Y(b),I(b)&&(g+=b._pf.charsLeftOver,g+=10*b._pf.unusedTokens.length,b._pf.score=g,(null==e||e>g)&&(e=g,c=b));o(a,c||b)}function ab(a){var b,c,d=a._i,e=fc.exec(d);if(e){for(a._pf.iso=!0,b=0,c=hc.length;c>b;b++)if(hc[b][1].exec(d)){a._f=hc[b][0]+(e[6]||" ");break}for(b=0,c=ic.length;c>b;b++)if(ic[b][1].exec(d)){a._f+=ic[b][0];break}d.match(Xb)&&(a._f+="Z"),Y(a)}else a._isValid=!1}function bb(a){ab(a),a._isValid===!1&&(delete a._isValid,vb.createFromInputFallback(a))}function cb(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function db(b){var c,d=b._i;d===a?b._d=new Date:x(d)?b._d=new Date(+d):null!==(c=Mb.exec(d))?b._d=new Date(+c[1]):"string"==typeof d?bb(b):w(d)?(b._a=cb(d.slice(0),function(a){return parseInt(a,10)}),V(b)):"object"==typeof d?W(b):"number"==typeof d?b._d=new Date(d):vb.createFromInputFallback(b)}function eb(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function fb(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function gb(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function hb(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function ib(a,b,c){var d=vb.duration(a).abs(),e=Ab(d.as("s")),f=Ab(d.as("m")),g=Ab(d.as("h")),h=Ab(d.as("d")),i=Ab(d.as("M")),j=Ab(d.as("y")),k=e<oc.s&&["s",e]||1===f&&["m"]||f<oc.m&&["mm",f]||1===g&&["h"]||g<oc.h&&["hh",g]||1===h&&["d"]||h<oc.d&&["dd",h]||1===i&&["M"]||i<oc.M&&["MM",i]||1===j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,hb.apply({},k)}function jb(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=vb(a).add(f,"d"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function kb(a,b,c,d,e){var f,g,h=fb(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:F(a-1)+g}}function lb(b){var c,d=b._i,e=b._f;return b._locale=b._locale||vb.localeData(b._l),null===d||e===a&&""===d?vb.invalid({nullInput:!0}):("string"==typeof d&&(b._i=d=b._locale.preparse(d)),vb.isMoment(d)?new m(d,!0):(e?w(e)?_(b):Y(b):db(b),c=new m(b),c._nextDay&&(c.add(1,"d"),c._nextDay=a),c))}function mb(a,b){var c,d;if(1===b.length&&w(b[0])&&(b=b[0]),!b.length)return vb();for(c=b[0],d=1;d<b.length;++d)b[d][a](c)&&(c=b[d]);return c}function nb(a,b){var c;return"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),D(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function ob(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function pb(a,b,c){return"Month"===b?nb(a,c):a._d["set"+(a._isUTC?"UTC":"")+b](c)}function qb(a,b){return function(c){return null!=c?(pb(this,a,c),vb.updateOffset(this,b),this):ob(this,a)}}function rb(a){return 400*a/146097}function sb(a){return 146097*a/400}function tb(a){vb.duration.fn[a]=function(){return this._data[a]}}function ub(a){"undefined"==typeof ender&&(wb=zb.moment,zb.moment=a?f("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.",vb):vb)}for(var vb,wb,xb,yb="2.9.0",zb="undefined"==typeof global||"undefined"!=typeof window&&window!==global.window?this:global,Ab=Math.round,Bb=Object.prototype.hasOwnProperty,Cb=0,Db=1,Eb=2,Fb=3,Gb=4,Hb=5,Ib=6,Jb={},Kb=[],Lb="undefined"!=typeof module&&module&&module.exports,Mb=/^\/?Date\((\-?\d+)/i,Nb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,Ob=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,Pb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,Qb=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Rb=/\d\d?/,Sb=/\d{1,3}/,Tb=/\d{1,4}/,Ub=/[+\-]?\d{1,6}/,Vb=/\d+/,Wb=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Xb=/Z|[\+\-]\d\d:?\d\d/gi,Yb=/T/i,Zb=/[\+\-]?\d+/,$b=/[\+\-]?\d+(\.\d{1,3})?/,_b=/\d/,ac=/\d\d/,bc=/\d{3}/,cc=/\d{4}/,dc=/[+-]?\d{6}/,ec=/[+-]?\d+/,fc=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,gc="YYYY-MM-DDTHH:mm:ssZ",hc=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],ic=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],jc=/([\+\-]|\d\d)/gi,kc=("Date|Hours|Minutes|Seconds|Milliseconds".split("|"),{Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6}),lc={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",Q:"quarter",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},mc={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},nc={},oc={s:45,m:45,h:22,d:26,M:11},pc="DDD w W M D d".split(" "),qc="M D H h m s w W".split(" "),rc={M:function(){return this.month()+1},MMM:function(a){return this.localeData().monthsShort(this,a)},MMMM:function(a){return this.localeData().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.localeData().weekdaysMin(this,a)},ddd:function(a){return this.localeData().weekdaysShort(this,a)},dddd:function(a){return this.localeData().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return r(this.year()%100,2)},YYYY:function(){return r(this.year(),4)},YYYYY:function(){return r(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+r(Math.abs(a),6)},gg:function(){return r(this.weekYear()%100,2)},gggg:function(){return r(this.weekYear(),4)},ggggg:function(){return r(this.weekYear(),5)},GG:function(){return r(this.isoWeekYear()%100,2)},GGGG:function(){return r(this.isoWeekYear(),4)},GGGGG:function(){return r(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return C(this.milliseconds()/100)},SS:function(){return r(C(this.milliseconds()/10),2)},SSS:function(){return r(this.milliseconds(),3)},SSSS:function(){return r(this.milliseconds(),3)},Z:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+":"+r(C(a)%60,2)},ZZ:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+r(C(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},x:function(){return this.valueOf()},X:function(){return this.unix()},Q:function(){return this.quarter()}},sc={},tc=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"],uc=!1;pc.length;)xb=pc.pop(),rc[xb+"o"]=i(rc[xb],xb);for(;qc.length;)xb=qc.pop(),rc[xb+xb]=h(rc[xb],2);rc.DDDD=h(rc.DDD,3),o(l.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=vb.utc([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=vb([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY LT",LLLL:"dddd, MMMM D, YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b,c){var d=this._calendar[a];return"function"==typeof d?d.apply(b,[c]):d},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",_ordinalParse:/\d{1,2}/,preparse:function(a){return a},postformat:function(a){return a},week:function(a){return jb(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},firstDayOfWeek:function(){return this._week.dow},firstDayOfYear:function(){return this._week.doy},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),vb=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=b,g._f=c,g._l=e,g._strict=f,g._isUTC=!1,g._pf=d(),lb(g)},vb.suppressDeprecationWarnings=!1,vb.createFromInputFallback=f("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),vb.min=function(){var a=[].slice.call(arguments,0);return mb("isBefore",a)},vb.max=function(){var a=[].slice.call(arguments,0);return mb("isAfter",a)},vb.utc=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=b,g._f=c,g._strict=f,g._pf=d(),lb(g).utc()},vb.unix=function(a){return vb(1e3*a)},vb.duration=function(a,b){var d,e,f,g,h=a,i=null;return vb.isDuration(a)?h={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(h={},b?h[b]=a:h.milliseconds=a):(i=Nb.exec(a))?(d="-"===i[1]?-1:1,h={y:0,d:C(i[Eb])*d,h:C(i[Fb])*d,m:C(i[Gb])*d,s:C(i[Hb])*d,ms:C(i[Ib])*d}):(i=Ob.exec(a))?(d="-"===i[1]?-1:1,f=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*d},h={y:f(i[2]),M:f(i[3]),d:f(i[4]),h:f(i[5]),m:f(i[6]),s:f(i[7]),w:f(i[8])}):null==h?h={}:"object"==typeof h&&("from"in h||"to"in h)&&(g=t(vb(h.from),vb(h.to)),h={},h.ms=g.milliseconds,h.M=g.months),e=new n(h),vb.isDuration(a)&&c(a,"_locale")&&(e._locale=a._locale),e},vb.version=yb,vb.defaultFormat=gc,vb.ISO_8601=function(){},vb.momentProperties=Kb,vb.updateOffset=function(){},vb.relativeTimeThreshold=function(b,c){return oc[b]===a?!1:c===a?oc[b]:(oc[b]=c,!0)},vb.lang=f("moment.lang is deprecated. Use moment.locale instead.",function(a,b){return vb.locale(a,b)}),vb.locale=function(a,b){var c;return a&&(c="undefined"!=typeof b?vb.defineLocale(a,b):vb.localeData(a),c&&(vb.duration._locale=vb._locale=c)),vb._locale._abbr},vb.defineLocale=function(a,b){return null!==b?(b.abbr=a,Jb[a]||(Jb[a]=new l),Jb[a].set(b),vb.locale(a),Jb[a]):(delete Jb[a],null)},vb.langData=f("moment.langData is deprecated. Use moment.localeData instead.",function(a){return vb.localeData(a)}),vb.localeData=function(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return vb._locale;if(!w(a)){if(b=L(a))return b;a=[a]}return K(a)},vb.isMoment=function(a){return a instanceof m||null!=a&&c(a,"_isAMomentObject")},vb.isDuration=function(a){return a instanceof n};for(xb=tc.length-1;xb>=0;--xb)B(tc[xb]);vb.normalizeUnits=function(a){return z(a)},vb.invalid=function(a){var b=vb.utc(0/0);return null!=a?o(b._pf,a):b._pf.userInvalidated=!0,b},vb.parseZone=function(){return vb.apply(null,arguments).parseZone()},vb.parseTwoDigitYear=function(a){return C(a)+(C(a)>68?1900:2e3)},vb.isDate=x,o(vb.fn=m.prototype,{clone:function(){return vb(this)},valueOf:function(){return+this._d-6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=vb(this).utc();return 0<a.year()&&a.year()<=9999?"function"==typeof Date.prototype.toISOString?this.toDate().toISOString():P(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):P(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return I(this)},isDSTShifted:function(){return this._a?this.isValid()&&y(this._a,(this._isUTC?vb.utc(this._a):vb(this._a)).toArray())>0:!1},parsingFlags:function(){return o({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(a){return this.utcOffset(0,a)},local:function(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(this._dateUtcOffset(),"m")),this},format:function(a){var b=P(this,a||vb.defaultFormat);return this.localeData().postformat(b)},add:u(1,"add"),subtract:u(-1,"subtract"),diff:function(a,b,c){var d,e,f=M(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=z(b),"year"===b||"month"===b||"quarter"===b?(e=j(this,f),"quarter"===b?e/=3:"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:q(e)},from:function(a,b){return vb.duration({to:this,from:a}).locale(this.locale()).humanize(!b)},fromNow:function(a){return this.from(vb(),a)},calendar:function(a){var b=a||vb(),c=M(b,this).startOf("day"),d=this.diff(c,"days",!0),e=-6>d?"sameElse":-1>d?"lastWeek":0>d?"lastDay":1>d?"sameDay":2>d?"nextDay":7>d?"nextWeek":"sameElse";return this.format(this.localeData().calendar(e,this,vb(b)))},isLeapYear:function(){return G(this.year())},isDST:function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=gb(a,this.localeData()),this.add(a-b,"d")):b},month:qb("Month",!0),startOf:function(a){switch(a=z(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this},endOf:function(b){return b=z(b),b===a||"millisecond"===b?this:this.startOf(b).add(1,"isoWeek"===b?"week":b).subtract(1,"ms")},isAfter:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this>+a):(c=vb.isMoment(a)?+a:+vb(a),c<+this.clone().startOf(b))},isBefore:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+a>+this):(c=vb.isMoment(a)?+a:+vb(a),+this.clone().endOf(b)<c)},isBetween:function(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)},isSame:function(a,b){var c;return b=z(b||"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this===+a):(c=+vb(a),+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))},min:f("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),this>a?this:a}),max:f("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),a>this?this:a}),zone:f("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",function(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}),utcOffset:function(a,b){var c,d=this._offset||0;return null!=a?("string"==typeof a&&(a=S(a)),Math.abs(a)<16&&(a=60*a),!this._isUTC&&b&&(c=this._dateUtcOffset()),this._offset=a,this._isUTC=!0,null!=c&&this.add(c,"m"),d!==a&&(!b||this._changeInProgress?v(this,vb.duration(a-d,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,vb.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?d:this._dateUtcOffset()},isLocal:function(){return!this._isUTC},isUtcOffset:function(){return this._isUTC},isUtc:function(){return this._isUTC&&0===this._offset},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.utcOffset(this._tzm):"string"==typeof this._i&&this.utcOffset(S(this._i)),this},hasAlignedHourOffset:function(a){return a=a?vb(a).utcOffset():0,(this.utcOffset()-a)%60===0},daysInMonth:function(){return D(this.year(),this.month())},dayOfYear:function(a){var b=Ab((vb(this).startOf("day")-vb(this).startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")},quarter:function(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)},weekYear:function(a){var b=jb(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,"y")},isoWeekYear:function(a){var b=jb(this,1,4).year;return null==a?b:this.add(a-b,"y")},week:function(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")},isoWeek:function(a){var b=jb(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")},weekday:function(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},isoWeeksInYear:function(){return E(this.year(),1,4)},weeksInYear:function(){var a=this.localeData()._week;return E(this.year(),a.dow,a.doy)},get:function(a){return a=z(a),this[a]()},set:function(a,b){var c;if("object"==typeof a)for(c in a)this.set(c,a[c]);else a=z(a),"function"==typeof this[a]&&this[a](b);return this},locale:function(b){var c;return b===a?this._locale._abbr:(c=vb.localeData(b),null!=c&&(this._locale=c),this)},lang:f("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(b){return b===a?this.localeData():this.locale(b)}),localeData:function(){return this._locale},_dateUtcOffset:function(){return 15*-Math.round(this._d.getTimezoneOffset()/15)}}),vb.fn.millisecond=vb.fn.milliseconds=qb("Milliseconds",!1),vb.fn.second=vb.fn.seconds=qb("Seconds",!1),vb.fn.minute=vb.fn.minutes=qb("Minutes",!1),vb.fn.hour=vb.fn.hours=qb("Hours",!0),vb.fn.date=qb("Date",!0),vb.fn.dates=f("dates accessor is deprecated. Use date instead.",qb("Date",!0)),vb.fn.year=qb("FullYear",!0),vb.fn.years=f("years accessor is deprecated. Use year instead.",qb("FullYear",!0)),vb.fn.days=vb.fn.day,vb.fn.months=vb.fn.month,vb.fn.weeks=vb.fn.week,vb.fn.isoWeeks=vb.fn.isoWeek,vb.fn.quarters=vb.fn.quarter,vb.fn.toJSON=vb.fn.toISOString,vb.fn.isUTC=vb.fn.isUtc,o(vb.duration.fn=n.prototype,{_bubble:function(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;g.milliseconds=d%1e3,a=q(d/1e3),g.seconds=a%60,b=q(a/60),g.minutes=b%60,c=q(b/60),g.hours=c%24,e+=q(c/24),h=q(rb(e)),e-=q(sb(h)),f+=q(e/30),e%=30,h+=q(f/12),f%=12,g.days=e,g.months=f,g.years=h},abs:function(){return this._milliseconds=Math.abs(this._milliseconds),this._days=Math.abs(this._days),this._months=Math.abs(this._months),this._data.milliseconds=Math.abs(this._data.milliseconds),this._data.seconds=Math.abs(this._data.seconds),this._data.minutes=Math.abs(this._data.minutes),this._data.hours=Math.abs(this._data.hours),this._data.months=Math.abs(this._data.months),this._data.years=Math.abs(this._data.years),this},weeks:function(){return q(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*C(this._months/12)
},humanize:function(a){var b=ib(this,!a,this.localeData());return a&&(b=this.localeData().pastFuture(+this,b)),this.localeData().postformat(b)},add:function(a,b){var c=vb.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=vb.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=z(a),this[a.toLowerCase()+"s"]()},as:function(a){var b,c;if(a=z(a),"month"===a||"year"===a)return b=this._days+this._milliseconds/864e5,c=this._months+12*rb(b),"month"===a?c:c/12;switch(b=this._days+Math.round(sb(this._months/12)),a){case"week":return b/7+this._milliseconds/6048e5;case"day":return b+this._milliseconds/864e5;case"hour":return 24*b+this._milliseconds/36e5;case"minute":return 24*b*60+this._milliseconds/6e4;case"second":return 24*b*60*60+this._milliseconds/1e3;case"millisecond":return Math.floor(24*b*60*60*1e3)+this._milliseconds;default:throw new Error("Unknown unit "+a)}},lang:vb.fn.lang,locale:vb.fn.locale,toIsoString:f("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",function(){return this.toISOString()}),toISOString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"},localeData:function(){return this._locale},toJSON:function(){return this.toISOString()}}),vb.duration.fn.toString=vb.duration.fn.toISOString;for(xb in kc)c(kc,xb)&&tb(xb.toLowerCase());vb.duration.fn.asMilliseconds=function(){return this.as("ms")},vb.duration.fn.asSeconds=function(){return this.as("s")},vb.duration.fn.asMinutes=function(){return this.as("m")},vb.duration.fn.asHours=function(){return this.as("h")},vb.duration.fn.asDays=function(){return this.as("d")},vb.duration.fn.asWeeks=function(){return this.as("weeks")},vb.duration.fn.asMonths=function(){return this.as("M")},vb.duration.fn.asYears=function(){return this.as("y")},vb.locale("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===C(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),Lb?module.exports=vb:"function"==typeof define&&define.amd?(define(function(a,b,c){return c.config&&c.config()&&c.config().noGlobal===!0&&(zb.moment=wb),vb}),ub(!0)):ub()}).call(this);
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/modernizr/modernizr.flexbox.min.js

try{
/* Modernizr 2.7.0 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-flexbox-shiv-cssclasses-testprop-testallprops-domprefixes-load
 */
console.log('starting parsing modernizr.flexbox.min.js');
;window.Modernizr=function(a,b,c){function x(a){j.cssText=a}function y(a,b){return x(prefixes.join(a+";")+(b||""))}function z(a,b){return typeof a===b}function A(a,b){return!!~(""+a).indexOf(b)}function B(a,b){for(var d in a){var e=a[d];if(!A(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function C(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:z(f,"function")?f.bind(d||b):f}return!1}function D(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+n.join(d+" ")+d).split(" ");return z(b,"string")||z(b,"undefined")?B(e,b):(e=(a+" "+o.join(d+" ")+d).split(" "),C(e,b,c))}var d="2.7.0",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m="Webkit Moz O ms",n=m.split(" "),o=m.toLowerCase().split(" "),p={},q={},r={},s=[],t=s.slice,u,v={}.hasOwnProperty,w;!z(v,"undefined")&&!z(v.call,"undefined")?w=function(a,b){return v.call(a,b)}:w=function(a,b){return b in a&&z(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=t.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(t.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(t.call(arguments)))};return e}),p.flexbox=function(){return D("flexWrap")};for(var E in p)w(p,E)&&(u=E.toLowerCase(),e[u]=p[E](),s.push((e[u]?"":"no-")+u));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)w(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},x(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e._domPrefixes=o,e._cssomPrefixes=n,e.testProp=function(a){return B([a])},e.testAllProps=D,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+s.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};
console.log('ending parsing modernizr.flexbox.min.js');
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/modernizr/modernizr.inputTypes.min.js

try{
/* Modernizr 2.6.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-input-inputtypes-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes
 */
console.log('starting parsing modernizrInputType.js');
;window.Modernizr=function(a,b,c){function A(a){i.cssText=a}function B(a,b){return A(m.join(a+";")+(b||""))}function C(a,b){return typeof a===b}function D(a,b){return!!~(""+a).indexOf(b)}function E(a,b){for(var d in a){var e=a[d];if(!D(e,"-")&&i[e]!==c)return b=="pfx"?e:!0}return!1}function F(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:C(f,"function")?f.bind(d||b):f}return!1}function G(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+o.join(d+" ")+d).split(" ");return C(b,"string")||C(b,"undefined")?E(e,b):(e=(a+" "+p.join(d+" ")+d).split(" "),F(e,b,c))}function H(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)s[c[d]]=c[d]in j;return s.list&&(s.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),s}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,g,h,i=a.length;d<i;d++)j.setAttribute("type",g=a[d]),e=j.type!=="text",e&&(j.value=k,j.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(g)&&j.style.WebkitAppearance!==c?(f.appendChild(j),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(j,null).WebkitAppearance!=="textfield"&&j.offsetHeight!==0,f.removeChild(j)):/^(search|tel)$/.test(g)||(/^(url|email)$/.test(g)?e=j.checkValidity&&j.checkValidity()===!1:e=j.value!=k)),r[a[d]]=!!e;return r}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.6.2",e={},f=b.documentElement,g="modernizr",h=b.createElement(g),i=h.style,j=b.createElement("input"),k=":)",l={}.toString,m=" -webkit- -moz- -o- -ms- ".split(" "),n="Webkit Moz O ms",o=n.split(" "),p=n.toLowerCase().split(" "),q={},r={},s={},t=[],u=t.slice,v,w=function(a,c,d,e){var h,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:g+(d+1),l.appendChild(j);return h=["&#173;",'<style id="s',g,'">',a,"</style>"].join(""),l.id=g,(m?l:n).innerHTML+=h,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=f.style.overflow,f.style.overflow="hidden",f.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),f.style.overflow=k),!!i},x=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=C(e[d],"function"),C(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),y={}.hasOwnProperty,z;!C(y,"undefined")&&!C(y.call,"undefined")?z=function(a,b){return y.call(a,b)}:z=function(a,b){return b in a&&C(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=u.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(u.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(u.call(arguments)))};return e});for(var I in q)z(q,I)&&(v=I.toLowerCase(),e[v]=q[I](),t.push((e[v]?"":"no-")+v));return e.input||H(),e.addTest=function(a,b){if(typeof a=="object")for(var d in a)z(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof enableClasses!="undefined"&&enableClasses&&(f.className+=" "+(b?"":"no-")+a),e[a]=b}return e},A(""),h=j=null,e._version=d,e._prefixes=m,e._domPrefixes=p,e._cssomPrefixes=o,e.hasEvent=x,e.testProp=function(a){return E([a])},e.testAllProps=G,e.testStyles=w,e}(this,this.document);
console.log('ending parsing modernizrInputType.js');

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/fastclick/build/fastclick.min.js

try{
/*
 FastClick: polyfill to remove click delays on browsers with touch UIs.

 @version 0.6.3
 @codingstandard ftlabs-jsv2
 @copyright The Financial Times Limited [All Rights Reserved]
 @license MIT License (see LICENSE.txt)
*/
console.log('starting parsing fastclick.js');
function FastClick(a,c){var d,b=this,f;this.trackingClick=!1;this.trackingClickStart=0;this.targetElement=null;this.lastTouchIdentifier=this.touchStartY=this.touchStartX=0;this.layer=a;if(!a||!a.nodeType)throw new TypeError("Layer must be a document node");this.options={onTouchStart:null,onClickCancelled:null,onTouchEnd:null,onBeforeClick:null};for(f in c)this.options[f]=c[f];this.onClick=function(){return FastClick.prototype.onClick.apply(b,arguments)};this.onMouse=function(){return FastClick.prototype.onMouse.apply(b,
arguments)};this.onTouchMove=function(){return FastClick.prototype.onTouchMove.apply(b,arguments)};this.onTouchStart=function(){b.options.onClickCancelled&&window.addEventListener("touchmove",b.onTouchMove,!0);var a=FastClick.prototype.onTouchStart.apply(b,arguments);b.options.onTouchStart&&b.options.onTouchStart.call(b);return a};this.onTouchEnd=function(){b.options.onClickCancelled&&window.removeEventListener("touchmove",b.onTouchMove,!0);var a=FastClick.prototype.onTouchEnd.apply(b,arguments);
b.options.onTouchEnd&&b.options.onTouchEnd.call(b,{target:null,origEvent:event});return a};this.onTouchCancel=function(){return FastClick.prototype.onTouchCancel.apply(b,arguments)};FastClick.notNeeded()||(this.deviceIsAndroid&&(a.addEventListener("mouseover",this.onMouse,!0),a.addEventListener("mousedown",this.onMouse,!0),a.addEventListener("mouseup",this.onMouse,!0)),a.addEventListener("click",this.onClick,!0),a.addEventListener("touchstart",this.onTouchStart,!1),a.addEventListener("touchend",this.onTouchEnd,
!1),a.addEventListener("touchcancel",this.onTouchCancel,!1),Event.prototype.stopImmediatePropagation||(a.removeEventListener=function(b,c,d){var e=Node.prototype.removeEventListener;"click"===b?e.call(a,b,c.hijacked||c,d):e.call(a,b,c,d)},a.addEventListener=function(b,c,d){var e=Node.prototype.addEventListener;"click"===b?e.call(a,b,c.hijacked||(c.hijacked=function(a){a.propagationStopped||c(a)}),d):e.call(a,b,c,d)}),"function"===typeof a.onclick&&(d=a.onclick,a.addEventListener("click",function(a){d(a)},
!1),a.onclick=null))}FastClick.prototype.deviceIsAndroid=0<navigator.userAgent.indexOf("Android");FastClick.prototype.deviceIsIOS=/iP(ad|hone|od)/.test(navigator.userAgent);FastClick.prototype.deviceIsIOS4=FastClick.prototype.deviceIsIOS&&/OS 4_\d(_\d)?/.test(navigator.userAgent);FastClick.prototype.deviceIsIOSWithBadTarget=FastClick.prototype.deviceIsIOS&&/OS ([6-9]|\d{2})_\d/.test(navigator.userAgent);
FastClick.prototype.needsClick=function(a){switch(a.nodeName.toLowerCase()){case "button":case "input":return this.deviceIsIOS&&"file"===a.type?!0:a.disabled;case "label":case "video":return!0;default:return/\bneedsclick\b/.test(a.className)}};
FastClick.prototype.needsFocus=function(a){switch(a.nodeName.toLowerCase()){case "textarea":case "select":return!0;case "input":switch(a.type){case "button":case "checkbox":case "file":case "image":case "radio":case "submit":return!1}return!a.disabled&&!a.readOnly;default:return/\bneedsfocus\b/.test(a.className)}};
FastClick.prototype.sendClick=function(a,c){var d,b;document.activeElement&&document.activeElement!==a&&document.activeElement.blur();b=c.changedTouches[0];d=document.createEvent("MouseEvents");d.initMouseEvent("click",!0,!0,window,1,b.screenX,b.screenY,b.clientX,b.clientY,!1,!1,!1,!1,0,null);d.forwardedTouchEvent=!0;this.options.onBeforeClick&&this.options.onBeforeClick.call(this);a.dispatchEvent(d)};
FastClick.prototype.focus=function(a){var c;this.deviceIsIOS&&a.setSelectionRange?(c=a.value.length,a.setSelectionRange(c,c)):a.focus()};FastClick.prototype.updateScrollParent=function(a){var c,d;c=a.fastClickScrollParent;if(!c||!c.contains(a)){d=a;do{if(d.scrollHeight>d.offsetHeight){c=d;a.fastClickScrollParent=d;break}d=d.parentElement}while(d)}c&&(c.fastClickLastScrollTop=c.scrollTop)};
FastClick.prototype.getTargetElementFromEventTarget=function(a){return a.nodeType===Node.TEXT_NODE?a.parentNode:a};
FastClick.prototype.onTouchStart=function(a){var c,d,b;c=this.getTargetElementFromEventTarget(a.target);d=a.targetTouches[0];if(this.deviceIsIOS){b=window.getSelection();if(b.rangeCount&&!b.isCollapsed)return!0;if(!this.deviceIsIOS4){if(d.identifier===this.lastTouchIdentifier)return a.preventDefault(),!1;this.lastTouchIdentifier=d.identifier;this.updateScrollParent(c)}}this.trackingClick=!0;this.trackingClickStart=a.timeStamp;this.targetElement=c;this.touchStartX=d.pageX;this.touchStartY=d.pageY;
200>a.timeStamp-this.lastClickTime&&a.preventDefault();return!0};FastClick.prototype.touchHasMoved=function(a){a=a.changedTouches[0];return 10<Math.abs(a.pageX-this.touchStartX)||10<Math.abs(a.pageY-this.touchStartY)?!0:!1};FastClick.prototype.onTouchMove=function(a){this.touchHasMoved(a)&&(this.options.onClickCancelled.call(this),window.removeEventListener("touchmove",this.onTouchMove,!0));return!0};
FastClick.prototype.findControl=function(a){return void 0!==a.control?a.control:a.htmlFor?document.getElementById(a.htmlFor):a.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")};
FastClick.prototype.onTouchEnd=function(a){var c,d,b;b=this.targetElement;this.touchHasMoved(a)&&(this.trackingClick=!1,this.targetElement=null);if(!this.trackingClick)return!0;if(200>a.timeStamp-this.lastClickTime)return this.cancelNextClick=!0;this.lastClickTime=a.timeStamp;c=this.trackingClickStart;this.trackingClick=!1;this.trackingClickStart=0;this.deviceIsIOSWithBadTarget&&(b=a.changedTouches[0],b=document.elementFromPoint(b.pageX-window.pageXOffset,b.pageY-window.pageYOffset));d=b.tagName.toLowerCase();
if("label"===d){if(c=this.findControl(b)){this.focus(b);if(this.deviceIsAndroid)return!1;b=c}}else if(this.needsFocus(b)){if(100<a.timeStamp-c||this.deviceIsIOS&&window.top!==window&&"input"===d)return this.targetElement=null,!1;this.focus(b);if(!this.deviceIsIOS4||"select"!==d)this.targetElement=null,a.preventDefault();return!1}if(this.deviceIsIOS&&!this.deviceIsIOS4&&(c=b.fastClickScrollParent)&&c.fastClickLastScrollTop!==c.scrollTop)return!0;this.needsClick(b)||(a.preventDefault(),this.sendClick(b,
a));return!1};FastClick.prototype.onTouchCancel=function(){this.trackingClick=!1;this.targetElement=null};FastClick.prototype.onMouse=function(a){return!this.targetElement||a.forwardedTouchEvent||!a.cancelable?!0:!this.needsClick(this.targetElement)||this.cancelNextClick?(a.stopImmediatePropagation?a.stopImmediatePropagation():a.propagationStopped=!0,a.stopPropagation(),a.preventDefault(),!1):!0};
FastClick.prototype.onClick=function(a){if(this.trackingClick)return this.targetElement=null,this.trackingClick=!1,!0;if("submit"===a.target.type&&0===a.detail)return!0;a=this.onMouse(a);a||(this.targetElement=null);return a};
FastClick.prototype.destroy=function(){var a=this.layer;this.deviceIsAndroid&&(a.removeEventListener("mouseover",this.onMouse,!0),a.removeEventListener("mousedown",this.onMouse,!0),a.removeEventListener("mouseup",this.onMouse,!0));a.removeEventListener("click",this.onClick,!0);a.removeEventListener("touchstart",this.onTouchStart,!1);a.removeEventListener("touchend",this.onTouchEnd,!1);a.removeEventListener("touchcancel",this.onTouchCancel,!1)};
FastClick.notNeeded=function(){return"undefined"===typeof window.ontouchstart?!0:!1};FastClick.attach=function(a){return new FastClick(a)};"undefined"!==typeof define&&define.amd&&define(function(){return FastClick});"undefined"!==typeof module&&module.exports&&(module.exports=FastClick.attach,module.exports.FastClick=FastClick);
console.log('ending parsing fastclick.js');

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/mobiscroll/2.11.1.patch/mobiscroll.js

try{
/*! mobile - v1.0.0 - 2014-07-21
 * Copyright (c) 2014 ; Licensed  */
/*!
 * Mobiscroll v2.11.1
 * http://mobiscroll.com
 *
 * Copyright 2010-2014, Acid Media
 * Licensed under the MIT license.
 *
 */
console.log('starting parsing mobiscroll.js');
(function ($) {

    function testProps(props) {
        var i;
        for (i in props) {
            if (mod[props[i]] !== undefined) {
                return true;
            }
        }
        return false;
    }

    function testPrefix() {
        var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
            p;

        for (p in prefixes) {
            if (testProps([prefixes[p] + 'Transform'])) {
                return '-' + prefixes[p].toLowerCase() + '-';
            }
        }
        return '';
    }

    function getCoord(e, c) {
        var ev = e.originalEvent || e;
        return ev.changedTouches ? ev.changedTouches[0]['page' + c] : e['page' + c];
    }

    function init(that, options, args) {
        var ret = that;

        // Init
        if (typeof options === 'object') {
            return that.each(function () {
                if (!this.id) {
                    this.id = 'mobiscroll' + (++id);
                }
                if (instances[this.id]) {
                    instances[this.id].destroy();
                }
                new $.mobiscroll.classes[options.component || 'Scroller'](this, options);
            });
        }

        // Method call
        if (typeof options === 'string') {
            that.each(function () {
                var r,
                    inst = instances[this.id];

                if (inst && inst[options]) {
                    r = inst[options].apply(this, Array.prototype.slice.call(args, 1));
                    if (r !== undefined) {
                        ret = r;
                        return false;
                    }
                }
            });
        }

        return ret;
    }

    function testTouch(e) {
        if (e.type == 'touchstart') {
            touches[e.target] = true;
        } else if (touches[e.target]) {
            delete touches[e.target];
            return false;
        }
        return true;
    }

    var id = +new Date(),
        touches = {},
        instances = {},
        extend = $.extend,
        mod = document.createElement('modernizr').style,
        has3d = testProps(['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective']),
        hasFlex = testProps(['flex', 'msFlex', 'WebkitBoxDirection']),
        prefix = testPrefix(),
        pr = prefix.replace(/^\-/, '').replace(/\-$/, '').replace('moz', 'Moz');

    $.fn.mobiscroll = function (method) {
        extend(this, $.mobiscroll.components);
        return init(this, method, arguments);
    };

    $.mobiscroll = $.mobiscroll || {
        util: {
            prefix: prefix,
            jsPrefix: pr,
            has3d: has3d,
            hasFlex: hasFlex,
            getCoord: getCoord,
            testTouch: testTouch
        },
        presets: {},
        themes: {
            listview: {}
        },
        i18n: {},
        instances: instances,
        classes: {},
        components: {},
        defaults: {},
        userdef: {},
        setDefaults: function (o) {
            extend(this.userdef, o);
        },
        presetShort: function (name, c) {
            this.components[name] = function (s) {
                return init(this, extend(s, { component: c, preset: name }), arguments);
            };
        }
    };

    $.scroller = $.scroller || $.mobiscroll;
    $.fn.scroller = $.fn.scroller || $.fn.mobiscroll;

})(jQuery);

(function ($) {

    var ms = $.mobiscroll,
        util = ms.util,
        has3d = util.has3d,
        pr = util.jsPrefix,
        get = util.getCoord,
        testTouch = util.testTouch,
        transEnd = 'webkitTransitionEnd transitionend',
        defaults = {
            controls: ['calendar'],
            firstDay: 0,
            maxMonthWidth: 170,
            months: 1,
            preMonths: 1,
            highlight: true,
            swipe: true,
            liveSwipe: true,
            divergentDayChange: true,
            navigation: 'yearMonth',
            // Localization
            dateText: 'Date',
            timeText: 'Time',
            calendarText: 'Calendar',
            prevMonthText: 'Previous Month',
            nextMonthText: 'Next Month',
            prevYearText: 'Previous Year',
            nextYearText: 'Next Year',
            btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left6',
            btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right6'
        };

    ms.presets.calbase = function (inst) {

        function isValid(d) {
            if (d < new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate())) {
                return false;
            }

            if (d > maxDateTime) {
                return false;
            }

            return invalidObj[d] === undefined || validObj[d] !== undefined;
        }

        function prepareObj(list, y, m) {
            var d, v, t, startTime,
                obj = {},
                n = preMonth + monthDiff;

            if (list) {
                // Convert deprecated object to list, will be removed in 3.0
                list = inst.convert(list);

                $.each(list, function (i, ev) {
                    d = ev.d || ev.start || ev;
                    v = d + '';

                    if (ev.start && ev.end) {
                        startTime = new Date(ev.start);
                        while (startTime <= ev.end) {
                            t = new Date(startTime.getFullYear(), startTime.getMonth(), startTime.getDate());
                            obj[t] = obj[t] || [];
                            obj[t].push(ev);
                            startTime.setDate(startTime.getDate() + 1);
                        }
                    } else if (d.getTime) { // Exact date
                        t = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                        obj[t] = obj[t] || [];
                        obj[t].push(ev);
                    } else if (!v.match(/w/i)) { // Day of month
                        v = v.split('/');
                        if (v[1]) {
                            if (m + n >= 11) {
                                t = s.getDate(y + 1, v[0] - 1, v[1]);
                                obj[t] = obj[t] || [];
                                obj[t].push(ev);
                            }
                            if (m - n <= 1) {
                                t = s.getDate(y - 1, v[0] - 1, v[1]);
                                obj[t] = obj[t] || [];
                                obj[t].push(ev);
                            }

                            t = s.getDate(y, v[0] - 1, v[1]);
                            obj[t] = obj[t] || [];
                            obj[t].push(ev);

                        } else {
                            for (j = 0; j < totalMonth; j++) {
                                t = s.getDate(y, m - preMonth - moveMonth + j, v[0]);
                                obj[t] = obj[t] || [];
                                obj[t].push(ev);
                            }

                        }
                    } else { // Day of week
                        var x = +v.replace('w', ''),
                            offset = 0,
                            w = s.getDate(y, m - preMonth - moveMonth, 1).getDay();

                        if (s.firstDay - w + 1 > 1) {
                            offset = 7;
                        }

                        for (j = 0; j < totalMonth * 5; j++) {
                            t = s.getDate(y, m - preMonth - moveMonth, j * 7 - offset - w + 1 + x);
                            obj[t] = obj[t] || [];
                            obj[t].push(ev);
                        }
                    }
                });
            }
            return obj;
        }

        function onGenMonth(y, m) {
            invalidObj = prepareObj(s.invalid, y, m);
            validObj = prepareObj(s.valid, y, m);
            inst.onGenMonth(y, m);
        }

        function genMonth(yr, mo) {
            var curr,
                cssClass,
                y,
                m,
                d,
                jm,
                jd,
                full,
                props,
                valid,
                selected,
                other,
                i,
                j,
                k = 1,
                offset = 0,
                real = s.getDate(yr, mo, 1),  // Get real year and month (if month < 0 or > 11)
                year = s.getYear(real),
                month = s.getMonth(real),
                sel = inst.getDate(true),
                w = s.getDate(year, month, 1).getDay(), // Get the weekday of the month
                html = '<div class="dw-cal-table">',
                weeknrs = '<div class="dw-week-nr-c">';

            if (s.firstDay - w + 1 > 1) {
                offset = 7;
            }

            for (j = 0; j < 42; j++) {
                i = j + s.firstDay - offset;
                curr = s.getDate(year, month, i - w + 1);
                y = curr.getFullYear();
                m = curr.getMonth();
                d = curr.getDate();
                jm = s.getMonth(curr);
                jd = s.getDay(curr);
                full = y + '-' + m + '-' + d;
                props = $.extend({
                    valid: isValid(curr),
                    selected: sel.getFullYear() === y && sel.getMonth() === m && sel.getDate() === d
                }, inst.getDayProps(curr, sel));
                valid = props.valid;
                selected = props.selected;
                cssClass = props.cssClass;
                other = jm !== month; // Day is from another month

                dayProps[full] = props;

                if (j % 7 === 0) {
                    html += (j ? '</div>' : '') + '<div class="dw-cal-row' + (s.highlight && sel - curr >= 0 && sel - curr < 1000 * 60 * 60 * 24 * 7 ? ' dw-cal-week-hl' : '') + '">';
                    if (weeks) {
                        // If displaying days from next month, reset month counter
                        if (weeks == 'month' && other && j) {
                            k = d == 1 ? 1 : 2;
                        } else if (weeks == 'year') {
                            k = s.getWeekNumber(curr);
                        }
                        weeknrs += '<div class="dw-week-nr"><div class="dw-week-nr-i">' + k + '</div></div>';
                        k++;
                    }
                }

                html += '<div role="button" tabindex="-1" class="dw-cal-day ' +
                    (s.dayClass || '') +
                    (selected ? ' dw-sel' : '') +
                    (cssClass ? ' ' + cssClass : '') +
                    (other ? ' dw-cal-day-diff' : '') +
                    (valid ? ' dw-cal-day-v dwb-e dwb-nhl' : ' dw-cal-day-inv') + '" data-day="' + (i % 7) + '" data-full="' + full + '"' + (selected ? ' aria-selected="true"' : '') + (valid ? '' : ' aria-disabled="true"') + '><div class="dw-i ' +
                    (selected ? activeClass : '') + ' ' +
                    (valid ? (s.validDayClass || '') : '') + '">' +
                    '<div class="dw-cal-day-fg">' + jd + '</div>' +
                    (props.markup || '') +
                    '<div class="dw-cal-day-frame"></div></div></div>';
            }

            html += '</div>' + weeknrs + '</div></div>';

            return html;
        }

        function setTitle(year, month) {
            for (i = 0; i < monthNr; ++i) {
                $(monthTitle[i]).text(months[s.getMonth(s.getDate(year, month - moveMonth + i, 1))]);
                if (yearTitle.length > 1) {
                    $(yearTitle[i]).text(s.getYear(s.getDate(year, month - moveMonth + i, 1)));
                }
            }
            if (yearTitle.length == 1) {
                yearTitle.text(s.getYear(s.getDate(year, month, 1)));
            }

            // Disable/enable prev/next buttons
            if (s.getDate(year, month - moveMonth - 1, 1) < minDate) {
                $('.dw-cal-prev-m', ctx).addClass(disabled).attr('aria-disabled', 'true');
            } else {
                $('.dw-cal-prev-m', ctx).removeClass(disabled).removeAttr('aria-disabled');
            }
            if (s.getDate(year, month + monthNr - moveMonth, 1) > maxDate) {
                $('.dw-cal-next-m', ctx).addClass(disabled).attr('aria-disabled', 'true');
            } else {
                $('.dw-cal-next-m', ctx).removeClass(disabled).removeAttr('aria-disabled');
            }
            if (s.getDate(year, month, 1).getFullYear() <= minDate.getFullYear()) {
                $('.dw-cal-prev-y', ctx).addClass(disabled).attr('aria-disabled', 'true');
            } else {
                $('.dw-cal-prev-y', ctx).removeClass(disabled).removeAttr('aria-disabled');
            }
            if (s.getDate(year, month, 1).getFullYear() >= maxDate.getFullYear()) {
                $('.dw-cal-next-y', ctx).addClass(disabled).attr('aria-disabled', 'true');
            } else {
                $('.dw-cal-next-y', ctx).removeClass(disabled).removeAttr('aria-disabled');
            }
        }

        function highlightDate(d) {
            inst.trigger('onDayHighlight', [d]);
            if (s.highlight) {
                $('.dw-cal .dw-sel .dw-i', ctx).removeClass(activeClass);
                $('.dw-cal .dw-sel', ctx).removeClass('dw-sel').removeAttr('aria-selected');
                $('.dw-cal-week-hl', ctx).removeClass('dw-cal-week-hl');

                $('.dw-cal .dw-cal-day[data-full="' + d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate() + '"]', ctx)
                    .addClass('dw-sel').attr('aria-selected', 'true')
                    .parent().addClass('dw-cal-week-hl');

                $('.dw-cal .dw-sel .dw-i', ctx).addClass(activeClass);
            }
        }

        function setDate(d, nav) {
            if (controls.calendar && (visibleTab === 'calendar' || nav)) {
                var dir,
                    load,
                    curr = s.getDate(currYear, currMonth, 1),
                    diff = Math.abs((s.getYear(d) - s.getYear(curr)) * 12 + s.getMonth(d) - s.getMonth(curr));


                if (inst.needsSlide && diff) {
                    currYear = s.getYear(d);
                    currMonth = s.getMonth(d);
                    if (d > curr) {
                        load = diff > preMonth - moveMonth + monthNr - 1;
                        currMonth -= load ? 0 : diff - preMonth;
                        dir = 'next';
                    } else if (d < curr) {
                        load = diff > preMonth + moveMonth;
                        currMonth += load ? 0 : diff - preMonth;
                        dir = 'prev';
                    }
                    changeMonth.call(this, currYear, currMonth, dir, Math.min(diff, preMonth), load, true);
                }
                if (!nav) {
                    highlightDate(d);
                }
                inst.needsSlide = true;
            }
        }

        function preload(y, m) {
            onGenMonth(y, m);

            for (i = 0; i < totalMonth; i++) {
                slidesArray[i].html(genMonth(y, m - moveMonth - preMonth + i));
            }

            inst.needsRefresh = false;
        }

        function changeMonth(y, m, dir, slideNr, load, active, callback) {
            // If called with any parameter, push into queue
            if (y) {
                queue.push({ y: y, m: m, dir: dir, slideNr: slideNr, load: load, active: active, callback: callback });
            }

            // Delay change if currently in transition
            if (trans) {
                return;
            }

            // Load params from queue
            var params = queue.shift(),
                d;

            y = params.y;
            m = params.m;
            dir = params.dir === 'next';
            slideNr = params.slideNr;
            load = params.load;
            active = params.active;
            callback = params.callback || empty;
            d = s.getDate(y, m, 1);
            y = s.getYear(d);
            m = s.getMonth(d);
            trans = true;

            inst.changing = true;
            inst.trigger('onMonthChange', [y, m]);

            onGenMonth(y, m);

            if (load) {
                for (i = 0; i < monthNr; i++) {
                    slidesArray[dir ? totalMonth - monthNr + i : i].html(genMonth(y, m - moveMonth + i));
                }
            }

            // Remove opacity from month during transition (if changed by button)
            if (active) {
                slides.addClass('dw-cal-slide-a');
            }

            setTimeout(function () {
                slide(dir ? startPos - animw * slideNr * rtl : startPos + animw * slideNr * rtl, 200, function () {
                    var tempArray;

                    slides.removeClass('dw-cal-slide-a');

                    // Reorder the slides array
                    if (dir) {
                        tempArray = slidesArray.splice(0, slideNr);
                        for (i = 0; i < slideNr; i++) {
                            slidesArray.push(tempArray[i]);
                            change(slidesArray[slidesArray.length - 1], +slidesArray[slidesArray.length - 2].data('curr') + 100 * rtl);
                        }
                    } else {
                        tempArray = slidesArray.splice(totalMonth - slideNr, slideNr);
                        for (i = slideNr - 1; i >= 0; i--) {
                            slidesArray.unshift(tempArray[i]);
                            change(slidesArray[0], +slidesArray[1].data('curr') - 100 * rtl);
                        }
                    }

                    // Generate new months
                    for (i = 0; i < slideNr; i++) {
                        slidesArray[dir ? totalMonth - slideNr + i : i].html(genMonth(y, m - moveMonth - preMonth + i + (dir ? totalMonth - slideNr : 0)));
                        if (load) {
                            slidesArray[dir ? i : totalMonth - slideNr + i].html(genMonth(y, m - moveMonth - preMonth + i + (dir ? 0 : totalMonth - slideNr)));
                        }
                    }

                    for (i = 0; i < monthNr; i++) {
                        slidesArray[preMonth + i].addClass('dw-cal-slide-a');
                    }

                    trans = false;

                    setTitle(y, m);

                    if (queue.length) {
                        setTimeout(function () {
                            changeMonth();
                        }, 10);
                    } else {
                        currYear = y;
                        currMonth = m;

                        inst.changing = false;

                        if (weeks) {
                            weeknr.html($('.dw-week-nr-c', slidesArray[preMonth]).html());
                        }

                        $('.dw-cal-day', ctx).attr('tabindex', -1);
                        $('.dw-cal-slide-a .dw-cal-day', ctx).attr('tabindex', 0);

                        if (inst.needsRefresh) {
                            refresh();
                        }

                        inst.trigger('onMonthLoaded', [y, m]);

                        callback();
                    }
                });
            }, 10);
        }

        function selectDay() {
            var cell = $(this),
                fill = inst.live,
                curr = inst.getDate(true),
                full = cell.attr('data-full'),
                parts = full.split('-'),
                d = new Date(parts[0], parts[1], parts[2]),
                dtime = new Date(d.getFullYear(), d.getMonth(), d.getDate(), curr.getHours(), curr.getMinutes(), curr.getSeconds()),
                selected = cell.hasClass('dw-sel');

            if (!showdiff && cell.hasClass('dw-cal-day-diff')) {
                return;
            }

            // Call onDayChange event
            if (inst.trigger('onDayChange', [$.extend(dayProps[full], { date: dtime, cell: this, selected: selected })]) !== false) {
                // Prevents month slide in setDate
                inst.needsSlide = false;

                // Set date on scroller
                inst.setDate(dtime, fill, 0.2, !fill, true);

                // Slide one month left or right
                if (s.divergentDayChange) {
                    running = true;
                    if (d < s.getDate(currYear, currMonth - moveMonth, 1)) { // Prev month
                        prevMonth();
                    } else if (d > s.getDate(currYear, currMonth - moveMonth + monthNr, 0)) { // Next month
                        nextMonth();
                    }
                    running = false;
                }
            }
        }

        function slide(pos, time, callback) {
            pos = Math.max(startPos - animw * preMonth, Math.min(pos, startPos + animw * preMonth));
            animc[0].style[pr + 'Transition'] = 'all ' + (time || 0) + 'ms';

            if (has3d) {
                if (callback) {
                    if (animPos == pos) {
                        callback();
                    } else {
                        animc.on(transEnd, function () {
                            animc.off(transEnd);
                            callback();
                        });
                    }
                }
                animc[0].style[pr + 'Transform'] = 'translate3d(' + pos + 'px,0,0)';
            } else {
                if (callback) {
                    setTimeout(callback, time);
                }
                animc[0].style.left = pos + 'px';
            }

            if (time) {
                startPos = pos;
            }

            animPos = pos;
        }

        function change(el, curr) {
            el.data('curr', curr);
            if (has3d) {
                el[0].style[pr + 'Transform'] = 'translate3d(' + curr + '%,0,0)';
            } else {
                el[0].style.left = curr + '%';
            }
        }

        function refresh() {
            if (inst.isVisible() && controls.calendar) {
                preload(currYear, currMonth);
            }
        }

        function nextMonth() {
            if (running && s.getDate(currYear, currMonth + monthNr - moveMonth, 1) <= maxDate) {
                changeMonth(currYear, ++currMonth, 'next', 1, false, true, nextMonth);
            }
        }

        function prevMonth() {
            if (running && s.getDate(currYear, currMonth - moveMonth - 1, 1) >= minDate) {
                changeMonth(currYear, --currMonth, 'prev', 1, false, true, prevMonth);
            }
        }

        function nextYear(btn) {
            if (running && s.getDate(currYear, currMonth, 1) <= s.getDate(s.getYear(maxDate) - 1, s.getMonth(maxDate) - monthDiff, 1)) {
                changeMonth(++currYear, currMonth, 'next', preMonth, true, true, function () { nextYear(btn); });
            } else if (running && !btn.hasClass('dwb-d')) {
                changeMonth(s.getYear(maxDate), s.getMonth(maxDate) - monthDiff, 'next', preMonth, true, true);
            }
        }

        function prevYear(btn) {
            if (running && s.getDate(currYear, currMonth, 1) >= s.getDate(s.getYear(minDate) + 1, s.getMonth(minDate) + moveMonth, 1)) {
                changeMonth(--currYear, currMonth, 'prev', preMonth, true, true, function () { prevYear(btn); });
            } else if (running && !btn.hasClass('dwb-d')) {
                changeMonth(s.getYear(minDate), s.getMonth(minDate) + moveMonth, 'prev', preMonth, true, true);
            }
        }

        var d,
            i,
            j,
            ret,
            cont,
            ctx,
            context,
            anim,
            animc,
            animw,
            animPos,
            startPos,
            html,
            initTabs,
            weeknr,
            months,
            monthTitle,
            yearTitle,
            minDate,
            maxDate,
            minDateTime,
            maxDateTime,
            prevDate,
            currYear,
            currMonth,
            startX,
            startY,
            endX,
            endY,
            validate,
            scrolled,
            validObj,
            invalidObj,
            panels,
            visibleTab,
            touch,
            trans,
            running,
            monthNr,
            totalMonth,
            monthDiff,
            moveMonth,
            showdiff,
            that = this,
            slides = [],
            slidesArray = [],
            queue = [],
            controls = {},
            dayProps = {},
            empty = function () {},
            orig = $.extend({}, inst.settings),
            s = $.extend(inst.settings, defaults, orig),
            weeks = s.weekCounter,
            layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),
            isLiquid = layout == 'liquid' && s.display !== 'bubble',
            isModal = s.display == 'modal',
            isRTL = s.rtl,
            rtl = isRTL ? -1 : 1, // Change month slide direction if RTL
            calWidth = isLiquid ? null : s.calendarWidth,
            preMonth = s.preMonths,
            yearBtn = s.navigation == 'yearMonth',
            ctrls = s.controls.join(','),
            showTabs = (s.tabs === true || (s.tabs !== false && isLiquid)) && s.controls.length > 1,
            checkTabs = (!showTabs && s.tabs === undefined && !isLiquid && s.controls.length > 1),
            activeClass = s.activeClass || '',
            activeTabClass = 'dw-sel ' + (s.activeTabClass || ''),
            activeTabInnerClass = s.activeTabInnerClass || '',
            disabled = 'dwb-d ' + (s.disabledClass || '');

        if (ctrls.match(/calendar/)) {
            controls.calendar = 1;
        }

        if (ctrls.match(/date/)) {
            controls.date = 1;
        }

        if (ctrls.match(/time/)) {
            controls.time = 1;
        }

        if (controls.calendar && controls.date) {
            showTabs = true;
            checkTabs = false;
        }

        s.layout = layout; // Pass back to core if set to liquid
        s.preset = (controls.date || controls.calendar ? 'date' : '') + (controls.time ? 'time' : '');

        // Call position on pageshow
        if (s.display == 'inline') {
            $(this).closest('[data-role="page"]').on('pageshow', function () {
                inst.position();
            });
        }

        // Extended methods
        // ---

        inst.changing = false;

        inst.needsRefresh = false;

        inst.needsSlide = true;

        inst.getDayProps = empty;

        inst.onGenMonth = empty;

        inst.prepareObj = prepareObj;

        inst.refresh = function () {
            // Postpone refresh if currently changing month
            if (!inst.changing) {
                refresh();
            } else {
                inst.needsRefresh = true;
            }
        };

        inst.navigate = function (d, anim) {
            var visible = inst.isVisible();
            if (anim && visible) {
                setDate(d, true);
            } else {
                currYear = d.getFullYear();
                currMonth = d.getMonth();
                if (visible) {
                    setTitle(currYear, currMonth);
                    preload(currYear, currMonth);
                }
            }
        };

        // ---

        ret = ms.presets.datetime.call(this, inst);

        validate = ret.validate;

        $.extend(ret, {
            onMarkupReady: function (dw) {
                var tabs,
                    monthBtns,
                    yearBtns = '',
                    monthIndex = s.dateOrder.search(/m/i),
                    yearIndex = s.dateOrder.search(/y/i);

                ctx = dw;

                context = s.display == 'inline' ? ($(this).is('div') ? $(this) : $(this).parent()) : inst.context;

                prevDate = inst.getDate(true);
                if (!currYear) {
                    currYear = s.getYear(prevDate);
                    currMonth = s.getMonth(prevDate);
                }

                startPos = 0;
                animPos = 0;

                initTabs = true;

                // Reset transition if previously closed during transition
                trans = false;

                months = s.monthNames;

                visibleTab = 'calendar';

                if (s.minDate) {
                    minDate = new Date(s.minDate.getFullYear(), s.minDate.getMonth(), 1);
                    minDateTime = s.minDate;
                } else {
                    minDate = new Date(s.startYear, 0, 1);
                    minDateTime = minDate;
                }

                if (s.maxDate) {
                    maxDate = new Date(s.maxDate.getFullYear(), s.maxDate.getMonth(), 1);
                    maxDateTime = s.maxDate;
                } else {
                    maxDate = new Date(s.endYear, 11, 31, 23, 59, 59);
                    maxDateTime = maxDate;
                }

                dw.addClass('dw-calendar' + (has3d ? '' : ' dw-cal-no3d'));

                cont = $('.dw', dw);
                panels = $('.dwcc', dw);

                if (controls.date) {
                    controls.date = $('.dwc', ctx).eq(0);
                } else if (controls.calendar) {
                    $('.dwc', ctx).eq(0).addClass('dwc-hh');
                }

                if (controls.time) {
                    controls.time = $('.dwc', ctx).eq(1);
                }

                // Generate calendar markup
                if (controls.calendar) {
                    // Calculate monthNr
                    monthNr = s.months == 'auto' ? // Exact month number from setting
                        Math.max(1, // Min 1 month
                            Math.min(3, // Max 3 months
                                Math.floor((calWidth || context.width()) / 280))) : s.months;

                    totalMonth = monthNr + 2 * preMonth;
                    monthDiff = Math.floor(monthNr / 2);
                    moveMonth = Math.round(monthNr / 2) - 1;
                    showdiff = s.showDivergentDays === undefined ? monthNr < 2 : s.showDivergentDays;

                    // Generate month buttons
                    monthBtns = '<div class="dw-cal-btnw"><div class="' + (isRTL ? 'dw-cal-next-m' : 'dw-cal-prev-m') + ' dw-cal-prev dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt ' + (s.btnCalPrevClass || '' ) + '"' + '>' + s.prevMonthText + '</a></div>';
                    for (i = 0; i < monthNr; ++i) {
                        monthBtns += '<div class="dw-cal-btnw-m" style="width: ' + 100 / monthNr + '%">' +
                            (!yearBtn && yearIndex < monthIndex ? '<span aria-live="assertive" class="dw-cal-year"></span>&nbsp;' : '') +
                            '<span aria-live="assertive" class="dw-cal-month"></span>' +
                            (!yearBtn && yearIndex > monthIndex ? '&nbsp;<span aria-live="assertive" class="dw-cal-year"></span>' : '') + '</div>';
                    }
                    monthBtns += '<div class="' + (isRTL ? 'dw-cal-prev-m' : 'dw-cal-next-m') + ' dw-cal-next dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt ' + (s.btnCalNextClass || '' ) + '"' + '>' + s.nextMonthText + '</a></div></div>';

                    // Generate year buttons
                    if (yearBtn) {
                        yearBtns = '<div class="dw-cal-btnw"><div class="' + (isRTL ? 'dw-cal-next-y' : 'dw-cal-prev-y') + ' dw-cal-prev dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt ' + (s.btnCalPrevClass || '' ) + '"' + '>' + s.prevYearText + '</a></div>' +
                            '<span aria-live="assertive" class="dw-cal-year"></span>' +
                            '<div class="' + (isRTL ? 'dw-cal-prev-y' : 'dw-cal-next-y') + ' dw-cal-next dw-cal-btn dwb dwb-e"><div role="button" class="dw-cal-btn-txt ' + (s.btnCalNextClass || '' ) + '"' + ' title="' + s.nextYearText + '"></div></div></div>';
                    }

                    // Generate calendar header
                    html = '<div class="dwc dw-cal-c"><div class="dw-cal ' +
                        (monthNr > 1 ? ' dw-cal-multi ' : '') +
                        (weeks ? ' dw-weeks ' : '') +
                        (showdiff ? '' : ' dw-hide-diff ') +
                        (s.calendarClass || '') + '">' +
                        '<div class="dw-cal-header"><div class="dw-cal-btnc ' + (yearBtn ? 'dw-cal-btnc-ym' : 'dw-cal-btnc-m') + '">' +
                        ((yearIndex < monthIndex || monthNr > 1) ? yearBtns + monthBtns : monthBtns + yearBtns) +
                        '</div><div class="dw-cal-days-c">';

                    for (j = 0; j < monthNr; ++j) {
                        // Generate week days
                        html += '<div class="dw-cal-days" style="width: ' + 100 / monthNr + '%"><table cellpadding="0" cellspacing="0"><tr>';
                        for (i = 0; i < 7; i++) {
                            html += '<th>' + s.dayNamesShort[(i + s.firstDay) % 7] + '</th>';
                        }
                        html += '</tr></table></div>';
                    }

                    html += '</div></div>' +
                        '<div class="dw-cal-anim-c ' + (s.calendarClass || '') + '">' +
                        '<div class="dw-week-nrs-c ' + (s.weekNrClass || '') + '">' +
                        '<div class="dw-week-nrs"></div>' +
                        '</div>' +
                        '<div class="dw-cal-anim">';

                    for (i = 0; i < monthNr + 2 * preMonth; i++) {
                        html += '<div class="dw-cal-slide"></div>';
                    }

                    html += '</div></div></div></div>';

                    controls.calendar = $(html);
                }

                // Insert controls in the required order
                $.each(s.controls, function (i, v) {
                    controls[v] = $('<div class="dw-cal-pnl" id="' + (that.id + '_dw_pnl_' + i) + '"></div>')
                        .append($('<div class="dw-cal-pnl-i"></div>').append(controls[v]))
                        .appendTo(panels);
                });

                // Generate tabs
                tabs = '<div class="dw-cal-tabs"><ul role="tablist">';

                $.each(s.controls, function (i, v) {
                    if (controls[v]) {
                        tabs += '<li role="tab" aria-controls="' + (that.id + '_dw_pnl_' + i) + '" class="dw-cal-tab ' + (i ? '' : activeTabClass) + '" data-control="' + v + '"><a href="#" class="dwb-e dwb-nhl dw-i ' + (!i ? activeTabInnerClass : '') + '">' + s[v + 'Text'] + '</a></li>';
                    }
                });
                tabs += '</ul></div>';

                panels.before(tabs);

                // Init slide animation containers
                anim = $('.dw-cal-anim-c', ctx);
                animc = $('.dw-cal-anim', ctx);

                if (controls.calendar) {
                    slides = $('.dw-cal-slide', ctx).each(function (i, v) { slidesArray.push($(v)); });
                    slides.slice(preMonth, preMonth + monthNr).addClass('dw-cal-slide-a');

                    for (i = 0; i < totalMonth; i++) {
                        change(slidesArray[i], 100 * (i - preMonth) * rtl);
                    }

                    preload(currYear, currMonth);

                    $('.dw-cal-slide-a .dw-cal-day', ctx).attr('tabindex', 0);

                    weeknr = $('.dw-week-nrs', ctx).html($('.dw-week-nr-c', slidesArray[preMonth]).html());
                }

                monthTitle = $('.dw-cal-month', ctx);
                yearTitle = $('.dw-cal-year', ctx);

                setTimeout(function () {
                    // Init day tap/click
                    inst.tap(anim, function (e) {
                        var day = $(e.target);
                        if (!trans && !scrolled) {
                            day = day.closest('.dw-cal-day', this);
                            if (day.hasClass('dw-cal-day-v')) {
                                selectDay.call(day[0]);
                            }
                        }
                    });

                    // Init prev/next month and year tap/click
                    $('.dw-cal-btn', ctx).on('touchstart mousedown keydown', function (e) {
                        var proceed,
                            btn = $(this);

                        if (e.type !== 'keydown') {
                            e.preventDefault();
                            proceed = testTouch(e);
                        } else {
                            proceed = e.keyCode === 32;
                        }

                        if (!running && proceed && !btn.hasClass('dwb-d')) {
                            running = true;
                            if (btn.hasClass('dw-cal-prev-m')) {
                                prevMonth();
                            } else if (btn.hasClass('dw-cal-next-m')) {
                                nextMonth();
                            } else if (btn.hasClass('dw-cal-prev-y')) {
                                prevYear(btn);
                            } else if (btn.hasClass('dw-cal-next-y')) {
                                nextYear(btn);
                            }

                            $(document).on('mouseup.dwbtn', function () {
                                $(document).off('.dwbtn');
                                running = false;
                            });
                        }
                    }).on('touchend touchcancel keyup', function () {
                        running = false;
                    });

                    // Init Tabs
                    $('.dw-cal-tab', ctx).on('touchstart click', function (e) {
                        var tab = $(this);

                        if (testTouch(e)) {
                            if (tab.hasClass('dw-sel')) {
                                return;
                            }

                            visibleTab = tab.attr('data-control');
                            $('.dw-cal-pnl', ctx).addClass('dw-cal-pnl-h');
                            $('.dw-cal-tab', ctx).removeClass(activeTabClass).removeAttr('aria-selected').find('.dw-i').removeClass(activeTabInnerClass);
                            tab.addClass(activeTabClass).attr('aria-selected', 'true').find('.dw-i').addClass(activeTabInnerClass);

                            controls[visibleTab].removeClass('dw-cal-pnl-h');

                            if (visibleTab === 'calendar') {
                                d = inst.getDate(true);
                                // Set the date of the calendar if date changed from the scroller
                                if (d.getFullYear() !== prevDate.getFullYear() || d.getMonth() !== prevDate.getMonth() || d.getDate() !== prevDate.getDate()) {
                                    setDate(d);
                                }
                            } else {
                                prevDate = inst.getDate(true);
                                inst.setDate(prevDate, false, 0, true);
                            }

                            inst.trigger('onTabChange', [visibleTab]);
                        }
                    });
                }, 300);

                // Init calendar width
                if (isLiquid) {
                    dw.addClass('dw-cal-liq');
                } else {
                    $('.dw-cal', ctx).width(calWidth || 280 * monthNr);
                }

                // Init calendar height
                if (s.calendarHeight) {
                    $('.dw-cal-anim-c', ctx).height(s.calendarHeight);
                }

                // Change month on swipe
                if (s.swipe) {
                    var rafID,
                        rafRunning,
                        startTime,
                        timeDiff,
                        scroll,
                        slideNr,
                        swipe,
                        swiping,
                        swipeLive = s.liveSwipe,
                        raf = window.requestAnimationFrame || function (x) { x(); },
                        rafc = window.cancelAnimationFrame || empty,
                        slideStart = function (e) {
                            if (!swiping && !trans) {
                                touch = true;
                                scrolled = false;
                                swiping = true;
                                startTime = new Date();
                                startPos = animPos;
                                startX = get(e, 'X');
                                startY = get(e, 'Y');
                            }
                        },
                        slideEnd = function () {
                            swiping = false;
                            scroll = false;
                            if (swipe) {
                                swipe = false;

                                rafc(rafID);
                                rafRunning = false;

                                timeDiff = new Date() - startTime;

                                slideNr = (timeDiff < 300 && Math.abs(endX - startX) > 50 ? (endX - startX < 0 ? -preMonth : preMonth) : Math.round((animPos - startPos) / animw)) * rtl;

                                if (slideNr > 0 && s.getDate(currYear, currMonth - slideNr - moveMonth, 1) >= minDate) { // Prev
                                    changeMonth(currYear, currMonth - slideNr, 'prev', slideNr);
                                } else if (slideNr < 0 && s.getDate(currYear, currMonth - slideNr + monthNr - moveMonth - 1, 1) <= maxDate) { // Next
                                    changeMonth(currYear, currMonth - slideNr, 'next', -slideNr);
                                } else if (swipeLive) { // Back to initial position
                                    slide(startPos, 200);
                                }
                            }
                        },
                        slideMoving = function (e) {
                            // Prevent native scroll if in transition
                            if (trans) {
                                e.preventDefault();
                            }

                            if (swiping) {
                                endX = get(e, 'X');
                                endY = get(e, 'Y');
                                if (!swipe && !scroll) {
                                    if (Math.abs(endX - startX) > 7) { // It's a swipe
                                        swipe = true;
                                        scrolled = true;
                                    } else if (!inst.scrollLock && Math.abs(endY - startY) > 10) { // It's a scroll
                                        scroll = true;
                                        scrolled = true;
                                        if (e.type === 'touchmove') {
                                            anim.trigger('touchend');
                                        }
                                    }
                                }

                                // Prevent native scroll if it is a swipe
                                if (swipe) {
                                    e.preventDefault();
                                }

                                if (swipe && swipeLive && !rafRunning) {
                                    rafRunning = true;
                                    rafID = raf(slideMove);
                                }
                            }
                        },
                        slideMove = function () {
                            slide(startPos + endX - startX);
                            rafRunning = false;
                        };

                    anim.on('touchstart', slideStart)
                        .on('touchmove', slideMoving)
                        .on('touchend touchcancel', slideEnd)
                        .on('mousedown', function (e) {
                            if (!touch) {
                                slideStart(e);
                                // Mouse events are attached to the document
                                $(document)
                                    .on('mousemove.dwsw', slideMoving)
                                    .on('mouseup.dwsw', function () {
                                        slideEnd();
                                        $(document).off('dwsw');
                                    });
                            }
                            touch = false;
                        });
                }
            },
            onShow: function () {
                setTitle(currYear, currMonth);
                inst.trigger('onMonthLoaded', [currYear, currMonth]);
            },
            onPosition: function (dw, ww, wh) {
                var w,
                    hasTabs,
                    nr,
                    mh,
                    oldw,
                    maxw = 0,
                    maxh = 0,
                    totalw = 0;

                // If liquid mode, reset heigths
                if (isLiquid && isModal) {
                    anim.height('');
                    panels.height('');
                }

                // Check if tabs needed, and search for max width and height
                if ((showTabs && initTabs) || checkTabs || isLiquid) {
                    $('.dw-cal-pnl', ctx).removeClass('dw-cal-pnl-h');

                    if (isLiquid) {
                        animc.width('');
                    }

                    $.each(controls, function (i, v) {
                        w = v.width();
                        maxw = Math.max(maxw, w);
                        maxh = Math.max(maxh, v.height());
                        totalw += w;
                    });

                    if (showTabs || (checkTabs && totalw > context.width())) {
                        hasTabs = true;
                        visibleTab = $('.dw-cal-tabs .dw-sel', ctx).attr('data-control');
                        cont.addClass('dw-cal-tabbed');
                    } else {
                        visibleTab = 'calendar';
                        maxw = '';
                        maxh = '';
                        cont.removeClass('dw-cal-tabbed');
                        panels.css({ width: '', height: '' });
                    }
                }

                // Full height calendar
                if (isLiquid && isModal) {

                    if (hasTabs) {
                        panels.height(controls.calendar.height());
                    }

                    mh = cont.outerHeight();

                    // Don't set fixed height if calendar height is bigger than viewport height
                    if (wh >= mh) {
                        anim.height(wh - mh + anim.height());
                    }

                    maxh = Math.max(maxh, controls.calendar.height());
                }

                // Set tab panel container width and height
                if (hasTabs) {
                    panels.css({ width: isLiquid ? '' : maxw, height: maxh });
                }

                if (animw) {
                    oldw = animw;
                }

                animw = Math.round(Math.round(anim.width()) / monthNr);


                // Do things only if calendar is visible (we have a width)
                if (animw) {
                    animc.width(animw);

                    // Recalcultae slide position
                    if (isLiquid && !initTabs && oldw) {
                        nr = startPos / oldw;
                        startPos = nr * animw;
                        slide(startPos, 0);
                    }

                    // Short or long month names
                    if (yearBtn) {
                        months = s.maxMonthWidth > $('.dw-cal-btnw-m', ctx).width() ? s.monthNamesShort : s.monthNames;
                        for (i = 0; i < monthNr; ++i) {
                            $(monthTitle[i]).text(months[s.getMonth(s.getDate(currYear, currMonth - moveMonth + i, 1))]);
                        }
                    }
                }

                // Show only current tab
                if (hasTabs) {
                    $('.dw-cal-pnl', ctx).addClass('dw-cal-pnl-h');
                    controls[visibleTab].removeClass('dw-cal-pnl-h');
                }

                inst.trigger('onCalResize', []);

                initTabs = false;
            },
            onClose: function () {
                slidesArray = [];
                visibleTab = null;
                currYear = null;
                currMonth = null;
                trans = true;
            },
            validate: function (dw, i) {
                var d;
                // Call original validation
                validate.call(this, dw, i);

                d = inst.getDate(true);

                inst.trigger('onSetDate', [{ date: d }]);

                // Set date on calendar
                setDate(d);
            }
        });

        return ret;
    };

})(jQuery);

(function ($) {

    var ms = $.mobiscroll,
        util = ms.util,
        get = util.getCoord,
        has3d = util.has3d,
        pr = util.jsPrefix,
        defaults = {
            firstSelectDay: 0,
            // Localization
            eventText: 'event',
            eventsText: 'events'
        };

    ms.presetShort('calendar');

    ms.presets.calendar = function (inst) {

        // Private functions
        // ---

        function getTextColor(color) {
            if (color) {
                // Cache calculated text colors, because it is slow
                if (textColors[color]) {
                    return textColors[color];
                }
                var div = $('<div style="background-color:' + color + ';"></div>').appendTo('body'),
                    style = window.getComputedStyle ? getComputedStyle(div[0]) : div[0].style,
                    rgb = style.backgroundColor.replace(/rgb|rgba|\(|\)|\s/g, '').split(','),
                    delta = rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114,
                    txt = delta > 130 ? '#000' : '#fff';

                div.remove();

                textColors[color] = txt;

                return txt;
            }
        }

        function showEvents(d, cell) {
            var events = eventObj[d];

            if (events) {
                var bg, maxHeight, txt,
                    calHeight = $('.dw-cal-c', ctx).height(),
                    cellHeight = cell.height(),
                    cellWidth = cell.width(),
                    top = cell.offset().top - $('.dw-cal-c', ctx).offset().top,
                    bottom = cell.closest('.dw-cal-row').index() < 2,
                    html = '<ul class="dw-cal-event-list">';

                pos = 0;
                scrolled = false;
                evd = cell;

                cell.addClass(selClass).find('.dw-i').addClass(activeClass);

                $.each(events, function (i, e) {
                    bg = e.color;
                    txt = getTextColor(bg);
                    html += '<li class="dw-cal-event"><div class="dw-cal-event-color" style="' + (bg ? 'background:' + bg + ';' : '') + '"></div>' + e.text + '</li>';
                });

                html += '</ul>';

                evsc.html(html);

                inst.trigger('onEventBubbleShow', [evd, evc]);

                maxHeight = evc.addClass('dw-cal-events-t').css({ top: bottom ? top + cellHeight : '0', bottom: bottom ? '0' : calHeight - top }).addClass('dw-cal-events-v').height();

                maxPos = maxHeight - evsc.height();

                evc.css(bottom ? 'bottom' : 'top', 'auto').removeClass('dw-cal-events-t');
                evci.css('max-height', maxHeight);

                scroll(0);

                // Calculate bubble position
                if (bottom) {
                    evc.addClass('dw-cal-events-b');
                } else {
                    evc.removeClass('dw-cal-events-b');
                }

                $('.dw-cal-events-arr', evc).css('left', cell.offset().left - evc.offset().left + cellWidth / 2);

                // Assign event click
                inst.tap($('.dw-cal-event', evsc), function (e) {
                    if (!scrolled) {
                        inst.trigger('onEventSelect', [e, events[$(this).index()], d]);
                    }
                });

                evVisible = true;
            }
        }

        function hideEvents() {
            if (evc) {
                evc.removeClass('dw-cal-events-v');
            }
            if (evd) {
                evd.removeClass(selClass).find('.dw-i').removeClass(activeClass);
            }
            evVisible = false;
        }

        function refresh() {
            if (eventMode) {
                hideEvents();
            }
            inst.refresh();
        }

        function scroll(pos) {
            if (has3d) {
                evsc[0].style[pr + 'Transform'] = 'translateY(' + pos + 'px)';
            } else {
                evsc.css('top', pos);
            }
        }

        // ---

        var base,
            ctx,
            endY,
            evc,
            evd,
            eventObj,
            evci,
            evsc,
            evVisible,
            i,
            d,
            markedObj,
            maxPos,
            pos,
            ret,
            scrolled,
            startPos,
            startY,
            touch,
            showEvent,
            textColors = {},
            orig = $.extend({}, inst.settings),
            s = $.extend(inst.settings, defaults, orig),
            selClass = 'dw-sel dw-cal-day-ev',
            activeClass = s.activeClass || '',
            multi = s.multiSelect || s.selectType == 'week',
            markedStyle = s.markedDisplay,
            markedText = s.events === true || s.markedText === true,
            eventID = 0,
            origValues = [],
            eventMode = $.isArray(s.events),
            eventList = eventMode ? $.extend(true, [], s.events) : [];

        ret = $.mobiscroll.presets.calbase.call(this, inst);
        base = $.extend({}, ret);

        if (s.selectedValues) {
            for (i = 0; i < s.selectedValues.length; i++) {
                d = s.selectedValues[i];
                inst._selectedValues[d] = d;
            }
        }

        if (eventMode) {
            $.each(eventList, function (i, e) {
                e._id = eventID++;
            });
        }

        // Extended methods
        // ---

        inst.onGenMonth = function (y, m) {
            eventObj = inst.prepareObj(eventList, y, m);
            markedObj = inst.prepareObj(s.marked, y, m);
        };

        inst.getDayProps = function (d) {
            var i,
                selected = multi ? inst._selectedValues[d] !== undefined : (eventMode ? d.getTime() === new Date().setHours(0, 0, 0, 0) : undefined),
                isMarked = markedObj[d] ? markedObj[d][0] : false,
                hasEvents = eventObj[d] ? eventObj[d][0] : false,
                marked = isMarked || hasEvents,
                txt = isMarked.text || (markedText && hasEvents ? eventObj[d].length + ' ' + (eventObj[d].length > 1 ? s.eventsText : s.eventText) : 0),
                allMarked = markedObj[d] || eventObj[d] || [],
                iconMarkup = '',
                markedMarkup = '<div class="dw-cal-day-m"' + (bgColor ? ' style="background-color:' + bgColor + ';border-color:' + bgColor + ' ' + bgColor + ' transparent transparent"' : '') + '></div>',
                bgColor = marked.color,
                txtColor = markedText && txt ? getTextColor(bgColor) : '';

            for (i = 0; i < allMarked.length; i++) {
                if (allMarked[i].icon) {
                    iconMarkup += '<span class="mbsc-ic mbsc-ic-' + allMarked[i].icon + '"' + (allMarked[i].color ? ' style="color:' + allMarked[i].color + ';"' : '') + '></span>\n';
                }
            }

            // Multicolor
            if (markedStyle == 'bottom') {
                markedMarkup = '<div class="dw-cal-day-m"><div class="dw-cal-day-m-t">';
                for (i = 0; i < allMarked.length; i++) {
                    markedMarkup += '<div class="dw-cal-day-m-c"' + (allMarked[i].color ? ' style="background:' + allMarked[i].color + ';"' : '') + '></div>';
                }
                markedMarkup += '</div></div>';
            }

            return {
                marked: marked,
                selected: eventMode ? false : selected,
                cssClass: eventMode && selected ? 'dw-cal-day-hl' : '',
                markup: markedText && txt ?
                    '<div class="dw-cal-day-txt-c"><div class="dw-cal-day-txt ' + (s.eventTextClass || '') + '" title="' + $('<div>' + txt + '</div>').text() + '"' + (bgColor ? ' style="background:' + bgColor + ';color:' + txtColor + ';text-shadow:none;"' : '') + '>' + iconMarkup + txt + '</div></div>' :
                        markedText && iconMarkup ?
                    '<div class="dw-cal-day-ic-c">' + iconMarkup + '</div>' :
                    marked ?
                        markedMarkup : ''
            };
        };

        inst.addValue = function (v) {
            inst._selectedValues[v] = v;
            refresh();
        };

        inst.removeValue = function (v) {
            delete inst._selectedValues[v];
            refresh();
        };

        inst.setValues = function (v, fill) {
            var i = 0;

            inst._selectedValues = {};
            if (v.length) {
                inst.setDate(v[0], fill);
            }

            for (i; i < v.length; i++) {
                inst._selectedValues[v[i]] = v[i];
            }
            refresh();
        };
        if (!inst._getValues) {
            inst._getValues = inst.getValues;

            inst.getValues = function () {
                return multi ? inst._getValues() : [inst.getDate()];
            };
        }

        if (eventMode) {

            inst.addEvent = function (events) {
                var ret = [];
                events = $.extend(true, [], $.isArray(events) ? events : [events]);
                $.each(events, function (i, e) {
                    e._id = eventID++;
                    eventList.push(e);
                    ret.push(e._id);
                });
                refresh();
                return ret;
            };

            inst.removeEvent = function (eids) {
                eids = $.isArray(eids) ? eids : [eids];
                $.each(eids, function (i, eid) {
                    $.each(eventList, function (j, e) {
                        if (e._id === eid) {
                            eventList.splice(j, 1);
                            return false;
                        }
                    });
                });
                refresh();
            };

            inst.getEvents = function () {
                return eventList;
            };

            inst.setEvents = function (events) {
                var ret = [];
                eventList = $.extend(true, [], events);
                $.each(eventList, function (i, e) {
                    e._id = eventID++;
                    ret.push(e._id);
                });
                refresh();
                return ret;
            };

        }

        // ---

        $.extend(ret, {
            highlight: !multi && !eventMode,
            divergentDayChange: !multi && !eventMode,
            buttons: eventMode ? ['cancel'] : s.buttons,
            onClear: function () {
                if (multi) {
                    inst._selectedValues = {};
                    inst.refresh();
                }
            },
            onBeforeShow: function () {
                if (eventMode) {
                    s.headerText = false;
                }
                if (s.closeOnSelect) {
                    s.divergentDayChange = false;
                }
                if (s.counter && multi) {
                    s.headerText = function () {
                        var length = 0,
                            w = (s.selectType == 'week') ? 7 : 1;
                        $.each(inst._selectedValues, function () {
                            length++;
                        });
                        return (length / w)  + " " + s.selectedText;
                    };
                }
            },
            onMarkupReady: function (dw) {
                base.onMarkupReady.call(this, dw);

                ctx = dw;

                if (multi) {
                    $('.dwv', dw).attr('aria-live', 'off');
                    origValues = $.extend({}, inst._selectedValues);
                }

                if (markedText) {
                    $('.dw-cal', dw).addClass('dw-cal-ev');
                }

                if (markedStyle) {
                    $('.dw-cal', dw).addClass('dw-cal-m-' + markedStyle);
                }

                if (eventMode) {
                    dw.addClass('dw-cal-em');
                    evc = $('<div class="dw-cal-events ' + (s.eventBubbleClass || '') + '"><div class="dw-cal-events-arr"></div><div class="dw-cal-events-i"><div class="dw-cal-events-sc"></div></div></div>').appendTo($('.dw-cal-c', dw));

                    evci = $('.dw-cal-events-i', evc);
                    evsc = $('.dw-cal-events-sc', evc);

                    evc.on('touchstart mousedown', function (e) {
                        if (maxPos < 0) {
                            touch = e.type === 'touchstart';
                            scrolled = false;
                            startPos = pos;
                            startY = get(e, 'Y');
                            endY = get(e, 'Y');

                            $(document).on(touch ? 'touchmove.dwsc' : 'mousemove.dwsc', function (e) {
                                e.preventDefault();
                                endY = get(e, 'Y');
                                pos = Math.min(0, Math.max(startPos + endY - startY, maxPos));
                                scroll(pos);

                                if (Math.abs(endY - startY) > 5) {
                                    scrolled = true;
                                }
                            }).on(touch ? 'touchend.dwsc' : 'mouseup.dwsc', function () {
                                $(document).off('.dwsc');
                            });
                        }
                    });

                    inst.tap(evc, function () {
                        if (!scrolled) {
                            hideEvents();
                        }
                    });
                }
            },
            onMonthChange: function () {
                if (eventMode) {
                    hideEvents();
                }
            },
            onMonthLoaded: function () {
                if (showEvent) {
                    showEvents(showEvent.d, $('.dw-cal-day-v[data-full="' + showEvent.full + '"]:not(.dw-cal-day-diff)', ctx));
                    showEvent = false;
                }
            },
            onDayChange: function (day) {
                var d = day.date,
                    cell = $(day.cell),
                    selected = day.selected;

                if (eventMode) {
                    hideEvents();
                    if (!cell.hasClass('dw-cal-day-ev')) {
                        //if (s.divergentDayChange && cell.hasClass('dw-cal-day-diff')) {
                        //    showEvent = { d: d, full: cell.attr('data-full') };
                        //} else {
                        //    showEvents(d, cell);
                        //}
                        setTimeout(function () {
                            if (inst.changing) {
                                showEvent = { d: d, full: cell.attr('data-full') };
                            } else {
                                showEvents(d, cell);
                            }
                        }, 10);
                    }
                } else if (multi) {
                    if (s.selectType == 'week') { // Select whole week
                        var i,
                            sel,
                            diff = d.getDay() - s.firstSelectDay;

                        diff = diff < 0 ? 7 + diff : diff;

                        if (!s.multiSelect) { // Only one week can be selected
                            inst._selectedValues = {};
                        }
                        for (i = 0; i < 7; i++) {
                            sel = new Date(d.getFullYear(), d.getMonth(), d.getDate() - diff + i);
                            if (selected) {
                                delete inst._selectedValues[sel];
                            } else {
                                inst._selectedValues[sel] = sel;
                            }
                        }
                        refresh();
                    } else { // Select day only
                        var days = $('.dw-cal .dw-cal-day[data-full="' + cell.attr('data-full') + '"]', ctx);

                        if (selected) {
                            days.removeClass('dw-sel').removeAttr('aria-selected').find('.dw-i').removeClass(activeClass);
                            delete inst._selectedValues[d];
                        } else {
                            days.addClass('dw-sel').attr('aria-selected', 'true').find('.dw-i').addClass(activeClass);
                            inst._selectedValues[d] = d;
                        }
                    }
                }

                if (!eventMode && !s.multiSelect && s.closeOnSelect && s.display !== 'inline') {
                    inst.needsSlide = false;
                    inst.setDate(d);
                    inst.select();
                    return false;
                }
            },
            onCalResize: function () {
                if (evVisible) {
                    $('.dw-cal-events-arr', evc).css('left', evd.offset().left - evc.offset().left + evd.width() / 2);
                }
            },
            onCancel: function () {
                if (!inst.live && multi) {
                    inst._selectedValues = $.extend({}, origValues);
                }
            }
        });

        return ret;
    };

})(jQuery);

(function ($) {

    var ms = $.mobiscroll,
        date = new Date(),
        defaults = {
            startYear: date.getFullYear() - 100,
            endYear: date.getFullYear() + 1,
            shortYearCutoff: '+10',
            showNow: false,
            stepHour: 1,
            stepMinute: 1,
            stepSecond: 1,
            separator: ' ',
            // Localization
            dateFormat: 'mm/dd/yy',
            dateOrder: 'mmddy',
            timeWheels: 'hhiiA',
            timeFormat: 'hh:ii A',
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            monthText: 'Month',
            dayText: 'Day',
            yearText: 'Year',
            hourText: 'Hours',
            minuteText: 'Minutes',
            ampmText: '&nbsp;',
            secText: 'Seconds',
            amText: 'am',
            pmText: 'pm',
            nowText: 'Now',
            getYear: function (d) { return d.getFullYear(); },
            getMonth: function (d) { return d.getMonth(); },
            getDay: function (d) { return d.getDate(); },
            getDate: function (y, m, d, h, i, s) { return new Date(y, m, d, h || 0, i || 0, s || 0); },
            getMaxDayOfMonth: function (y, m) { return 32 - new Date(y, m, 32).getDate(); },
            getWeekNumber: function (d) {
                // Copy date so don't modify original
                d = new Date(d);
                d.setHours(0, 0, 0);
                // Set to nearest Thursday: current date + 4 - current day number
                // Make Sunday's day number 7
                d.setDate(d.getDate() + 4 - (d.getDay() || 7));
                // Get first day of year
                var yearStart = new Date(d.getFullYear(), 0, 1);
                // Calculate full weeks to nearest Thursday
                return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            }
        },
        /**
         * @class Mobiscroll.datetime
         * @extends Mobiscroll
         * Mobiscroll Datetime component
         */
        preset = function (inst) {
            var that = $(this),
                html5def = {},
                format;
            // Force format for html5 date inputs (experimental)
            if (that.is('input')) {
                switch (that.attr('type')) {
                    case 'date':
                        format = 'yy-mm-dd';
                        break;
                    case 'datetime':
                        format = 'yy-mm-ddTHH:ii:ssZ';
                        break;
                    case 'datetime-local':
                        format = 'yy-mm-ddTHH:ii:ss';
                        break;
                    case 'month':
                        format = 'yy-mm';
                        html5def.dateOrder = 'mmyy';
                        break;
                    case 'time':
                        format = 'HH:ii:ss';
                        break;
                }
                // Check for min/max attributes
                var min = that.attr('min'),
                    max = that.attr('max');
                if (min) {
                    html5def.minDate = ms.parseDate(format, min);
                }
                if (max) {
                    html5def.maxDate = ms.parseDate(format, max);
                }
            }

            // Set year-month-day order
            var i,
                k,
                keys,
                values,
                wg,
                start,
                end,
                hasTime,
                orig = $.extend({}, inst.settings),
                s = $.extend(inst.settings, defaults, html5def, orig),
                offset = 0,
                wheels = [],
                ord = [],
                o = {},
                f = { y: getYear, m: getMonth, d: getDay, h: getHour, i: getMinute, s: getSecond, a: getAmPm },
                invalid = s.invalid,
                valid = s.valid,
                p = s.preset,
                dord = s.dateOrder,
                tord = s.timeWheels,
                regen = dord.match(/D/),
                ampm = tord.match(/a/i),
                hampm = tord.match(/h/),
                hformat = p == 'datetime' ? s.dateFormat + s.separator + s.timeFormat : p == 'time' ? s.timeFormat : s.dateFormat,
                defd = new Date(),
                stepH = s.stepHour,
                stepM = s.stepMinute,
                stepS = s.stepSecond,
                mind = s.minDate || new Date(s.startYear, 0, 1),
                maxd = s.maxDate || new Date(s.endYear, 11, 31, 23, 59, 59),
                minH = mind.getHours() % stepH,
                minM = mind.getMinutes() % stepM,
                minS = mind.getSeconds() % stepS,
                maxH = getMax(stepH, minH, (hampm ? 11 : 23)),
                maxM = getMax(stepM, minM, 59),
                maxS = getMax(stepM, minM, 59);

            format = format || hformat;

            if (p.match(/date/i)) {

                // Determine the order of year, month, day wheels
                $.each(['y', 'm', 'd'], function (j, v) {
                    i = dord.search(new RegExp(v, 'i'));
                    if (i > -1) {
                        ord.push({ o: i, v: v });
                    }
                });
                ord.sort(function (a, b) { return a.o > b.o ? 1 : -1; });
                $.each(ord, function (i, v) {
                    o[v.v] = i;
                });

                wg = [];
                for (k = 0; k < 3; k++) {
                    if (k == o.y) {
                        offset++;
                        values = [];
                        keys = [];
                        start = s.getYear(mind);
                        end = s.getYear(maxd);
                        for (i = start; i <= end; i++) {
                            keys.push(i);
                            values.push((dord.match(/yy/i) ? i : (i + '').substr(2, 2)) + (s.yearSuffix || ''));
                        }
                        addWheel(wg, keys, values, s.yearText);
                    } else if (k == o.m) {
                        offset++;
                        values = [];
                        keys = [];
                        for (i = 0; i < 12; i++) {
                            var str = dord.replace(/[dy]/gi, '').replace(/mm/, (i < 9 ? '0' + (i + 1) : i + 1) + (s.monthSuffix || '')).replace(/m/, i + 1 + (s.monthSuffix || ''));
                            keys.push(i);
                            values.push(str.match(/MM/) ? str.replace(/MM/, '<span class="dw-mon">' + s.monthNames[i] + '</span>') : str.replace(/M/, '<span class="dw-mon">' + s.monthNamesShort[i] + '</span>'));
                        }
                        addWheel(wg, keys, values, s.monthText);
                    } else if (k == o.d) {
                        offset++;
                        values = [];
                        keys = [];
                        for (i = 1; i < 32; i++) {
                            keys.push(i);
                            values.push((dord.match(/dd/i) && i < 10 ? '0' + i : i) + (s.daySuffix || ''));
                        }
                        addWheel(wg, keys, values, s.dayText);
                    }
                }
                wheels.push(wg);
            }

            if (p.match(/time/i)) {
                hasTime = true;

                // Determine the order of hours, minutes, seconds wheels
                ord = [];
                $.each(['h', 'i', 's', 'a'], function (i, v) {
                    i = tord.search(new RegExp(v, 'i'));
                    if (i > -1) {
                        ord.push({ o: i, v: v });
                    }
                });
                ord.sort(function (a, b) {
                    return a.o > b.o ? 1 : -1;
                });
                $.each(ord, function (i, v) {
                    o[v.v] = offset + i;
                });

                wg = [];
                for (k = offset; k < offset + 4; k++) {
                    if (k == o.h) {
                        offset++;
                        values = [];
                        keys = [];
                        for (i = minH; i < (hampm ? 12 : 24); i += stepH) {
                            keys.push(i);
                            values.push(hampm && i === 0 ? 12 : tord.match(/hh/i) && i < 10 ? '0' + i : i);
                        }
                        addWheel(wg, keys, values, s.hourText);
                    } else if (k == o.i) {
                        offset++;
                        values = [];
                        keys = [];
                        for (i = minM; i < 60; i += stepM) {
                            keys.push(i);
                            values.push(tord.match(/ii/) && i < 10 ? '0' + i : i);
                        }
                        addWheel(wg, keys, values, s.minuteText);
                    } else if (k == o.s) {
                        offset++;
                        values = [];
                        keys = [];
                        for (i = minS; i < 60; i += stepS) {
                            keys.push(i);
                            values.push(tord.match(/ss/) && i < 10 ? '0' + i : i);
                        }
                        addWheel(wg, keys, values, s.secText);
                    } else if (k == o.a) {
                        offset++;
                        var upper = tord.match(/A/);
                        addWheel(wg, [0, 1], upper ? [s.amText.toUpperCase(), s.pmText.toUpperCase()] : [s.amText, s.pmText], s.ampmText);
                    }
                }

                wheels.push(wg);
            }

            function get(d, i, def) {
                if (o[i] !== undefined) {
                    return +d[o[i]];
                }
                if (def !== undefined) {
                    return def;
                }
                return f[i](defd);
            }

            function addWheel(wg, k, v, lbl) {
                wg.push({
                    values: v,
                    keys: k,
                    label: lbl
                });
            }

            function step(v, st, min, max) {
                return Math.min(max, Math.floor(v / st) * st + min);
            }

            function getYear(d) {
                return s.getYear(d);
            }

            function getMonth(d) {
                return s.getMonth(d);
            }

            function getDay(d) {
                return s.getDay(d);
            }

            function getHour(d) {
                var hour = d.getHours();
                hour = hampm && hour >= 12 ? hour - 12 : hour;
                return step(hour, stepH, minH, maxH);
            }

            function getMinute(d) {
                return step(d.getMinutes(), stepM, minM, maxM);
            }

            function getSecond(d) {
                return step(d.getSeconds(), stepS, minS, maxS);
            }

            function getAmPm(d) {
                return ampm && d.getHours() > 11 ? 1 : 0;
            }

            function getDate(d) {
                var hour = get(d, 'h', 0);
                return s.getDate(get(d, 'y'), get(d, 'm'), get(d, 'd'), get(d, 'a', 0) ? hour + 12 : hour, get(d, 'i', 0), get(d, 's', 0));
            }

            function getMax(step, min, max) {
                return Math.floor((max - min) / step) * step + min;
            }

            function getClosestValidDate(d, dir) {
                var next,
                    prev,
                    nextValid = false,
                    prevValid = false,
                    up = 0,
                    down = 0;

                if (isValid(d)) {
                    return d;
                }

                if (d < mind) {
                    d = mind;
                }

                if (d > maxd) {
                    d = maxd;
                }

                next = d;
                prev = d;

                if (dir !== 2) {
                    nextValid = isValid(next);

                    while (!nextValid && next < maxd) {
                        next = new Date(next.getTime() + 1000 * 60 * 60 * 24);
                        nextValid = isValid(next);
                        up++;
                    }
                }

                if (dir !== 1) {
                    prevValid = isValid(prev);

                    while (!prevValid && prev > mind) {
                        prev = new Date(prev.getTime() - 1000 * 60 * 60 * 24);
                        prevValid = isValid(prev);
                        down++;
                    }
                }

                if (dir === 1 && nextValid) {
                    return next;
                }

                if (dir === 2 && prevValid) {
                    return prev;
                }

                return down < up && prevValid ? prev : next;
            }

            function isValid(d) {
                if (d < mind) {
                    return false;
                }

                if (d > maxd) {
                    return false;
                }

                if (isInObj(d, valid)) {
                    return true;
                }

                if (isInObj(d, invalid)) {
                    return false;
                }

                return true;
            }

            function isInObj(d, obj) {
                var curr,
                    j,
                    v;

                if (obj) {
                    for (j = 0; j < obj.length; j++) {
                        curr = obj[j];
                        v = curr + '';
                        if (!curr.start) {
                            if (curr.getTime) { // Exact date
                                if (d.getFullYear() == curr.getFullYear() && d.getMonth() == curr.getMonth() && d.getDate() == curr.getDate()) {
                                    return true;
                                }
                            } else if (!v.match(/w/i)) { // Day of month
                                v = v.split('/');
                                if (v[1]) {
                                    if ((v[0] - 1) == d.getMonth() && v[1] == d.getDate()) {
                                        return true;
                                    }
                                } else if (v[0] == d.getDate()) {
                                    return true;
                                }
                            } else { // Day of week
                                v = +v.replace('w', '');
                                if (v == d.getDay()) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function validateDates(obj, y, m, first, maxdays, idx, val) {
                var j, d, v;

                if (obj) {
                    for (j = 0; j < obj.length; j++) {
                        d = obj[j];
                        v = d + '';
                        if (!d.start) {
                            if (d.getTime) { // Exact date
                                if (s.getYear(d) == y && s.getMonth(d) == m) {
                                    idx[s.getDay(d) - 1] = val;
                                }
                            } else if (!v.match(/w/i)) { // Day of month
                                v = v.split('/');
                                if (v[1]) {
                                    if (v[0] - 1 == m) {
                                        idx[v[1] - 1] = val;
                                    }
                                } else {
                                    idx[v[0] - 1] = val;
                                }
                            } else { // Day of week
                                v = +v.replace('w', '');
                                for (k = v - first; k < maxdays; k += 7) {
                                    if (k >= 0) {
                                        idx[k] = val;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function validateTimes(vobj, temp, y, m, mins, maxs, dir, dw, valid) {
                var dd, v, val, str, parts1, parts2, j, v1, v2, i1, i2, prop1, prop2, target, add, remove,
                    spec = {},
                    steps = { h: stepH, i: stepM, s: stepS, a: 1 },
                    d = get(temp, 'd'),
                    day = s.getDate(y, m, d),
                    w = ['a', 'h', 'i', 's'];

                if (vobj) {
                    $.each(vobj, function (i, obj) {
                        if (obj.start) {
                            obj.apply = false;
                            dd = obj.d;
                            v = dd + '';
                            str = v.split('/');
                            if (dd && ((dd.getTime && y == s.getYear(dd) && m == s.getMonth(dd) && d == s.getDay(dd)) || // Exact date
                                (!v.match(/w/i) && ((str[1] && d == str[1] && m == str[0] - 1) || (!str[1] && d == str[0]))) || // Day of month
                                (v.match(/w/i) && day.getDay() == +v.replace('w', '')) // Day of week
                                )) {
                                obj.apply = true;
                                spec[day] = true; // Prevent applying generic rule on day, if specific exists
                            }
                        }
                    });

                    $.each(vobj, function (i, obj) {
                        if (obj.start && (obj.apply || (!obj.d && !spec[day]))) {

                            parts1 = obj.start.split(':');
                            parts2 = obj.end.split(':');

                            for (j = 0; j < 3; j++) {
                                if (parts1[j] === undefined) {
                                    parts1[j] = 0;
                                }
                                if (parts2[j] === undefined) {
                                    parts2[j] = 59;
                                }
                                parts1[j] = +parts1[j];
                                parts2[j] = +parts2[j];
                            }

                            parts1.unshift(parts1[0] > 11 ? 1 : 0);
                            parts2.unshift(parts2[0] > 11 ? 1 : 0);

                            if (hampm) {
                                if (parts1[1] >= 12) {
                                    parts1[1] = parts1[1] - 12;
                                }

                                if (parts2[1] >= 12) {
                                    parts2[1] = parts2[1] - 12;
                                }
                            }

                            prop1 = true;
                            prop2 = true;
                            $.each(w, function (i, v) {
                                if (o[v] !== undefined) {
                                    val = get(temp, v);
                                    add = 0;
                                    remove = 0;
                                    i1 = 0;
                                    i2 = undefined;
                                    target = $('.dw-ul', dw).eq(o[v]);

                                    // Look ahead if next wheels should be disabled completely
                                    for (j = i + 1; j < 4; j++) {
                                        if (parts1[j] > 0) {
                                            add = steps[v];
                                        }
                                        if (parts2[j] < maxs[w[j]]) {
                                            remove = steps[v];
                                        }
                                    }

                                    // Calculate min and max values
                                    v1 = step(parts1[i], steps[v], mins[v], maxs[v]) + add;
                                    v2 = step(parts2[i], steps[v], mins[v], maxs[v]) - remove;

                                    if (prop1) {
                                        i1 = getValidIndex(target, v1, maxs[v], 0);
                                    }

                                    if (prop2) {
                                        i2 = getValidIndex(target, v2, maxs[v], 1);
                                    }

                                    // Disable values
                                    if (prop1 || prop2) {
                                        if (valid) {
                                            $('.dw-li', target).slice(i1, i2).addClass('dw-v');
                                        } else {
                                            $('.dw-li', target).slice(i1, i2).removeClass('dw-v');
                                        }
                                    }

                                    // Get valid value
                                    val = inst.getValidCell(val, target, dir).val;

                                    prop1 = prop1 && val == step(parts1[i], steps[v], mins[v], maxs[v]);
                                    prop2 = prop2 && val == step(parts2[i], steps[v], mins[v], maxs[v]);
                                }
                            });
                        }
                    });
                }
            }

            function getIndex(t, v) {
                return $('.dw-li', t).index($('.dw-li[data-val="' + v + '"]', t));
            }

            function getValidIndex(t, v, max, add) {
                if (v < 0) {
                    return 0;
                }
                if (v > max) {
                    return $('.dw-li', t).length;
                }
                return getIndex(t, v) + add;
            }

            function getArray(d) {
                var i,
                    ret = [];

                for (i in o) {
                    ret[o[i]] = f[i](d);
                }

                return ret;
            }

            function convertRanges(arr) {
                var i, v, start,
                    ret = [];

                if (arr) {
                    for (i = 0; i < arr.length; i++) {
                        v = arr[i];
                        if (v.start && v.start.getTime) {
                            start = new Date(v.start);
                            while (start <= v.end) {
                                ret.push(new Date(start.getFullYear(), start.getMonth(), start.getDate()));
                                start.setDate(start.getDate() + 1);
                            }
                        } else {
                            ret.push(v);
                        }
                    }
                    return ret;
                }
                return arr;
            }

            // Extended methods
            // ---

            /**
             * Sets the selected date
             *
             * @param {Date} d Date to select.
             * @param {Boolean} [fill=false] Also set the value of the associated input element. Default is true.
             * @param {Number} [time=0] Animation time to scroll to the selected date.
             * @param {Boolean} [temp=false] Set temporary value only.
             * @param {Boolean} [change=fill] Trigger change on input element.
             */
            inst.setDate = function (d, fill, time, temp, change) {
                inst.temp = getArray(d);
                inst.setValue(inst.temp, fill, time, temp, change);
            };

            /**
             * Returns the currently selected date.
             *
             * @param {Boolean} [temp=false] If true, return the currently shown date on the picker, otherwise the last selected one.
             * @return {Date}
             */
            inst.getDate = function (temp) {
                return getDate(temp ? inst.temp : inst.values);
            };

            /**
             * @deprecated since 2.7.0, backward compatibility code
             */
            inst.convert = function (obj) {
                var x = obj;

                if (!$.isArray(obj)) { // Convert from old format
                    x = [];
                    $.each(obj, function (i, o) {
                        $.each(o, function (j, o) {
                            if (i === 'daysOfWeek') {
                                if (o.d) {
                                    o.d = 'w' + o.d;
                                } else {
                                    o = 'w' + o;
                                }
                            }
                            x.push(o);
                        });
                    });
                }

                return x;
            };

            // ---


            // Initializations
            // --- 

            inst.format = hformat;
            inst.buttons.now = { text: s.nowText, css: 'dwb-n', handler: function () { inst.setDate(new Date(), false, 0.3, true, true); } };

            // @deprecated since 2.8.0, backward compatibility code
            // ---
            if (s.showNow) {
                s.buttons.splice($.inArray('set', s.buttons) + 1, 0, 'now');
            }
            invalid = invalid ? inst.convert(invalid) : false;
            // ---

            invalid = convertRanges(invalid);
            valid = convertRanges(valid);

            // Normalize min and max dates for comparing later (set default values where there are no values from wheels)
            mind = getDate(getArray(mind));
            maxd = getDate(getArray(maxd));

            // ---

            return {
                wheels: wheels,
                headerText: s.headerText ? function () {
                    return ms.formatDate(hformat, getDate(inst.temp), s);
                } : false,
                formatResult: function (d) {
                    return ms.formatDate(format, getDate(d), s);
                },
                parseValue: function (val) {
                    return getArray(ms.parseDate(format, val, s));
                },
                validate: function (dw, i, time, dir) {
                    var validated = getClosestValidDate(getDate(inst.temp), dir),
                        temp = getArray(validated),//inst.temp,//.slice(0),
                        mins = { y: mind.getFullYear(), m: 0, d: 1, h: minH, i: minM, s: minS, a: 0 },
                        maxs = { y: maxd.getFullYear(), m: 11, d: 31, h: maxH, i: maxM, s: maxS, a: 1 },
                        y = get(temp, 'y'),
                        m = get(temp, 'm'),
                        minprop = true,
                        maxprop = true;

                    $.each(['y', 'm', 'd', 'a', 'h', 'i', 's'], function (x, i) {
                        if (o[i] !== undefined) {
                            var min = mins[i],
                                max = maxs[i],
                                maxdays = 31,
                                val = get(temp, i),
                                t = $('.dw-ul', dw).eq(o[i]);

                            if (i == 'd') {
                                maxdays = s.getMaxDayOfMonth(y, m);
                                max = maxdays;
                                if (regen) {
                                    $('.dw-li', t).each(function () {
                                        var that = $(this),
                                            d = that.data('val'),
                                            w = s.getDate(y, m, d).getDay(),
                                            str = dord.replace(/[my]/gi, '').replace(/dd/, (d < 10 ? '0' + d : d) + (s.daySuffix || '')).replace(/d/, d + (s.daySuffix || ''));
                                        $('.dw-i', that).html(str.match(/DD/) ? str.replace(/DD/, '<span class="dw-day">' + s.dayNames[w] + '</span>') : str.replace(/D/, '<span class="dw-day">' + s.dayNamesShort[w] + '</span>'));
                                    });
                                }
                            }
                            if (minprop && mind) {
                                min = f[i](mind);
                            }
                            if (maxprop && maxd) {
                                max = f[i](maxd);
                            }
                            if (i != 'y') {
                                var i1 = getIndex(t, min),
                                    i2 = getIndex(t, max);
                                $('.dw-li', t).removeClass('dw-v').slice(i1, i2 + 1).addClass('dw-v');
                                if (i == 'd') { // Hide days not in month
                                    $('.dw-li', t).removeClass('dw-h').slice(maxdays).addClass('dw-h');
                                }
                            }
                            if (val < min) {
                                val = min;
                            }
                            if (val > max) {
                                val = max;
                            }
                            if (minprop) {
                                minprop = val == min;
                            }
                            if (maxprop) {
                                maxprop = val == max;
                            }
                            // Disable some days
                            if (i == 'd') {
                                var first = s.getDate(y, m, 1).getDay(),
                                    idx = {};

                                // Set invalid indexes
                                validateDates(invalid, y, m, first, maxdays, idx, 1);
                                // Delete indexes which are valid 
                                validateDates(valid, y, m, first, maxdays, idx, 0);

                                $.each(idx, function (i, v) {
                                    if (v) {
                                        $('.dw-li', t).eq(i).removeClass('dw-v');
                                    }
                                });
                            }
                        }
                    });

                    // Invalid times
                    if (hasTime) {
                        validateTimes(invalid, temp, y, m, mins, maxs, dir, dw, 0);
                        validateTimes(valid, temp, y, m, mins, maxs, dir, dw, 1);
                    }

                    inst.temp = temp;
                }
            };
        };

    $.each(['date', 'time', 'datetime'], function (i, v) {
        ms.presets[v] = preset;
        ms.presetShort(v);
    });

    // Utility functions
    ms.datetime = {};

    /**
     * Format a date into a string value with a specified format.
     * @param {String} format Output format.
     * @param {Date} date Date to format.
     * @param {Object} [settings={}] Settings.
     * @return {String} Returns the formatted date string.
     */
    ms.formatDate = ms.datetime.formatDate = function (format, date, settings) {
        if (!date) {
            return null;
        }
        var s = $.extend({}, defaults, settings),
            look = function (m) { // Check whether a format character is doubled
                var n = 0;
                while (i + 1 < format.length && format.charAt(i + 1) == m) {
                    n++;
                    i++;
                }
                return n;
            },
            f1 = function (m, val, len) { // Format a number, with leading zero if necessary
                var n = '' + val;
                if (look(m)) {
                    while (n.length < len) {
                        n = '0' + n;
                    }
                }
                return n;
            },
            f2 = function (m, val, s, l) { // Format a name, short or long as requested
                return (look(m) ? l[val] : s[val]);
            },
            i,
            year,
            output = '',
            literal = false;

        for (i = 0; i < format.length; i++) {
            if (literal) {
                if (format.charAt(i) == "'" && !look("'")) {
                    literal = false;
                } else {
                    output += format.charAt(i);
                }
            } else {
                switch (format.charAt(i)) {
                    case 'd':
                        output += f1('d', s.getDay(date), 2);
                        break;
                    case 'D':
                        output += f2('D', date.getDay(), s.dayNamesShort, s.dayNames);
                        break;
                    case 'o':
                        output += f1('o', (date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
                        break;
                    case 'm':
                        output += f1('m', s.getMonth(date) + 1, 2);
                        break;
                    case 'M':
                        output += f2('M', s.getMonth(date), s.monthNamesShort, s.monthNames);
                        break;
                    case 'y':
                        year = s.getYear(date);
                        output += (look('y') ? year : (year % 100 < 10 ? '0' : '') + year % 100);
                        //output += (look('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
                        break;
                    case 'h':
                        var h = date.getHours();
                        output += f1('h', (h > 12 ? (h - 12) : (h === 0 ? 12 : h)), 2);
                        break;
                    case 'H':
                        output += f1('H', date.getHours(), 2);
                        break;
                    case 'i':
                        output += f1('i', date.getMinutes(), 2);
                        break;
                    case 's':
                        output += f1('s', date.getSeconds(), 2);
                        break;
                    case 'a':
                        output += date.getHours() > 11 ? s.pmText : s.amText;
                        break;
                    case 'A':
                        output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();
                        break;
                    case "'":
                        if (look("'")) {
                            output += "'";
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        output += format.charAt(i);
                }
            }
        }
        return output;
    };

    /**
     * Extract a date from a string value with a specified format.
     * @param {String} format Input format.
     * @param {String} value String to parse.
     * @param {Object} [settings={}] Settings.
     * @return {Date} Returns the extracted date.
     */
    ms.parseDate = ms.datetime.parseDate = function (format, value, settings) {
        var s = $.extend({}, defaults, settings),
            def = s.defaultValue || new Date();

        if (!format || !value) {
            return def;
        }

        value = (typeof value == 'object' ? value.toString() : value + '');

        var shortYearCutoff = s.shortYearCutoff,
            year = s.getYear(def),
            month = s.getMonth(def) + 1,
            day = s.getDay(def),
            doy = -1,
            hours = def.getHours(),
            minutes = def.getMinutes(),
            seconds = 0, //def.getSeconds(),
            ampm = -1,
            literal = false, // Check whether a format character is doubled
            lookAhead = function (match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches) {
                    iFormat++;
                }
                return matches;
            },
            getNumber = function (match) { // Extract a number from the string value
                lookAhead(match);
                var size = (match == '@' ? 14 : (match == '!' ? 20 : (match == 'y' ? 4 : (match == 'o' ? 3 : 2)))),
                    digits = new RegExp('^\\d{1,' + size + '}'),
                    num = value.substr(iValue).match(digits);

                if (!num) {
                    return 0;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            },
            getName = function (match, s, l) { // Extract a name from the string value and convert to an index
                var names = (lookAhead(match) ? l : s),
                    i;

                for (i = 0; i < names.length; i++) {
                    if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
                        iValue += names[i].length;
                        return i + 1;
                    }
                }
                return 0;
            },
            checkLiteral = function () {
                iValue++;
            },
            iValue = 0,
            iFormat;

        for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
                    literal = false;
                } else {
                    checkLiteral();
                }
            } else {
                switch (format.charAt(iFormat)) {
                    case 'd':
                        day = getNumber('d');
                        break;
                    case 'D':
                        getName('D', s.dayNamesShort, s.dayNames);
                        break;
                    case 'o':
                        doy = getNumber('o');
                        break;
                    case 'm':
                        month = getNumber('m');
                        break;
                    case 'M':
                        month = getName('M', s.monthNamesShort, s.monthNames);
                        break;
                    case 'y':
                        year = getNumber('y');
                        break;
                    case 'H':
                        hours = getNumber('H');
                        break;
                    case 'h':
                        hours = getNumber('h');
                        break;
                    case 'i':
                        minutes = getNumber('i');
                        break;
                    case 's':
                        seconds = getNumber('s');
                        break;
                    case 'a':
                        ampm = getName('a', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
                        break;
                    case 'A':
                        ampm = getName('A', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
                        break;
                    case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        checkLiteral();
                }
            }
        }
        if (year < 100) {
            year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                (year <= (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)) ? 0 : -100);
        }
        if (doy > -1) {
            month = 1;
            day = doy;
            do {
                var dim = 32 - new Date(year, month - 1, 32).getDate();
                if (day <= dim) {
                    break;
                }
                month++;
                day -= dim;
            } while (true);
        }
        hours = (ampm == -1) ? hours : ((ampm && hours < 12) ? (hours + 12) : (!ampm && hours == 12 ? 0 : hours));

        var date = s.getDate(year, month - 1, day, hours, minutes, seconds);

        if (s.getYear(date) != year || s.getMonth(date) + 1 != month || s.getDay(date) != day) {
            return def; // Invalid date
        }

        return date;
    };

})(jQuery);

(function ($) {
    var ms = $.mobiscroll,
        defaults = {
            invalid: [],
            showInput: true,
            inputClass: ''
        },
        preset = function (inst) {
            var orig = $.extend({}, inst.settings),
                s = $.extend(inst.settings, defaults, orig),
                layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),
                isLiquid = layout == 'liquid',
                origReadOnly = s.readonly,
                elm = $(this),
                input,
                prevent,
                id = this.id + '_dummy',
                lvl = 0,
                ilvl = 0,
                timer = {},
                wa = s.wheelArray || createWheelArray(elm),
                labels = generateLabels(lvl),
                currLevel = 0,
                currWheelVector = [],
                fwv = firstWheelVector(wa),
                w = generateWheelsFromVector(fwv, lvl);

            /**
             * Disables the invalid items on the wheels
             * @param {Object} dw - the jQuery mobiscroll object
             * @param {Number} nrWheels - the number of the current wheels
             * @param {Array} whArray - The wheel array objects containing the wheel tree
             * @param {Array} whVector - the wheel vector containing the current keys
             */
            function setDisabled(dw, nrWheels, whArray, whVector) {
                var j,
                    i = 0;

                while (i < nrWheels) {
                    var currWh = $('.dwwl' + i, dw),
                        inv = getInvalidKeys(whVector, i, whArray);

                    for (j = 0; j < inv.length; j++) {
                        $('.dw-li[data-val="' + inv[j] + '"]', currWh).removeClass('dw-v');
                    }
                    i++;
                }
            }

            /**
             * Returns the invalid keys of one wheel as an array
             * @param {Array} whVector - the wheel vector used to search for the wheel in the wheel array
             * @param {Number} index - index of the wheel in the wheel vector, that we are interested in
             * @param {Array} whArray - the wheel array we are searching in
             * @return {Array} - list of invalid keys
             */
            function getInvalidKeys(whVector, index, whArray) {
                var i = 0,
                    n,
                    whObjA = whArray,
                    invalids = [];

                while (i < index) {
                    var ii = whVector[i];
                    //whObjA = whObjA[ii].children;
                    for (n in whObjA) {
                        if (whObjA[n].key == ii) {
                            whObjA = whObjA[n].children;
                            break;
                        }
                    }
                    i++;
                }
                i = 0;
                while (i < whObjA.length) {
                    if (whObjA[i].invalid) {
                        invalids.push(whObjA[i].key);
                    }
                    i++;
                }
                return invalids;
            }

            /**
             * Creates a Boolean vector with true values (except one) that can be used as the readonly vector
             * n - the length of the vector
             * i - the index of the value that's going to be false
             */
            function createROVector(n, i) {
                var a = [];
                while (n) {
                    a[--n] = true;
                }
                a[i] = false;
                return a;
            }

            /**
             * Creates a labels vector, from values if they are defined, otherwise from numbers
             * l - the length of the vector
             */
            function generateLabels(l) {
                var a = [],
                    i;
                for (i = 0; i < l; i++) {
                    a[i] = s.labels && s.labels[i] ? s.labels[i] : i;
                }
                return a;
            }

            /**
             * Creates the wheel array from the vector provided
             * wv - wheel vector containing the values that should be selected on the wheels
             * l - the length of the wheel array
             */
            function generateWheelsFromVector(wv, l, index) {
                var i = 0, j, obj, chInd,
                    w = [[]],
                    wtObjA = wa;

                if (l) { // if length is defined we need to generate that many wheels (even if they are empty)
                    for (j = 0; j < l; j++) {
                        if (isLiquid) {
                            w[0][j] = {};
                        } else {
                            w[j] = [{}];
                        }
                    }
                }
                while (i < wv.length) { // we generate the wheels until the length of the wheel vector
                    if (isLiquid) {
                        w[0][i] = getWheelFromObjA(wtObjA, labels[i]);
                    } else {
                        w[i] = [getWheelFromObjA(wtObjA, labels[i])];
                    }

                    j = 0;
                    chInd = undefined;

                    while (j < wtObjA.length && chInd === undefined) {
                        if (wtObjA[j].key == wv[i] && ((index !== undefined && i <= index) || index === undefined)) {
                            chInd = j;
                        }
                        j++;
                    }

                    if (chInd !== undefined && wtObjA[chInd].children) {
                        i++;
                        wtObjA = wtObjA[chInd].children;
                    } else if ((obj = getFirstValidItemObjOrInd(wtObjA)) && obj.children) {
                        i++;
                        wtObjA = obj.children;
                    } else {
                        return w;
                    }
                }
                return w;
            }

            /**
             * Returns the first valid Wheel Node Object or its index from a Wheel Node Object Array
             * getInd - if it is true then the return value is going to be the index, otherwise the object itself
             */
            function getFirstValidItemObjOrInd(wtObjA, getInd) {
                if (!wtObjA) {
                    return false;
                }

                var i = 0,
                    obj;

                while (i < wtObjA.length) {
                    if (!(obj = wtObjA[i++]).invalid) {
                        return getInd ? i - 1 : obj;
                    }
                }
                return false;
            }

            function getWheelFromObjA(objA, lbl) {
                var wheel = {
                        keys: [],
                        values: [],
                        label: lbl
                    },
                    j = 0;

                while (j < objA.length) {
                    wheel.values.push(objA[j].value);
                    wheel.keys.push(objA[j].key);
                    j++;
                }
                return wheel;
            }

            /**
             * Hides the last i number of wheels
             * i - the last number of wheels that has to be hidden
             */
            function hideWheels(dw, i) {
                $('.dwfl', dw).css('display', '').slice(i).hide();
            }

            /**
             * Generates the first wheel vector from the wheeltree
             * wt - the wheel tree object
             * uses the lvl global variable to determine the length of the vector
             */
            function firstWheelVector(wa) {
                var t = [],
                    ndObjA = wa,
                    obj,
                    ok = true,
                    i = 0;

                while (ok) {
                    obj = getFirstValidItemObjOrInd(ndObjA);
                    t[i++] = obj.key;
                    ok = obj.children;
                    if (ok) {
                        ndObjA = ok;
                    }
                }
                return t;
            }

            /**
             * Calculates the level of a wheel vector and the new wheel vector, depending on current wheel vector and the index of the changed wheel
             * wv - current wheel vector
             * index - index of the changed wheel
             */
            function calcLevelOfVector2(wv, index) {
                var t = [],
                    ndObjA = wa,
                    lvl = 0,
                    next = false,
                    i,
                    childName,
                    chInd;

                if (wv[lvl] !== undefined && lvl <= index) {
                    i = 0;

                    childName = wv[lvl];
                    chInd = undefined;

                    while (i < ndObjA.length && chInd === undefined) {
                        if (ndObjA[i].key == wv[lvl] && !ndObjA[i].invalid) {
                            chInd = i;
                        }
                        i++;
                    }
                } else {
                    chInd = getFirstValidItemObjOrInd(ndObjA, true);
                    childName = ndObjA[chInd].key;
                }

                next = chInd !== undefined ? ndObjA[chInd].children : false;

                t[lvl] = childName;

                while (next) {
                    ndObjA = ndObjA[chInd].children;
                    lvl++;
                    next = false;
                    chInd = undefined;

                    if (wv[lvl] !== undefined && lvl <= index) {
                        i = 0;

                        childName = wv[lvl];
                        chInd = undefined;

                        while (i < ndObjA.length && chInd === undefined) {
                            if (ndObjA[i].key == wv[lvl] && !ndObjA[i].invalid) {
                                chInd = i;
                            }
                            i++;
                        }
                    } else {
                        chInd = getFirstValidItemObjOrInd(ndObjA, true);
                        chInd = chInd === false ? undefined : chInd;
                        childName = ndObjA[chInd].key;
                    }
                    next = chInd !== undefined && getFirstValidItemObjOrInd(ndObjA[chInd].children) ? ndObjA[chInd].children : false;
                    t[lvl] = childName;
                }
                return {
                    lvl: lvl + 1,
                    nVector: t
                }; // return the calculated level and the wheel vector as an object
            }

            function createWheelArray(ul) {
                var wheelArray = [];

                lvl = lvl > ilvl++ ? lvl : ilvl;

                ul.children('li').each(function (index) {
                    var that = $(this),
                        c = that.clone();

                    c.children('ul,ol').remove();

                    var v = c.html().replace(/^\s\s*/, '').replace(/\s\s*$/, ''),
                        inv = that.data('invalid') ? true : false,
                        wheelObj = {
                            key: that.attr('data-val') === undefined ? index : that.attr('data-val'),
                            value: v,
                            invalid: inv,
                            children: null
                        },
                        nest = that.children('ul,ol');

                    if (nest.length) {
                        wheelObj.children = createWheelArray(nest);
                    }

                    wheelArray.push(wheelObj);
                });

                ilvl--;
                return wheelArray;
            }

            $('#' + id).remove(); // Remove input if exists

            if (s.showInput) {
                var typeStr = 'type="text"';
                if (Capriza && Capriza.device && Capriza.device.ios8) typeStr = '';
//                input = $('<input type="text" id="' + id + '" value="" class="' + s.inputClass + '" placeholder="' + (s.placeholder || '') + '" readonly />').insertBefore(elm);
                input = $('<input '+typeStr+' id="' + id + '" value="" class="' + s.inputClass + '" placeholder="' + (s.placeholder || '') + '" readonly />').insertBefore(elm);
                s.anchor = input; // give the core the input element for the bubble positioning
                inst.attachShow(input);
            }

            if (!s.wheelArray) {
                elm.hide().closest('.ui-field-contain').trigger('create');
            }

            return {
                width: 50,
                wheels: w,
                layout: layout,
                headerText: false,
                formatResult: function (d) {
                    return d.slice(0, currLevel).join(' ');
                },
                parseValue: function (value) {
                    return value ? value.split(" ") : (s.defaultValue || fwv);
                },
                onBeforeShow: function () {
                    var t = inst.temp;
                    currWheelVector = t.slice(0);
                    s.wheels = generateWheelsFromVector(t, lvl, lvl);
                    prevent = true;
                },
                onValueFill: function (v, change) {
                    if (input) {
                        input.val(v);
                    }
                    if (change) {
                        elm.change();
                    }

                },
                onShow: function (dw) {
                    $('.dwwl', dw).on('mousedown touchstart', function () {
                        clearTimeout(timer[$('.dwwl', dw).index(this)]);
                    });
                },
                onDestroy: function () {
                    if (input) {
                        input.remove();
                    }
                    elm.show();
                },
                validate: function (dw, index, time) {
                    var args = [],
                        t = inst.temp,
                        i = (index || 0) + 1,
                        j,
                        o;

                    if ((index !== undefined && currWheelVector[index] != t[index]) || (index === undefined && !prevent)) {
                        s.wheels = generateWheelsFromVector(t, null, index);
                        o = calcLevelOfVector2(t, index === undefined ? t.length : index);
                        currLevel = o.lvl;

                        for (j = 0; j < t.length; j++) {
                            inst.temp[j] = o.nVector[j] || 0;
                        }

                        while (i < o.lvl) {
                            args.push(i++);
                        }

                        if (args.length) {
                            s.readonly = createROVector(lvl, index);
                            clearTimeout(timer[index]);
                            timer[index] = setTimeout(function () {
                                prevent = true;
                                hideWheels(dw, o.lvl);
                                currWheelVector = inst.temp.slice(0);
                                inst.changeWheel(args, index === undefined ? time : 0, index !== undefined);
                                s.readonly = origReadOnly;
                            }, index === undefined ? 0 : time * 1000);
                            return false;
                        }
                    } else {
                        o = calcLevelOfVector2(t, t.length);
                        currLevel = o.lvl;
                    }

                    currWheelVector = t.slice(0);
                    setDisabled(dw, o.lvl, wa, t);
                    hideWheels(dw, o.lvl);

                    prevent = false;
                }
            };
        };

    $.each(['list', 'image', 'treelist'], function (i, v) {
        ms.presets[v] = preset;
        ms.presetShort(v);
    });

})(jQuery);

(function ($) {
    var theme = {
        dateOrder: 'Mddyy',
        //mode: 'mixed',
        rows: 5,
        minWidth: 76,
        height: 36,
        showLabel: false,
        selectedLineHeight: true,
        selectedLineBorder: 2,
        useShortLabels: true,
        icon: { filled: 'star3', empty: 'star' },
        btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down6',
        btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up6',
        onThemeLoad: function (lang, s) {
            if (s.theme) {
                s.theme = s.theme.replace('android-ics', 'android-holo');
            }
        }
    };

    $.mobiscroll.themes['android-ics'] = theme;
    $.mobiscroll.themes['android-ics light'] = theme;
    $.mobiscroll.themes['android-holo'] = theme;
    $.mobiscroll.themes['android-holo light'] = theme;

})(jQuery);


(function ($) {

    $.mobiscroll.themes.android = {
        dateOrder: 'Mddyy',
        mode: 'clickpick',
        height: 50,
        showLabel: false,
        btnStartClass: 'mbsc-ic mbsc-ic-play3',
        btnStopClass: 'mbsc-ic mbsc-ic-pause2',
        btnResetClass: 'mbsc-ic mbsc-ic-stop2',
        btnLapClass: 'mbsc-ic mbsc-ic-loop2'
    };

})(jQuery);


(function ($) {

    $.mobiscroll.themes.ios = {
        display: 'bottom',
        dateOrder: 'MMdyy',
        rows: 5,
        height: 30,
        minWidth: 60,
        headerText: false,
        showLabel: false,
        btnWidth: false,
        selectedLineHeight: true,
        selectedLineBorder: 2,
        useShortLabels: true
    };

})(jQuery);

(function ($) {

    $.mobiscroll.themes.ios7 = {
        display: 'bottom',
        dateOrder: 'MMdyy',
        rows: 5,
        height: 34,
        minWidth: 55,
        headerText: false,
        showLabel: false,
        btnWidth: false,
        selectedLineHeight: true,
        selectedLineBorder: 1,
        useShortLabels: true,
        btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
        btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
        btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
        btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5'
    };

})(jQuery);

(function ($) {

    $.mobiscroll.classes.Scroller = function (el, settings) {
        var $doc,
            $header,
            $markup,
            $overlay,
            $persp,
            $popup,
            $wnd,
            hasButtons,
            isLiquid,
            isModal,
            isScrollable,
            isVisible,
            itemHeight,
            posEvents,
            posDebounce,
            preset,
            preventChange,
            preventPos,
            scrollLock,
            theme,
            valueText,
            wasReadOnly,
            wndWidth,
            wndHeight,

            m,
            mw, // Modal width
            mh, // Modal height
            anim,
            lang,
            click,
            moved,
            start,
            startTime,
            stop,
            p,
            min,
            max,
            target,
            index,
            lines,
            timer,
            buttons,
            btn,
            that = this,
            $elm = $(el),
            s,
            iv = {},
            pos = {},
            pixels = {},
            wheels = [],
            elmList = [],
            isInput = $elm.is('input');

        // Event handlers

        function onStart(ev) {
            // Scroll start
            if (testTouch(ev) && !move && !click && !btn && !isReadOnly(this)) {
                // Prevent touch highlight
                ev.preventDefault();

                move = true;
                isScrollable = s.mode != 'clickpick';
                target = $('.dw-ul', this);
                setGlobals(target);
                moved = iv[index] !== undefined; // Don't allow tap, if still moving
                p = moved ? getCurrentPosition(target) : pos[index];
                start = getCoord(ev, 'Y');
                startTime = new Date();
                stop = start;
                scroll(target, index, p, 0.001);

                if (isScrollable) {
                    target.closest('.dwwl').addClass('dwa');
                }

                if (ev.type === 'mousedown') {
                    $(document).on('mousemove', onMove).on('mouseup', onEnd);
                }
            }
        }

        function onMove(ev) {
            if (move) {
                if (isScrollable) {
                    // Prevent scroll
                    ev.preventDefault();
                    ev.stopPropagation();
                    stop = getCoord(ev, 'Y');
                    if (Math.abs(stop - start) > 3) {
                        scroll(target, index, constrain(p + (start - stop) / itemHeight, min - 1, max + 1));
                        moved = true;
                    }
                }
            }
        }

        function onEnd(ev) {
            if (move) {
                var time = new Date() - startTime,
                    val = constrain(p + (start - stop) / itemHeight, min - 1, max + 1),
                    speed,
                    dist,
                    tindex,
                    ttop = target.offset().top;

                if (has3d && time < 300) {
                    speed = (stop - start) / time;
                    dist = (speed * speed) / s.speedUnit;
                    if (stop - start < 0) {
                        dist = -dist;
                    }
                } else {
                    dist = stop - start;
                }

                tindex = Math.round(p - dist / itemHeight);

                if (!moved) { // this is a "tap"
                    var idx = Math.floor((stop - ttop) / itemHeight),
                        li = $($('.dw-li', target)[idx]),
                        hl = isScrollable;
                    if (event('onValueTap', [li]) !== false) {
                        tindex = idx;
                    } else {
                        hl = true;
                    }

                    if (hl) {
                        li.addClass('dw-hl'); // Highlight
                        setTimeout(function () {
                            li.removeClass('dw-hl');
                        }, 200);
                    }
                }

                if (isScrollable) {
                    calc(target, tindex, 0, true, Math.round(val));
                }

                if (ev.type === 'mouseup') {
                    $(document).off('mousemove', onMove).off('mouseup', onEnd);
                }

                move = false;
            }
        }

        function onBtnStart(ev) {
            // Can't call preventDefault here, it kills page scroll
            if (btn) {
                btn.removeClass('dwb-a');
            }
            btn = $(this);
            // Active button
            if (!btn.hasClass('dwb-d') && !btn.hasClass('dwb-nhl')) {
                btn.addClass('dwb-a');
            }
            // +/- buttons
            if (btn.hasClass('dwwb')) {
                if (testTouch(ev)) {
                    step(ev, btn.closest('.dwwl'), btn.hasClass('dwwbp') ? plus : minus);
                }
            }
            if (ev.type === 'mousedown') {
                $(document).on('mouseup', onBtnEnd);
            }
        }

        function onBtnEnd(ev) {
            if (click) {
                clearInterval(timer);
                click = false;
            }
            if (btn) {
                btn.removeClass('dwb-a');
                btn = null;
            }
            if (ev.type === 'mouseup') {
                $(document).off('mousedown', onBtnEnd);
            }
        }

        function onKeyDown(ev) {
            if (ev.keyCode == 38) { // up
                step(ev, $(this), minus);
            } else if (ev.keyCode == 40) { // down
                step(ev, $(this), plus);
            }
        }

        function onKeyUp() {
            if (click) {
                clearInterval(timer);
                click = false;
            }
        }

        function onScroll(ev) {
            if (!isReadOnly(this)) {
                ev.preventDefault();
                ev = ev.originalEvent || ev;
                var delta = ev.wheelDelta ? (ev.wheelDelta / 120) : (ev.detail ? (-ev.detail / 3) : 0),
                    t = $('.dw-ul', this);

                setGlobals(t);
                calc(t, Math.round(pos[index] - delta), delta < 0 ? 1 : 2);
            }
        }

        function onPosition(ev) {
            clearTimeout(posDebounce);
            posDebounce = setTimeout(function () {
                var isScroll = ev.type == 'scroll';
                if (isScroll && !scrollLock) {
                    return;
                }
                that.position(!isScroll);
            }, 200);
        }

        function onHide(prevAnim) {
            var activeEl,
                value,
                type;

            $markup.remove();
            if ($activeElm && !prevAnim) {
                setTimeout(function () {
                    preventShow = true;
                    activeEl = $activeElm[0];
                    type = activeEl.type;
                    value = activeEl.value;
                    $activeElm.focus();
                    if (!(Capriza && Capriza.device && Capriza.device.ios8)) {
                        activeEl.type = 'button';
                        activeEl.type = type;
                    }
                    activeEl.value = value;
                }, 200);
            }
            isVisible = false;
        }

        // Private functions

        function step(ev, w, func) {
            ev.stopPropagation();
            ev.preventDefault();
            if (!click && !isReadOnly(w) && !w.hasClass('dwa')) {
                click = true;
                // + Button
                var t = w.find('.dw-ul');

                setGlobals(t);
                clearInterval(timer);
                timer = setInterval(function () { func(t); }, s.delay);
                func(t);
            }
        }

        function isReadOnly(wh) {
            if ($.isArray(s.readonly)) {
                var i = $('.dwwl', $markup).index(wh);
                return s.readonly[i];
            }
            return s.readonly;
        }

        function generateWheelItems(i) {
            var html = '<div class="dw-bf">',
                ww = wheels[i],
            // @deprecated since 2.6.0, backward compatibility code
            // ---
                w = ww.values ? ww : convert(ww),
            // ---
                l = 1,
                labels = w.labels || [],
                values = w.values,
                keys = w.keys || values;

            $.each(values, function (j, v) {
                if (l % 20 === 0) {
                    html += '</div><div class="dw-bf">';
                }
                html += '<div role="option" aria-selected="false" class="dw-li dw-v" data-val="' + keys[j] + '"' + (labels[j] ? ' aria-label="' + labels[j] + '"' : '') + ' style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;">' +
                    '<div class="dw-i"' + (lines > 1 ? ' style="line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;"' : '') + '>' + v + '</div></div>';
                l++;
            });

            html += '</div>';
            return html;
        }

        function setGlobals(t) {
            min = $('.dw-li', t).index($('.dw-v', t).eq(0));
            max = $('.dw-li', t).index($('.dw-v', t).eq(-1));
            index = $('.dw-ul', $markup).index(t);
        }

        function formatHeader(v) {
            var t = s.headerText;
            return t ? (typeof t === 'function' ? t.call(el, v) : t.replace(/\{value\}/i, v)) : '';
        }

        function readValue() {
            that.temp = that.values ? that.values.slice(0) : s.parseValue($elm.val() || '', that);
            setValue();
        }

        function getCurrentPosition(t) {
            var style = window.getComputedStyle ? getComputedStyle(t[0]) : t[0].style,
                matrix,
                px;

            if (has3d) {
                $.each(['t', 'webkitT', 'MozT', 'OT', 'msT'], function (i, v) {
                    if (style[v + 'ransform'] !== undefined) {
                        matrix = style[v + 'ransform'];
                        return false;
                    }
                });
                matrix = matrix.split(')')[0].split(', ');
                px = matrix[13] || matrix[5];
            } else {
                px = style.top.replace('px', '');
            }

            return Math.round(m - (px / itemHeight));
        }

        function ready(t, i) {
            clearTimeout(iv[i]);
            delete iv[i];
            t.closest('.dwwl').removeClass('dwa');
        }

        function scroll(t, index, val, time, active) {
            var px = (m - val) * itemHeight,
                style = t[0].style;

            if (px == pixels[index] && iv[index]) {
                return;
            }

            if (time && px != pixels[index]) {
                // Trigger animation start event
                event('onAnimStart', [$markup, index, time]);
            }

            pixels[index] = px;

            style[pr + 'Transition'] = 'all ' + (time ? time.toFixed(3) : 0) + 's ease-out';

            if (has3d) {
                style[pr + 'Transform'] = 'translate3d(0,' + px + 'px,0)';
            } else {
                style.top = px + 'px';
            }

            if (iv[index]) {
                ready(t, index);
            }

            if (time && active) {
                t.closest('.dwwl').addClass('dwa');
                iv[index] = setTimeout(function () {
                    ready(t, index);
                }, time * 1000);
            }

            pos[index] = val;
        }

        function getValid(val, t, dir) {
            var cell = $('.dw-li[data-val="' + val + '"]', t),
                cells = $('.dw-li', t),
                v = cells.index(cell),
                l = cells.length;

            // Scroll to a valid cell
            if (!cell.hasClass('dw-v')) {
                var cell1 = cell,
                    cell2 = cell,
                    dist1 = 0,
                    dist2 = 0;

                while (v - dist1 >= 0 && !cell1.hasClass('dw-v')) {
                    dist1++;
                    cell1 = cells.eq(v - dist1);
                }

                while (v + dist2 < l && !cell2.hasClass('dw-v')) {
                    dist2++;
                    cell2 = cells.eq(v + dist2);
                }

                // If we have direction (+/- or mouse wheel), the distance does not count
                if (((dist2 < dist1 && dist2 && dir !== 2) || !dist1 || (v - dist1 < 0) || dir == 1) && cell2.hasClass('dw-v')) {
                    cell = cell2;
                    v = v + dist2;
                } else {
                    cell = cell1;
                    v = v - dist1;
                }
            }

            return {
                cell: cell,
                v: v,
                val: cell.hasClass('dw-v') ? cell.attr('data-val') : null
            };
        }

        function scrollToPos(time, index, manual, dir, active) {
            // Call validation event
            if (event('validate', [$markup, index, time, dir]) !== false) {
                // Set scrollers to position
                $('.dw-ul', $markup).each(function (i) {
                    var t = $(this),
                        sc = i == index || index === undefined,
                        res = getValid(that.temp[i], t, dir),
                        cell = res.cell;

                    if (!(cell.hasClass('dw-sel')) || sc) {
                        // Set valid value
                        that.temp[i] = res.val;

                        if (!s.multiple) {
                            $('.dw-sel', t).removeAttr('aria-selected');
                            cell.attr('aria-selected', 'true');
                        }

                        // Add selected class to cell
                        $('.dw-sel', t).removeClass('dw-sel');
                        cell.addClass('dw-sel');

                        // Scroll to position
                        scroll(t, i, res.v, sc ? time : 0.1, sc ? active : false);
                    }
                });

                // Reformat value if validation changed something
                valueText = s.formatResult(that.temp);
                if (that.live) {
                    setValue(manual, manual, 0, true);
                }

                $header.html(formatHeader(valueText));

                if (manual) {
                    event('onChange', [valueText]);
                }
            }

        }

        function event(name, args) {
            var ret;
            args.push(that);
            $.each([userdef, theme, preset, settings], function (i, v) {
                if (v && v[name]) { // Call preset event
                    ret = v[name].apply(el, args);
                }
            });
            return ret;
        }

        function calc(t, val, dir, anim, orig) {
            val = constrain(val, min, max);

            var cell = $('.dw-li', t).eq(val),
                o = orig === undefined ? val : orig,
                active = orig !== undefined,
                idx = index,
                time = anim ? (val == o ? 0.1 : Math.abs((val - o) * s.timeUnit)) : 0;

            // Set selected scroller value
            that.temp[idx] = cell.attr('data-val');

            scroll(t, idx, val, time, active);

            setTimeout(function () {
                // Validate
                scrollToPos(time, idx, true, dir, active);
            }, 10);
        }

        function plus(t) {
            var val = pos[index] + 1;
            calc(t, val > max ? min : val, 1, true);
        }

        function minus(t) {
            var val = pos[index] - 1;
            calc(t, val < min ? max : val, 2, true);
        }

        function setValue(fill, change, time, noscroll, temp) {
            if (isVisible && !noscroll) {
                scrollToPos(time);
            }

            valueText = s.formatResult(that.temp);

            if (!temp) {
                that.values = that.temp.slice(0);
                that.val = valueText;
            }

            if (fill) {

                event('onValueFill', [valueText, change]);

                if (isInput) {
                    $elm.val(valueText);
                    if (change) {
                        preventChange = true;
                        $elm.change();
                    }
                }
            }
        }


        // Public functions

        /**
         * Positions the scroller on the screen.
         */
        that.position = function (check) {

            var nw = $persp.width(), // To get the width without scrollbar
                nh = $wnd[0].innerHeight || $wnd.innerHeight();

            if (!(wndWidth === nw && wndHeight === nh && check) && !preventPos && (event('onPosition', [$markup, nw, nh]) !== false) && isModal) {
                var w,
                    l,
                    t,
                    aw, // anchor width
                    ah, // anchor height
                    ap, // anchor position
                    at, // anchor top
                    al, // anchor left
                    arr, // arrow
                    arrw, // arrow width
                    arrl, // arrow left
                    dh,
                    scroll,
                    totalw = 0,
                    minw = 0,
                    sl = $wnd.scrollLeft(),
                    st = $wnd.scrollTop(),
                    wr = $('.dwwr', $markup),
                    d = $('.dw', $markup),
                    css = {},
                    anchor = s.anchor === undefined ? $elm : s.anchor;

                // Set / unset liquid layout based on screen width, but only if not set explicitly by the user
                if (isLiquid && s.layout !== 'liquid') {
                    if (nw < 400) {
                        $markup.addClass('dw-liq');
                    } else {
                        $markup.removeClass('dw-liq');
                    }
                }

                if (/modal|bubble/.test(s.display)) {
                    wr.width('');
                    $('.dwc', $markup).each(function () {
                        w = $(this).outerWidth(true);
                        totalw += w;
                        minw = (w > minw) ? w : minw;
                    });
                    w = totalw > nw ? minw : totalw;
                    wr.width(w).css('white-space', totalw > nw ? '' : 'nowrap');
                }

                mw = d.outerWidth();
                mh = d.outerHeight(true);
                scrollLock = mh <= nh && mw <= nw;

                that.scrollLock = scrollLock;

                if (s.display == 'modal') {
                    l = Math.max(0, (nw - mw) / 2);
                    t = st + (nh - mh) / 2;
                } else if (s.display == 'bubble') {
                    scroll = true;
                    arr = $('.dw-arrw-i', $markup);
                    ap = anchor.offset();
                    at = Math.abs($(s.context).offset().top - ap.top);
                    al = Math.abs($(s.context).offset().left - ap.left);

                    // horizontal positioning
                    aw = anchor.outerWidth();
                    ah = anchor.outerHeight();
                    l = constrain(al - (d.outerWidth(true) - aw) / 2 - sl, 3, nw - mw - 3);

                    // vertical positioning
                    t = at - mh; // above the input
                    if ((t < st) || (at > st + nh)) { // if doesn't fit above or the input is out of the screen
                        d.removeClass('dw-bubble-top').addClass('dw-bubble-bottom');
                        t = at + ah; // below the input
                    } else {
                        d.removeClass('dw-bubble-bottom').addClass('dw-bubble-top');
                    }

                    // Calculate Arrow position
                    arrw = arr.outerWidth();
                    arrl = constrain(al + aw / 2 - (l + (mw - arrw) / 2) - sl, 0, arrw);

                    // Limit Arrow position
                    $('.dw-arr', $markup).css({ left: arrl });
                } else {
                    if (s.display == 'top') {
                        t = st;
                    } else if (s.display == 'bottom') {
                        t = st + nh - mh;
                    }
                }

                css.top = t < 0 ? 0 : t;
                css.left = l;
                d.css(css);

                // If top + modal height > doc height, increase doc height
                $persp.height(0);
                dh = Math.max(t + mh, s.context == 'body' ? $(document).height() : $doc.scrollHeight);
                $persp.css({ height: dh, left: sl });

                // Scroll needed
                if (scroll && ((t + mh > st + nh) || (at > st + nh))) {
                    preventPos = true;
                    setTimeout(function () { preventPos = false; }, 300);
                    $wnd.scrollTop(Math.min(t + mh - nh, dh - nh));
                }
            }

            wndWidth = nw;
            wndHeight = nh;
        };

        /**
         * Enables the scroller and the associated input.
         */
        that.enable = function () {
            s.disabled = false;
            if (isInput) {
                $elm.prop('disabled', false);
            }
        };

        /**
         * Disables the scroller and the associated input.
         */
        that.disable = function () {
            s.disabled = true;
            if (isInput) {
                $elm.prop('disabled', true);
            }
        };

        /**
         * Gets the selected wheel values, formats it, and set the value of the scroller instance.
         * If input parameter is true, populates the associated input element.
         * @param {Array} values Wheel values.
         * @param {Boolean} [fill=false] Also set the value of the associated input element.
         * @param {Number} [time=0] Animation time
         * @param {Boolean} [temp=false] If true, then only set the temporary value.(only scroll there but not set the value)
         */
        that.setValue = function (values, fill, time, temp, change) {
            that.temp = $.isArray(values) ? values.slice(0) : s.parseValue.call(el, values + '', that);
            setValue(fill, change === undefined ? fill : change, time, false, temp);
        };

        /**
         * Return the selected wheel values.
         */
        that.getValue = function () {
            return that.values;
        };

        /**
         * Return selected values, if in multiselect mode.
         */
        that.getValues = function () {
            var ret = [],
                i;

            for (i in that._selectedValues) {
                ret.push(that._selectedValues[i]);
            }
            return ret;
        };

        /**
         * Changes the values of a wheel, and scrolls to the correct position
         * @param {Array} idx Indexes of the wheels to change.
         * @param {Number} [time=0] Animation time when scrolling to the selected value on the new wheel.
         * @param {Boolean} [manual=false] Indicates that the change was triggered by the user or from code.
         */
        that.changeWheel = function (idx, time, manual) {
            if ($markup) {
                var i = 0,
                    nr = idx.length;

                $.each(s.wheels, function (j, wg) {
                    $.each(wg, function (k, w) {
                        if ($.inArray(i, idx) > -1) {
                            wheels[i] = w;
                            $('.dw-ul', $markup).eq(i).html(generateWheelItems(i));
                            nr--;
                            if (!nr) {
                                that.position();
                                scrollToPos(time, undefined, manual);
                                return false;
                            }
                        }
                        i++;
                    });
                    if (!nr) {
                        return false;
                    }
                });
            }
        };

        /**
         * Return true if the scroller is currently visible.
         */
        that.isVisible = function () {
            return isVisible;
        };

        /**
         * Attach tap event to the given element.
         */
        that.tap = function (el, handler, prevent) {
            var startX,
                startY;

            if (s.tap) {
                el.on('touchstart.dw', function (ev) {
                    // Can't always call preventDefault here, it kills page scroll
                    if (prevent) {
                        ev.preventDefault();
                    }
                    startX = getCoord(ev, 'X');
                    startY = getCoord(ev, 'Y');
                }).on('touchend.dw', function (ev) {
                    var that = this;
                    // If movement is less than 20px, fire the click event handler
                    if (Math.abs(getCoord(ev, 'X') - startX) < 20 && Math.abs(getCoord(ev, 'Y') - startY) < 20) {
                        // preventDefault and setTimeout are needed by iOS
                        ev.preventDefault();
                        setTimeout(function () {
                            handler.call(that, ev);
                        }, isOldAndroid ? 400 : 10);
                    }
                    setTap();
                });
            }

            el.on('click.dw', function (ev) {
                if (!tap) {
                    // If handler was not called on touchend, call it on click;
                    handler.call(this, ev);
                }
                ev.preventDefault();
            });

        };

        /**
         * Shows the scroller instance.
         * @param {Boolean} prevAnim - Prevent animation if true
         * @param {Boolean} prevFocus - Prevent focusing if true
         */
        that.show = function (prevAnim, prevFocus) {
            // Create wheels
            var lbl,
                html,
                l = 0,
                mAnim = '';

            if (s.disabled || isVisible) {
                return;
            }

            if (anim !== false) {
                if (s.display == 'top') {
                    anim = 'slidedown';
                }
                if (s.display == 'bottom') {
                    anim = 'slideup';
                }
            }

            // Parse value from input
            readValue();

            event('onBeforeShow', []);

            if (isModal && anim && !prevAnim) {
                mAnim = 'dw-' + anim + ' dw-in';
            }

            // Create wheels containers
            html = '<div class="' + s.theme + ' dw-' + s.display +
                (isLiquid ? ' dw-liq' : '') +
                (lines > 1 ? ' dw-ml' : '') +
                (hasButtons ? '' : ' dw-nobtn') + '">' +
                '<div class="dw-persp">' +
                (isModal ? '<div class="dwo"></div>' : '') + // Overlay
                '<div' + (isModal ? ' role="dialog" tabindex="-1"' : '') + ' class="dw dwbg ' + mAnim + (s.rtl ? ' dw-rtl' : ' dw-ltr') + '">' + // Popup
                (s.display === 'bubble' ? '<div class="dw-arrw"><div class="dw-arrw-i"><div class="dw-arr"></div></div></div>' : '') + // Bubble arrow
                '<div class="dwwr">' + // Popup content
                '<div aria-live="assertive" class="dwv' + (s.headerText ? '' : ' dw-hidden') + '"></div>' + // Header
                '<div class="dwcc">'; // Wheel group container

            $.each(s.wheels, function (i, wg) { // Wheel groups
                html += '<div class="dwc' + (s.mode != 'scroller' ? ' dwpm' : ' dwsc') + (s.showLabel ? '' : ' dwhl') + '">' +
                    '<div class="dwwc"' + (s.maxWidth ? '' : ' style="max-width:600px;"') + '>' +
                    (hasFlex ? '' : '<table class="dw-tbl" cellpadding="0" cellspacing="0"><tr>');

                $.each(wg, function (j, w) { // Wheels
                    wheels[l] = w;
                    lbl = w.label !== undefined ? w.label : j;
                    html += '<' + (hasFlex ? 'div' : 'td') + ' class="dwfl"' + ' style="' +
                        (s.fixedWidth ? ('width:' + (s.fixedWidth[l] || s.fixedWidth) + 'px;') :
                            (s.minWidth ? ('min-width:' + (s.minWidth[l] || s.minWidth) + 'px;') : 'min-width:' + s.width + 'px;') +
                            (s.maxWidth ? ('max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;') : '')) + '">' +
                        '<div class="dwwl dwwl' + l + '">' +
                        (s.mode != 'scroller' ?
                            '<a href="#" tabindex="-1" class="dwb-e dwwb dwwbp ' + (s.btnPlusClass || '') + '" style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;"><span>+</span></a>' + // + button
                            '<a href="#" tabindex="-1" class="dwb-e dwwb dwwbm ' + (s.btnMinusClass  || '') + '" style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;"><span>&ndash;</span></a>' : '') + // - button
                        '<div class="dwl">' + lbl + '</div>' + // Wheel label
                        '<div tabindex="0" aria-live="off" aria-label="' + lbl + '" role="listbox" class="dwww">' +
                        '<div class="dww" style="height:' + (s.rows * itemHeight) + 'px;">' +
                        '<div class="dw-ul">';

                    // Create wheel values
                    html += generateWheelItems(l) +
                        '</div></div><div class="dwwo"></div></div><div class="dwwol"' +
                        (s.selectedLineHeight ? ' style="height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;"' : '') + '></div></div>' +
                        (hasFlex ? '</div>' : '</td>');

                    l++;
                });

                html += (hasFlex ? '' : '</tr></table>') + '</div></div>';
            });

            html += '</div>';

            if (isModal && hasButtons) {
                html += '<div class="dwbc">';
                $.each(buttons, function (i, b) {
                    b = (typeof b === 'string') ? that.buttons[b] : b;
                    html += '<span' + (s.btnWidth ? ' style="width:' + (100 / buttons.length) + '%"' : '') + ' class="dwbw ' + b.css + '"><a href="#" class="dwb dwb' + i + ' dwb-e" role="button">' + b.text + '</a></span>';
                });
                html += '</div>';
            }
            html += '</div></div></div></div>';

            $markup = $(html);
            $persp = $('.dw-persp', $markup);
            $overlay = $('.dwo', $markup);
            $header = $('.dwv', $markup);
            $popup = $('.dw', $markup);

            pixels = {};

            isVisible = true;

            posEvents = 'orientationchange resize';

            scrollToPos();

            event('onMarkupReady', [$markup]);

            // Show
            if (isModal) {
                ms.activeInstance = that;
                $markup.appendTo(s.context);
                if (has3d && anim && !prevAnim) {
                    $markup.addClass('dw-trans').on(animEnd, function () {
                        $markup.removeClass('dw-trans').find('.dw').removeClass(mAnim);
                        if (!prevFocus) {
                            $popup.focus();
                        }
                    });
                }
            } else if ($elm.is('div')) {
                $elm.html($markup);
            } else {
                $markup.insertAfter($elm);
            }

            event('onMarkupInserted', [$markup]);

            if (isModal) {
                // Enter / ESC
                $(window).on('keydown.dw', function (ev) {
                    if (ev.keyCode == 13) {
                        that.select();
                    } else if (ev.keyCode == 27) {
                        that.cancel();
                    }
                });

                // Prevent scroll if not specified otherwise
                if (s.scrollLock) {
                    $markup.on('touchmove', function (ev) {
                        if (scrollLock) {
                            ev.preventDefault();
                        }
                    });
                }

                // Disable inputs to prevent bleed through (Android bug)
                //if (isOldAndroid) {
                if (pr !== 'Moz') {
                    $('input,select,button', $doc).each(function () {
                        if (!this.disabled) {
                            $(this).addClass('dwtd').prop('disabled', true);
                        }
                    });
                }

                posEvents += ' scroll';
            }

            // Set position
            that.position();
            $wnd.on(posEvents, onPosition);

            // Events
            $markup.on('DOMMouseScroll mousewheel', '.dwwl', onScroll)
                .on('keydown', '.dwwl', onKeyDown)
                .on('keyup', '.dwwl', onKeyUp)
                .on('selectstart mousedown', prevdef) // Prevents blue highlight on Android and text selection in IE
                .on('click', '.dwb-e', prevdef)
                .on('keydown', '.dwb-e', function (ev) {
                    if (ev.keyCode == 32) { // Space
                        ev.preventDefault();
                        ev.stopPropagation();
                        $(this).click();
                    }
                });

            setTimeout(function () {
                // Init buttons
                $.each(buttons, function (i, b) {
                    that.tap($('.dwb' + i, $markup), function (ev) {
                        b = (typeof b === 'string') ? that.buttons[b] : b;
                        b.handler.call(this, ev, that);
                    }, true);
                });

                if (s.closeOnOverlay) {
                    that.tap($overlay, function () {
                        that.cancel();
                    });
                }

                if (isModal && !anim && !prevFocus) {
                    $popup.focus();
                }

                $markup
                    .on('touchstart mousedown', '.dwwl', onStart)
                    .on('touchmove', '.dwwl', onMove)
                    .on('touchend', '.dwwl', onEnd)
                    .on('touchstart mousedown', '.dwb-e', onBtnStart)
                    .on('touchend', '.dwb-e', onBtnEnd);

            }, 300);

            event('onShow', [$markup, valueText]);
        };

        /**
         * Hides the scroller instance.
         */
        that.hide = function (prevAnim, btn, force) {

            // If onClose handler returns false, prevent hide
            if (!isVisible || (!force && event('onClose', [valueText, btn]) === false)) {
                return false;
            }

            // Re-enable temporary disabled fields
            //if (isOldAndroid) {
            if (pr !== 'Moz') {
                $('.dwtd', $doc).each(function () {
                    $(this).prop('disabled', false).removeClass('dwtd');
                });
            }

            // Hide wheels and overlay
            if ($markup) {
                if (has3d && isModal && anim && !prevAnim && !$markup.hasClass('dw-trans')) { // If dw-trans class was not removed, means that there was no animation
                    $markup.addClass('dw-trans').find('.dw').addClass('dw-' + anim + ' dw-out').on(animEnd, function () {
                        onHide(prevAnim);
                    });
                } else {
                    onHide(prevAnim);
                }

                // Stop positioning on window resize
                $wnd.off(posEvents, onPosition);
            }

            delete ms.activeInstance;
        };

        /**
         * Set button handler.
         */
        that.select = function () {
            if (that.hide(false, 'set') !== false) {
                setValue(true, true, 0, true);
                event('onSelect', [that.val]);
            }
        };

        /**
         * Cancel and hide the scroller instance.
         */
        that.cancel = function () {
            if (that.hide(false, 'cancel') !== false) {
                event('onCancel', [that.val]);
            }
        };

        /**
         * Show mobiscroll on focus and click event of the parameter.
         * @param {jQuery} $elm - Events will be attached to this element.
         * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
         */
        that.attachShow = function ($elm, beforeShow) {
            elmList.push($elm);
            if (s.display !== 'inline') {
                $elm
                    .on('mousedown.dw', prevdef) // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
                    .on((s.showOnFocus ? 'focus.dw' : '') + (s.showOnTap ? ' click.dw' : ''), function (ev) {
                        if ((ev.type !== 'focus' || (ev.type === 'focus' && !preventShow)) && !tap) {
                            if (beforeShow) {
                                beforeShow();
                            }
                            // Hide virtual keyboard
                            if ($(document.activeElement).is('input,textarea')) {
                                $(document.activeElement).blur();
                            }
                            $activeElm = $elm;
                            that.show();
                        }
                        setTimeout(function () {
                            preventShow = false;
                        }, 300); // With jQuery < 1.9 focus is fired twice in IE
                    });
            }
        };

        /**
         * Scroller initialization.
         */
        that.init = function (ss) {
            var pres;

            // Update original user settings
            extend(settings, ss);

            s = extend({}, defaults, userdef, settings);

            // Get theme defaults
            theme = ms.themes[s.theme];

            // Get language defaults
            lang = ms.i18n[s.lang];

            event('onThemeLoad', [lang, settings]);

            extend(s, theme, lang, userdef, settings);

            // Add default buttons
            s.buttons = s.buttons || ['set', 'cancel'];

            // Hide header text in inline mode by default
            s.headerText = s.headerText === undefined ? (s.display !== 'inline' ? '{value}' : false) : s.headerText;

            that.settings = s;

            // Unbind all events (if re-init)
            $elm.off('.dw');

            pres = ms.presets[s.preset];

            if (pres) {
                preset = pres.call(el, that);
                extend(s, preset, settings); // Load preset settings
            }

            // Set private members
            m = Math.floor(s.rows / 2);
            itemHeight = s.height;
            anim = isOldAndroid ? false : s.animate;
            lines = s.multiline;
            isLiquid = (s.layout || (/top|bottom/.test(s.display) && s.wheels.length == 1 ? 'liquid' : '')) === 'liquid';
            isModal = s.display !== 'inline';
            buttons = s.buttons;
            $wnd = $(s.context == 'body' ? window : s.context);
            $doc = $(s.context)[0];

            // @deprecated since 2.8.0, backward compatibility code
            // ---
            if (!s.setText) {
                buttons.splice($.inArray('set', buttons), 1);
            }
            if (!s.cancelText) {
                buttons.splice($.inArray('cancel', buttons), 1);
            }
            if (s.button3) {
                buttons.splice($.inArray('set', buttons) + 1, 0, { text: s.button3Text, handler: s.button3 });
            }
            // ---

            that.context = $wnd;
            that.live = !isModal || ($.inArray('set', buttons) == -1);
            that.buttons.set = { text: s.setText, css: 'dwb-s', handler: that.select };
            that.buttons.cancel = { text: (that.live) ? s.closeText : s.cancelText, css: 'dwb-c', handler: that.cancel };
            that.buttons.clear = {
                text: s.clearText,
                css: 'dwb-cl',
                handler: function () {
                    that.trigger('onClear', [$markup]);
                    $elm.val('');
                    if (!that.live) {
                        that.hide(false, 'clear');
                    }
                }
            };

            hasButtons = buttons.length > 0;

            if (isVisible) {
                that.hide(true, false, true);
            }

            if (isModal) {
                readValue();
                if (isInput) {
                    // Set element readonly, save original state
                    if (wasReadOnly === undefined) {
                        wasReadOnly = el.readOnly;
                    }
                    el.readOnly = true;
                }
                that.attachShow($elm);
            } else {
                that.show();
            }

            if (isInput) {
                $elm.on('change.dw', function () {
                    if (!preventChange) {
                        that.setValue($elm.val(), false, 0.2);
                    }
                    preventChange = false;
                });
            }
        };

        /**
         * Sets one ore more options.
         */
        that.option = function (opt, value) {
            var obj = {};
            if (typeof opt === 'object') {
                obj = opt;
            } else {
                obj[opt] = value;
            }
            that.init(obj);
        };

        /**
         * Destroys the mobiscroll instance.
         */
        that.destroy = function () {
            // Force hide without animation
            that.hide(true, false, true);

            // Remove all events from elements
            $.each(elmList, function (i, v) {
                v.off('.dw');
            });

            // Reset original readonly state
            if (isInput) {
                el.readOnly = wasReadOnly;
            }

            // Delete scroller instance
            delete instances[el.id];

            event('onDestroy', []);
        };

        /**
         * Returns the mobiscroll instance.
         */
        that.getInst = function () {
            return that;
        };

        /**
         * Returns the closest valid cell.
         */
        that.getValidCell = getValid;

        /**
         * Triggers a mobiscroll event.
         */
        that.trigger = event;

        instances[el.id] = that;

        that.values = null;
        that.val = null;
        that.temp = null;
        that.buttons = {};
        that._selectedValues = {};

        that.init(settings);
    };

    function setTap() {
        tap = true;
        setTimeout(function () {
            tap = false;
        }, 500);
    }

    function constrain(val, min, max) {
        return Math.max(min, Math.min(val, max));
    }

    /**
     * @deprecated since 2.6.0, backward compatibility code
     */
    function convert(w) {
        var ret = {
            values: [],
            keys: []
        };
        $.each(w, function (k, v) {
            ret.keys.push(k);
            ret.values.push(v);
        });
        return ret;
    }

    var $activeElm,
        move,
        tap,
        preventShow,
        ms = $.mobiscroll,
        instances = ms.instances,
        util = ms.util,
        pr = util.jsPrefix,
        has3d = util.has3d,
        hasFlex = util.hasFlex,
        getCoord = util.getCoord,
        testTouch = util.testTouch,
        prevdef = function (ev) { ev.preventDefault(); },
        extend = $.extend,
        animEnd = 'webkitAnimationEnd animationend',
        userdef = ms.userdef,
        isOldAndroid = /android [1-3]/i.test(navigator.userAgent),
        defaults = extend(ms.defaults, {
            // Localization
            setText: 'Set',
            selectedText: 'Selected',
            closeText: 'Close',
            cancelText: 'Cancel',
            clearText: 'Clear',
            // Options
            minWidth: 80,
            height: 40,
            rows: 3,
            multiline: 1,
            delay: 300,
            disabled: false,
            readonly: false,
            closeOnOverlay: true,
            showOnFocus: true,
            showOnTap: true,
            showLabel: true,
            wheels: [],
            theme: '',
            display: 'modal',
            mode: 'scroller',
            preset: '',
            //lang: 'en-US',
            context: 'body',
            scrollLock: true,
            tap: true,
            btnWidth: true,
            speedUnit: 0.0012,
            timeUnit: 0.1,
            formatResult: function (d) {
                return d.join(' ');
            },
            parseValue: function (value, inst) {
                var val = value.split(' '),
                    ret = [],
                    i = 0,
                    keys;

                $.each(inst.settings.wheels, function (j, wg) {
                    $.each(wg, function (k, w) {
                        // @deprecated since 2.6.0, backward compatibility code
                        // ---
                        w = w.values ? w : convert(w);
                        // ---
                        keys = w.keys || w.values;
                        if ($.inArray(val[i], keys) !== -1) {
                            ret.push(val[i]);
                        } else {
                            ret.push(keys[0]);
                        }
                        i++;
                    });
                });
                return ret;
            }
        });

    // Prevent re-show on window focus
    $(window).on('focus', function () {
        if ($activeElm) {
            preventShow = true;
        }
    });

    $(document).on('mouseover mouseup mousedown click', function (ev) { // Prevent standard behaviour on body click
        if (tap) {
            ev.stopPropagation();
            ev.preventDefault();
            return false;
        }
    });

})(jQuery);

(function ($) {

    $.mobiscroll.themes['sense-ui'] = {
        btnStartClass: 'mbsc-ic mbsc-ic-play3',
        btnStopClass: 'mbsc-ic mbsc-ic-pause2',
        btnResetClass: 'mbsc-ic mbsc-ic-stop2',
        btnLapClass: 'mbsc-ic mbsc-ic-loop2'
    };

})(jQuery);
(function ($) {

    $.mobiscroll.themes.wp = {
        minWidth: 76,
        height: 76,
        accent: 'none',
        dateOrder: 'mmMMddDDyy',
        headerText: false,
        showLabel: false,
        icon: { filled: 'star3', empty: 'star' },
        btnWidth: false,
        btnStartClass: 'mbsc-ic mbsc-ic-play3',
        btnStopClass: 'mbsc-ic mbsc-ic-pause2',
        btnResetClass: 'mbsc-ic mbsc-ic-stop2',
        btnLapClass: 'mbsc-ic mbsc-ic-loop2',
        btnHideClass: 'mbsc-ic mbsc-ic-close',
        btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left2',
        btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right2',
        btnPlusClass: 'mbsc-ic mbsc-ic-plus',
        btnMinusClass: 'mbsc-ic mbsc-ic-minus',
        onMarkupInserted: function (elm, inst) {
            var click,
                touch,
                active;

            $('.dw', elm).addClass('wp-' + inst.settings.accent);

            $('.dwb-s .dwb', elm).addClass('mbsc-ic mbsc-ic-checkmark');
            $('.dwb-c .dwb', elm).addClass('mbsc-ic mbsc-ic-close');
            $('.dwb-cl .dwb', elm).addClass('mbsc-ic mbsc-ic-close');
            $('.dwb-n .dwb', elm).addClass('mbsc-ic mbsc-ic-loop2');

            $('.dwwl', elm).on('touchstart mousedown DOMMouseScroll mousewheel', function (e) {
                if (e.type === 'mousedown' && touch) {
                    return;
                }
                touch = e.type === 'touchstart';
                click = true;
                active = $(this).hasClass('wpa');
                $('.dwwl', elm).removeClass('wpa');
                $(this).addClass('wpa');
            }).on('touchmove mousemove', function () {
                click = false;
            }).on('touchend mouseup', function (e) {
                if (click && active && $(e.target).closest('.dw-li').hasClass('dw-sel')) {
                    $(this).removeClass('wpa');
                }
                if (e.type === 'mouseup') {
                    touch = false;
                }
                click = false;
            });
        },
        onThemeLoad: function (lang, s) {
            if (lang && lang.dateOrder && !s.dateOrder) {
                var ord = lang.dateOrder;
                ord = ord.match(/mm/i) ? ord.replace(/mmMM|mm|MM/,  'mmMM') : ord.replace(/mM|m|M/,  'mM');
                ord = ord.match(/dd/i) ? ord.replace(/ddDD|dd|DD/,  'ddDD') : ord.replace(/dD|d|D/,  'dD');
                s.dateOrder = ord;
            }
        }
    };

    $.mobiscroll.themes['wp light'] = $.mobiscroll.themes.wp;

})(jQuery);



(function ($) {

    var defaults = {
        inputClass: '',
        invalid: [],
        rtl: false,
        showInput: true,
        group: false,
        groupLabel: 'Groups'
    };

    $.mobiscroll.presetShort('select');

    $.mobiscroll.presets.select = function (inst) {
        var change,
            grIdx,
            gr,
            group,
            input,
            optIdx,
            option,
            prev,
            prevent,
            timer,
            w,
            orig = $.extend({}, inst.settings),
            s = $.extend(inst.settings, defaults, orig),
            layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),
            isLiquid = layout == 'liquid',
            elm = $(this),
            multiple = elm.prop('multiple'),
            id = this.id + '_dummy',
            lbl = $('label[for="' + this.id + '"]').attr('for', id),
            label = s.label !== undefined ? s.label : (lbl.length ? lbl.text() : elm.attr('name')),
            selectedClass = 'dw-msel mbsc-ic mbsc-ic-checkmark',
            invalid = [],
            origValues = [],
            main = {},
            roPre = s.readonly;

        function genWheels() {
            var cont,
                wheel,
                wg = 0,
                values = [],
                keys = [],
                w = [[]];

            if (s.group) {

                $('optgroup', elm).each(function (i) {
                    values.push($(this).attr('label'));
                    keys.push(i);
                });

                wheel = {
                    values: values,
                    keys: keys,
                    label: s.groupLabel
                };

                if (isLiquid) {
                    w[0][wg] = wheel;
                } else {
                    w[wg] = [wheel];
                }

                cont = group;
                wg++;

            } else {
                cont = elm;
            }

            values = [];
            keys = [];

            $('option', cont).each(function () {
                var v = $(this).attr('value');
                values.push($(this).text());
                keys.push(v);
                if ($(this).prop('disabled')) {
                    invalid.push(v);
                }
            });

            wheel = {
                values: values,
                keys: keys,
                label: label
            };

            if (isLiquid) {
                w[0][wg] = wheel;
            } else {
                w[wg] = [wheel];
            }

            return w;
        }

        function getOption() {
            option = multiple ? (elm.val() ? elm.val()[0] : $('option', elm).attr('value')) : elm.val();

            if (s.group) {
                group = elm.find('option[value="' + option + '"]').parent();
                gr = group.index();
                prev = gr;
            }
        }

        function setVal(v, fill, change) {
            var value = [];

            if (multiple) {
                var sel = [],
                    i = 0;

                for (i in inst._selectedValues) {
                    sel.push(main[i]);
                    value.push(i);
                }

                input.val(sel.join(', '));
            } else {
                input.val(v);
                value = fill ? inst.values[optIdx] : null;
            }

            if (fill) {
                elm.val(value);
                if (change) {
                    prevent = true;
                    elm.change();
                }
            }
        }

        function onTap(li) {
            if (multiple && li.hasClass('dw-v') && li.closest('.dw').find('.dw-ul').index(li.closest('.dw-ul')) == optIdx) {
                var val = li.attr('data-val'),
                    selected = li.hasClass('dw-msel');

                if (selected) {
                    li.removeClass(selectedClass).removeAttr('aria-selected');
                    delete inst._selectedValues[val];
                } else {
                    li.addClass(selectedClass).attr('aria-selected', 'true');
                    inst._selectedValues[val] = val;
                }

                if (inst.live) {
                    setVal(val, true, true);
                }

                return false;
            }
        }

        // If groups is true and there are no groups fall back to no grouping
        if (s.group && !$('optgroup', elm).length) {
            s.group = false;
        }

        if (!s.invalid.length) {
            s.invalid = invalid;
        }

        if (s.group) {
            grIdx = 0;
            optIdx = 1;
        } else {
            grIdx = -1;
            optIdx = 0;
        }

        $('option', elm).each(function () {
            if (!$(this).attr('value')) {
                $(this).attr('value', $(this).text());
            }
            main[$(this).attr('value')] = $(this).text();
        });

        getOption();

        $('#' + id).remove();

        var typeStr = 'type="text"';
        if (Capriza && Capriza.device && Capriza.device.ios8) typeStr = '';

        input = $('<input '+typeStr+' id="' + id + '" class="' + s.inputClass + '" placeholder="' + (s.placeholder || '') + '" readonly />');

        if (s.showInput) {
            input.insertBefore(elm);
        }

        inst.attachShow(input);

        var v = elm.val() || [],
            i = 0;

        for (i; i < v.length; i++) {
            inst._selectedValues[v[i]] = v[i];
        }

        setVal(main[option]);

        elm.off('.dwsel').on('change.dwsel', function () {
            if (!prevent) {
                inst.setValue(multiple ? elm.val() || [] : [elm.val()], true);
            }
            prevent = false;
        }).addClass('dw-hsel').attr('tabindex', -1).closest('.ui-field-contain').trigger('create');

        // Extended methods
        // ---

        if (!inst._setValue) {
            inst._setValue = inst.setValue;
        }

        inst.setValue = function (d, fill, time, temp, change) {
            var i,
                value,
                v = $.isArray(d) ? d[0] : d;

            option = v !== undefined ? v : $('option', elm).attr('value');

            if (multiple) {
                inst._selectedValues = {};
                for (i = 0; i < d.length; i++) {
                    inst._selectedValues[d[i]] = d[i];
                }
            }

            if (s.group) {
                group = elm.find('option[value="' + option + '"]').parent();
                gr = group.index();
                value = [gr, option];
            } else {
                value = [option];
            }

            inst._setValue(value, fill, time, temp, change);

            // Set input/select values
            if (fill) {
                var changed = multiple ? true : option !== elm.val();
                setVal(main[option], changed, change === undefined ? fill : change);
            }
        };

        inst.getValue = function (temp, group) {
            var val = temp ? inst.temp : inst.values;
            return s.group && group ? val : val[optIdx];
        };

        // ---

        return {
            width: 50,
            wheels: w,
            layout: layout,
            headerText: false,
            multiple: multiple,
            anchor: input,
            formatResult: function (d) {
                return main[d[optIdx]];
            },
            parseValue: function () {
                var v = elm.val() || [],
                    i = 0;

                if (multiple) {
                    inst._selectedValues = {};
                    for (i; i < v.length; i++) {
                        inst._selectedValues[v[i]] = v[i];
                    }
                }

                getOption();

                return s.group ? [gr, option] : [option];
            },
            onBeforeShow: function () {
                if (multiple && s.counter) {
                    s.headerText = function () {
                        var length = 0;
                        $.each(inst._selectedValues, function () {
                            length++;
                        });
                        return length + ' ' + s.selectedText;
                    };
                }

                if (option === undefined) {
                    getOption();
                }

                if (s.group) {
                    prev = gr;
                    inst.temp = [gr, option];
                }

                s.wheels = genWheels();
            },
            onMarkupReady: function (dw) {
                dw.addClass('dw-select');

                $('.dwwl' + grIdx, dw).on('mousedown touchstart', function () {
                    clearTimeout(timer);
                });

                if (multiple) {
                    dw.addClass('dwms');

                    $('.dwwl', dw).on('keydown', function (e) {
                        if (e.keyCode == 32) { // Space
                            e.preventDefault();
                            e.stopPropagation();
                            onTap($('.dw-sel', this));
                        }
                    }).eq(optIdx).addClass('dwwms').attr('aria-multiselectable', 'true');

                    origValues = $.extend({}, inst._selectedValues);
                }
            },
            validate: function (dw, i, time) {
                var j,
                    v,
                    t = $('.dw-ul', dw).eq(optIdx);

                if (i === undefined && multiple) {
                    v = inst._selectedValues;
                    j = 0;

                    $('.dwwl' + optIdx + ' .dw-li', dw).removeClass(selectedClass).removeAttr('aria-selected');

                    for (j in v) {
                        $('.dwwl' + optIdx + ' .dw-li[data-val="' + v[j] + '"]', dw).addClass(selectedClass).attr('aria-selected', 'true');
                    }
                }

                if (i === undefined || i === grIdx) {
                    gr = +inst.temp[grIdx];
                    if (gr !== prev) {
                        group = elm.find('optgroup').eq(gr);
                        option = group.find('option').eq(0).val();
                        option = option || elm.val();
                        s.wheels = genWheels();
                        if (s.group && !change) {
                            inst.temp = [gr, option];
                            s.readonly = [false, true];
                            clearTimeout(timer);
                            timer = setTimeout(function () {
                                change = true;
                                prev = gr;
                                inst.changeWheel([optIdx], undefined, true);
                                s.readonly = roPre;
                            }, time * 1000);
                            return false;
                        }
                    } else {
                        s.readonly = roPre;
                    }
                } else {
                    option = inst.temp[optIdx];
                }

                $.each(s.invalid, function (i, v) {
                    $('.dw-li[data-val="' + v + '"]', t).removeClass('dw-v');
                });

                change = false;
            },
            onClear: function (dw) {
                inst._selectedValues = {};
                input.val('');
                $('.dwwl' + optIdx + ' .dw-li', dw).removeClass(selectedClass).removeAttr('aria-selected');
            },
            onValueTap: onTap,
            onSelect: function (v) {
                setVal(v, true, true);
            },
            onCancel: function () {
                if (!inst.live && multiple) {
                    inst._selectedValues = $.extend({}, origValues);
                }
            },
            onChange: function (v) {
                if (inst.live && !multiple) {
                    input.val(v);
                    prevent = true;
                    elm.val(inst.temp[optIdx]).change();
                }
            },
            onDestroy: function () {
                input.remove();
                elm.removeClass('dw-hsel').removeAttr('tabindex');
            }
        };
    };

})(jQuery);
console.log('ending parsing mobiscroll.js');
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/html2canvas/html2canvas-tweaked.min.js

try{
/*
  html2canvas 0.4.1 <http://html2canvas.hertzen.com>
  Copyright (c) 2013 Niklas von Hertzen

  Released under MIT License
*/
console.log('starting parsing html2canvas.js');
(function(t,e,n){"use strict";function r(t,e,n){var r,a=t.runtimeStyle&&t.runtimeStyle[e],o=t.style;return!/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test(n)&&/^-?\d/.test(n)&&(r=o.left,a&&(t.runtimeStyle.left=t.currentStyle.left),o.left="fontSize"===e?"1em":n||0,n=o.pixelLeft+"px",o.left=r,a&&(t.runtimeStyle.left=a)),/^(thin|medium|thick)$/i.test(n)?n:Math.round(parseFloat(n))+"px"}function a(t){return parseInt(t,10)}function o(t){return-1!==(""+t).indexOf("%")}function i(t,e,a,o){if(t=(t||"").split(","),t=t[o||0]||t[0]||"auto",t=d.Util.trimText(t).split(" "),"backgroundSize"===a&&t[0]&&t[0].match(/^(cover|contain|auto)$/))return t;if(t[0]=-1===t[0].indexOf("%")?r(e,a+"X",t[0]):t[0],t[1]===n){if("backgroundSize"===a)return t[1]="auto",t;t[1]=t[0]}return t[1]=-1===t[1].indexOf("%")?r(e,a+"Y",t[1]):t[1],t}function l(t,e){var n=[];return{storage:n,width:t,height:e,clip:function(){n.push({type:"function",name:"clip",arguments:arguments})},translate:function(){n.push({type:"function",name:"translate",arguments:arguments})},fill:function(){n.push({type:"function",name:"fill",arguments:arguments})},save:function(){n.push({type:"function",name:"save",arguments:arguments})},restore:function(){n.push({type:"function",name:"restore",arguments:arguments})},fillRect:function(){n.push({type:"function",name:"fillRect",arguments:arguments})},createPattern:function(){n.push({type:"function",name:"createPattern",arguments:arguments})},drawShape:function(){var t=[];return n.push({type:"function",name:"drawShape",arguments:t}),{moveTo:function(){t.push({name:"moveTo",arguments:arguments})},lineTo:function(){t.push({name:"lineTo",arguments:arguments})},arcTo:function(){t.push({name:"arcTo",arguments:arguments})},bezierCurveTo:function(){t.push({name:"bezierCurveTo",arguments:arguments})},quadraticCurveTo:function(){t.push({name:"quadraticCurveTo",arguments:arguments})}}},drawImage:function(){n.push({type:"function",name:"drawImage",arguments:arguments})},fillText:function(){n.push({type:"function",name:"fillText",arguments:arguments})},setVariable:function(t,e){return n.push({type:"variable",name:t,arguments:e}),e}}}var s,c,d={};d.Util={},d.Util.log=function(e){d.logging&&t.console&&t.console.log&&t.console.log(e)},d.Util.trimText=function(t){return function(e){return t?t.apply(e):((e||"")+"").replace(/^\s+|\s+$/g,"")}}(String.prototype.trim),d.Util.asFloat=function(t){return parseFloat(t)},function(){var t=/((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g,e=/(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;d.Util.parseTextShadows=function(n){if(!n||"none"===n)return[];for(var r=n.match(t),a=[],o=0;r&&r.length>o;o++){var i=r[o].match(e);a.push({color:i[0],offsetX:i[1]?i[1].replace("px",""):0,offsetY:i[2]?i[2].replace("px",""):0,blur:i[3]?i[3].replace("px",""):0})}return a}}(),d.Util.parseBackgroundImage=function(t){var e,n,r,a,o,i,l,s,c=" \r\n	",d=[],h=0,u=0,f=function(){e&&('"'===n.substr(0,1)&&(n=n.substr(1,n.length-2)),n&&s.push(n),"-"===e.substr(0,1)&&(a=e.indexOf("-",1)+1)>0&&(r=e.substr(0,a),e=e.substr(a)),d.push({prefix:r,method:e.toLowerCase(),value:o,args:s})),s=[],e=r=n=o=""};f();for(var p=0,g=t.length;g>p;p++)if(i=t[p],!(0===h&&c.indexOf(i)>-1)){switch(i){case'"':l?l===i&&(l=null):l=i;break;case"(":if(l)break;if(0===h){h=1,o+=i;continue}u++;break;case")":if(l)break;if(1===h){if(0===u){h=0,o+=i,f();continue}u--}break;case",":if(l)break;if(0===h){f();continue}if(1===h&&0===u&&!e.match(/^url$/i)){s.push(n),n="",o+=i;continue}}o+=i,0===h?e+=i:n+=i}return f(),d},d.Util.Bounds=function(t){var e,n={};return t.getBoundingClientRect&&(e=t.getBoundingClientRect(),n.top=e.top,n.bottom=e.bottom||e.top+e.height,n.left=e.left,n.width=t.offsetWidth,n.height=t.offsetHeight),n},d.Util.OffsetBounds=function(t){var e=t.offsetParent?d.Util.OffsetBounds(t.offsetParent):{top:0,left:0};return{top:t.offsetTop+e.top,bottom:t.offsetTop+t.offsetHeight+e.top,left:t.offsetLeft+e.left,width:t.offsetWidth,height:t.offsetHeight}},d.Util.getCSS=function(t,n,r){s!==t&&(c=e.defaultView.getComputedStyle(t,null));var o=c[n];if(/^background(Size|Position)$/.test(n))return i(o,t,n,r);if(/border(Top|Bottom)(Left|Right)Radius/.test(n)){var l=o.split(" ");return 1>=l.length&&(l[1]=l[0]),l.map(a)}return o},d.Util.resizeBounds=function(t,e,n,r,a){var o,i,l=n/r,s=t/e;return a&&"auto"!==a?s>l^"contain"===a?(i=r,o=r*s):(o=n,i=n/s):(o=n,i=r),{width:o,height:i}},d.Util.BackgroundPosition=function(t,e,n,r,a){var i,l,s=d.Util.getCSS(t,"backgroundPosition",r);return 1===s.length&&(s=[s[0],s[0]]),i=o(s[0])?(e.width-(a||n).width)*(parseFloat(s[0])/100):parseInt(s[0],10),l="auto"===s[1]?i/n.width*n.height:o(s[1])?(e.height-(a||n).height)*parseFloat(s[1])/100:parseInt(s[1],10),"auto"===s[0]&&(i=l/n.height*n.width),{left:i,top:l}},d.Util.BackgroundSize=function(t,e,n,r){var a,i,l=d.Util.getCSS(t,"backgroundSize",r);if(1===l.length&&(l=[l[0],l[0]]),o(l[0]))a=e.width*parseFloat(l[0])/100;else{if(/contain|cover/.test(l[0]))return d.Util.resizeBounds(n.width,n.height,e.width,e.height,l[0]);a=parseInt(l[0],10)}return i="auto"===l[0]&&"auto"===l[1]?n.height:"auto"===l[1]?a/n.width*n.height:o(l[1])?e.height*parseFloat(l[1])/100:parseInt(l[1],10),"auto"===l[0]&&(a=i/n.height*n.width),{width:a,height:i}},d.Util.BackgroundRepeat=function(t,e){var n=d.Util.getCSS(t,"backgroundRepeat").split(",").map(d.Util.trimText);return n[e]||n[0]},d.Util.Extend=function(t,e){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e},d.Util.Children=function(t){var e;try{e=t.nodeName&&"IFRAME"===t.nodeName.toUpperCase()?t.contentDocument||t.contentWindow.document:function(t){var e=[];return null!==t&&function(t,e){var r=t.length,a=0;if("number"==typeof e.length)for(var o=e.length;o>a;a++)t[r++]=e[a];else for(;e[a]!==n;)t[r++]=e[a++];return t.length=r,t}(e,t),e}(t.childNodes)}catch(r){d.Util.log("html2canvas.Util.Children failed with exception: "+r.message),e=[]}return e},d.Util.isTransparent=function(t){return!t||"transparent"===t||"rgba(0, 0, 0, 0)"===t},d.Util.Font=function(){var t={};return function(e,r,a){if(t[e+"-"+r]!==n)return t[e+"-"+r];var o,i,l,s=a.createElement("div"),c=a.createElement("img"),d=a.createElement("span"),h="Hidden Text";return s.style.visibility="hidden",s.style.fontFamily=e,s.style.fontSize=r,s.style.margin=0,s.style.padding=0,a.body.appendChild(s),c.src="data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=",c.width=1,c.height=1,c.style.margin=0,c.style.padding=0,c.style.verticalAlign="baseline",d.style.fontFamily=e,d.style.fontSize=r,d.style.margin=0,d.style.padding=0,d.appendChild(a.createTextNode(h)),s.appendChild(d),s.appendChild(c),o=c.offsetTop-d.offsetTop+1,s.removeChild(d),s.appendChild(a.createTextNode(h)),s.style.lineHeight="normal",c.style.verticalAlign="super",i=c.offsetTop-s.offsetTop+1,l={baseline:o,lineWidth:1,middle:i},t[e+"-"+r]=l,a.body.removeChild(s),l}}(),function(){function t(t){return function(e){try{t.addColorStop(e.stop,e.color)}catch(r){n.log(["failed to add color stop: ",r,"; tried to add: ",e])}}}var n=d.Util,r={};d.Generate=r;var a=[/^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,/^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,/^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/,/^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,/^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/,/^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/,/^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/];r.parseGradient=function(t,e){var n,r,o,i,l,s,c,d,h,u,f,p,g=a.length;for(r=0;g>r&&!(o=t.match(a[r]));r+=1);if(o)switch(o[1]){case"-webkit-linear-gradient":case"-o-linear-gradient":if(n={type:"linear",x0:null,y0:null,x1:null,y1:null,colorStops:[]},l=o[2].match(/\w+/g))for(s=l.length,r=0;s>r;r+=1)switch(l[r]){case"top":n.y0=0,n.y1=e.height;break;case"right":n.x0=e.width,n.x1=0;break;case"bottom":n.y0=e.height,n.y1=0;break;case"left":n.x0=0,n.x1=e.width}if(null===n.x0&&null===n.x1&&(n.x0=n.x1=e.width/2),null===n.y0&&null===n.y1&&(n.y0=n.y1=e.height/2),l=o[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g))for(s=l.length,c=1/Math.max(s-1,1),r=0;s>r;r+=1)d=l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/),d[2]?(i=parseFloat(d[2]),i/="%"===d[3]?100:e.width):i=r*c,n.colorStops.push({color:d[1],stop:i});break;case"-webkit-gradient":if(n={type:"radial"===o[2]?"circle":o[2],x0:0,y0:0,x1:0,y1:0,colorStops:[]},l=o[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/),l&&(n.x0=l[1]*e.width/100,n.y0=l[2]*e.height/100,n.x1=l[3]*e.width/100,n.y1=l[4]*e.height/100),l=o[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g))for(s=l.length,r=0;s>r;r+=1)d=l[r].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/),i=parseFloat(d[2]),"from"===d[1]&&(i=0),"to"===d[1]&&(i=1),n.colorStops.push({color:d[3],stop:i});break;case"-moz-linear-gradient":if(n={type:"linear",x0:0,y0:0,x1:0,y1:0,colorStops:[]},l=o[2].match(/(\d{1,3})%?\s(\d{1,3})%?/),l&&(n.x0=l[1]*e.width/100,n.y0=l[2]*e.height/100,n.x1=e.width-n.x0,n.y1=e.height-n.y0),l=o[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g))for(s=l.length,c=1/Math.max(s-1,1),r=0;s>r;r+=1)d=l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/),d[2]?(i=parseFloat(d[2]),d[3]&&(i/=100)):i=r*c,n.colorStops.push({color:d[1],stop:i});break;case"-webkit-radial-gradient":case"-moz-radial-gradient":case"-o-radial-gradient":if(n={type:"circle",x0:0,y0:0,x1:e.width,y1:e.height,cx:0,cy:0,rx:0,ry:0,colorStops:[]},l=o[2].match(/(\d{1,3})%?\s(\d{1,3})%?/),l&&(n.cx=l[1]*e.width/100,n.cy=l[2]*e.height/100),l=o[3].match(/\w+/),d=o[4].match(/[a-z\-]*/),l&&d)switch(d[0]){case"farthest-corner":case"cover":case"":h=Math.sqrt(Math.pow(n.cx,2)+Math.pow(n.cy,2)),u=Math.sqrt(Math.pow(n.cx,2)+Math.pow(n.y1-n.cy,2)),f=Math.sqrt(Math.pow(n.x1-n.cx,2)+Math.pow(n.y1-n.cy,2)),p=Math.sqrt(Math.pow(n.x1-n.cx,2)+Math.pow(n.cy,2)),n.rx=n.ry=Math.max(h,u,f,p);break;case"closest-corner":h=Math.sqrt(Math.pow(n.cx,2)+Math.pow(n.cy,2)),u=Math.sqrt(Math.pow(n.cx,2)+Math.pow(n.y1-n.cy,2)),f=Math.sqrt(Math.pow(n.x1-n.cx,2)+Math.pow(n.y1-n.cy,2)),p=Math.sqrt(Math.pow(n.x1-n.cx,2)+Math.pow(n.cy,2)),n.rx=n.ry=Math.min(h,u,f,p);break;case"farthest-side":"circle"===l[0]?n.rx=n.ry=Math.max(n.cx,n.cy,n.x1-n.cx,n.y1-n.cy):(n.type=l[0],n.rx=Math.max(n.cx,n.x1-n.cx),n.ry=Math.max(n.cy,n.y1-n.cy));break;case"closest-side":case"contain":"circle"===l[0]?n.rx=n.ry=Math.min(n.cx,n.cy,n.x1-n.cx,n.y1-n.cy):(n.type=l[0],n.rx=Math.min(n.cx,n.x1-n.cx),n.ry=Math.min(n.cy,n.y1-n.cy))}if(l=o[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g))for(s=l.length,c=1/Math.max(s-1,1),r=0;s>r;r+=1)d=l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/),d[2]?(i=parseFloat(d[2]),i/="%"===d[3]?100:e.width):i=r*c,n.colorStops.push({color:d[1],stop:i})}return n},r.Gradient=function(n,r){if(0!==r.width&&0!==r.height){var a,o,i=e.createElement("canvas"),l=i.getContext("2d");if(i.width=r.width,i.height=r.height,a=d.Generate.parseGradient(n,r))switch(a.type){case"linear":o=l.createLinearGradient(a.x0,a.y0,a.x1,a.y1),a.colorStops.forEach(t(o)),l.fillStyle=o,l.fillRect(0,0,r.width,r.height);break;case"circle":o=l.createRadialGradient(a.cx,a.cy,0,a.cx,a.cy,a.rx),a.colorStops.forEach(t(o)),l.fillStyle=o,l.fillRect(0,0,r.width,r.height);break;case"ellipse":var s=e.createElement("canvas"),c=s.getContext("2d"),h=Math.max(a.rx,a.ry),u=2*h;s.width=s.height=u,o=c.createRadialGradient(a.rx,a.ry,0,a.rx,a.ry,h),a.colorStops.forEach(t(o)),c.fillStyle=o,c.fillRect(0,0,u,u),l.fillStyle=a.colorStops[a.colorStops.length-1].color,l.fillRect(0,0,i.width,i.height),l.drawImage(s,a.cx-a.rx,a.cy-a.ry,2*a.rx,2*a.ry)}return i}},r.ListAlpha=function(t){var e,n="";do e=t%26,n=String.fromCharCode(e+64)+n,t/=26;while(26*t>26);return n},r.ListRoman=function(t){var e,n=["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"],r=[1e3,900,500,400,100,90,50,40,10,9,5,4,1],a="",o=n.length;if(0>=t||t>=4e3)return t;for(e=0;o>e;e+=1)for(;t>=r[e];)t-=r[e],a+=n[e];return a}}(),d.Parse=function(r,a,o){function i(){var t=be(e.documentElement,"backgroundColor"),n=me.isTransparent(t)&&fe===e.body,r=ce(fe,null,!1,n);s(fe),ue(fe,r,function(){n&&(t=r.backgroundColor),c(),me.log("Done parsing, moving to Render."),o({backgroundColor:t,stack:r})})}function s(t){function n(){for(var t=/:before|:after/,n=e.styleSheets,r=0,a=n.length;a>r;r++)try{for(var o=n[r].cssRules,i=0,s=o.length;s>i;i++)if(t.test(o[i].selectorText)){var kd=o[i].selectorText.match(/(^[^:]+)/);kd&&kd.length>1&&kd[1]&&l.push(kd[1])}}catch(c){}for(r=0,a=l.length;a>r;r++)l[r]=l[r].match(/(^[^:]*)/)[1]}function r(){for(var t=e.querySelectorAll(l.join(",")),n=0,r=t.length;r>n;n++)a(t[n])}function a(t){var e=Y(t,":before"),n=Y(t,":after");e&&i.push({type:"before",pseudo:e,el:t}),n&&i.push({type:"after",pseudo:n,el:t})}function o(){i.forEach(function(t){h(t.el,ve+"-parent")}),i.forEach(function(t){"before"===t.type?t.el.insertBefore(t.pseudo,t.el.firstChild):t.el.appendChild(t.pseudo)})}var i=[],l=[];n(),r(t),o()}function c(){xe.removeChild(Ce);for(var t=e.getElementsByClassName(ve+"-element");t.length;)t[0].parentNode.removeChild(t[0]);for(var n=e.getElementsByClassName(ve+"-parent");n.length;)u(n[0],ve+"-parent")}function h(t,e){t.classList?t.classList.add(e):t.className=t.className+" "+e}function u(t,e){t.classList?t.classList.remove(e):t.className=t.className.replace(e,"").trim()}function f(){return Math.max(Math.max(ge.body.scrollWidth,ge.documentElement.scrollWidth),Math.max(ge.body.offsetWidth,ge.documentElement.offsetWidth),Math.max(ge.body.clientWidth,ge.documentElement.clientWidth))}function p(){return Math.max(Math.max(ge.body.scrollHeight,ge.documentElement.scrollHeight),Math.max(ge.body.offsetHeight,ge.documentElement.offsetHeight),Math.max(ge.body.clientHeight,ge.documentElement.clientHeight))}function g(t,e){var n=parseInt(be(t,e),10);return isNaN(n)?0:n}function m(t,e,n,r,a,o){"transparent"!==o&&(t.setVariable("fillStyle",o),t.fillRect(e,n,r,a),pe+=1)}function y(t,e,r){return t.length>0?e+r.toUpperCase():n}function w(t,e){switch(e){case"lowercase":return t.toLowerCase();case"capitalize":return t.replace(/(^|\s|:|-|\(|\))([a-z])/g,y);case"uppercase":return t.toUpperCase();default:return t}}function x(t){return/^(normal|none|0px)$/.test(t)}function b(t,e,n,r){null!==t&&me.trimText(t).length>0&&(r.fillText(t,e,n),pe+=1)}function v(t,e,r,a){var o=!1,i=be(e,"fontWeight"),l=be(e,"fontFamily"),s=be(e,"fontSize"),c=me.parseTextShadows(be(e,"textShadow"));switch(parseInt(i,10)){case 401:i="bold";break;case 400:i="normal"}return t.setVariable("fillStyle",a),t.setVariable("font",[be(e,"fontStyle"),be(e,"fontVariant"),i,s,l].join(" ")),t.setVariable("textAlign",o?"right":"left"),c.length&&(t.setVariable("shadowColor",c[0].color),t.setVariable("shadowOffsetX",c[0].offsetX),t.setVariable("shadowOffsetY",c[0].offsetY),t.setVariable("shadowBlur",c[0].blur)),"none"!==r?me.Font(l,s,ge):n}function C(t,e,n,r,a){switch(e){case"underline":m(t,n.left,Math.round(n.top+r.baseline+r.lineWidth),n.width,1,a);break;case"overline":m(t,n.left,Math.round(n.top),n.width,1,a);break;case"line-through":m(t,n.left,Math.ceil(n.top+r.middle+r.lineWidth),n.width,1,a)}}function k(t,e,n,r,a){var o;if(ye.rangeBounds&&!a)("none"!==n||0!==me.trimText(e).length)&&(o=T(e,t.node,t.textOffset)),t.textOffset+=e.length;else if(t.node&&"string"==typeof t.node.nodeValue){var i=r?t.node.splitText(e.length):null;o=S(t.node,a),t.node=i}return o}function T(t,e,n){var r=ge.createRange();return r.setStart(e,n),r.setEnd(e,n+t.length),r.getBoundingClientRect()}function S(t,e){var n=t.parentNode,r=ge.createElement("wrapper"),a=t.cloneNode(!0);r.appendChild(t.cloneNode(!0)),n.replaceChild(r,t);var o=e?me.OffsetBounds(r):me.Bounds(r);return n.replaceChild(a,r),o}function E(t,e,n){var r,o,i=n.ctx,l=be(t,"color"),s=be(t,"textDecoration"),c=be(t,"textAlign"),d={node:e,textOffset:0};me.trimText(e.nodeValue).length>0&&(e.nodeValue=w(e.nodeValue,be(t,"textTransform")),c=c.replace(["-webkit-auto"],["auto"]),o=!a.letterRendering&&/^(left|right|justify|auto)$/.test(c)&&x(be(t,"letterSpacing"))?e.nodeValue.split(/(\b| )/):e.nodeValue.split(""),r=v(i,t,s,l),a.chinese&&o.forEach(function(t,e){/.*[\u4E00-\u9FA5].*$/.test(t)&&(t=t.split(""),t.unshift(e,1),o.splice.apply(o,t))}),o.forEach(function(t,e){var a=k(d,t,s,o.length-1>e,n.transform.matrix);a&&(b(t,a.left,a.bottom,i),C(i,s,a,r,l))}))}function R(t,e){var n,r,a=ge.createElement("boundelement");return a.style.display="inline",n=t.style.listStyleType,t.style.listStyleType="none",a.appendChild(ge.createTextNode(e)),t.insertBefore(a,t.firstChild),r=me.Bounds(a),t.removeChild(a),t.style.listStyleType=n,r}function M(t){var e=-1,n=1,r=t.parentNode.childNodes;if(t.parentNode){for(;r[++e]!==t;)1===r[e].nodeType&&n++;return n}return-1}function I(t,e){var n,r=M(t);switch(e){case"decimal":n=r;break;case"decimal-leading-zero":n=1===(""+r).length?r="0"+(""+r):""+r;break;case"upper-roman":n=d.Generate.ListRoman(r);break;case"lower-roman":n=d.Generate.ListRoman(r).toLowerCase();break;case"lower-alpha":n=d.Generate.ListAlpha(r).toLowerCase();break;case"upper-alpha":n=d.Generate.ListAlpha(r)}return n+". "}function L(t,e,n){var r,a,o,i=e.ctx,l=be(t,"listStyleType");if(/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(l)){if(a=I(t,l),o=R(t,a),v(i,t,"none",be(t,"color")),"inside"!==be(t,"listStylePosition"))return;i.setVariable("textAlign","left"),r=n.left,b(a,r,o.bottom,i)}}function O(t){var e=r[t];return e&&e.succeeded===!0?e.img:!1}function z(t,e){var n=Math.max(t.left,e.left),r=Math.max(t.top,e.top),a=Math.min(t.left+t.width,e.left+e.width),o=Math.min(t.top+t.height,e.top+e.height);return{left:n,top:r,width:a-n,height:o-r}}function B(t,e,n){var r,a="static"!==e.cssPosition,o=a?be(t,"zIndex"):"auto",i=be(t,"opacity"),l="none"!==be(t,"cssFloat");e.zIndex=r=U(o),r.isPositioned=a,r.isFloated=l,r.opacity=i,r.ownStacking="auto"!==o||1>i,r.depth=n?n.zIndex.depth+1:0,n&&n.zIndex.children.push(e)}function U(t){return{depth:0,zindex:t,children:[]}}function A(t,e,n,r,a){var o=g(e,"paddingLeft"),i=g(e,"paddingTop"),l=g(e,"paddingRight"),s=g(e,"paddingBottom");_(t,n,0,0,n.width,n.height,r.left+o+a[3].width,r.top+i+a[0].width,r.width-(a[1].width+a[3].width+o+l),r.height-(a[0].width+a[2].width+i+s))}function N(t){return["Top","Right","Bottom","Left"].map(function(e){return{width:g(t,"border"+e+"Width"),color:be(t,"border"+e+"Color")}})}function P(t){return["TopLeft","TopRight","BottomRight","BottomLeft"].map(function(e){return be(t,"border"+e+"Radius")})}function F(t,e,n,r){var a=4*((Math.sqrt(2)-1)/3),o=n*a,i=r*a,l=t+n,s=e+r;return{topLeft:V({x:t,y:s},{x:t,y:s-i},{x:l-o,y:e},{x:l,y:e}),topRight:V({x:t,y:e},{x:t+o,y:e},{x:l,y:s-i},{x:l,y:s}),bottomRight:V({x:l,y:e},{x:l,y:e+i},{x:t+o,y:s},{x:t,y:s}),bottomLeft:V({x:l,y:s},{x:l-o,y:s},{x:t,y:e+i},{x:t,y:e})}}function V(t,e,n,r){var a=function(t,e,n){return{x:t.x+(e.x-t.x)*n,y:t.y+(e.y-t.y)*n}};return{start:t,startControl:e,endControl:n,end:r,subdivide:function(o){var i=a(t,e,o),l=a(e,n,o),s=a(n,r,o),c=a(i,l,o),d=a(l,s,o),h=a(c,d,o);return[V(t,i,c,h),V(h,d,s,r)]},curveTo:function(t){t.push(["bezierCurve",e.x,e.y,n.x,n.y,r.x,r.y])},curveToReversed:function(r){r.push(["bezierCurve",n.x,n.y,e.x,e.y,t.x,t.y])}}}function D(t,e,n,r,a,o,i){e[0]>0||e[1]>0?(t.push(["line",r[0].start.x,r[0].start.y]),r[0].curveTo(t),r[1].curveTo(t)):t.push(["line",o,i]),(n[0]>0||n[1]>0)&&t.push(["line",a[0].start.x,a[0].start.y])}function $(t,e,n,r,a,o,i){var l=[];return e[0]>0||e[1]>0?(l.push(["line",r[1].start.x,r[1].start.y]),r[1].curveTo(l)):l.push(["line",t.c1[0],t.c1[1]]),n[0]>0||n[1]>0?(l.push(["line",o[0].start.x,o[0].start.y]),o[0].curveTo(l),l.push(["line",i[0].end.x,i[0].end.y]),i[0].curveToReversed(l)):(l.push(["line",t.c2[0],t.c2[1]]),l.push(["line",t.c3[0],t.c3[1]])),e[0]>0||e[1]>0?(l.push(["line",a[1].end.x,a[1].end.y]),a[1].curveToReversed(l)):l.push(["line",t.c4[0],t.c4[1]]),l}function G(t,e,n){var r=t.left,a=t.top,o=t.width,i=t.height,l=e[0][0],s=e[0][1],c=e[1][0],d=e[1][1],h=e[2][0],u=e[2][1],f=e[3][0],p=e[3][1],g=o-c,m=i-u,y=o-h,w=i-p;return{topLeftOuter:F(r,a,l,s).topLeft.subdivide(.5),topLeftInner:F(r+n[3].width,a+n[0].width,Math.max(0,l-n[3].width),Math.max(0,s-n[0].width)).topLeft.subdivide(.5),topRightOuter:F(r+g,a,c,d).topRight.subdivide(.5),topRightInner:F(r+Math.min(g,o+n[3].width),a+n[0].width,g>o+n[3].width?0:c-n[3].width,d-n[0].width).topRight.subdivide(.5),bottomRightOuter:F(r+y,a+m,h,u).bottomRight.subdivide(.5),bottomRightInner:F(r+Math.min(y,o+n[3].width),a+Math.min(m,i+n[0].width),Math.max(0,h-n[1].width),Math.max(0,u-n[2].width)).bottomRight.subdivide(.5),bottomLeftOuter:F(r,a+w,f,p).bottomLeft.subdivide(.5),bottomLeftInner:F(r+n[3].width,a+w,Math.max(0,f-n[3].width),Math.max(0,p-n[2].width)).bottomLeft.subdivide(.5)}}function W(t,e,n,r,a){var o=be(t,"backgroundClip"),i=[];switch(o){case"content-box":case"padding-box":D(i,r[0],r[1],e.topLeftInner,e.topRightInner,a.left+n[3].width,a.top+n[0].width),D(i,r[1],r[2],e.topRightInner,e.bottomRightInner,a.left+a.width-n[1].width,a.top+n[0].width),D(i,r[2],r[3],e.bottomRightInner,e.bottomLeftInner,a.left+a.width-n[1].width,a.top+a.height-n[2].width),D(i,r[3],r[0],e.bottomLeftInner,e.topLeftInner,a.left+n[3].width,a.top+a.height-n[2].width);break;default:D(i,r[0],r[1],e.topLeftOuter,e.topRightOuter,a.left,a.top),D(i,r[1],r[2],e.topRightOuter,e.bottomRightOuter,a.left+a.width,a.top),D(i,r[2],r[3],e.bottomRightOuter,e.bottomLeftOuter,a.left+a.width,a.top+a.height),D(i,r[3],r[0],e.bottomLeftOuter,e.topLeftOuter,a.left,a.top+a.height)}return i}function H(t,e,n){var r,a,o,i,l,s,c=e.left,d=e.top,h=e.width,u=e.height,f=P(t),p=G(e,f,n),g={clip:W(t,p,n,f,e),borders:[]};for(r=0;4>r;r++)if(n[r].width>0){switch(a=c,o=d,i=h,l=u-n[2].width,r){case 0:l=n[0].width,s=$({c1:[a,o],c2:[a+i,o],c3:[a+i-n[1].width,o+l],c4:[a+n[3].width,o+l]},f[0],f[1],p.topLeftOuter,p.topLeftInner,p.topRightOuter,p.topRightInner);break;case 1:a=c+h-n[1].width,i=n[1].width,s=$({c1:[a+i,o],c2:[a+i,o+l+n[2].width],c3:[a,o+l],c4:[a,o+n[0].width]},f[1],f[2],p.topRightOuter,p.topRightInner,p.bottomRightOuter,p.bottomRightInner);break;case 2:o=o+u-n[2].width,l=n[2].width,s=$({c1:[a+i,o+l],c2:[a,o+l],c3:[a+n[3].width,o],c4:[a+i-n[3].width,o]},f[2],f[3],p.bottomRightOuter,p.bottomRightInner,p.bottomLeftOuter,p.bottomLeftInner);break;case 3:i=n[3].width,s=$({c1:[a,o+l+n[2].width],c2:[a,o],c3:[a+i,o+n[0].width],c4:[a+i,o+l]},f[3],f[0],p.bottomLeftOuter,p.bottomLeftInner,p.topLeftOuter,p.topLeftInner)}g.borders.push({args:s,color:n[r].color})}return g}function j(t,e){var n=t.drawShape();return e.forEach(function(t,e){n[0===e?"moveTo":t[0]+"To"].apply(null,t.slice(1))}),n}function q(t,e,n){"transparent"!==n&&(t.setVariable("fillStyle",n),j(t,e),t.fill(),pe+=1)}function X(t,e,n){var r,a,o=ge.createElement("valuewrap"),i=["lineHeight","textAlign","fontFamily","color","fontSize","paddingLeft","paddingTop","width","height","border","borderLeftWidth","borderTopWidth"];i.forEach(function(e){try{o.style[e]=be(t,e)}catch(n){me.log("html2canvas: Parse: Exception caught in renderFormValue: "+n.message)}}),o.style.borderColor="black",o.style.borderStyle="solid",o.style.display="block",o.style.position="absolute",(/^(submit|reset|button|text|password)$/.test(t.type)||"SELECT"===t.nodeName)&&(o.style.lineHeight=be(t,"height")),o.style.top=e.top+"px",o.style.left=e.left+"px",r="SELECT"===t.nodeName?(t.options[t.selectedIndex]||0).text:t.value,r||(r=t.placeholder),a=ge.createTextNode(r),o.appendChild(a),xe.appendChild(o),E(t,a,n),xe.removeChild(o)}function _(t){t.drawImage.apply(t,Array.prototype.slice.call(arguments,1)),pe+=1}function Y(n,r){var a=t.getComputedStyle(n,r),o=t.getComputedStyle(n);if(a&&a.content&&"none"!==a.content&&"-moz-alt-content"!==a.content&&"none"!==a.display&&o.content!==a.content){var i=a.content+"";("'"===i[0]||'"'===i[0])&&(i=i.replace(/(^['"])|(['"]$)/g,""));var l="url"===i.substr(0,3),s=e.createElement(l?"img":"span");return s.className=ve+"-element ",Object.keys(a).filter(Q).forEach(function(t){try{s.style[t]=a[t]}catch(e){me.log(["Tried to assign readonly property ",t,"Error:",e])}}),l?s.src=me.parseBackgroundImage(i)[0].args[0]:s.innerHTML=i,s}}function Q(e){return isNaN(t.parseInt(e,10))}function J(t,e,n,r){var a=Math.round(r.left+n.left),o=Math.round(r.top+n.top);t.createPattern(e),t.translate(a,o),t.fill(),t.translate(-a,-o)}function K(t,e,n,r,a,o,i,l){var s=[];s.push(["line",Math.round(a),Math.round(o)]),s.push(["line",Math.round(a+i),Math.round(o)]),s.push(["line",Math.round(a+i),Math.round(l+o)]),s.push(["line",Math.round(a),Math.round(l+o)]),j(t,s),t.save(),t.clip(),J(t,e,n,r),t.restore()}function Z(t,e,n){m(t,e.left,e.top,e.width,e.height,n)}function te(t,e,n,r,a){var o=me.BackgroundSize(t,e,r,a),i=me.BackgroundPosition(t,e,r,a,o),l=me.BackgroundRepeat(t,a);switch(r=ne(r,o),l){case"repeat-x":case"repeat no-repeat":K(n,r,i,e,e.left,e.top+i.top,99999,r.height);break;case"repeat-y":case"no-repeat repeat":K(n,r,i,e,e.left+i.left,e.top,r.width,99999);break;case"no-repeat":K(n,r,i,e,e.left+i.left,e.top+i.top,r.width,r.height);break;default:J(n,r,i,{top:e.top,left:e.left,width:r.width,height:r.height})}}function ee(t,e,n){for(var r,a=be(t,"backgroundImage"),o=me.parseBackgroundImage(a),i=o.length;i--;)if(a=o[i],a.args&&0!==a.args.length){var l="url"===a.method?a.args[0]:a.value;r=O(l),r?te(t,e,n,r,i):me.log("html2canvas: Error loading background:",a)}}function ne(t,e){if(t.width===e.width&&t.height===e.height)return t;var n,r=ge.createElement("canvas");return r.width=e.width,r.height=e.height,n=r.getContext("2d"),_(n,t,0,0,t.width,t.height,0,0,e.width,e.height),r}function re(t,e,n){return t.setVariable("globalAlpha",be(e,"opacity")*(n?n.opacity:1))}function ae(t){return t.replace("px","")}function oe(t){var e=/(matrix)\((.+)\)/,n=be(t,"transform")||be(t,"-webkit-transform")||be(t,"-moz-transform")||be(t,"-ms-transform")||be(t,"-o-transform"),r=be(t,"transform-origin")||be(t,"-webkit-transform-origin")||be(t,"-moz-transform-origin")||be(t,"-ms-transform-origin")||be(t,"-o-transform-origin")||"0px 0px";r=r.split(" ").map(ae).map(me.asFloat);var a;if(n&&"none"!==n){var o=n.match(e);if(o)switch(o[1]){case"matrix":a=o[2].split(",").map(me.trimText).map(me.asFloat)}}return{origin:r,matrix:a}}function ie(t,e,n,r){var o=l(e?n.width:f(),e?n.height:p()),i={ctx:o,opacity:re(o,t,e),cssPosition:be(t,"position"),borders:N(t),transform:r,clip:e&&e.clip?me.Extend({},e.clip):null};return B(t,i,e),a.useOverflow===!0&&/(hidden|scroll|auto)/.test(be(t,"overflow"))===!0&&/(BODY)/i.test(t.nodeName)===!1&&(i.clip=i.clip?z(i.clip,n):n),i}function le(t,e,n){var r={left:e.left+t[3].width,top:e.top+t[0].width,width:e.width-(t[1].width+t[3].width),height:e.height-(t[0].width+t[2].width)};return n&&(r=z(r,n)),r}function se(t,e){var n=e.matrix?me.OffsetBounds(t):me.Bounds(t);return e.origin[0]+=n.left,e.origin[1]+=n.top,n}function ce(t,e,n){var r,a=oe(t,e),o=se(t,a),i=ie(t,e,o,a),l=i.borders,s=i.ctx,c=le(l,o,i.clip),d=H(t,o,l),h=we.test(t.nodeName)?"#efefef":be(t,"backgroundColor");switch(j(s,d.clip),s.save(),s.clip(),c.height>0&&c.width>0&&!n?(Z(s,o,h),ee(t,c,s)):n&&(i.backgroundColor=h),s.restore(),d.borders.forEach(function(t){q(s,t.args,t.color)}),t.nodeName){case"IMG":(r=O(t.getAttribute("src")))?A(s,t,r,o,l):me.log("html2canvas: Error loading <img>:"+t.getAttribute("src"));break;case"INPUT":/^(text|url|email|submit|button|reset)$/.test(t.type)&&(t.value||t.placeholder||"").length>0&&X(t,o,i);break;case"TEXTAREA":(t.value||t.placeholder||"").length>0&&X(t,o,i);break;case"SELECT":(t.options||t.placeholder||"").length>0&&X(t,o,i);break;case"LI":L(t,i,c);break;case"CANVAS":A(s,t,t,o,l)}return i}function de(t){return"none"!==be(t,"display")&&"hidden"!==be(t,"visibility")&&!t.hasAttribute("data-html2canvas-ignore")}function he(t,e,r){return r||(r=function(){}),de(t)&&(e=ce(t,e,!1)||e,!we.test(t.nodeName))?ue(t,e,r):(r(),n)}function ue(t,e,n){function r(n){n.nodeType===n.ELEMENT_NODE?he(n,e,o):n.nodeType===n.TEXT_NODE?(E(t,n,e),o()):o()}function o(){0>=--l&&(me.log("finished rendering "+i.length+" children."),n())}var i=me.Children(t),l=i.length+1;o(),a.async?i.forEach(function(t){setTimeout(function(){r(t)},0)}):i.forEach(r)}t.scroll(0,0);var fe=a.elements===n?e.body:a.elements[0],pe=0,ge=fe.ownerDocument,me=d.Util,ye=me.Support(a,ge),we=RegExp("("+a.ignoreElements+")"),xe=ge.body,be=me.getCSS,ve="___html2canvas___pseudoelement",Ce=ge.createElement("style");Ce.innerHTML="."+ve+'-parent:before { content: "" !important; display: none !important; }'+"."+ve+'-parent:after { content: "" !important; display: none !important; }',xe.appendChild(Ce),r=r||{},i()},d.Preload=function(r){function a(t){E.href=t,E.href=E.href;var e=E.protocol+E.host;return e===g}function o(){b.log("html2canvas: start: images: "+x.numLoaded+" / "+x.numTotal+" (failed: "+x.numFailed+")"),!x.firstRun&&x.numLoaded>=x.numTotal&&(b.log("Finished loading images: # "+x.numTotal+" (failed: "+x.numFailed+")"),"function"==typeof r.complete&&r.complete(x))}function i(e,a,i){var l,s,c=r.proxy;E.href=e,e=E.href,l="html2canvas_"+v++,i.callbackname=l,c+=c.indexOf("?")>-1?"&":"?",c+="url="+encodeURIComponent(e)+"&callback="+l,s=k.createElement("script"),t[l]=function(e){"error:"===e.substring(0,6)?(i.succeeded=!1,x.numLoaded++,x.numFailed++,o()):(p(a,i),a.src=e),t[l]=n;try{delete t[l]}catch(r){}s.parentNode.removeChild(s),s=null,delete i.script,delete i.callbackname},s.setAttribute("type","text/javascript"),s.setAttribute("src",c),i.script=s,t.document.body.appendChild(s)}function l(e,n){var r=t.getComputedStyle(e,n),a=r.content;"url"===a.substr(0,3)&&m.loadImage(d.Util.parseBackgroundImage(a)[0].args[0]),u(r.backgroundImage,e)}function s(t){l(t,":before"),l(t,":after")}function c(t,e){var r=d.Generate.Gradient(t,e);r!==n&&(x[t]={img:r,succeeded:!0},x.numTotal++,x.numLoaded++,o())}function h(t){return t&&t.method&&t.args&&t.args.length>0}function u(t,e){var r;d.Util.parseBackgroundImage(t).filter(h).forEach(function(t){"url"===t.method?m.loadImage(t.args[0]):t.method.match(/\-?gradient$/)&&(r===n&&(r=d.Util.Bounds(e)),c(t.value,r))})}function f(t){var e=!1;try{b.Children(t).forEach(f)}catch(r){}try{e=t.nodeType}catch(a){e=!1,b.log("html2canvas: failed to access some element's nodeType - Exception: "+a.message)}if(1===e||e===n){s(t);try{u(b.getCSS(t,"backgroundImage"),t)}catch(r){b.log("html2canvas: failed to get background-image - Exception: "+r.message)}u(t)}}function p(e,a){e.onload=function(){a.timer!==n&&t.clearTimeout(a.timer),x.numLoaded++,a.succeeded=!0,e.onerror=e.onload=null,o()},e.onerror=function(){if("anonymous"===e.crossOrigin&&(t.clearTimeout(a.timer),r.proxy)){var l=e.src;return e=new Image,a.img=e,e.src=l,i(e.src,e,a),n}x.numLoaded++,x.numFailed++,a.succeeded=!1,e.onerror=e.onload=null,o()}}var g,m,y,w,x={numLoaded:0,numFailed:0,numTotal:0,cleanupDone:!1},b=d.Util,v=0,C=r.elements[0]||e.body,k=C.ownerDocument,T=C.getElementsByTagName("img"),S=T.length,E=k.createElement("a"),R=function(t){return t.crossOrigin!==n}(new Image);for(E.href=t.location.href,g=E.protocol+E.host,m={loadImage:function(t){var e,o;t&&x[t]===n&&(e=new Image,t.match(/data:image\/.*;base64,/i)?(e.src=t.replace(/url\(['"]{0,}|['"]{0,}\)$/gi,""),o=x[t]={img:e},x.numTotal++,p(e,o)):a(t)||r.allowTaint===!0?(o=x[t]={img:e},x.numTotal++,p(e,o),e.src=t):R&&!r.allowTaint&&r.useCORS?(e.crossOrigin="anonymous",o=x[t]={img:e},x.numTotal++,p(e,o),e.src=t):r.proxy&&(o=x[t]={img:e},x.numTotal++,i(t,e,o)))},cleanupDOM:function(a){var i,l;
if(!x.cleanupDone){a&&"string"==typeof a?b.log("html2canvas: Cleanup because: "+a):b.log("html2canvas: Cleanup after timeout: "+r.timeout+" ms.");for(l in x)if(x.hasOwnProperty(l)&&(i=x[l],"object"==typeof i&&i.callbackname&&i.succeeded===n)){t[i.callbackname]=n;try{delete t[i.callbackname]}catch(s){}i.script&&i.script.parentNode&&(i.script.setAttribute("src","about:blank"),i.script.parentNode.removeChild(i.script)),x.numLoaded++,x.numFailed++,b.log("html2canvas: Cleaned up failed img: '"+l+"' Steps: "+x.numLoaded+" / "+x.numTotal)}t.stop!==n?t.stop():e.execCommand!==n&&e.execCommand("Stop",!1),e.close!==n&&e.close(),x.cleanupDone=!0,a&&"string"==typeof a||o()}},renderingDone:function(){w&&t.clearTimeout(w)}},r.timeout>0&&(w=t.setTimeout(m.cleanupDOM,r.timeout)),b.log("html2canvas: Preload starts: finding background-images"),x.firstRun=!0,f(C),b.log("html2canvas: Preload: Finding images"),y=0;S>y;y+=1)m.loadImage(T[y].getAttribute("src"));return x.firstRun=!1,b.log("html2canvas: Preload: Done."),x.numTotal===x.numLoaded&&o(),m},d.Renderer=function(t,r){function a(t,e){return"children"===t?-1:"children"===e?1:t-e}function o(t){function e(t){Object.keys(t).sort(a).forEach(function(n){var r=[],a=[],i=[],l=[];t[n].forEach(function(t){t.node.zIndex.isPositioned||1>t.node.zIndex.opacity?i.push(t):t.node.zIndex.isFloated?a.push(t):r.push(t)}),function s(t){t.forEach(function(t){l.push(t),t.children&&s(t.children)})}(r.concat(a,i)),l.forEach(function(t){t.context?e(t.context):o.push(t.node)})})}var r,o=[];return r=function(t){function e(t,r,a){var o="auto"===r.zIndex.zindex?0:Number(r.zIndex.zindex),i=t,l=r.zIndex.isPositioned,s=r.zIndex.isFloated,c={node:r},d=a;r.zIndex.ownStacking?(i=c.context={children:[{node:r,children:[]}]},d=n):(l||s)&&(d=c.children=[]),0===o&&a?a.push(c):(t[o]||(t[o]=[]),t[o].push(c)),r.zIndex.children.forEach(function(t){e(i,t,d)})}var r={};return e(r,t),r}(t),e(r),o}function i(t){var e;if("string"==typeof r.renderer&&d.Renderer[t]!==n)e=d.Renderer[t](r);else{if("function"!=typeof t)throw Error("Unknown renderer");e=t(r)}if("function"!=typeof e)throw Error("Invalid renderer defined");return e}return i(r.renderer)(t,r,e,o(t.stack),d)},d.Util.Support=function(t,e){function r(){var t=new Image,r=e.createElement("canvas"),a=r.getContext===n?!1:r.getContext("2d");if(a===!1)return!1;r.width=r.height=10,t.src=["data:image/svg+xml,","<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>","<foreignObject width='10' height='10'>","<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>","sup","</div>","</foreignObject>","</svg>"].join("");try{a.drawImage(t,0,0),r.toDataURL()}catch(o){return!1}return d.Util.log("html2canvas: Parse: SVG powered rendering available"),!0}function a(){var t,n,r,a,o=!1;return e.createRange&&(t=e.createRange(),t.getBoundingClientRect&&(n=e.createElement("boundtest"),n.style.height="123px",n.style.display="block",e.body.appendChild(n),t.selectNode(n),r=t.getBoundingClientRect(),a=r.height,123===a&&(o=!0),e.body.removeChild(n))),o}return{rangeBounds:a(),svgRendering:t.svgRendering&&r()}},t.html2canvas=function(e,n){e=e.length?e:[e];var r,a={logging:!1,elements:e,background:"#fff",proxy:null,timeout:0,useCORS:!1,allowTaint:!1,svgRendering:!1,ignoreElements:"IFRAME|OBJECT|PARAM",useOverflow:!0,letterRendering:!1,chinese:!1,async:!1,width:null,height:null,taintTest:!0,renderer:"Canvas"};return a=d.Util.Extend(n,a),d.logging=a.logging,a.complete=function(t){("function"!=typeof a.onpreloaded||a.onpreloaded(t)!==!1)&&d.Parse(t,a,function(t){("function"!=typeof a.onparsed||a.onparsed(t)!==!1)&&(r=d.Renderer(t,a),"function"==typeof a.onrendered&&a.onrendered(r))})},t.setTimeout(function(){d.Preload(a)},0),{render:function(t,e){return d.Renderer(t,d.Util.Extend(e,a))},parse:function(t,e){return d.Parse(t,d.Util.Extend(e,a))},preload:function(t){return d.Preload(d.Util.Extend(t,a))},log:d.Util.log}},t.html2canvas.log=d.Util.log,t.html2canvas.Renderer={Canvas:n},d.Renderer.Canvas=function(t){function r(t,e){t.beginPath(),e.forEach(function(e){t[e.name].apply(t,e.arguments)}),t.closePath()}function a(t){if(-1===l.indexOf(t.arguments[0].src)){c.drawImage(t.arguments[0],0,0);try{c.getImageData(0,0,1,1)}catch(e){return s=i.createElement("canvas"),c=s.getContext("2d"),!1}l.push(t.arguments[0].src)}return!0}function o(e,n){switch(n.type){case"variable":e[n.name]=n.arguments;break;case"function":switch(n.name){case"createPattern":if(n.arguments[0].width>0&&n.arguments[0].height>0)try{e.fillStyle=e.createPattern(n.arguments[0],"repeat")}catch(o){h.log("html2canvas: Renderer: Error creating pattern",o.message)}break;case"drawShape":r(e,n.arguments);break;case"drawImage":n.arguments[8]>0&&n.arguments[7]>0&&(!t.taintTest||t.taintTest&&a(n))&&e.drawImage.apply(e,n.arguments);break;default:e[n.name].apply(e,n.arguments)}}}t=t||{};var i=e,l=[],s=e.createElement("canvas"),c=s.getContext("2d"),h=d.Util,u=t.canvas||i.createElement("canvas");return function(t,e,r,a,i){var l,s,c,d=u.getContext("2d"),f=t.stack;return u.width=u.style.width=e.width||f.ctx.width,u.height=u.style.height=e.height||f.ctx.height,c=d.fillStyle,d.fillStyle=h.isTransparent(t.backgroundColor)&&e.background!==n?e.background:t.backgroundColor,d.fillRect(0,0,u.width,u.height),d.fillStyle=c,a.forEach(function(t){d.textBaseline="bottom",d.save(),t.transform.matrix&&(d.translate(t.transform.origin[0],t.transform.origin[1]),d.transform.apply(d,t.transform.matrix),d.translate(-t.transform.origin[0],-t.transform.origin[1])),t.clip&&(d.beginPath(),d.rect(t.clip.left,t.clip.top,t.clip.width,t.clip.height),d.clip()),t.ctx.storage&&t.ctx.storage.forEach(function(t){o(d,t)}),d.restore()}),h.log("html2canvas: Renderer: Canvas renderer done - returning canvas obj"),1===e.elements.length&&"object"==typeof e.elements[0]&&"BODY"!==e.elements[0].nodeName?(s=i.Util.Bounds(e.elements[0]),l=r.createElement("canvas"),l.width=Math.ceil(s.width),l.height=Math.ceil(s.height),d=l.getContext("2d"),d.drawImage(u,s.left,s.top,s.width,s.height,0,0,s.width,s.height),u=null,l):u}}})(window,document);
console.log('ending parsing html2canvas.js');

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: vendor/velocity/velocity.min.js

try{
/*! VelocityJS.org (1.2.1). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
console.log('starting parsing velocity.js');
!function(e){function t(e){var t=e.length,r=$.type(e);return"function"===r||$.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===r||0===t||"number"==typeof t&&t>0&&t-1 in e}if(!e.jQuery){var $=function(e,t){return new $.fn.init(e,t)};$.isWindow=function(e){return null!=e&&e==e.window},$.type=function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?a[o.call(e)]||"object":typeof e},$.isArray=Array.isArray||function(e){return"array"===$.type(e)},$.isPlainObject=function(e){var t;if(!e||"object"!==$.type(e)||e.nodeType||$.isWindow(e))return!1;try{if(e.constructor&&!n.call(e,"constructor")&&!n.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}for(t in e);return void 0===t||n.call(e,t)},$.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i>o&&(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i>o&&(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},$.data=function(e,t,a){if(void 0===a){var n=e[$.expando],o=n&&r[n];if(void 0===t)return o;if(o&&t in o)return o[t]}else if(void 0!==t){var n=e[$.expando]||(e[$.expando]=++$.uuid);return r[n]=r[n]||{},r[n][t]=a,a}},$.removeData=function(e,t){var a=e[$.expando],n=a&&r[a];n&&$.each(t,function(e,t){delete n[t]})},$.extend=function(){var e,t,r,a,n,o,i=arguments[0]||{},s=1,l=arguments.length,u=!1;for("boolean"==typeof i&&(u=i,i=arguments[s]||{},s++),"object"!=typeof i&&"function"!==$.type(i)&&(i={}),s===l&&(i=this,s--);l>s;s++)if(null!=(n=arguments[s]))for(a in n)e=i[a],r=n[a],i!==r&&(u&&r&&($.isPlainObject(r)||(t=$.isArray(r)))?(t?(t=!1,o=e&&$.isArray(e)?e:[]):o=e&&$.isPlainObject(e)?e:{},i[a]=$.extend(u,o,r)):void 0!==r&&(i[a]=r));return i},$.queue=function(e,r,a){function n(e,r){var a=r||[];return null!=e&&(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r>a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,"string"==typeof e?[e]:e):[].push.call(a,e)),a}if(e){r=(r||"fx")+"queue";var o=$.data(e,r);return a?(!o||$.isArray(a)?o=$.data(e,r,n(a)):o.push(a),o):o||[]}},$.dequeue=function(e,t){$.each(e.nodeType?[e]:e,function(e,r){t=t||"fx";var a=$.queue(r,t),n=a.shift();"inprogress"===n&&(n=a.shift()),n&&("fx"===t&&a.unshift("inprogress"),n.call(r,function(){$.dequeue(r,t)}))})},$.fn=$.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error("Not a DOM node.")},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&&"html"===!e.nodeType.toLowerCase&&"static"===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),r=this.offset(),a=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:$(e).offset();return r.top-=parseFloat(t.style.marginTop)||0,r.left-=parseFloat(t.style.marginLeft)||0,e.style&&(a.top+=parseFloat(e.style.borderTopWidth)||0,a.left+=parseFloat(e.style.borderLeftWidth)||0),{top:r.top-a.top,left:r.left-a.left}}};var r={};$.expando="velocity"+(new Date).getTime(),$.uuid=0;for(var a={},n=a.hasOwnProperty,o=a.toString,i="Boolean Number String Function Array Date RegExp Object Error".split(" "),s=0;s<i.length;s++)a["[object "+i[s]+"]"]=i[s].toLowerCase();$.fn.init.prototype=$.fn,e.Velocity={Utilities:$}}}(window),function(e){"object"==typeof module&&"object"==typeof module.exports?module.exports=e():"function"==typeof define&&define.amd?define(e):e()}(function(){return function(e,t,r,a){function n(e){for(var t=-1,r=e?e.length:0,a=[];++t<r;){var n=e[t];n&&a.push(n)}return a}function o(e){return g.isWrapped(e)?e=[].slice.call(e):g.isNode(e)&&(e=[e]),e}function i(e){var t=$.data(e,"velocity");return null===t?a:t}function s(e){return function(t){return Math.round(t*e)*(1/e)}}function l(e,r,a,n){function o(e,t){return 1-3*t+3*e}function i(e,t){return 3*t-6*e}function s(e){return 3*e}function l(e,t,r){return((o(t,r)*e+i(t,r))*e+s(t))*e}function u(e,t,r){return 3*o(t,r)*e*e+2*i(t,r)*e+s(t)}function c(t,r){for(var n=0;m>n;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b>t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o>0?n=i:r=i;while(Math.abs(o)>h&&++s<v);return i}function d(t){for(var r=0,n=1,o=b-1;n!=o&&w[n]<=t;++n)r+=x;--n;var i=(t-w[n])/(w[n+1]-w[n]),s=r+i*x,l=u(s,e,a);return l>=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&&p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S="Float32Array"in t;if(4!==arguments.length)return!1;for(var P=0;4>P;++P)if("number"!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&&a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T="generateBezier("+[e,r,a,n]+")";return C.toString=function(){return T},C}function u(e,t){var r=e;return g.isString(e)?v.Easings[e]||(r=!1):r=g.isArray(e)&&1===e.length?s.apply(null,e):g.isArray(e)&&2===e.length?b.apply(null,e.concat([t])):g.isArray(e)&&4===e.length?l.apply(null,e):!1,r===!1&&(r=v.Easings[v.defaults.easing]?v.defaults.easing:h),r}function c(e){if(e){var t=(new Date).getTime(),r=v.State.calls.length;r>1e4&&(v.State.calls=n(v.State.calls));for(var o=0;r>o;o++)if(v.State.calls[o]){var s=v.State.calls[o],l=s[0],u=s[2],f=s[3],d=!!f,m=null;f||(f=v.State.calls[o][3]=t-16);for(var y=Math.min((t-f)/u.duration,1),h=0,b=l.length;b>h;h++){var S=l[h],w=S.element;if(i(w)){var V=!1;if(u.display!==a&&null!==u.display&&"none"!==u.display){if("flex"===u.display){var C=["-webkit-box","-moz-box","-ms-flexbox","-webkit-flex"];$.each(C,function(e,t){x.setPropertyValue(w,"display",t)})}x.setPropertyValue(w,"display",u.display)}u.visibility!==a&&"hidden"!==u.visibility&&x.setPropertyValue(w,"visibility",u.visibility);for(var T in S)if("element"!==T){var k=S[T],A,F=g.isString(k.easing)?v.Easings[k.easing]:k.easing;if(1===y)A=k.endValue;else{var E=k.endValue-k.startValue;if(A=k.startValue+E*F(y,u,E),!d&&A===k.currentValue)continue}if(k.currentValue=A,"tween"===T)m=A;else{if(x.Hooks.registered[T]){var j=x.Hooks.getRoot(T),H=i(w).rootPropertyValueCache[j];H&&(k.rootPropertyValue=H)}var N=x.setPropertyValue(w,T,k.currentValue+(0===parseFloat(A)?"":k.unitType),k.rootPropertyValue,k.scrollData);x.Hooks.registered[T]&&(i(w).rootPropertyValueCache[j]=x.Normalizations.registered[j]?x.Normalizations.registered[j]("extract",null,N[1]):N[1]),"transform"===N[0]&&(V=!0)}}u.mobileHA&&i(w).transformCache.translate3d===a&&(i(w).transformCache.translate3d="(0px, 0px, 0px)",V=!0),V&&x.flushTransformCache(w)}}u.display!==a&&"none"!==u.display&&(v.State.calls[o][2].display=!1),u.visibility!==a&&"hidden"!==u.visibility&&(v.State.calls[o][2].visibility=!1),u.progress&&u.progress.call(s[1],s[1],y,Math.max(0,f+u.duration-t),f,m),1===y&&p(o)}}v.State.isTicking&&P(c)}function p(e,t){if(!v.State.calls[e])return!1;for(var r=v.State.calls[e][0],n=v.State.calls[e][1],o=v.State.calls[e][2],s=v.State.calls[e][4],l=!1,u=0,c=r.length;c>u;u++){var p=r[u].element;if(t||o.loop||("none"===o.display&&x.setPropertyValue(p,"display",o.display),"hidden"===o.visibility&&x.setPropertyValue(p,"visibility",o.visibility)),o.loop!==!0&&($.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test($.queue(p)[1]))&&i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var f=!1;$.each(x.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&&new RegExp("^\\("+r+"[^.]").test(n)&&(f=!0,delete i(p).transformCache[t])}),o.mobileHA&&(f=!0,delete i(p).transformCache.translate3d),f&&x.flushTransformCache(p),x.Values.removeClass(p,"velocity-animating")}if(!t&&o.complete&&!o.loop&&u===c-1)try{o.complete.call(n,n)}catch(d){setTimeout(function(){throw d},1)}s&&o.loop!==!0&&s(n),o.loop!==!0||t||($.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&&360===parseFloat(t.endValue)&&(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&&100===parseFloat(t.endValue)&&"%"===t.unitType&&(t.endValue=0,t.startValue=100)}),v(p,"reverse",{loop:!0,delay:o.delay})),o.queue!==!1&&$.dequeue(p,o.queue)}v.State.calls[e]=!1;for(var g=0,m=v.State.calls.length;m>g;g++)if(v.State.calls[g]!==!1){l=!0;break}l===!1&&(v.State.isTicking=!1,delete v.State.calls,v.State.calls=[])}var f=function(){if(r.documentMode)return r.documentMode;for(var e=7;e>4;e--){var t=r.createElement("div");if(t.innerHTML="<!--[if IE "+e+"]><span></span><![endif]-->",t.getElementsByTagName("span").length)return t=null,e}return a}(),d=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r=(new Date).getTime(),a;return a=Math.max(0,16-(r-e)),e=r+a,setTimeout(function(){t(r+a)},a)}}(),g={isString:function(e){return"string"==typeof e},isArray:Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isNode:function(e){return e&&e.nodeType},isNodeList:function(e){return"object"==typeof e&&/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&&e.length!==a&&(0===e.length||"object"==typeof e[0]&&e[0].nodeType>0)},isWrapped:function(e){return e&&(e.jquery||t.Zepto&&t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&&e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},$,m=!1;if(e.fn&&e.fn.jquery?($=e,m=!0):$=t.Velocity.Utilities,8>=f&&!m)throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if(7>=f)return void(jQuery.fn.velocity=jQuery.fn.animate);var y=400,h="swing",v={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement("div"),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:$,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:"",duration:y,easing:h,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){$.data(e,"velocity",{isSVG:g.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:1},debug:!1};t.pageYOffset!==a?(v.State.scrollAnchor=t,v.State.scrollPropertyLeft="pageXOffset",v.State.scrollPropertyTop="pageYOffset"):(v.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,v.State.scrollPropertyLeft="scrollLeft",v.State.scrollPropertyTop="scrollTop");var b=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o={x:-1,v:0,tension:null,friction:null},i=[0],s=0,l=1e-4,u=.016,c,p,f;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,o.tension=e,o.friction=t,c=null!==n,c?(s=a(e,t),p=s/n*u):p=u;;)if(f=r(f||o,p),i.push(1+f.x),s+=16,!(Math.abs(f.x)>l&&Math.abs(f.v)>l))break;return c?function(e){return i[e*(i.length-1)|0]}:s}}();v.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},$.each([["ease",[.25,.1,.25,1]],["ease-in",[.42,0,1,1]],["ease-out",[0,0,.58,1]],["ease-in-out",[.42,0,.58,1]],["easeInSine",[.47,0,.745,.715]],["easeOutSine",[.39,.575,.565,1]],["easeInOutSine",[.445,.05,.55,.95]],["easeInQuad",[.55,.085,.68,.53]],["easeOutQuad",[.25,.46,.45,.94]],["easeInOutQuad",[.455,.03,.515,.955]],["easeInCubic",[.55,.055,.675,.19]],["easeOutCubic",[.215,.61,.355,1]],["easeInOutCubic",[.645,.045,.355,1]],["easeInQuart",[.895,.03,.685,.22]],["easeOutQuart",[.165,.84,.44,1]],["easeInOutQuart",[.77,0,.175,1]],["easeInQuint",[.755,.05,.855,.06]],["easeOutQuint",[.23,1,.32,1]],["easeInOutQuint",[.86,0,.07,1]],["easeInExpo",[.95,.05,.795,.035]],["easeOutExpo",[.19,1,.22,1]],["easeInOutExpo",[1,0,0,1]],["easeInCirc",[.6,.04,.98,.335]],["easeOutCirc",[.075,.82,.165,1]],["easeInOutCirc",[.785,.135,.15,.86]]],function(e,t){v.Easings[t[0]]=l.apply(null,t[1])});var x=v.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:["fill","stroke","stopColor","color","backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","outlineColor"],transformsBase:["translateX","translateY","scale","scaleX","scaleY","skewX","skewY","rotateZ"],transforms3D:["transformPerspective","translateZ","scaleZ","rotateX","rotateY"]},Hooks:{templates:{textShadow:["Color X Y Blur","black 0px 0px 0px"],boxShadow:["Color X Y Blur Spread","black 0px 0px 0px 0px"],clip:["Top Right Bottom Left","0px 0px 0px 0px"],backgroundPosition:["X Y","0% 0%"],transformOrigin:["X Y Z","50% 50% 0px"],perspectiveOrigin:["X Y","50% 50%"]},registered:{},register:function(){for(var e=0;e<x.Lists.colors.length;e++){var t="color"===x.Lists.colors[e]?"0 0 0 1":"255 255 255 1";x.Hooks.templates[x.Lists.colors[e]]=["Red Green Blue Alpha",t]}var r,a,n;if(f)for(r in x.Hooks.templates){a=x.Hooks.templates[r],n=a[0].split(" ");var o=a[1].match(x.RegEx.valueSplit);"Color"===n[0]&&(n.push(n.shift()),o.push(o.shift()),x.Hooks.templates[r]=[n.join(" "),o.join(" ")])}for(r in x.Hooks.templates){a=x.Hooks.templates[r],n=a[0].split(" ");for(var e in n){var i=r+n[e],s=e;x.Hooks.registered[i]=[r,s]}}},getRoot:function(e){var t=x.Hooks.registered[e];return t?t[0]:e},cleanRootPropertyValue:function(e,t){return x.RegEx.valueUnwrap.test(t)&&(t=t.match(x.RegEx.valueUnwrap)[1]),x.Values.isCSSNullValue(t)&&(t=x.Hooks.templates[e][1]),t},extractValue:function(e,t){var r=x.Hooks.registered[e];if(r){var a=r[0],n=r[1];return t=x.Hooks.cleanRootPropertyValue(a,t),t.toString().match(x.RegEx.valueSplit)[n]}return t},injectValue:function(e,t,r){var a=x.Hooks.registered[e];if(a){var n=a[0],o=a[1],i,s;return r=x.Hooks.cleanRootPropertyValue(n,r),i=r.toString().match(x.RegEx.valueSplit),i[o]=t,s=i.join(" ")}return r}},Normalizations:{registered:{clip:function(e,t,r){switch(e){case"name":return"clip";case"extract":var a;return x.RegEx.wrappedValueAlreadyExtracted.test(r)?a=r:(a=r.toString().match(x.RegEx.valueUnwrap),a=a?a[1].replace(/,(\s+)?/g," "):r),a;case"inject":return"rect("+r+")"}},blur:function(e,t,r){switch(e){case"name":return v.State.isFirefox?"filter":"-webkit-filter";case"extract":var a=parseFloat(r);if(!a&&0!==a){var n=r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a=n?n[1]:0}return a;case"inject":return parseFloat(r)?"blur("+r+")":"none"}},opacity:function(e,t,r){if(8>=f)switch(e){case"name":return"filter";case"extract":var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case"inject":return t.style.zoom=1,parseFloat(r)>=1?"":"alpha(opacity="+parseInt(100*parseFloat(r),10)+")"}else switch(e){case"name":return"opacity";case"extract":return r;case"inject":return r}}},register:function(){9>=f||v.State.isGingerbread||(x.Lists.transformsBase=x.Lists.transformsBase.concat(x.Lists.transforms3D));for(var e=0;e<x.Lists.transformsBase.length;e++)!function(){var t=x.Lists.transformsBase[e];x.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return"transform";case"extract":return i(r)===a||i(r).transformCache[t]===a?/^scale/i.test(t)?1:0:i(r).transformCache[t].replace(/[()]/g,"");case"inject":var o=!1;switch(t.substr(0,t.length-1)){case"translate":o=!/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case"scal":case"scale":v.State.isAndroid&&i(r).transformCache[t]===a&&1>n&&(n=1),o=!/(\d)$/i.test(n);break;case"skew":o=!/(deg|\d)$/i.test(n);break;case"rotate":o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]="("+n+")"),i(r).transformCache[t]}}}();for(var e=0;e<x.Lists.colors.length;e++)!function(){var t=x.Lists.colors[e];x.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return t;case"extract":var o;if(x.RegEx.wrappedValueAlreadyExtracted.test(n))o=n;else{var i,s={black:"rgb(0, 0, 0)",blue:"rgb(0, 0, 255)",gray:"rgb(128, 128, 128)",green:"rgb(0, 128, 0)",red:"rgb(255, 0, 0)",white:"rgb(255, 255, 255)"};/^[A-z]+$/i.test(n)?i=s[n]!==a?s[n]:s.black:x.RegEx.isHex.test(n)?i="rgb("+x.Values.hexToRgb(n).join(" ")+")":/^rgba?\(/i.test(n)||(i=s.black),o=(i||n).toString().match(x.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g," ")}return 8>=f||3!==o.split(" ").length||(o+=" 1"),o;case"inject":return 8>=f?4===n.split(" ").length&&(n=n.split(/\s+/).slice(0,3).join(" ")):3===n.split(" ").length&&(n+=" 1"),(8>=f?"rgb":"rgba")+"("+n.replace(/\s+/g,",").replace(/\.(\d)+(?=,)/g,"")+")"}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t="width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return(f||v.State.isAndroid&&!v.State.isChrome)&&(t+="|transform"),new RegExp("^("+t+")$","i").test(e)},prefixCheck:function(e){if(v.State.prefixMatches[e])return[v.State.prefixMatches[e],!0];for(var t=["","Webkit","Moz","ms","O"],r=0,a=t.length;a>r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),g.isString(v.State.prefixElement.style[n]))return v.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,a;return e=e.replace(t,function(e,t,r,a){return t+t+r+r+a+a}),a=r.exec(e),a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?"deg":/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?"":"px"},getDisplayType:function(e){var t=e&&e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?"inline":/^(li)$/i.test(t)?"list-item":/^(tr)$/i.test(t)?"table-row":/^(table)$/i.test(t)?"table":/^(tbody)$/i.test(t)?"table-row-group":"block"},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?" ":"")+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp("(^|\\s)"+t.split(" ").join("|")+"(\\s|$)","gi")," ")}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&&x.setPropertyValue(e,"display","none")}var l=0;if(8>=f)l=$.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&&0===x.getPropertyValue(e,"display")&&(u=!0,x.setPropertyValue(e,"display",x.Values.getDisplayType(e))),!o){if("height"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(x.getPropertyValue(e,"borderTopWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderBottomWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingTop"))||0)-(parseFloat(x.getPropertyValue(e,"paddingBottom"))||0);return n(),c}if("width"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(x.getPropertyValue(e,"borderLeftWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderRightWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingLeft"))||0)-(parseFloat(x.getPropertyValue(e,"paddingRight"))||0);return n(),p}}var d;d=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),"borderColor"===r&&(r="borderTopColor"),l=9===f&&"filter"===r?d.getPropertyValue(r):d[r],(""===l||null===l)&&(l=e.style[r]),n()}if("auto"===l&&/^(top|right|bottom|left)$/i.test(r)){var g=s(e,"position");("fixed"===g||"absolute"===g&&/top|left/i.test(r))&&(l=$(e).position()[r]+"px")}return l}var l;if(x.Hooks.registered[r]){var u=r,c=x.Hooks.getRoot(u);n===a&&(n=x.getPropertyValue(e,x.Names.prefixCheck(c)[0])),x.Normalizations.registered[c]&&(n=x.Normalizations.registered[c]("extract",e,n)),l=x.Hooks.extractValue(u,n)}else if(x.Normalizations.registered[r]){var p,d;p=x.Normalizations.registered[r]("name",e),"transform"!==p&&(d=s(e,x.Names.prefixCheck(p)[0]),x.Values.isCSSNullValue(d)&&x.Hooks.templates[r]&&(d=x.Hooks.templates[r][1])),l=x.Normalizations.registered[r]("extract",e,d)}if(!/^[\d-]/.test(l))if(i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(g){l=0}else l=e.getAttribute(r);else l=s(e,x.Names.prefixCheck(r)[0]);return x.Values.isCSSNullValue(l)&&(l=0),v.debug>=2&&console.log("Get "+r+": "+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if("scroll"===r)o.container?o.container["scroll"+o.direction]=a:"Left"===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(x.Normalizations.registered[r]&&"transform"===x.Normalizations.registered[r]("name",e))x.Normalizations.registered[r]("inject",e,a),s="transform",a=i(e).transformCache[r];else{if(x.Hooks.registered[r]){var l=r,u=x.Hooks.getRoot(r);n=n||x.getPropertyValue(e,u),a=x.Hooks.injectValue(l,a,n),r=u}if(x.Normalizations.registered[r]&&(a=x.Normalizations.registered[r]("inject",e,a),r=x.Normalizations.registered[r]("name",e)),s=x.Names.prefixCheck(r)[0],8>=f)try{e.style[s]=a}catch(c){v.debug&&console.log("Browser does not support ["+a+"] for ["+s+"]")}else i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;v.debug>=2&&console.log("Set "+r+" ("+s+"): "+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(x.getPropertyValue(e,t))}var r="";if((f||v.State.isAndroid&&!v.State.isChrome)&&i(e).isSVG){var a={translate:[t("translateX"),t("translateY")],skewX:[t("skewX")],skewY:[t("skewY")],scale:1!==t("scale")?[t("scale"),t("scale")]:[t("scaleX"),t("scaleY")],rotate:[t("rotateZ"),0,0]};$.each(i(e).transformCache,function(e){/^translate/i.test(e)?e="translate":/^scale/i.test(e)?e="scale":/^rotate/i.test(e)&&(e="rotate"),a[e]&&(r+=e+"("+a[e].join(" ")+") ",delete a[e])})}else{var n,o;$.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],"transformPerspective"===t?(o=n,!0):(9===f&&"rotateZ"===t&&(t="rotate"),void(r+=t+n+" "))}),o&&(r="perspective"+o+" "+r)}x.setPropertyValue(e,"transform",r)}};x.Hooks.register(),x.Normalizations.register(),v.hook=function(e,t,r){var n=a;return e=o(e),$.each(e,function(e,o){if(i(o)===a&&v.init(o),r===a)n===a&&(n=v.CSS.getPropertyValue(o,t));else{var s=v.CSS.setPropertyValue(o,t,r);"transform"===s[0]&&v.CSS.flushTransformCache(o),n=s}}),n};var S=function(){function e(){return l?T.promise||null:f}function n(){function e(e){function p(e,t){var r=a,i=a,s=a;return g.isArray(e)?(r=e[0],!g.isArray(e[1])&&/^[\d-]/.test(e[1])||g.isFunction(e[1])||x.RegEx.isHex.test(e[1])?s=e[1]:(g.isString(e[1])&&!x.RegEx.isHex.test(e[1])||g.isArray(e[1]))&&(i=t?e[1]:u(e[1],o.duration),e[2]!==a&&(s=e[2]))):r=e,t||(i=i||o.easing),g.isFunction(r)&&(r=r.call(n,w,P)),g.isFunction(s)&&(s=s.call(n,w,P)),[r||0,i,s]}function f(e,t){var r,a;return a=(t||"0").toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,""}),r||(r=x.Values.getUnitType(e)),[a,r]}function d(){var e={myParent:n.parentNode||r.body,position:x.getPropertyValue(n,"position"),fontSize:x.getPropertyValue(n,"fontSize")},a=e.position===N.lastPosition&&e.myParent===N.lastParent,o=e.fontSize===N.lastFontSize;N.lastParent=e.myParent,N.lastPosition=e.position,N.lastFontSize=e.fontSize;var s=100,l={};if(o&&a)l.emToPx=N.lastEmToPx,l.percentToPxWidth=N.lastPercentToPxWidth,l.percentToPxHeight=N.lastPercentToPxHeight;else{var u=i(n).isSVG?r.createElementNS("http://www.w3.org/2000/svg","rect"):r.createElement("div");v.init(u),e.myParent.appendChild(u),$.each(["overflow","overflowX","overflowY"],function(e,t){v.CSS.setPropertyValue(u,t,"hidden")}),v.CSS.setPropertyValue(u,"position",e.position),v.CSS.setPropertyValue(u,"fontSize",e.fontSize),v.CSS.setPropertyValue(u,"boxSizing","content-box"),$.each(["minWidth","maxWidth","width","minHeight","maxHeight","height"],function(e,t){v.CSS.setPropertyValue(u,t,s+"%")}),v.CSS.setPropertyValue(u,"paddingLeft",s+"em"),l.percentToPxWidth=N.lastPercentToPxWidth=(parseFloat(x.getPropertyValue(u,"width",null,!0))||1)/s,l.percentToPxHeight=N.lastPercentToPxHeight=(parseFloat(x.getPropertyValue(u,"height",null,!0))||1)/s,l.emToPx=N.lastEmToPx=(parseFloat(x.getPropertyValue(u,"paddingLeft"))||1)/s,e.myParent.removeChild(u)}return null===N.remToPx&&(N.remToPx=parseFloat(x.getPropertyValue(r.body,"fontSize"))||16),null===N.vwToPx&&(N.vwToPx=parseFloat(t.innerWidth)/100,N.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=N.remToPx,l.vwToPx=N.vwToPx,l.vhToPx=N.vhToPx,v.debug>=1&&console.log("Unit ratios: "+JSON.stringify(l),n),l}if(o.begin&&0===w)try{o.begin.call(m,m)}catch(y){setTimeout(function(){throw y},1)}if("scroll"===k){var S=/^x$/i.test(o.axis)?"Left":"Top",V=parseFloat(o.offset)||0,C,A,F;o.container?g.isWrapped(o.container)||g.isNode(o.container)?(o.container=o.container[0]||o.container,C=o.container["scroll"+S],F=C+$(n).position()[S.toLowerCase()]+V):o.container=null:(C=v.State.scrollAnchor[v.State["scrollProperty"+S]],A=v.State.scrollAnchor[v.State["scrollProperty"+("Left"===S?"Top":"Left")]],F=$(n).offset()[S.toLowerCase()]+V),s={scroll:{rootPropertyValue:!1,startValue:C,currentValue:C,endValue:F,unitType:"",easing:o.easing,scrollData:{container:o.container,direction:S,alternateValue:A}},element:n},v.debug&&console.log("tweensContainer (scroll): ",s.scroll,n)}else if("reverse"===k){if(!i(n).tweensContainer)return void $.dequeue(n,o.queue);"none"===i(n).opts.display&&(i(n).opts.display="auto"),"hidden"===i(n).opts.visibility&&(i(n).opts.visibility="visible"),i(n).opts.loop=!1,i(n).opts.begin=null,i(n).opts.complete=null,b.easing||delete o.easing,b.duration||delete o.duration,o=$.extend({},i(n).opts,o);var E=$.extend(!0,{},i(n).tweensContainer);for(var j in E)if("element"!==j){var H=E[j].startValue;E[j].startValue=E[j].currentValue=E[j].endValue,E[j].endValue=H,g.isEmptyObject(b)||(E[j].easing=o.easing),v.debug&&console.log("reverse tweensContainer ("+j+"): "+JSON.stringify(E[j]),n)}s=E}else if("start"===k){var E;i(n).tweensContainer&&i(n).isAnimating===!0&&(E=i(n).tweensContainer),$.each(h,function(e,t){if(RegExp("^"+x.Lists.colors.join("$|^")+"$").test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(x.RegEx.isHex.test(n)){for(var s=["Red","Green","Blue"],l=x.Values.hexToRgb(n),u=i?x.Values.hexToRgb(i):a,c=0;c<s.length;c++){var f=[l[c]];o&&f.push(o),u!==a&&f.push(u[c]),h[e+s[c]]=f}delete h[e]}}});for(var R in h){var O=p(h[R]),z=O[0],q=O[1],M=O[2];R=x.Names.camelCase(R);var I=x.Hooks.getRoot(R),B=!1;if(i(n).isSVG||"tween"===I||x.Names.prefixCheck(I)[1]!==!1||x.Normalizations.registered[I]!==a){(o.display!==a&&null!==o.display&&"none"!==o.display||o.visibility!==a&&"hidden"!==o.visibility)&&/opacity|filter/.test(R)&&!M&&0!==z&&(M=0),o._cacheValues&&E&&E[R]?(M===a&&(M=E[R].endValue+E[R].unitType),B=i(n).rootPropertyValueCache[I]):x.Hooks.registered[R]?M===a?(B=x.getPropertyValue(n,I),M=x.getPropertyValue(n,R,B)):B=x.Hooks.templates[I][1]:M===a&&(M=x.getPropertyValue(n,R));var W,G,D,X=!1;if(W=f(R,M),M=W[0],D=W[1],W=f(R,z),z=W[0].replace(/^([+-\/*])=/,function(e,t){return X=t,""}),G=W[1],M=parseFloat(M)||0,z=parseFloat(z)||0,"%"===G&&(/^(fontSize|lineHeight)$/.test(R)?(z/=100,G="em"):/^scale/.test(R)?(z/=100,G=""):/(Red|Green|Blue)$/i.test(R)&&(z=z/100*255,G="")),/[\/*]/.test(X))G=D;else if(D!==G&&0!==M)if(0===z)G=D;else{l=l||d();var Y=/margin|padding|left|right|width|text|word|letter/i.test(R)||/X$/.test(R)||"x"===R?"x":"y";switch(D){case"%":M*="x"===Y?l.percentToPxWidth:l.percentToPxHeight;break;case"px":break;default:M*=l[D+"ToPx"]}switch(G){case"%":M*=1/("x"===Y?l.percentToPxWidth:l.percentToPxHeight);break;case"px":break;default:M*=1/l[G+"ToPx"]}}switch(X){case"+":z=M+z;break;case"-":z=M-z;break;case"*":z=M*z;break;case"/":z=M/z}s[R]={rootPropertyValue:B,startValue:M,currentValue:M,endValue:z,unitType:G,easing:q},v.debug&&console.log("tweensContainer ("+R+"): "+JSON.stringify(s[R]),n)}else v.debug&&console.log("Skipping ["+I+"] due to a lack of browser support.")}s.element=n}s.element&&(x.Values.addClass(n,"velocity-animating"),L.push(s),""===o.queue&&(i(n).tweensContainer=s,i(n).opts=o),i(n).isAnimating=!0,w===P-1?(v.State.calls.push([L,m,o,null,T.resolver]),v.State.isTicking===!1&&(v.State.isTicking=!0,c())):w++)}var n=this,o=$.extend({},v.defaults,b),s={},l;switch(i(n)===a&&v.init(n),parseFloat(o.delay)&&o.queue!==!1&&$.queue(n,o.queue,function(e){v.velocityQueueEntryFlag=!0,i(n).delayTimer={setTimeout:setTimeout(e,parseFloat(o.delay)),next:e}}),o.duration.toString().toLowerCase()){case"fast":o.duration=200;break;case"normal":o.duration=y;break;case"slow":o.duration=600;break;default:o.duration=parseFloat(o.duration)||1}v.mock!==!1&&(v.mock===!0?o.duration=o.delay=1:(o.duration*=parseFloat(v.mock)||1,o.delay*=parseFloat(v.mock)||1)),o.easing=u(o.easing,o.duration),o.begin&&!g.isFunction(o.begin)&&(o.begin=null),o.progress&&!g.isFunction(o.progress)&&(o.progress=null),o.complete&&!g.isFunction(o.complete)&&(o.complete=null),o.display!==a&&null!==o.display&&(o.display=o.display.toString().toLowerCase(),"auto"===o.display&&(o.display=v.CSS.Values.getDisplayType(n))),o.visibility!==a&&null!==o.visibility&&(o.visibility=o.visibility.toString().toLowerCase()),o.mobileHA=o.mobileHA&&v.State.isMobile&&!v.State.isGingerbread,o.queue===!1?o.delay?setTimeout(e,o.delay):e():$.queue(n,o.queue,function(t,r){return r===!0?(T.promise&&T.resolver(m),!0):(v.velocityQueueEntryFlag=!0,void e(t))}),""!==o.queue&&"fx"!==o.queue||"inprogress"===$.queue(n)[0]||$.dequeue(n)}var s=arguments[0]&&(arguments[0].p||$.isPlainObject(arguments[0].properties)&&!arguments[0].properties.names||g.isString(arguments[0].properties)),l,f,d,m,h,b;if(g.isWrapped(this)?(l=!1,d=0,m=this,f=this):(l=!0,d=1,m=s?arguments[0].elements||arguments[0].e:arguments[0]),m=o(m)){s?(h=arguments[0].properties||arguments[0].p,b=arguments[0].options||arguments[0].o):(h=arguments[d],b=arguments[d+1]);var P=m.length,w=0;if(!/^(stop|finish)$/i.test(h)&&!$.isPlainObject(b)){var V=d+1;b={};for(var C=V;C<arguments.length;C++)g.isArray(arguments[C])||!/^(fast|normal|slow)$/i.test(arguments[C])&&!/^\d/.test(arguments[C])?g.isString(arguments[C])||g.isArray(arguments[C])?b.easing=arguments[C]:g.isFunction(arguments[C])&&(b.complete=arguments[C]):b.duration=arguments[C]}var T={promise:null,resolver:null,rejecter:null};l&&v.Promise&&(T.promise=new v.Promise(function(e,t){T.resolver=e,T.rejecter=t}));var k;switch(h){case"scroll":k="scroll";break;case"reverse":k="reverse";break;case"finish":case"stop":$.each(m,function(e,t){i(t)&&i(t).delayTimer&&(clearTimeout(i(t).delayTimer.setTimeout),i(t).delayTimer.next&&i(t).delayTimer.next(),delete i(t).delayTimer)});var A=[];return $.each(v.State.calls,function(e,t){t&&$.each(t[1],function(r,n){var o=b===a?"":b;return o===!0||t[2].queue===o||b===a&&t[2].queue===!1?void $.each(m,function(r,a){a===n&&((b===!0||g.isString(b))&&($.each($.queue(a,g.isString(b)?b:""),function(e,t){g.isFunction(t)&&t(null,!0)}),$.queue(a,g.isString(b)?b:"",[])),"stop"===h?(i(a)&&i(a).tweensContainer&&o!==!1&&$.each(i(a).tweensContainer,function(e,t){t.endValue=t.currentValue
}),A.push(e)):"finish"===h&&(t[2].duration=1))}):!0})}),"stop"===h&&($.each(A,function(e,t){p(t,!0)}),T.promise&&T.resolver(m)),e();default:if(!$.isPlainObject(h)||g.isEmptyObject(h)){if(g.isString(h)&&v.Redirects[h]){var F=$.extend({},b),E=F.duration,j=F.delay||0;return F.backwards===!0&&(m=$.extend(!0,[],m).reverse()),$.each(m,function(e,t){parseFloat(F.stagger)?F.delay=j+parseFloat(F.stagger)*e:g.isFunction(F.stagger)&&(F.delay=j+F.stagger.call(t,e,P)),F.drag&&(F.duration=parseFloat(E)||(/^(callout|transition)/.test(h)?1e3:y),F.duration=Math.max(F.duration*(F.backwards?1-e/P:(e+1)/P),.75*F.duration,200)),v.Redirects[h].call(t,t,F||{},e,P,m,T.promise?T:a)}),e()}var H="Velocity: First argument ("+h+") was not a property map, a known action, or a registered redirect. Aborting.";return T.promise?T.rejecter(new Error(H)):console.log(H),e()}k="start"}var N={lastParent:null,lastPosition:null,lastFontSize:null,lastPercentToPxWidth:null,lastPercentToPxHeight:null,lastEmToPx:null,remToPx:null,vwToPx:null,vhToPx:null},L=[];$.each(m,function(e,t){g.isNode(t)&&n.call(t)});var F=$.extend({},v.defaults,b),R;if(F.loop=parseInt(F.loop),R=2*F.loop-1,F.loop)for(var O=0;R>O;O++){var z={delay:F.delay,progress:F.progress};O===R-1&&(z.display=F.display,z.visibility=F.visibility,z.complete=F.complete),S(m,"reverse",z)}return e()}};v=$.extend(S,v),v.animate=S;var P=t.requestAnimationFrame||d;return v.State.isMobile||r.hidden===a||r.addEventListener("visibilitychange",function(){r.hidden?(P=function(e){return setTimeout(function(){e(!0)},16)},c()):P=t.requestAnimationFrame||d}),e.Velocity=v,e!==t&&(e.fn.velocity=S,e.fn.velocity.defaults=v.defaults),$.each(["Down","Up"],function(e,t){v.Redirects["slide"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u=l.begin,c=l.complete,p={height:"",marginTop:"",marginBottom:"",paddingTop:"",paddingBottom:""},f={};l.display===a&&(l.display="Down"===t?"inline"===v.CSS.Values.getDisplayType(e)?"inline-block":"block":"none"),l.begin=function(){u&&u.call(i,i);for(var r in p){f[r]=e.style[r];var a=v.CSS.getPropertyValue(e,r);p[r]="Down"===t?[a,0]:[0,a]}f.overflow=e.style.overflow,e.style.overflow="hidden"},l.complete=function(){for(var t in f)e.style[t]=f[t];c&&c.call(i,i),s&&s.resolver(i)},v(e,p,l)}}),$.each(["In","Out"],function(e,t){v.Redirects["fade"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u={opacity:"In"===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&&c.call(i,i),s&&s.resolver(i)},l.display===a&&(l.display="In"===t?"auto":"none"),v(this,u,l)}}),v}(window.jQuery||window.Zepto||window,window,document)});
console.log('ending parsing velocity.js');
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: cached-templates/output/compiled-cached-templates.js

this["Handlebars"] = this["Handlebars"] || {};
this["Handlebars"]["templates"] = this["Handlebars"]["templates"] || {};

this["Handlebars"]["templates"]["errorPage"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <div class=\"button-wrap\">\n            <button>"
    + escapeExpression(((helper = (helper = helpers.buttonText || (depth0 != null ? depth0.buttonText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"buttonText","hash":{},"data":data}) : helper)))
    + "</button>\n            </div>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\""
    + escapeExpression(((helper = (helper = helpers.pageId || (depth0 != null ? depth0.pageId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"pageId","hash":{},"data":data}) : helper)))
    + "\" data-url=\""
    + escapeExpression(((helper = (helper = helpers.pageId || (depth0 != null ? depth0.pageId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"pageId","hash":{},"data":data}) : helper)))
    + "\" class='error-page-inner'>\n    ";
  stack1 = ((helper = (helper = helpers.addErrorCogs || (depth0 != null ? depth0.addErrorCogs : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"addErrorCogs","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n    <div data-role=\"content\" id=\"errorPageContent\">\n        <h1>";
  stack1 = ((helper = (helper = helpers.header1 || (depth0 != null ? depth0.header1 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"header1","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</h1>\n\n        <h2>";
  stack1 = ((helper = (helper = helpers.header2 || (depth0 != null ? depth0.header2 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"header2","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</h2>\n\n        <p>";
  stack1 = ((helper = (helper = helpers.p1 || (depth0 != null ? depth0.p1 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"p1","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</p>\n\n        <p>";
  stack1 = ((helper = (helper = helpers.p2 || (depth0 != null ? depth0.p2 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"p2","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</p>\n\n        <p>";
  stack1 = ((helper = (helper = helpers.p3 || (depth0 != null ? depth0.p3 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"p3","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</p>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.buttonText : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n    </div>\n\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["splash"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\"splash\" class=\"active\">\n\n    <img id=\"splash-capriza-custom\"  alt=\"logo\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAOYCAYAAABVYOQgAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH3AwfCxMa9HqLNQAAIABJREFUeNrsvXl8VNXd+P+5+507M1lISAKBJJNlEkhIQlgEWURFUBSXatqs7MRay9PX0+exT/u19qH9ttrt+bb92n6rPC4hhICmv29VUFEUkEW2YBCyzWQlC4QkZJuZuy/fPxr6o1bCTDZmwnm/XvPSl96Ze+47n3vuOeee8zkACAQCgUAgEAgEAoFAIBAIhI9g4/XD2dnZBMuydsMwsjAMm0WSZDBN06E4jodjGEYAgKEoimIYRp8kSXW6rrdgGHaxvb29+siRIyoSPQzr169PBYBv0jT9hCzLyRzHyTabTU1ISLCyLEuYTCYwmUyA4/jfv+PxeODq1avalStXxObmZmNwcJCmafoLURTfFEXxL+Xl5b1INACsWLGCjI6OzjGbzT8iCCJ24cKFxLx581ibzQYWi8Xn3xscHISamho4duyYq66ujqYo6i8ej2d7aWlpwx0rurCwMJthmN/FxcVZ1q5dGzxnzhzAsLG7SdxuN3z88cfqRx99pADAblmWnysuLu6/Y0RnZ2cHh4SEFJvN5pVbt261zJ49e1wLyfM8lJeXS8eOHeMFQXiyrKzs8KQXvWHDhjiSJI/cddddkevWrWNpmp6wwjocDvj973/Pq6q6/bXXXvtNIIkmfDm4oKAgkaKoiuzs7IhvfvObFEEQE1rY8PBwWLJkCXXy5Mkls2fPpisrK49MOtG5ubmRJpPpdGFhYdj999+P364Cm0wmWLx4MfX5558vSE5O7vjyyy+/DATR3grDzGbz2w8++GDYPffcg9/uQgcHB8MPfvADM03TfyosLJw1aUSvX7/+O5GRkVnf+MY3aH8p+PTp06GgoMDEsuze7du34wEvesOGDSEEQbz4zDPPWG7saPgDy5cvx6dNm2ZrbGzcHPCiSZL8H4sXL6aio6P9r8mEYbBu3TorTdO/KCoqogJW9LZt2xhd159+9NFHTf56AQkJCRATE8PyPP/NgBXd19f3mM1mwyIiIvz6tnzwwQetZrP5XwJWNMdxT919991Wf6//srKyQNO0OQUFBdP8tYzkcP9T07T70tLSRnUCwzDg6tWr0NLSAt3d3TA4OKjwPK9TFAVBQUF0cHAwFh8fDzExMTDSDhBJkpCamqpVVFSsAoCdASV648aNUzEMM4+02mhqaoLDhw+Lp0+fNnAc78Ew7LTL5ToHAB4cxyVd1xkcx8NpmrYRBLFUUZTpixYt0tauXctNm+Z7YGZkZFjq6uoeCzjRiqIkRUZGSgDA+vKDoihCWVmZdOLECVHTtP9lGMbrJSUlHbf6Xl5eXujJkyf/5fTp0/+2Zs0a5hvf+Abty0ig3W4HXdfvDrg62jCM+KioKJ8azoqiwEsvveT5/PPPP1RVNWHnzp0/80YyAEBZWVlfcXHxT3Vdt3/00UcXf/e73wmGYXh97qioKJBleUphYaE50B6GQVarlfTlx3bs2OG5cuXKhzNnznyypKTk2kgKVFxc3Nnf33+3w+FwvvPOO4rXgzYEAeHh4bymaSkBJRrDMDPLsl6Lbm9vh8rKSllRlMLt27froylUeXm5LMvyg/v375d7enq8/l5YWBgAwIxAi2iWYRivRb/33nseVVVfLC4uFseiYMXFxZ0Yhv3vd955x+vfCw8Pp3Ecnx5odTTmy8OoqqoKAOCvY1k4j8fz5zNnzuje1tUWi4XBMMwaaBHtNT09PSDLsrxz587GsSzc3r172zAMG7x8+bK39TSOYRg5aUW73W4gCKJ7XAqI486uri5vjwWKophJK1rTNNB1XRyPAhqG0elyubw+fmhyzuQVDQDSeBRQ07RBSZK8jmgMw/BJK1pVVQAA5XZfDIZhYBgGNtkjWvUT0fikFo1hmF+IHqtr8ueIvu1Vx9A7zcktGsdxVHUMw5g07lVVBUmSVm7ZsqVzrAuoKEqQLxGt63rRli1bcidapCiKPy0tLf3zuIrOysqCX/3qVwwARI7HRVit3vWqV6xYAfPnz+cAgJtIye+//75+6NCh0HGPaJZlgWXZ2357chwHHMdN+HnNZvMtB2P8fobPZAGJRqKRaAQSjUQj0UgBEo1EI5BoJBqJRkwIww4qHTlyRL548aKENA1PT08PM2LROI7vGhgY+HxgYACZ9CZiSbIBWUAgEAgEYhjGffpUbm5uJEEQswAgBMOwEF3XQzAMYwBAxzBsAAAGdV1voSiqpbi4uBOJ9oLt27fj9fX1izEMW81x3FJVVTMAwBwVFcVbLBawWq24xWKhaJrGdV0HQRAwl8ulXr16Ve/t7aV1XVdYlj3v8XgOKIqyp6ysrAmJvoH8/PwZJpPpXwzD2GKxWIgFCxawiYmJdFxcHERERHid0KqnpwecTidUVVXJZ8+eNQiCaHS73S/Jsvx2eXm5fMeKzsnJmRkcHPySYRjfWL58OXHvvffS06ePzRISTdPgyy+/hHfeecfd0dEhq6q6raSkpOyOE11YWLiZoqg/rFq1inr00Udpk2n8EiDU1tbC66+/7nG73V/wPP/Url27uia96OzsbDokJGSX1Wpd86//+q+WGTMmZrWZruvw7rvvKu+///6gIAhrysrKzkxa0UVFRRwAHElPT5/99NNPm0ly4tflfPnll/DHP/7RI4riI6WlpUcCRbTX6z1WrFhBhoeHH1i4cOG8oqIibqJTsV0nKioK7HY7febMmey0tLSPL1y4cDkQRHs9Hp2YmPgbm822cOPGjexYpsUcCSkpKfD0009zFEW9n5ubGz5pRBcWFt5DkmTRs88+y/lLAqsFCxZgy5cvD7ZYLK9MCtFDeaCLt27dyo0ke+54kpOTw1AU9WBhYeE9AS/aZDJtnDFjRnhWVpbfFZ5hGCgsLDSzLPv7gBfNMMwLOTk5Fn+9gIULFwLLsol5eXnLA1Z0QUHBsqCgoFC73e6/F4Dj8Mgjj5gtFsv3AlY0y7K5K1asMPv7bbl48WJMUZSH/DX7DMAt3oJjGLYmNTV11M2M65nCrl27BqIogqZpQJIkWCwWCAoKgsjIyFFlUrdarWCz2eT6+vr7AGBfQInOz88PUhRlWmxs7Ih+WJZlqKiogMOHD3saGxspkiQ9FEW1AIAb/rZunNY0LUxV1QgAsNpsNmnlypXBCxYsgJE0IefOnWu9dOnSwwEnGsOwxNDQUBHHcZ8z7FZUVMBrr70mAEAtz/O/Jwji4H//93/fdFB/48aNU+vq6pa0tbX9oLS0dM6zzz5rSUnxLTXS7Nmz8f379z8AgUZhYWH2r3/96wHDR8rKysQtW7ZczsvLu3ck5123bt3SzZs393700UeyL+eVJMlYv3697K/JYIdL9TMlJCTEp1Gjjz76SDl06FD7wMBA2kg3PCgpKTkuCMLct956y+VLsnOapiE4OFgUBCE50FodZpPJ5LVol8sF5eXliiAIK0a7SU1ZWdklWZbX/p//838EUfQ+30pYWJgGADEBJRrDMM6XLGEffPCBBAC7du/e3T4WBSstLf0cAD48ePCg12vMp06dShqGEVhZwnRdxwmC8LrNdfr0aUmW5dfGsnA8z//i008/Fbw9PiQkhAWA0IDsgntbbfT399OiKFaOZeFKS0srBwcH4do175JCEgRBTuosYb29vUBRVHt5ebk2xuUzWJat8TYdG4ZhQFEUPWlFq6oKhmGMyzxqXdevDA4Oei0ax3Fq0ooez3Rsuq73CoJ31fRQj3JyJ6/CMGxcUv0YhqH7kt74TsgS5hfp2GCy51Qar4j26WLuhASD/pCObSinEsp7N0FVh1/mJiXHSrQsy3M2b95cPNYFVFX1bl9E67q+ajzKcStEUXxr9+7dH46raJvNBoWFhTMBYP14XIS37yzT09OB47jZADB7IiVXVFToFy5ccALA+IqOioqCqKio2357zpw5E2bOnDnh5+3u7jYuXLgw/nU0YoIehggkGolGohFINBKNQKKRaCQagUQj0YhbMeygktPphP379yNLt6ChoQEbjegT1dXVv66urkYmvUDX9ZPIAgKBQCDuWPLz82fk5eUljbh5h/h6NmzYEKKq6gqaph8iCGKNIAjRGIb9GABeRKJHQXZ2djDLsqsoilqD4/hDhmGEzJkzR507d645NTUVjhw5ou3btw9QRPsuljaZTMsxDFvNsuxjkiTFxcXFCVlZWZa0tDQ8NjYWcBz3abdmJPpvYHl5eVkkST5gMpmekCQpY+rUqdLcuXNN6enpVFJSEtA0Pap513es6Ly8vFiCIFazLPuYpmnLOI7D09PTiYyMDHbWrFlgtVrHdH9x8g4SG0oQxEqGYR4BgNUEQVgzMzPVrKysoKSkJAgNHd81RpNW9IYNG1hd15dSFLWGpunHZFmOTk5O5ufPnx+SmpqKRURETGh5Jo3o7du3406ncy5N06s5jntSFMXUuLg46foDLCYmBgiCYG5X+cgArw7iSZJ8wGKxPNXa2ro4Ojpamzt3Lpuenk4nJCQAy7KMv5Q1oETn5ORMpyjqEZZlH9V1fSlN01RmZiaWmZlpSk5OhuDgYL8tu1+Lzs/PD8JxfDVN0w9jGPagruuhqampyvWOwkTXs5NGdFFRESWK4j0EQTxI0/SjN+ko0BCA3G7R/9RRiIyMlLKysrg5c+aQY9FRuGNF5+TkzKQo6iGr1Zoty/IihmHwjIwMfLw6CneM6A0bNoRomvYAx3GPGYaxWtf1oNmzZ+uZmZlsoNWzfiU6OzuboGk6y2w2P8wwzDfcbneKzWbTMjIy2LS0NEhISIDblal3POjq6oLOzk5sQkSvW7fODgArzWbzk5IkLQoODtazsrLY1NRUctasWcCy7KSoZwVBgKamJqivr9dqampczc3NDAAMEgRxCsfxo8M+jEZYHcTpur7aYrE8JYri4rCwMO36SNdQRyHgpSqKAs3NzeB0Oo2qqip3c3MzoaqqQtP0KUEQPjIM46wgCOfLy8vdXj31vYzYMMMw7jObzU/ouv4AQRDmuXPnYhkZGay/dxS8wTAMuHz5MjQ3N0Ntba1YU1Oj9Pf30wzDODVN+1SSpEOKopzbu3fviJOCY8NVBzRNr6dp+jGe55Pi4uLkoY4CZrPZwF/ySI8Fn3/+Obz22msiwzCnBEH4RNO0E5IkVXgbraN6GGqalhMfH//DtWvX4na7HWiapmGSoqoqMAyz75VXXvnmeJ1j2LBMTk7G0tLSIJAc9/T0wKlTp6Cvrw/1DMcKnuehubn5762AlpYWRlVV1TAM+kc/+hEz3oP5k1K0LMvQ0tICTqfTuHjx4mBzczM5dMtXeDyezwCgwjCMitLS0ivPPPNMFQCkooj2shXgdDqhpqZGrK+vl/v7+1mWZR2KopyQZfmkruvHA2nTMr8Q7XK5oKGhARwOh1pVVcVfvnyZoSiqS9f106IoHtd1/bjFYrnw6quvKhCgTLjor3YEWlpaSFmWdYZhKniePwoAR3Ecr9ixY0c/GusYXUeAYRjGoSjKCUVRDimKcmI0HYE7UrQkSdDc3AyNjY1qVVXVQHNzM6MoioJh2GlZlo8CwGld1yuKi4sH4Q5jTEV//PHH8Pbbb1//3TOGYbwsy/LH45BK884WvXbtWli6dCm0tLRAXV3dfdXV1Us6OjrYoqKiq7quHxZF8VOCIM7t3LmzBgAMJHoUhIaGQmhoKMydO5cBAEbTNOjs7JzpdDrXVVdXZzc0NCgbNmygWJatliTpI1VVT2MY9nlJSck1JHoUEAQB0dHREB0dDffee68JAExDPbr5dXV1WfX19Z7GxkZq69atLoqiTrlcrkMYhlUIgnAm0PeZve3taI7jIDU1FYb2eLECAPT19bH19fVra2trVzudTr6zs5P5zne+0yLL8jFRFE8MVTnVSPQYVDkLFy6EhQsX0vC3PVqgtbV1ltPpnOV0OvMaGxu1LVu2AMMw1W63+5Cu62c0TTteVlbWh0SPssqx2Wxgs9lg9erVlhsGke6ura1d4HA4XC0tLaann366lyCILwYHBz/Vdf243W6vvHr1KhI9RlUOBQBThqI+urGxMbq2tnZFfX290draium6TiPR4xT1K1eutF6P+sbGRoiMjPSrsg478F9XV6ddvHgRZFkOqKifM2eO373HvOkEi7lz517p7e0dqKysDHnnnXdCKysr3QMDAxRFUXhISAjc7g1+x5KrV6/CqVOnkhYvXpydkZGRMnv2bFNqaupgVVWVa6zO4ZWtFStWkNOnT8+gKGoVy7KPy7KcPnPmTH7+/PnBaWlpRFxcXMCLH+pYgdPphOrqaqGhoUEZHBykGYapEgThgK7rZ0bTsRqRnezsbIvJZFpEUdQakiQfUVU1Ojk5WUpPTw+x2+2YzWabFJHe398Pzc3N0NTUpA/N7eBomu6jKOrU4ODgpziOn/O2YzUmYbh+/foEXdfvN5lMj6uqusxqtRoZGRlUeno6O2vWLOA4blKIl2UZmpqaoKGhAWpqajyNjY24oig6wzDneZ7fXlJS8sm4ir6R7du3401NTRm6rq9kGOYRVVUXRkRE8PPmzePmzJnD2u12IMnJs0apu7sb9u7dq585c+aF0tLSFydM9NdUMwRFUZnX63dRFDMjIiLErKws85w5c4jk5OSAF//2229r+/bt+8lwosf9CofGos8NfV7Kzs42Xb16dcnBgwcfOnLkyFpJkmLj4uLEefPmWVNTU7HJ8GD1iw5LeXm5AACfDH3+bdOmTdampqa7rly58ugHH3zwsKqq01JSUvS5c+ea58yZA+Hh4ZNCtN+FTkFBwTQMw5ZaLJZvKIqymmVZOj09nczIyGBmz54NFosFVR1jQWlp6RUAKB/6QF5eXvzx48cfOH/+/FOiKN4dFhampqWlmVNSUoj09PSAmSLs90+hoUkyrwLAq9nZ2YQoipm9vb0PnTx58jFBENKHHqyWOXPm4CkpKX67miCgHvdfebD+vKioiLt69erdn3zyyZojR448csODNSg1NRX86cEa0O2qHTt28Dc8WL+/cePGqY2NjSsuX7786LvvvrsKx3FrSkoKZGZmmtLT0yEsLAyJHgvefPPN7q/W75WVlStra2sf27Vr1z1msxmGeqx0amoqmM1mJHoM6/cdQx/Iy8uLP3HixKrKysoneZ5fMnXqVOV6x8lutwNFUUj0GIp/BQBeWbFiBSnLckZfX9+aY8eOPS6KYmpMTIw0Xh2nOzbVz5EjR9QbHqz/Mzs729LU1LToesdJUZTpSUlJxtDYNIx2RBIlr/r/WzTuGx6s/5KbmxtZVVW1vKWl5RvvvvvuKoIguJSUFDwjI4POyMiAKVOmBHbP0B+5PiIJAKtMJtNjkiRlRUZGillZWea0tDSysrJSO3DgwE9u6+jdZGTbtm1MX1/fYpZl11AU9ajH40nSdX3YYVLEGJCfnx+Uk5MzE5lAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCARi7ECzSb+GwsLCWbqu+zR3nKbpzqE1NF/LTX8sOzs72Gw2+5S7XVEUdffu3e2BLpogiJNTpkzBMQzzKq2nx+NhBEH4GYxkA3aapr+H4/jzDMN4lVDJMAwcAAQACPjF2ziOEz/72c8sQUFBXh3/1ltv6fv37x/2mGFvjzVr1tBPPvmkV6nN+vr64Lnnnht1xvK8vLx7WZZ9AvNhpY6qqgM7d+78sT//8Ug/jKaFCQkJz2ZmZnq1o44sy7Bv3z4eAJBoX7HZbPqaNWu8Eu12u2Hfvn3+Xx2hNgYSjUQjkGgkGolGINFINAKJRqKRaAQSjUQjkGgkGolGINFINAKJRqKRaAQSPWkY0+kGmqZR+fn5eaP8mUxfv6DrOjEG573x90i/Fc0wDGRlZeGapr0y2t+y2WxeJ+onSRKysrJgLM57HYIgxjyX9JiJ5jgOtm3bxgLAhG4jwbIsbNu2jQEABtXRCCQaiUaiEUg0Eo1AopFoJBqBRCPRSDRSMDEMO6h07do1cDqdyNIt6O3tHbloHMdbv/jii+rKykq0XvwWGIZhYBjWhkwgEAgEAjEMqEXxNRQUFDyOYZiv7z6/3LVrV+2I2tF3bOeCJHfOmjULpyjKqww07e3tdFdX188AAIn2qbuM4/i3v/3tMc1Ag7rgE/XHQwqQaCQagUQj0Ug0AolGohFINBKNRCOQaCQagUQj0Ug0AolGohFINBKNRCOQaCQa4Rs3nUBTWFi4mqbpJ+5EKaqqMhMmWtf1u+x2+9MZGRl3ZASyLDsxogEAEhISYPXq1ei+R3U0Eo1AopFoJBqBRCPRCCQaiUaiEUg0Eo34B4YdVGpoaIAPP/wQWboFzc3N2IhFYxh20ul0/glloPEOwzBOIwsIBAKBQCAQCAQiILlp17GgoODfaZr+KVLkVa/QkGX5x7t37/69z11wwzC4lStXcmvXrkUmb8E777yjf/TRR9xwxww7qETTNFgsFmTyFnizrxYaJp0gkGgkGolGINFINBKNFCDRSDQCiUaikWjEhDDsoNLBgwelkydPikjT8LjdbnbEoimK2uHxePZ7PB5k0gs0TetAFhAIBAKBQNx+7oi9srKzsy0URYWRJDlFVVUcx/EBiqIGKIrq37Fjh4JEj4DCwsIIXdcfMZvNywmCuFsUxZkEQegMw6gmk0kDABAEgZAkiZJlmcFxXGJZ1qlp2kmPx3OApunPiouL+5Hom7Bu3bqlHMf9hyRJq1JTU7W0tDST3W6HmJgYIAjipt9zuVzQ0tICTU1NRlVVlau5uZmmKOoLj8fzislk2jtWET9molesWEHOmDEj1TCMhWazeSGGYSm6rscBAI1h2PUxFREAeAzDnDzPHzIM47QkSafLy8u1kZ5348aNUymKepPjuBUPPfQQt2TJEsxsNo/4OhRFgcrKSjhw4IC7ra1N0DTtuTfffHPnbRe9fv36VIqivqvrer7ZbMbS0tIIu91umjJlCoSFhf3D5BJFUUCSJOjs7ISGhgaxpqZG7O7uxjEM+7+CIPy5rKzsjI/VxFqapkseeugh7rHHHqNJcmw3s6uvr4fXX3/d09fXVymKYk5JSUnHhItet26dnWGY/41h2PKVK1dSd999NxkdHe3z71y7dg1OnDihHzhwQNR1/ZAkSduKi4tbvJCcbTab3/jRj35kiYmJGc8xDNi3b5+6f/9+tyzLj+/ateuzCasP169f/2+bNm1yf/DBB6okScZYIEmS8d577ylbtmxxrV+/fuMtzv/kt7/9bdfly5eNiaKqqsrYsmWLu6Cg4MFxj+js7Gw6KCiodOrUqQ99//vft0ydOnXM/4idnZ3wq1/9yu1yuf4yc+bMzdu3b9dv/P/5+fkzGIap/tnPfhY0kjtoNDQ0NMAvf/lLXhTF+3fv3n3Kl+/6MvCPBQUFlSUmJq756U9/Oi6SAQCioqLgpZdeskRHRz/V2tr666+WwWQylT3xxBOmiZYMAJCYmAjPPPMMx7LsOxs2bAgZF9GbNm36cXh4+IPf//73zTRNj+sFsSwLzz33nMVisTy9fv36/Bvq5VXBwcGZa9asoeA2MW/ePFi6dGkIRVH/Peai8/LyMnEc/9G///u/j7vk61gsFvjBD35gIUnyz3l5eaEAABzH/XDt2rVWHL+9b+Byc3MZkiTX5OfnLxlT0Waz+dXc3Fw2PDx8Qi8oOjoaFi9eTHMc98u8vLxYVVUXLV68+LZ3jhiGgcLCQhPHcX8eM9GFhYX3sSw7+5577rktvcjs7GxG07T1OI5/Mz09XZ2oO+pWLFq0CGNZNs7bqL6laJZl/+3xxx83D9eNHU+CgoIgLS1Nw3H8+eTkZL9ZfoBhGDz22GNms9n8o1GLzs/PD9I07b677777to6JLF++nNN1Pdhms/nV+MrixYtxRVHuLywsNI9KNIZhDyQmJkpjneLXVzIyMmDTpk0QFxfnV6I5joP4+HjZMIyHb3UseYtq46F58+YF3e4LoigK7r33Xp+/p6oqtLS0QH9/P/T394MoikBRFJjNZrBYLJCYmDjqxVALFiywXrp06UEAeHvEoimKWhATExNQQ6mGYcDp06fh4MGDA01NTSaapi9hGNYGAO26rvfhOG7BcXwqhmHTBUGYExYWJi1btoxbtWoVOZI7NyEhASMIYumoIlqSpMTR9MDa2tqgtrbWqKurG+zv7zfcbjdOEAQEBQVhYWFh9Jw5c5i0tDSwWq1jIrmjowP++Mc/unp7e9sEQXiBIIhDO3bsuOkg/ooVK0hN0xbs27fve++///4j3/72t7m5c+f6FFgxMTEgimJcUVERNdzYNTnM6Fw0QRAjknDx4kXYs2fPYE9Pj8cwjI9FUfzMMIxOAOgBAAIAwgmCsJ0/f/4JSZLuuuuuu7CnnnrKNGXKlBFLdjqd8F//9V9uSZK+u3Pnzl0AYNzqO0eOHFEB4CQAnMzPz1/0xz/+8cOtW7cGL1q0yGvZNE0Dx3GS2+2eAQDNPotWVdUeExMjAwDnywXv379ffvfdd3tEUSwqLS394BYX/PKGDRtCTp8+/dy5c+e+9+Mf/9g8c+ZMnyX39PTAb3/7WzfP8w/u3r37xEj+ULt37z6Vl5d372uvvXYiKSmJCwsL8/q7oaGh6sDAwMzhRN+01YHjeLDVavXpNjp16pTx7rvvtmmalllaWvq+N1FVXFzc/8YbbzwvimLhz3/+c8/AwIDPkv70pz+5ZFnePlLJ1ykrKzuv6/pvS0pKfJpwGB4eThAEMX2kzbsgk8nk9aACz/Pw5ptv8qIoPvnmm292+3qRJSUlf9U07c+lpaW8L99rbm6G9vZ2j81m+90YjbG8WF1drXZ1dfnSKiJ0XSdHJBrDMKvZbKZ8iWYMww6VlpZ+OdKLJAjiP7/44gv92rVrXn/n6NGjkqZpr3113HqkvPzyyxKGYaXHjh1TfeglEjiOYyOOaF9EHzlyxOXxeF4dzUXu2LGDJwjir2fOnPFa2sWLF0VZlt8byyaiKIplp0+f9rr6wHGcMAxjZKJ1XacoivKryl/VAAAgAElEQVSq6tB1Hdra2liapo+O9iJ5nt9z9uzZQW+O1TQNenp6OLPZXD2WoiVJquzu7jZpmuataGzEon3h6tWrQJJk3xtvvOEa7W8RBHGho6PDqyG6wcFBIEnSs2PHDn4sRZeXlws0TXd3dnaCD1E9/qKHLrhzLH6rpKSkQ5ZlzO12e3UnAcC4TOnCcbzH5fIubjAMgwmJaE3TwDAMaawukqbpvsHBQW9Fq+MhGsOwfp7n/Uu0ruug67o8htHkEUXRqz8wAGjjIVrXdbcsy/5VdQxF9FhGlssb0bquA47j+jhVHWAYhv9FNIZh6hjetqo3T/yhqmNcItrH8k5cHT2Won35A/uD6AmrOoYiesIvWNO0cas6xjqiybG6YEVR4gsKCv5jjDoM07z9AyuKEjpW5/1K7zDBR9njL3r69OmwcuXKeMMwto9RhODeTDkLDg6GlStXBo/Veb8qztuXHhMW0bGxsRAbG8tM9C0bHh4Oubm5dCBUHSi7QSA9DO90UEQj0ajqQKCIRqIRqOpAEY1EI0beZUeiJyCi4RZrNpHoCYroYQeVOjo64MyZM8jiLbhy5Qo2mtG7mrq6uk/r6uqQSe9wIAUIBAKBQCAQd06H5naefNOmTVZRFKcSBDHVMIxwAAgDgHAAoAAAWJaNwjAMw3GcwnH8n9bG6breq+u6AgAgCMIVALg+B7AHw7AewzCukSTZTRBE11jM3fZr0evXr09QVXU+RVGzOI6br+t6iqIoYYqiWHEc1zmOk4OCgjSr1YoFBQWRISEhzPWVBhzHAYZhgOM4mEymf/ptQRBA13UwDAOuT7FVVVXv7++XBgYGVJfLZQwODhKCINCapuE0TbspirqGYVgdz/PnFEWpJkmyYufOnY0BJ7qwsDACx/EnOY7LlmV5vtlsNhITE7GZM2eaIyMj8YiICAgJCQGr1QoTmXtDURRwuVzQ398PXV1d0NnZqXd0dHicTqfhdruBYZhzPM+X4zj+l5GsKpsQ0UNZHLPNZvP3VVVNmzt3rrZo0SKz3W4fs+XH44nL5QKn0wmnTp3yVFZWEhRFXXS5XP8ly/JfRpNlcsxEZ2dn0yEhId/FMOx/zJgxg1uzZo0pIyMDxjqj4kSiKAqcP38ePvjgA+HKlSu8pmk/x3H8T6PNUTpi0fn5+Q+ZTKbX7HZ7aHZ2tsnfcmmMBU1NTVBeXs43Njb2SpK0saSk5JMJE71t2zZGFMVSmqYf3rx5s2nu3LmTvmlWUVEBb7zxhqiqajmGYZtHEt0+ic7NzQ0PCgo6lJiYmPzd736Xvt2ZaSYSnufh97//vdTa2nq+t7d3dXl5+cC4iM7Lyws1m81frFixIjo3N5e6xQuFSYmmaVBcXCyfPn26HsOwhb6sb/Qq9VdhYaGZ47hTK1eutOXk5NyRkgH+toAoKyuL6OnpCeno6LjParXuamlp8WrFgVfvDFmW/e/09HRbdnY2CQgoLCykp0+fnpWYmPhTr/9Itzpg3bp1T5lMpseKiorYOzWSvwpJkvC9732PA4B/zcvLmzdq0UO7Pex4+umnOX/JoOgvBAcHQ3Z2NsNx3BujFm2xWL49e/Zsdvbs2cjs1/DAAw/gJpMpoaCgYNmIRW/YsIHFMOzHTz31lAkpvUmTDcPg0Ucf5cxm8wu3rG6G6Yo+Fh8fj49X/nxVVaGnpwcEQQBBEECWZZBlGTweD8iyDIrie4+XoiigaRrMZvPf/53jOGBZFsLDw/9hY4exYsmSJdiePXuWbdy4cepwg1E3Fc1xXPY999wz6hEhWZahsbERamtr1UuXLnm6u7uNa9eu0ZIkUQzD9BIE4cFx3AUAvGEYHgC4pmmaW9f1v+eREAThpgvDTSYTe0Pzy0IQhAUAwjAMMxuGYTIMI0jTNE6SpDCGYZTQ0FA5IiICi4mJ4WbNmkUlJiYCw4x8QZnJZIKUlBTlwoULKwFgj0+it2/fjre2tj6QkZExopNfu3YNjh07pp45c8bd2dnJsixbLYri+4qinAOAdgzD2nft2tU10bd6bm5uuNvtnnH58uWZVVVVGYcOHXpEFMWMiIgIceHChZbly5eTI8mRnZWVZa2vr398ONHYTXqBmeHh4Z/94Q9/8CkvKc/zsHfvXvHEiRM6juNvybL8hiAIZ8rLy2V/rWeHhngXsiy7Sdf13CVLluA5OTksx3mf7q+rqwuef/753tdeey3Mp4jGcTw9ISHBp0bzpUuX4De/+Q0vimKxy+V6oby8vDcQHmhD2Rw/B4DPs7Ozf3Dy5MlfVFZWFv7gBz/wOtlhREQEqKpqyc/PD9q9e/eg160OkiRnxcTEeL0PUk9PD7z00ku82+1e9/rrrz8bKJK/Snl5ee9rr732zMDAwJYXX3yR7+vr8/q7YWFhAoZhiT4171iWnTtt2jSvp/S++uqrLlEUX9y5c+f/Nxmabbt27dorCML/2rFjh9vb70yfPh0DAN9EG4Zh83aflfb2dmhpaVEYhvn1ZGojBwUF/dzpdOreZgqLiopiASDGV9Fmb8eaz549q+m6XjJRGzBOFC+//LKE4/jec+fOeZXvx2QyUTiOB/kkWtd1k7dtS4fD4VYU5dhk7PmJonjE4XB4VX0wDIPRNB3iq2jW24ju7+8HTdPaJ2kvu723t9ert+AsywKGYcG+iia8fZMtyzKQJClORssYhgmS5F06P5IkgSAIk0+icRxXvM35ZjKZDE3TrJM0ooO87bjIsgyaprl8FS16+5eMjIwkMQxLmIyWdV1PiIqK8mogXpIkUBSl3yfRBEF4fcskJyebTSbTqskomuO41cnJyZyXog1VVQd9jehBj8e79Ml33XUXpqrqN9atWxc2mSTn5uZGqqr68IIFC7w6fnBwUMYwrM/XdnTd1atXvTpBSEgILF++HGMY5s+TyDNmsVheuf/++3Fv5w5euXJFBF93rRAE4fzly5cfAy+ziOXk5LAOh2PNpk2bXiVJ8ruB3HkpKiqiFEV5JSIi4oGnnnrK6xelnZ2duKqq9T5FtKZpta2trV5PDmFZFl544QVzYmJiAQBcLCgouDsQJQ9tmVednJyc8/zzz5u97bTpug4DAwOm8PBw3yJa1/WKhoYGyjAM8HaKAcdx8MMf/pA7efJk8ttvv/3x1q1buwRBKMEw7DBBEKeLi4v9rq29bds2pq+vbyEA3Mdx3DqTyRT5rW99y7xo0SLwZWpFS0sLMAzT8fLLL9+0BXHTX9u6dWvb888/PyM2NtbnCzAMA2pqauDs2bPSxYsXpWvXrpk4jqvVdf0sz/NOXdfbCYJoVVW1DQAGFUUZHKt5yDeyfft23Ol0BpMkadU0bSaO4zMNw5hhMpnsBEHMEwQhLSwsTEpNTaUWLFjApqWlwUjmrrz33nv6e++998rrr7/+rE8RPSRr35dfflkUGxvr846RGIZBamoqpKamMgDA8DwPTqczvbOzM72np0ft6uriu7u7tf7+fkqWZRLHcaawsFAjSVImCMKN47iEYZh4Q3Pzph2BGztLhmGwuq4zmqZZVFWlGxoaCJZlJZIktSlTpsjh4eFEZGQkFx4eTkZGRkJSUhJYLJZRT1g5d+6cS5bl94ftOQ4zoLLn8OHDBWvXrrWOdoYSx3GQmZl54zn/aZRLVVVSkiTS4/FwiqLAjT3T4VLA39hzo2n679voXf93ALg+aGMej+qnr68P2tvbKQD4bDRP4PNnz541EDenrKxM3Lx588u3cjnsWxRBEH7217/+ddDbFOx3GpIkweHDh3VJkv4wKtEJCQnvdHV1tRw6dEhFWv+ZPXv28JqmvVNaWtowKtHbt2/XJUnK2bNnj+zLJl13Ag0NDXD8+HHZ5XJ915vjb9miuHDhQk9mZqZRWVm5aNmyZfR4TKsKNAYGBuAXv/gFz/P8ur1791aOiWgAgPPnzx9PSUmJvHDhQurSpUvp27VHuD/A8zz853/+J+92u/+zpKTkDW+/5/WUgpiYmH/t7Oz8+Fe/+pXb2x13Jhsulwt++ctfut1u954333zzt+M6qrVx48bffO973xvs6Oi4o5pxra2txne+853BTZs2bR+JOJ/rgPPnzx+cPXv25cOHDz/A8zwkJSURgbxS9lYIggBvv/22XFxcLIiiuLW4uPhPI4rQkRagoKBgGsuyfyYIYtXDDz/M3H///bgvEwP9HY/HA59++qn2/vvvy4ZhfOB2u5/ds2fP1RFXBaMtUGFh4V0mk+l5VVUfWLJkCSxdupRNSkqCQFxYZBgGOJ1OOHbsmHjy5EkgCOIjnud/sXv37rOjrnPHqpA5OTkzWZbdwDDMBhzHIxcsWEDMmjWLtdvtMJr9vseb3t5ecDqdUFNTI1RUVOiapl2RJKnYMIzikpKSjjF7uI1H4fPy8pIIgniI47iHZVleTNM0HhUVJcXExDAxMTHmkJAQsFgsYDab//7P8Vj1pSgKuN1ucLvd4PF4wO12w8DAALS2tvKtra3SlStXaFmWdZqmT7rd7v0Yhn3oTS/Pb0R/9RwFBQUJGIbZDcNIoWk6jaKoGAzDwnVdD9U0LUhRFAuGYcCyrGw2mzWCIAwAALP5bwNuJEliX7d1tiAIuqqqBoZhmNvtNoaGTTGe5wlBEGhd14GmaQ9BEIM4jvcZhtGjKEqrJElVGIbVAYCjtLS0EbzYvzwQRHs7Ush5PJ4pBEFMUVWVGhIcCgCg6zqJYZj1a+pUF47j6tAwax8AAI7jqqqqvRRF9e7atcsDCAQCgUAgEAjEBLajCwoKtnAc9xyGsqF4M0Zi8Dz/y9LS0jdvdsxwE2imL1y4MOm+++5Dom/BwYMH9WPHjg27IfGwA8mhoaFgs9mQyVsQEhJyyy482vBmgkCikWgkGoFEI9FINFKARCPRCCQaib7TGZdJc6dOnYLXX39dMQxDvxMkqqpK3hbRycnJkJ2dTTkcDqGurs7geZ4ymUy1oih+rCjKMVVVK3AcFyaTbJqmhQkXHRoaCqtWrYJVq1aZAABEUYTW1tZ0h8ORVl1d/XRjYyONYdggjuPHPR7PZ7quH7fb7ZXbt2/XUdUxCliWBbvdDna7HV+7dq0VAKCrq2uq0+l8or6+ftVQgljm6aefrpdl+WNVVT8TRfFEoCYqvG2iv46IiAiIiIiApUuXmm+I+jkOhyO1qqpqS2NjI7N161bXZIl6v5lB/pWoDx6KenayRL1fT9X/atQLggBtbW1zHA7H7ECL+oBaE2Eyma5HPbF27dpgXdfhypUrbHNz8xM1NTWra2trtUuXLlH+GPXDiu7p6QGXy+W3W+XhOA7R0dEQHR0NS5cu5QD+tgi+sbFxjtPpTK2trX26vb2dfvbZZ9sNwzjqcrk+wjDs85KSktaJLutN33Dn5+evCgoK+rEkSRkMw+A2m01LTk62JiQk4DabDQJlvYqmadDS0gINDQ1GTU2Nq76+npBlWaEoqsLtdn9kGMZJiqLOjXfiFq+mEmRnZwebTKY5GIYtMJvN98qyvAjDMC42NlZKSUkJjo+PJ+Lj4yE4ODgg5AuCAE1NTVBXV6c7nU5XU1MTTRBEr2EYpwVB+AjH8RM2m612LOv6Ec/ZyMnJmU5R1DwMwxZwHLdckqS5FEWRNptNs9vtFpvNhiUmJgbEDp1DdT00NzdDTU0NX1tbqw0MDFAMw1QJgnBA1/UzmqYdLysr65tw0cPJp2l6Mcuy9/A8n0HTNB4XF6delz+U9SVgor62tlZxOByulpYWE47j1zRNOynL8ie+Rv24zkIqKiqi3G53KoZhCxiGuZsgiCWSJMWGh4e7ExMTsZSUlND4+HiYMWMG+Pv6clVVr9f14HA4RIfDoSuKophMpvMul+t9wzD+73C7MU/4dK8NGzawmqZlAMB8s9l8r67rC2VZjoqKihLsdjubmJhI22w2mD59OuC4f4/i9vX1QX19PRw4cECpr6/fXlpa+qLfiP46VqxYQcbGxiZrmjbPbDYvJwjibo/HkxgaGiomJibSiYmJjM1mg/j4eL/cOPjtt9/W9u3b95PhRPtFqYe26Kge+pRcr3a6urrSe3p6lp4/f34pjuN3iaI4PSwsTExMTGQSEhJIu90OsbGxfh/5ft0zHEq7eW7o8wcAgE2bNlmvXbuW0dvbu6C6uvpeTdOyJEmaGh0dLdrtdi4+Pp68Xu3422zjgOqCv/HGGy4AOD70+d31Nn5bW9uc9vb2BadPn75XUZRFiqIED8k3x8fHE/4gP+DzPwztZvwP8tevX5/Q0tIyv6ura+mpU6eWC4KQzLKsbrPZjMcff5yz2+0TP1wAkxBd110AMCiKYremad04jntEUSRcLpcyku37UET/LXpTNU2bRxDEQpZll0uSlEiSJJaQkKAkJSWZ4+Pj8bi4OAgNDQUAoFHV4QUFBQXTMAybDwDzGYZ5QFXVdIIgiKSkJH5owIu6Qapf7Q7vt6Jzc3MjSZJcONSxuUeW5QwMw1ibzcYnJydbEhISaH+V6reiN27cOFVV1UU3StV13RwdHS0kJSWxs2bNopOSkgJGql+Izs7ONplMpkxN0+ZzHLccABZKkhQ9depUPikpiUxKSjLFxcVBbGwskCTp19kMRVGExsZGaGpqur2it23bxly7di2DIIgFwcHB96uqOp/n+elhYWGS3W6nEhISKJvNBjExMUDTtN+Pp165cgUaGhqM6urq/rq6OmNgYMBEUdQFSZI+JQji3eG+O2Yt+MLCQjOGYXMBYCnHcQ/KspyhaZp1xowZnqSkJDYhIYG22WwQFRUFgZAJ0uVyQW1tLdTW1soOh8Pd2dlppmm6VVGUT2VZPqnr+vGysrImb39vRKKLioo4URSzDMOYb7Va79M0LUsUxcgZM2bwgShV0zRobGyE5uZmo6qqylVfX0/JsqwzDFMhCMJHhmEcEwThfHl5uXuk58C8rFPn6bo+Lygo6H5N07IEQYgKCwuTZs+eTaakpASU1Bujta6uTnU4HO4rV66YGIZp03X9CM/zx3yN1lGJLigoeNRqtb7I83wSx3FqfHy8YbfbzTabDWw2W0C8JblOZ2cnNDQ0QF1dHV9bW6v09vaaaJquk2X5kKIoRymKOllcXNw5nmUYbi14ZmZm5uzc3FzMarXSgSJVFEVoamoCh8OhVFdXD7S0tHAAwGMYdkIUxcMYhp0ymUxfTPSmPMO2OsLDw/365eoNdStUVVUN1tfXU5IkGSzLnuV5/igAHNU07czNtpBGPcNh6tahd3bqxYsX3ZcvX+Zomr4KAJ/xPH+QIIhzPM/XFRcXa/5Wdr8VbRgGtLS0gNPpBIfDMeB0OgmXy0XTNH1OluVPAOCoIAhni4uLB1DPcAyiVdf105IkHcRx/IQgCHUlJSUaBCDk7Y5Wp9Ppdjgc4Ha7GYqiKmRZ/sQwjLMEQZzdsWNHJ0wSyImO1qqqKr6jo4P9arReunTJMfSSdlJCjpfYCxcuQE1NzWBtba167dq1EBzHuzRN+wwAPtc07ZQsy/U3th6mT59uzcvLC1iRNE0Lw02UHBfR1dXVsHPnTlXXdQYAGIqiFAAIJQjicQB4fLJFq6qqpKqqPwGAiZ3XsWjRIli0aBEJk+BVmTcMTaAZ9hi0cnaCQKKRaCQagUQj0Ug0UoBEI9EIJBqJvtMZdiyir68PmpubkaVb0N/fj41YNIZhl8+cOVN/9uxZlBH9Fhh/2zj9CjKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQY8VwW6EWWCyWbUjRrTEMw+B5/g+lpaV7bnbMcAs64zMzMxcsW7YMrTO8BUeOHNFPnTplG+6YYVfORkREQGpqKjJ5C6qrq41bHYPWgk8QSDQSjUQjkGgkGolGCpBoJBqBRCPRdzrjkrG8oqICdu7c6dF1XbsTJIqiyNwW0bGxsXDfffeZ6+rq+MbGRlKWZZKm6QZZlg8BwOe6rp8zDEOcTLJpmu6dcNFTp06FJ554AgCAA/hb/ryWlhZ7XV1dXHV1dV57e7uJYZhOVVVPKoryKY7jJ3bu3FkDAAaqOkZBaGgohIaGwty5c2kAoDVNg9bW1plOp3Om0+lcU1dXh23YsIEgSbJSkqSDAFBBEMSx4uLifiR6FBAEAdf3RVy9erXlhqhfXFdXl1VVVSV0dHSYi4qKOhVF+VxV1UOBHvV+s33HDVHPAABzPeodDke20+l80OFwkBs2bMBJkjwviuLHOI4fZ1n28x07dvBI9NhEPf7ggw8GDxf1mqYdkiTpEEEQ53bu3FmNRI9f1BdWV1c/4XQ66U2bNsk0TVe63e4jOI4fFwThRHl5ueDXogcGBkCWZaBpOhCiPsgwDLh8+TLb0NBwj8PhWFxXV6f09fVR3/nOd5yKohwURfEwSZKn3nzzze6JLustN/cVRTExNDRUSEpKIu12u+X6humBsmMyz/PQ0NAA9fX1WnV1tevSpUsmgiB6AeCEIAiHAOBzSZKqysvLtdsi+kZycnKmUxQ1j6bpxSzL3iMIQobValXj4+MhOTk5yGazYXFxcX4b+V+lr68P6uvroba2VnY6nfzly5fNLMteUhTlU0mSPidJ8mhxcXHLhIv+KtnZ2QTHcSmaps2jaXoxRVFLJEmyBwcHi0Pyg6833yiK8nvxsixDS0sLNDU16dXV1W6Hw0Hrui5RFHWe5/kDAHA8ODj47MsvvyxNqOivY8WKFWRsbGyypmnzGIa5myTJuyVJSg4JCZESEhLIpKQkk81mg/j4eCBJMmCivrq6mq+vrxevXLliZRimRZKkg5qmHVFV9eiePXuuTrjom0R+MEVRWQRBLGAYZpmu6wsNwwiaMWOGOzk5mUtKSuLi4+MhPDzc78V7PB5oaGiAxsZGo6amhm9ubqYoiuqmKOrUwMDAhxiGHSgpKem4LaK/jtzc3HCCIOYTBLGQZdkVqqrOxTCMiYmJkVJSUizx8fFkfHw8hIaG+rV4wzCgo6MD6uvr4ZNPPhFbW1v/Z2lp6Yt+I/rryM/PDyIIIl3X9Xksyy7FcfwuRVEipk2bJtjtdnNCQgJls9lg+vTpgGH+NxVwaOPInwwn2i8qy6Gd6I8Pff4AALBhw4aQ9vb2+W1tbctOnTp1jyzLmQDATps2TbLb7Vx8fDxpt9shIiICjXWMhqGRu0+GPn9vZra2ts5ra2tbcPLkyeWSJGWRJInHxsZKKSkpQderneDgYCR6NOzdu/cyAFwGgH03ync4HPOcTucCjuOWi6I4n6IoGJIfHB8fTyQmJoLVakWix1J+dnY2zbJsusPhmN/S0rIUABZLkhQTFhbGJyYmEmvWrDHbbLYJL+ekezlbXl4ui6JYrev6eVEUT1EUdZ5hmJ7e3l5Lc3MzDA4OoogeYVt9CsuySwBgvtlsvkeW5QxN0ywzZ84Uk5KSTPHx8YTNZoOoqCggCMKMqg4vKCwsNGMYNtcwjPlms/lBWZbv0jTNOmPGDE9SUpLpejNwSKoFPQy9oKioiBNFMcswjPlWq/U+TdOyJEmKiI6OFpKSktiEhAT6BqlBqHnn3e1vMplM874qdebMmV8nlYIAZMJFb9++HXc4HHYcx+dzHLeUIIgloijarVarnJCQgNntdrPNZoPY2FgwmUx+LVXTNGhra4O2tjbsdovG8vLyEnEcn2+1WpdjGLb00qVLSeHh4WpCQgKelJRkiouLg7i4OOA4zu8HswcHB6GhoQHq6ur4qqoqT2dnp5UkyTZVVQ9jGPbxsCLG8PYnOI5L0XV9CU3TKwmCWCTLctS0adNcSUlJTFJSkvmG29/vb3VZlqG+vh7q6ur0urq6/kuXLjEYhvXpun5KkqSDOI6fuHTpkuPIkSOqVxE30tu/ubl5lqZp80wm01KKopYKghAfHBws3zj2HBsbCwzDQCDQ0dEBzc3NUFtbK9bU1Cj9/f00y7IXFUU5KMvyScMwKkpLS0e8OSTmi1SWZZfQNL1MFMX4oKCgf5AaExMDLMsGhNTr0epwOAyHwzHY3NxM4jjeDwBneJ4/4Gu0jkp0fn7+qqCgoB/LspxO0zQZFxen2O126/UOwO0eO/AFl8sFDQ0N4HQ6lerqak9HR4eJoqjLhmEcEQThsKZpp8rKyupvV6tjUWZm5tKcnBwsKCgoYKTqug5tbW1QX19vVFVV9TY0NBA8zxMkSZ4VBOFT+Ntb74ry8nK33zTvwsPDwd8ld3V1gdPp/Ie6lWEYp6qqn8iyfFhRlHNDA0+ow+ItiqJAc3MzOJ1O4+LFi4PNzc0kAPA4jh/3eDyf6bp+/PLly1+OZd16R4i+Hq0NDQ1iTU2N1N3dzfpjtAaU6K+LVsMweIIg/D5a/Vp0d3c3OByOG6PVxDCMIxCj1W9E3xitVVVV7ubmZkLXdQ9N06c8Hs9hRVGOBnK03jbRgiCAw+EAh8MhVlVVuTs6OiwEQVzWdf0zSZI+wzDsVGlpqQPuIMZt+duOHTsAANihDyiKEg8A8RiGbQQAKCgomGwun5/weR3Lli2DZcuW3THROjSBZthj0MrZCQKJRqKRaAQSjUQj0UgBEo1EI5BoJPpOZ9ixDo/HA11dXcjSLfB4PKOaEtZ39OjRrqNHjyKT3tGHFCAQCAQCgUDcMfhNqoBt27Yx3d3dYTRNh6uq+ve1KziOcziO33Q2u6qqMgB4bjhexXG8Jzg4uGc0GWMCUvS6devCAMCu63oKQRApNE3H4TgeZRjGVF3XpyiKEmwYBsUwjGg2mxWSJA0AAAzDCJqmdYIgDBzH/2k9hq7rmqZpmCzLuGEY2pB4jOd5ShRFFsdxlSTJARzHr2EY1q3r+lVJklo0TavDMKwOx3FHSUnJtYAVXVhYGAEAqxmGeRAAVqiqGh4eHu6Jjo7G4+LiLFOmTCGsVitYrVawWCwQHBwMJpNpzMshCAIMDg6Cy+UCl8sFbrcbent7tUuXLrnb2tr0np4eM0mSPRiGHR6a6f/xrl27uvxadHZ29hSO40eltWIAACAASURBVL5lMpk2q6o6Oy0tTU1LS7Pa7XaYMWOGXyY0MQwD2tvbwel0QlVVlauqqookSbLK4/G8QRDE3rFMQjvqq8/NzU0xmUw/MAwjJzMzU1+2bJl5zpw5AZGg6mvqe7hw4QIcPXrUc+HCBZwgiDJZln9dUlLivG2iN2zYEEIQxH8BQN7KlSuJ1atXU/6eB8kXent74cCBA8qhQ4d0DMN2CoLw3FCmnIkTXVBQ8DjDMMV33XUXk5OTwwbSwiFfGRwchLKyMqGiokIURTF/9+7dH07Iw3PLli2/ePbZZ/nGxkbjTsLhcBjPPPMMv3nz5h+NRJwvS1ixzZs3vxUVFVXwwgsvmKdNm3ZHdTjCwsJg8eLFVEVFxV2zZ8+O++KLL/aPi+itW7f+KSoq6ps/+clPzGazGe5ETCYTLFu2jD516tSsWbNm4ZWVlUfHVPT69euftVgsz73wwgscx3F3dFeaoiiYP38+9dlnn91lt9urL1686BgT0Xl5efE0Tf/1hRde4AIhteVERXZSUhJ95syZVYmJia/W1NTcsqt/q7fgmMVi2fvkk0+y06dPR4ZvwG63w6JFi7iQkJDfe3M8fouu9ENBQUHJDz30EJqW8PV3O2sYxrfWrVsXMyrRLMv++lvf+laQP3af/QGO4+C+++4jKIp6bsQdlry8vIVTpkz59A9/+IMFxycuoD0eD8iyDIqi/MN/uxk3toAoigKapmEiW0U9PT3wH//xH26XyxUx3KYN5DAVft59993HjoVkVVWhubkZOjs74dq1a9Dd3c13dXXJPT09IMsyLooipWkaqWkaRZIkj+O4jOO4dIPAm5pWFOXvVnVdZ3Rdp1VV5QiCUEmSVBmGkWmaNsLDw/WpU6cyU6dO5cLDwyEyMnJMkoaHh4fDtGnTNEmSlgHAxz6LJgji8fT09BGXoqWlBc6dO6dduHDB09raaqJp+jJJkhcEQXCoqtoCAK2aprUBwKBhGINWq5Ufy81rhtK5mQRBCMZx3Nrd3T2zrq5uJkVRcQzDJBuGMUcUxZkxMTHCnDlzuHnz5pHx8fEjOte8efMsnZ2da4YT/bVVx7p166Jpmm7YsWMH62v9/OWXX8Jbb73l7urqElVVfUvTtE9wHD82UQPsPj7MQnEcX0aS5EqCIHIiIiJMOTk5lvT0dJ9+p6GhAX772982vfrqqwk+ic7Pz38iLS2t+Ic//KHXyTpkWYZXXnlFqKqq6hUE4enExMQPt2/frgfQsw3Lz89/2GQyvZqRkRFaVFRk8nYXDk3TYPPmzSrP8+by8nLZ61YHQRDJsbGxXncBFUWBX/7yl54LFy7s7+/vTyotLX0/wCQDABi7d+/ej+N40pdffnng17/+tUdVvVuaThAEBAUFCSaTKc6n5h3HcXOnT5/udf38l7/8RW5vbz86c+bMHH/YLmk07Nixgx8YGMhua2s79de//lXx9nuRkZG6YRiJvrajZ0VFRXl1ApfLBQcPHtQEQdgcgFH8tZSXl2s8zxceOHBAHa5peSPR0dGMrusJPonWdT3Y27bo6dOnDZIk3x9NTjh/pLS09ApJkp9UVFR4dXxQUBCD43ior6JN3uawq62t9fA8vx8mITzPv19bW+tVk5NhGIwkySBfRbPePnE7OztVgiAaJ6NowzAaOjs7ZS9FA0EQwb6Kpr0VLQgCBgCDk1E0juMDPM971ZGgaXrYPNb4TU6gaZp3u87RNA2qqrKTNKJNNE17tcetqqqg67roq2hRkrybtja058m0SSp6ekhIiFeDPZIkga7rg+Mm2m63W2iaXjIZRTMMsyQpKcnipWhDUZQ+n0RjGOYRRe82ol+wYAFB/b/2zjw+qur8/8+569xZMgmJIUASIEECAWQJi0LQABa/AkobS4FsQAIB2592se3XrxWlinWpv1rQSr8gmmRIqKYUELBI0QAClsiSCCZsCWQlhGyTmbn3zt3O9w+jL6sk3JlMCIb7eb148cfc9Z1zn3Oe55zzPDS9ZM2aNX1qciApKYlCCKVOnDhR13vxPK9omubyFXRVU1OTrgeKjo6G6OhoS1VV1cq+BDomJub/DR061DRo0CBdx1+9elUAgFqfQIuieKq+vl63l7d8+XILTdN/TE9Pn9kXIKenpz9AUdTaFStW6I731NfXawihCz6BVlW1rLa2VndsOCIiAp544gmL2WzelZmZ+Vx2dvb3ck1Cdna2OSsra63FYvnHb3/7W4svleVaWlo4kiQvdvZ7Z4GjMxUVFT7FLYYPHw4vv/yyOTc391elpaWPZ2ZmblRVNTc3N7cMAPAt3oJHkiSZoSjKo+PGjaMzMjLMvlSQa2pqAoSQ2NUy3+uCjo2NPVldXU20trb6VCnTbrfD448/bqmtrYWDBw/+vLi4eGVWVhZiGOZTj8ezW9O0EoRQrSiKdZ3FbXu4xdJut3sgRVFRCKExHMfNkyQp0WKxwMSJE9kZM2awUVFRPl/3zJkzQJJkUVfHdOr1rFy5cvuiRYt+mJSU1K2Xc7lccO7cOSgrKxOrqqqEpqYm0ul0mimK4hmGuYoQcgGAEyHk0TTNLctyo6qqLlmWXb7ei6ZpG0mSNpqmwwmCsAKAGWMcjDG2yrLcX5ZlS1BQEB8WFqZFR0ez8fHxXFxcXLfrH/7pT39ynzp16mdbtmzJ89V0gNvt/tvhw4fvT0pK6lbNKZvNBhMnToSJEyd+nT4TAMDpdAY1NTUFiaIIPM+DJEkgSdJ1Z8FVVe10rEmSpOkboL+eBWcYBmiaBovFAizLQlhYGAQHBwMABDTFuyRJUFZWRgHAv7o6rlPQFovlH1VVVW9cunTJ2hP1/+x2uy8t6ZZ18Q8dOoRJkjx0ozBxp4PxjRs3yoqivLZr1y4PGOrMRYc9e/Z4RFH84w0DVDf4/c3S0lL14sWLBtXr6JNPPsEej+dKXl7eR90CnZOT0ybLctq6det4vbGP20Wtra3gcDi8Xq/3x3qGrzf04x0Oxy5Zlj92OBwG6Q5pmgabNm0SAGBjXl7e53rO0RUwaWlp+clnn3129t1335UNzACbNm3yVlZWfup0On+l9xxdK/7LysqU4cOHb6+pqVkCAFxcXNxtuYwXYwzvvfeecuTIkbrW1taZviyt0L2H5cyZM574+Ph3KyoqHqyqqjInJCQwN3OVaW9LkiRYt26dp7i4uNzr9SZt3bq1xZfzfSosePr06fZhw4a943K5xh48eDBq6NChTGhoaJ+HXF5eDi+99JKnoaFhh9PpfGjr1q0+z5H6vcI8LS3tYZPJtHnChAnW5ORkU//+/fsc4IaGBti2bZtYWlraLoriMofD8YG/1+rWUv709HQLRVG/RQj9fMSIEeihhx4KiouLg+/zDgGMMZSXl8OuXbvaz58/j1VV/RPLsq92d0lxQIh0rEXO5DjulwAQMXXqVHLy5MlsTEwM6F220Nv2t7KyEoqLi71Hjx5VMcb1Xq/3TzzP5wRqLWHAm15KSsqdDMMsMplMj3i93rjw8HAhPj6eGzhwoCk8PBzCw8MhODi4V6p5er1eaGtrg8bGRrh69SrU19eLZWVlQmNjI8ey7Dmv1/t3TdO25ubmBnxBUI9+40lJSVRUVNQ4AJhoMpnG0jQ9TpblWEmSggGA4DjOa7Va1Y4AE2m329mgoCDyq+0OZrMZEEJAEMR1E6cIggCapgHGGHj+yy9bVVVob29X29ravE6nU3U6neDxeEie5xkAwAzDtNE0XakoSokgCCUAcLympqakp8tH9Zox7TA3YYqi3EEQxB0Y4zCEUCjLsgO/yqFEkmQ4QggRBEFjjL8T6kMIOTVNkwEAFEW52mFjJUEQ6gGgCQCaCYK4hhBqNJlMTYHcumHIkCFDN0GoC4dkOgAk+TgGdeXn5//ZwPpdUV1AmzFixIg1I0aM0D10KioqagcAA7QvoAEARo4ciR555BFdF2ptbYWioiKDaCcyshYYoA3QhgzQBmgDtIHAAG2ANmSANkAboA0ZoA3QhnxWQBPxY4xRampq5O0IkmVZ59tvv+3qcdAEQQDLsiaaps/dbpAlSaIlSVoDAH/ocdB2ux3efPNNBgCY2w30u+++q+3evduw0UZnaIA2ZIA2QBsyQBugDdCGDNAGaEMGaAO0AdpQYBWw6F1bWxs89thj+DbliG4aaIwxsCzb3t7eHno7ki4sLNRuCuhv3FA1DIVhow3QBmhDBmgDtCEDtAHaAG3IAG2ANmSANkAboA0FQF1G744fPy5du3ZNV1InSZIQxhgbSH0ETZLkrtra2vra2lpfrmdkTzdk6LYQ6qsvtmjRoiiSJEcTBDGGoqg4lmWtCKHgL9PoEZqqqi2KorQJgnABAK4SBFEmCMLnPTVD1KdAp6Sk3Mtx3EKCIH5M0zQ3aNAgZfDgwVxERISJoqivs0FqmgaCIIAgCNDc3Cxfu3aNr66uBqfTyZhMppMej2cLSZI7cnJyGm550IsXL+5PkuQgTdMQQogmSdIKACDLcsnWrVubAgx4nNVq3cRx3IgZM2ZwU6ZMIfXWNf+meJ6Hs2fPwtGjRz0lJSUkSZIHBEFY7XA4jt8SoJcuXWpSVXUOy7IPUBQ1UxTFaIqicHBwsIQQwjRNY4ZhUF1dHSuK4gKHw7ErEPdNSkqihg8f/mcAWLpw4UIuKSmJCFSWdkmSoKioSN25c6egKMp+t9u9auvWrVd7BXRKSspgjuP+B2OcFhMTo44fP942bNgwNHDgQLBav1v56cUXX3SWl5enBwJ0SkpKiNVq3T1kyJBxv/jFL8zXSxIbKODbt2/3/utf/5JEUfxxfn7+voA7LJ0pMzPThhD6M8Z48cyZM8nZs2czYWFhN9MWh5jN5lOJiYkDUlNTe7TWAMMwsHDhQnbChAnsq6++umPp0qU/z8nJ2dTjLnhKSspkhND5yZMnL1q3bh2XkpJyUyEvWLCAsVqt++69994B6enpN62gw5133gm///3vOY7j1qWnpy/qUdAZGRk/5jiu6NFHH43Izs42X8889LRCQkLyhg8fPiotLe2mbxyNiIiAp556imNZ9q3U1NS7ewR0enr6Ao7j8p5++mlzQkJCrwzflixZ8hOLxTLvscce43qrjkBkZCSsWrXKzHHctvT0dEtAQWdkZCSyLJv75JNPckOGDOmVF8zIyAilKGrjT3/6U0tv1w1ISEhA48ePD2FZ9uWAgV66dGkwTdP/WLVqVa9BBgBgWXbT9OnTuWHDht0SzlFaWhoHAJlpaWnDAgKaoqhX77nnnqDeMhcdHXACQRD/tXDhwltmQ39QUBDMnTuXMZvNf+w26CVLlsQihFIWLlzI9uZL2Wy2F+fPn8/2RqWLrjR79mxSVdX/SktLG9At0AzDPDNnzhy6N0YXXyk1NXUMxjhx1qxZt9xskNlshmnTpiGGYR71G3RKSkqIqqoLZs2aRfVya37p4YcfZm/Vwjn33nsvS1HUUr9BEwTxw9GjR6s2m63XXmLp0qVDFEWZcf/999+yc5sxMTFAUVS/1NTUeL9ccKvVmnr33Xdbe/MlCIL45YwZM0iW7X4XUVVVBaWlpWpJSUl7S0sLyfM8jTFGZrNZCg0NVSdMmGBPSEggBgwY4NN1EUIwbtw44vDhwz8AgDKfQK9Zs4a4fPny1DFjxvj9YnV1dXD+/Hmorq6WamtrvbIsq3V1dbp7sw5nIGv27Nndshl1dXWQm5vrvnTpkqhp2lZJkvYjhCoBoJGiKOx0OsObmpqGVVdXP7h9+/bFkydPptPS0jiLRbcvAvHx8dzJkycfAIB1PoG+cOHCqNDQUNlqtfoUEpMkCfbt26fu3btXkCTJRZLkPrfbfRwhVIkQkgAAFEUp0dmaM0aOHIm7E0f54osv4LXXXuMlSVoTHBz8xuuvv369urnXAOALANiZmpr62+Li4pcvXryY9swzz1j1ms0777wTFEWZ7M9gfNkbb7zhwj7o0qVLeNWqVZ4VK1Z8kJKSMq6bXzrKzs6uLi8vx/7q7NmzOCsrq72jzImvfcNzq1evdqmqqutemqbhZcuWSZmZmTafOkOapsdER0dbfLF/L7zwAi8IQsamTZvmFBQUlHSHclpa2v1BQUHBekuTfFttbW3w2muv8bIsJ2/ZsuUTX8/Pycl5tqGhoWzv3r2qXjsdGhrKi6I40ifQLMuO6d+/v66ojaZpsGHDBrfX612Vm5u7LUDj09/NmzfP74747bff9iiK8lpeXt5+Py+BRVHM2rlzp1eW9RWOjoiIQCRJDvYJNEIoVK+TcvbsWWhra6t1OByOALnbdwLA5KlTp/oVnquoqIDy8nJBVdW13XkOh8NxhiTJ06WlpbqODwkJYTDG/X0CjTG26Z0aOn78uNfr9eYGakjHcdwTs2bNomia9uv8/Px8lyRJv87JyRG7+ywej+e9M2fOiDpBsyRJRvgEWlVVm9ls1vUw1dXVgt6RhJ5IIcY4ffbs2X5RvnTpEtTU1IiCIGwJxPOoqnqmurpa1NlAEE3T/XwFrXuys729HWmadi1QzuCYMWNwcHCwXyd/+OGHgqqqbwRwEUyr2+3WdWDHF2j2FTSr1xvrmLMju/tGCxYsICmK+u958+ZZ/Dmf53n47LPPCADYEEDPVLcJpWkaKIryDTRBEIqi6CvBarPZMEEQd3T3pViW/UlkZKTZ38D+sWPHMEVRRe+8806gvi7QNO2O4OBgXXEWjDFomqb6ClrWO6wZOHCgiSCI+O46KBzHrZk/f36Qvxc4dOiQy+PxbA5krIWm6RHh4eG6mnQHL8En0CRJuj0efUudx48fbzKbzYu680Lp6elLwsLCBo4dO9Y/Q9raCtXV1RRN07sDCZpl2QXjxo2j9YJWVdXja4u+2traqjegAhjjuPT09Il+eoEDaJpel5WVZfV3ZvvIkSMqQRA7AjGk+8ZzxamqGhMXF6freLfbrUmSdM3XcfTl5uZmXTdgGAZSU1PNLMvmd+Xrd9IBWk0m0745c+ZwsbGxfkP56KOPeFEU/xrI1mw2mzckJyczX9Uov5FaWloEAGjwCbQgCMXV1dWy3oeaPn06mjx5chRBEIeWLl06RG+LsdvtxydPnhyTnJxM+wuksrIS3G63Z8uWLYcDBTkzM/OF4ODgST/4wQ90j6ZaWloUjHGnoKlOWnRJZWUlDwB2vTdavnw5N2DAgNE7d+48vXz58vcFQdhOkuTnJpOpduPGjXxqamoQQmgYxjjBarUu0jTt7pSUFDYpKalbQ8MDBw6IiqL8LwB0e6PS4sWLw2w22xtms3ne008/bdHbmgEAGhoaCIzxRZ9AkyR5rKqqilMUBfTeDCEE8+bNo+677z7r4cOHF544ceLB+vp6iud5Li0tjaIoSrLb7eLQoUOpCRMmmCdOnAjdXQEqSRJ8+umnIEnSO/6cn5GREQoAw1VVHW232xdIkjR15syZ9Pz58xlfZtwVRQGn02myWCwXfAKdk5PTtmrVqopz586NHDVqlE8Pb7PZ4MEHHyQffPDBkG+bcwhwoYWPP/5YIwjiUEFBQZUOqO2apv1HH0JRlBQWFuaNjIykEhISuHHjxoHe0MM3VVNTAyzL1m/cuFH2CTQAgNfrLTh69OjvRo0adWstpvhGK9q5c6fo8Xie1unlURs2bPg2yID88c+dO4c1TesyJEt08VnmHDt2DCRJuhU5wyeffII1TSvNz8//rLefpaSkxCUIwl6/QOfn59eSJPnpwYMHtVuxNW/btk1wu92/6+1n4Xkezp8/TwPAPr9AAwB4PJ6ntm/fLuqNe9ws7dmzR5Fl+VhBQUGvV3wvLi7GNE3vz8/Pb/cbdH5+/r9VVT32/vvv3zKkGxoa4P333/cKgpDV28+CMYadO3e6BUH4/zfsI3S4lsv27Nkj1dXV9TpkVVXh9ddf92ia9j8Oh+NSbz/PsWPHQBCECofDcbDboAsKCqo0TXvsj3/8Iy8IQq++2Ntvvy02Nzcfy8nJeeNWsM25ubm8IAg/1TXq0XNQTk7O2zzP/+3VV1/19NYoZPv27XJxcXFtS0vL/EB4gd01GZs2beJlWXbk5eV9GjDQAABtbW3ZNTU1e1566SVe7/ROoLR79275gw8+aBRF8d7CwkJ3b7fmbdu2SWfOnDmnquov9J6jG3RhYaE6aNCgxTU1NW89+eSTwoULF3r8hQRBgPXr1/Pvv/9+hdvtvmfLli1XehOwpmmQk5Mj7tu3r1qSpB/4Epb1KwCcnp6+gKbpt6ZMmUItXLjQbLfbA/5SJSUlsGnTJo8kSe8pivLT7saaly5dyv/lL3/h/HGxO6JzsH79end9fX2JqqpzuqrGGTDQAAALFiyw22y2NQCwYtKkSWjGjBnmYcOGAUn6H4wTRRGOHz8O//znP93Xrl1r4Hn+Z/5uCQ4UaFEUYd++fcqePXtEWZafHzx48Ktr1qzx2Ynr9ma9lJSUEJZlf0bT9FJFUaLi4uLk0aNHm2NjY1FYWBgEBwdfF74kSeB0OqGhoQFqamrwqVOnXBcuXDBzHHfM5XK9kJ+fvzeQnZ6voBsbG2H//v3Sxx9/rJEkuVeSpF/m5ORc9vf+Ad0VuWjRoiiKohJNJtM9DMPcrShKlCAIYTRNK+gb81SaphGKoiCGYZwURVXIsnxYFMVDsix/UlhY2NIT9rUr0DzPQ1NTE9TU1EBFRYV48uRJye12qxhjhyiKbxQUFHS7Q+rx7adr1qwhzp8//x9GXJZlrbCw0HkzO7IlS5a4LRbLV+tQ4KsVtzzPmzDGQNP0FYIgTvE8f4AgiKK8vLzPA3n/Ppvq5zoteogkSd8ZZTEM05KTk9MGhgwZMmTothXqovMwSZLE9aWXtVqt7q4mUHsFdGpq6jMURT1DUZTSV0DLskxrmkbQNC0ghFSaplsQQjWyLF8SRbGYJMnDPZVksMtFGw8//DCRnJzM9rXP2OPxcIqiQFtbm7WlpSW6tbV12oULF3547tw5ta2tjcnOzv6Q5/l3QkJCPuxkb2JgQfdVfbUr1m63w+DBX26kmjlzprXjjwDFxcXzi4qKZtbX12vLli17DmO8obtBrU4jQHfdddd9I0eOTBo5ciS6nf4IDMPA0KFD0YwZM9ixY8eaGhsbp7e2tj4eHx9//vPPPz9rgO4BBQcHw7Rp0+i4uDhzeXn5Q3fddVfi2LFj3z916pTP00xG6nkdiouLg1deecUyZcqUmSRJlupdMWuA9qczoyjIzMxkH3nkkSiSJD9dtGjRQAN0D+qBBx6gkpOT+1kslk8CnvfO0H9qzpw5zJQpUwaaTKZNBugeVkZGhonjuIfT09PnGKB7UCzLwsqVKy0Mw2x+7LHHWAN0Dyo+Ph6ioqIsLS0tiwzQPaz58+fbLBbLfxuge1hjxowBhNCQG+UoNUB3UyRJwoQJEwAh9FCX4/CuftyzZ493//79Yl+BghD6umHZbDY1NDSUGjBgABcTE0PFxcVBaGioX9cdN24cd+rUqXkA8JrPoDHGr4uiuEUUxT7ZEtvb2yPq6+sHlZWVxR49enSeIAgJsbGxanJysiU+3rccAlFRUaCqapfb15Dx8X+pjhInGSzLrklISAhetmwZpzdniaqqkJWVpSCEbJ2FUw0b3aGcnBzR4XBs9Hq9d544cWLP2rVreb17d0iShODgYF7TtOFGZ6hTDofD89Zbb/3k6tWrRxwOh+iL+dA0bYQB2jfhtra2BYcPH1auXdOX0KZfv34MAIQboH1UYWGhkyCId4uLi3Ut0bVYLDQABBmg/ZAoikeqqqp4PcdyHEfSNB1igPZPtXpr7nIcBzRNhxqg/ZCmaU5BEHQNgRmGAYSQxQDthwiCiNCb7NDr9YKqqu0GaH+GHhhHhoWFMT6AbjNA+yGLxfKjuLg4XesPBUHQFEVxGqB9VGpqaryqqokTJ+rLMicIgqxpWqebTSkD6XeVnZ1txhh/kJaWxurN+9TU1OQFgCtGi9apjgD+yenTp4ffe++9uoNu9fX1GCF0wWjRNzYVYziOe0LTtAWLFy/2KU0cxhiam5s5n9OxfWWjCIIY1VfBapoWwXFcDMMw8aIo3m02m4lZs2aZZs2aRflaTcnpdAJBEN6ustB01aJ/fMcddzwZERHRpyL/HZXuqZCQEKZfv350WFgYxMXFQXfqvdTU1ABN0xVdHdOl6Zg2bZopOTmZMwxL1zp9+rTs9Xq7LMFtdIYB0PHjx0VN0/YZoHtQFRUV4HK5PHl5eUcM0D2oDz/8UFAU5a9wg0wMBuhu6MqVK3DixAnV4/H8+UbHGqD9FMYYNm/e7MEY/0FPpgYDtJ8qKirSqqqqqi9duqSrirLhGfqhL774Aufn57sEQUg+cOCAYoDuAZWWlsL69et5URQf3rp1q+7tcAZo/S477Nq1S9m5c6fH6/U+XFBQcMiX8w3QOlRXVwdvvvmm59q1a5Wapv2ooKCgwtdrGKBvAHjbtm2ekpISVVXV38XExLzpTyo2A/S3pKoqVFdXw6lTp7SjR496Wltbsaqqr5AkuT4vL8/VnWt3Cbq1tRUuXbp52YN5nr9p99I0DZxOJ7S2tkJTUxNfVVUlVVdXm2mabtQ07SOv15sniuLBQKWU6BQ0Qqj+xIkTl06cOHFTXhwhpJIkKd6klqsAgAYAtaIofiHLcqWqqhdkWT55KySZNWTIkCFDhgwZ6sao6mbdKDs7mxZFMVzTtP6apiGCIMwEQbAYY5fD4TgWqPukp6ePZBjmI4IgSIqi3BhjDSHk0jRNxhg3e73eMlVVKwDgEgBcCgkJuRyoTGA31TNMSUmJQQhN5TgugWGYBE3TBkmSFCaKotVkMglWq1UiCAJMJhOWZZlsaWlpBIDhARwjs1ar1frUU0/ZvF5vuKIoIIoiaJoGLpcLGhsbH7hy5Yqnvr5ebmpqotva2swrVqy4ghA6IgjCvzDGH/RELYGAgF68ePEIk8n0KEmSCwEgOC4uTo2NjTVHRUVBv379ICQkBOx2OxAEkPE8SwAACpNJREFUYQGArxdrV1VVwYsvvhjwxNwURWnh4V3u27F90+2ur6+PrKysXFhWVjbv1KlTr69cubKS5/kNoijmBsqB6Rbo1NTUaWaz+VWM8bjExESUmJjIDh069Otk2N8HkSQJUVFREBUVBffdd59FVVUoLy8ftX///pdPnz798qpVq/J4nl+dl5fXfNNBZ2RkDGIYJpdhmCkLFiywJCYmIl/Kht7q4EePHg2jR4+2OJ1O2LVrV1ZRUVFGZmbmH1wu18v+xj58bnrp6emLKIo6++CDD05fv369NSkpqc9A/rbsdjukpaUxL7zwgmXw4MG/s9vt/87IyBjU46AzMzOfsFqtm5955hlrcnIy051SIN8nRUREwOrVq83z588fS9P050uWLBnVY6CXLVv2a7vd/vvnn3/e/FU+z9tqHPxl8WI6Ozs7hKKow6mpqWMCDjotLW0uwzBrVq9ebfE3p0Vf0eTJk9Hy5cvtLMvuX7BgQb+Age7o+Lb+5je/sYSEhBguHgDcfffdaNasWfbg4OBtep2+G4JmWfbtOXPmsLGxsQbhb2jhwoVsWFjYxIyMjMXdBp2enj7HYrHcM3/+fMZA+91hYFZWlpVhmHXZ2dnmboHmOG7t4sWLbX11+NZdxcbGwqhRozhJkrL9Bp2amjqN47hhkyZNMoh2oXnz5lkoivrtjWw10UVrXnb//fdbvlFLzNB1NGzYMLBarda0tLREf13wuWPHjg140EKSJJBlGSRJgtbW1h55+ebmZu7ZZ59tIQiCMpvNKkmSDEEQ0L9/f1P//v3J8PBwCA8Ph9DQUAiE0zV16lTun//85zwA+MQn0CkpKTEkSQZFRkb6fXOPxwPnz5+H8vJy9cKFC57W1lZwuVysoigESZIyQkihKErSNC2gC0dMJlOFoihzL1++DJqmUQghGwAAxphCCA0xm81jEEIjZFkerGmaJTY2Vhg/fnzQmDFjiKioKL/uGR8fT3300UdzAaDT1JmoE/uckpCQ8Ndf/vKXNl9vWlJSAh9++KH7/PnzBMuyJYIg7JNluZggiBqE0JXuRsECqfT09HBN0+41mUyzAeCHkZGR7COPPBI0ZswYn7/SlStXyh6Px15YWCjobtE0TY+Ijo62+HIzt9sNGzZs8FRUVNTzPP88SZKFGzZsuKX3KDocjkYA+DsA/D0pKemnXq934bp169ZGR0eHPf7441a9uToYhgG73S5ijGMA4AvdoE0m010RERG67bPL5YKnn37a4/F43qqoqPi13sXZt5I6njk/KSnpXVVVn3/22Wcfe+655yx6CxeHh4drLS0tnYLuDObw/v37637ITZs2edxu96bNmzf/4vsI+dvAc3Jy/sftdq/7y1/+ont2ZeDAgWxHi9Y/vNM0zaa3CG5zczN88cUXmsViebIvDdsoilpTWVkp1dXV6TrebrezCKEwX0Hrzsv573//WyUI4u83Yyb5Zmrjxo0yQmh7aWmprvXQLMsihmGCfQXNMoy+8Mb58+c9giB82BedEUEQ/nX27Fld5sNkMsFXQ0lfQNM0Tet6mJaWFg1jfKUvgsYYX2ltbdV0mhqgKMrsE2iCICRZ1ldfked5RBCEsy+CJghC0ctBkiToKqdSZ6BFr1efyTWbzVjTtH7QNxV5xx136Brmer1e8DlLGEEQgl7QsbGxJoqiJvdFyhRFjR80aBCnEzSWJMm3vHckSbo8Ho+uh5k0aZKJZdmV0PeyqyOKojLvueceXZ2V2+2WMMa+tWhN0841NjbqDahAeHh4+LJly57oS5QzMjJSw8LCOL0z/vX19SLG+JJPoHmeP1VfX6/Lw0MIweOPP25hWfa5jIyMX/WFlp2SkjKfYZj/ffTRR3UH1RoaGhBN0xd9Ag0A56qqqjx6bxIeHg5r1qzhBg4c+PsVK1Z8mpGRcc/3EXBqamr88uXL/xESEpL/5JNPmqOjo/UOA6GtrY3jeb6yU3vfSWd4sqKigsYYg94Zlv79+8PatWutBw8enLRt27b9K1asaFJVdaskSZ94vd5PCwsLW27R1htDEMRMi8XyKMZ45Ny5c+kHHniA0usZAwBUV1cDwzBXc3NzhU6//M5+WL58+ZXVq1dH6P2rfvsvXF5eDiUlJWpZWZmntraWYxjmKgCc9Hq951RVvYwQqiJJ8jLGuMFkMrX3VGH0zMxMm6IoIZqmhWCM+yOERlqt1kkIodFerzeG4ziIj48npkyZYhk7diz4MxG9e/dubceOHZs2b968yqcW3QFrV0lJSVZ0dLTP01kIIYiPj4f4+HgSAIJUVYWamprIurq6yKamJnz16lWhsbFRaW5uRi6XixFFkc7IyNAoihJJkhQoinIRBOHCGH+9crNjE2Znz2pBCDHfONaiqqpNVVULxli1WCwSx3FaUFAQDBkyxBQdHU0PGjQIIiMjQW/wrCudOHHCLYri7i6Hip39IMvye0VFRYsfeugha3cnaEmShCFDhsCQIUO++orM1/GsCFEUraIoWj0ezx2CIADGWNf1GYb5j5bIcRyYzWawWCxAkiQBAHRPmZ7W1laorq6mJEk64PdFsrOzz3722WfYUOcqKCiQsrKy/npDd76rHz0ez3M7duxw621Zt5u8Xi98/PHHKs/z3csSVldX915DQ0PdoUOHNAPrd1VYWOjFGO/Tk/KnS9AHDhxQeJ7/4ZYtW7x6PcXbRRcvXoSioiKvLMuZuvqpGx1w5syZpoSEBHT69Om7ExMTaWMd3peT0S+99BIvCMLP8vLy/h0Q0AAAJ0+ePDRy5MjBpaWlI6dNm0bfLlsqridRFGHt2rV8W1vbunfeeedPukdeeg+02Wx7aZq+r6ysbEBCQoLuGZi+1pJfeeUV/tq1a3vfeuutVT4NcfUeePnyZS0oKGirpmmDjxw5cufYsWNZXzOHf59VW1sLzz33nKe5ufntyMjIrAMHDvg0FPPLE1m6dOkvEEJ/mDt3LjV//vw+bbclSYIdO3bIe/fuVRRF+ZXD4firP9fx2+VLSUkZbLVa/8qy7PQf/ehH5sTERNSXzIkkSXD48GG8fft2XpKkA+3t7Y/+7W9/q/H3et2OHaelpU21WCzPY4zvuf/+++mpU6dSgwYN+l6biMOHD8tFRUUKQugwz/OrA5F9IWBB+sWLF4/gOO5RhNDioKAgdurUqea4uDhq2LBhoLdoTG9IEAS4ePEinD17Vjl69Cjvdru9mqblK4qyIS8v73yg7tMjsyGpqamTaJqew3HcbK/XO9ZmsykDBgyAqKgoS3h4OBUSEgI2mw2sVivYbDboyU7V7XaDy+X6+p/T6YSGhgaltrbWc+XKFWhvb6dYli3tWF78QX5+/mc98Rw3Y9oJpaWlxSKEhgPASKvVOgEhFAUAdyiKEizLsl1RFBPHcaLZbFZsNhv+apxus9kI+HKSFHEcR16nNaqKouCOoZcK8GVaCJfLhXiepwRBMJEkKTIM004QRCtJks2qqla73e6TAFAOAOe2bNlSATdIG/99AX1DJSUlUUOGDAnDGIdqmhaGEKIBADDGIR3/U9dbboUxdiGEFAAAhFArAICmaQpCqIkkySaGYZp7akLBkCFDhgwZMmTIkCFDhgwZMmTIkCFDhgz5pP8DdvGwBjR9oMYAAAAASUVORK5CYII=\">\n\n    <div style=\"    height: 100%;\">\n        <div id=\"splash-app-details-container\" style=\"height: 88%;\">\n            <div id=\"splash-app-logo-container\">\n                <img id=\"splash-app-logo\" src=\""
    + escapeExpression(((helper = (helper = helpers.iconUrl || (depth0 != null ? depth0.iconUrl : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconUrl","hash":{},"data":data}) : helper)))
    + "\" alt=\"app-logo\">\n            </div>\n            <div id=\"splash-app-title-container\">\n                <div id=\"splash-app-title\" style=\"\">"
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + "</div>\n                 <div id=\"splash-message\"></div>\n            </div>\n        </div>\n\n        <div id=\"splash-app-details-waiter\" style=\"height: 88%;\">\n        </div>\n        <div id=\"splash-capriza-logo-container\" style=\"    position: relative;    height: 11%;\">\n            <img id=\"splash-capriza-logo\"  alt=\"logo\" style=\"    float: left;    height: 100%;    border-radius: 16%;\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH3AwfCxQYVTV83gAAHgVJREFUeNrt3XmUXVWZNvD33fsM95w71JSqVJLKXBlrSEJICDEDFVQGhY5oUBQFWwFttbVVVGwb2hY/P6cGtRe6RG0n5COo2ChoGkIlKYhBQhMSAoQwJJAQUkmNd77nnP1+f4Sm1UYXSW4lN3Wf31qshJWp6jn7PGfvc89ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAqMSKA0Wiwp6POCTkeCsU1SUKIa1lT3Ii4r+XPK6FAiDJ/urPIYEgyyBQbTFJykLs2hCgAgBEmWxf66eFgImsZy0QTSWgs6fhk0k6zEtUoLA1kolqRMElSjJMJHVZukZQbsnKNWH7EKm7I8kmp2MtjnplY26/+D0aBkYA4yishExGJEBFJMMwcZS2J8raYvMukS6KcHLOVIdZDxGpITLhXovyzyhT3k1IvckQHiWm/l7QP8ukPBygAgD/f3zaf6WUKuWlKy3QxNI2VNUN0rJ3FTCUTNAoZS9k1eXbGGI6N1xwb77E9RrNdS2TVENspYitFbNcc+X/tn5ivO8oShWmScJgkTB/5ebGXTKlPpLA/L8WXAlPqJSoetsRkPFKxDLHzAkm0g8Lso6LkKYr0rkQh+zSf/3QRBQCj/kieSxfnilJtRNxBOr6YJJxNUamenfosey2R9qY5HJ8WV7EWYm8isdtIbNWMgu/ekJT6yOT2kuT3ksk+UzLZp/KSe06bYMAjFetn5TwtUbZHmcIWtuRhb9nO51EAcErq7W5LxFgvUCSLWPvLiWixmGITu01Z7c8kVdORUP50zfEZpGItRKyquBkDMvl9ZHLPkMnsEjO8LWMyT2iKioYsf6eEuY3KFLZQpP/gn/3ofhQAVJzB9e3TLcXLScdez0ovk6g4gWPjM7rmNFvXzI+rZDspfxoRWwjrNfdCP5n0k2Qyjxsz9Eg6Gt5hEQUZIbWBosxvLSU9seU7nkUBwAk33N0xWzN3kdNwoZjcmSwqpusWiqpdEtPJTlKJWUTKQVDlXkjknyczuJWigQfy0cAfWKRUYLY3UTR8Fxu+2+/avg8FAGXXt6U15RViZxsrdRGROY9J+7puMenaJZ6qXXjk6I7hdOILIfccmcGHKOrfOBwNPOiKcvZwlL9VouBXiVU7H0UBwDEb2jh/hsVqDen4xRTmZqua9pJu6ErouqWs4jMQUAWeS4gGH6bo8PpCeOieUEw+z8S/lCB/e/zwrA188e0RCgD+qsym9k6R2MVKO5eSssdYjedo3dAV0zULiJSLgE6l2UH2GYr6uk3Qe3dG8vsMMf1IgtLNyVWP7kQBwCvS981rY8u+jFlfyjqe1E3nO1bTOY5KtmGIjKJzB+FL/xGGL/2iKBK8SFHuJiG+BVu3SuXvb5sUmdi7mJ0rSDtN1tjVjjX2fFvFZyKc0V0FFA0+TOGBX+Siw/cpFEA1LRG7p8SynFjDVs3HScLZuukcscau9nTNfBzpq7ILCtjq1WCou63Vsms/RqZ0uUp1sD3hUl83LCNiG+FUOVyVMVqP9kIqt6nzzWQ3XEtRod0a9xbLGnexVt5EhAOvwAxgFE7zc6r2PaRj17I7tsae+L6E1fhGnMEHFMBolls/b4I4/rVE0bt1w0qyJ77XU4k5CAawBBjNMve2j2U3da1QdLnVdK62Jl7uKm8SggEUwGg21N3WalmpLxHTm+xJf+tY49+hWccRDKAARrPspjnjSNV/gSR8pzX+YsueeLnNdi2CARTAaCbrOuM537mGhD9mjbtI2xP/NoYdH44XTgJW+o6/s83J9bmfJLKusZov1PaUD3nY8QEFUAXSGztXKRX/nopPbXJa/zGuknMRCqAARrtcd2eLOLXfI7ZWujM+G9NjzkYogHMAo3663z0llrXGXSdkPmpPvsK1x79D4RFagBlANUz3N7R1KZ38sUq2Nzgz/8nDZ/mAAqgC/fcsrHF879tM/BZ35nWY7gOWANUis3H+ZaT0N+2xq11n6odcUjGEApgBjHbD985u0F7jj4is17uzr3d1/VKEApgBVMVa/76OlWx7v9QNqxJO69UOLt8dWRIMkpR6SQovkZR6yRR7iUyJKMqFYgoRRfmITFFe+QPKMaRcYeVpdsfE2K7X7DQQ2XWkYi3EbhNmAHAMA7H7LCtr5a5n1n/vzvqip8d0IZTy7ulkMk9RlN5JZnhbwQxtC0zxoM/MAelYH7G1n4T2mjD7FFMxLSJ5xVwQIzlhfuW9fMzsM4krxJ4YqlOW10zKbSZWTWSCqWQKdeQ05LU3lVTtaSmVaFMqOZfYrkMBwKvLr58z2bi1v1LxGTPduV/z2WlEKGVgcs9S1Ncdhb2/TUtujy/a30tiHuRouIeM/JdfUk/wOduzZe2ZtWt0YeyuSSYyc8X2lrH230BBup3dhlA3nO3ohhW2rll4yrwUBQUwwjIb299Iyr/dmXyVb0+83CJSCOV4dvr0TgoP3lWMDq0LxOSyZOj2KMrflkxaD56s12/L2jU63/zUQhF9Hun4RWQKM3XDysgad1Fc155R0e89RAGM1KAQ4tz9i/6RlHuN2/ZNX9csQCjHKspT2PtbCfb9KCOl3hxFpW8bE/4i2bX9sUr8cofvnd3AlvtOthIfYpKJdsu7HGv8JVYlLhNQACOgt7stEbdr1yqvZYXb/q04pvzHuqwfoGDvd4rhgTtItL2Fg/SX/ZU71jGTOVW+h3R3Zztb8c+ylC7STeeJM/mqGMdaUACjdr1/f9skQ6lNVtP5zU7rZ1xcynss8/wSBft/aoK93y2J8G1acp/3Vm5/7lT+lrKb5owTil/NRB+0xr9d25OvstlKogBGk+zGeQtEeevd6f9QY427GIv9YxAevpdKu/9PTkxxq5ihDyZX7Hx8NH1/ue7OFmPHv85CFzozrnGtsRcwCmA07PwbFpxH2rndnfPluG5YiUCO+qhfpOLuLxSjQ/f2S5S9LHHWY/eM6vFyX8dCchK3qWTHOHf29SftkyEUQDk2Zs+iK4mdG2Md3/ZUqgOBHO2+n3uOio99JCfB4LocHb6scdmudFWc49i60M4V9D8T6Y+5bTf6unYxCuBUk+lZ/HHW/vWx+T/CHXzHNuWX0pP/lBOKPpJY/tC/V2MG6Q1tXUp5d9rTP+7b4y9RKIBT5ci/afFnyUp8zlvwE49j4xHI0e78B38jxd3XD0hQWPHHr6yuRsP3dc7SdqzbmvCeRmfqhywUQKUf+TedcYNyG66Mzf+xz04DAjlKwb4fh8Gem3oVZ870lu18HokQpR/obFImtsVuefcEe8qHT8ilhDhTfUxH/kXXKqfmqti8f8fOfyw7//6fhcGemw6p0vBS7Pz/I/m67b1scitL+34yEB76nWAGUIk7//2LryIVv9E77dYYu2MRyFGK+jZK4fGr+1VUnO93bd+HRF5ljG2ct4DY7Ymdfnt8pM8rYQZwVBtmwYVE9g2x+T/Ezn8MTHY3FZ/4dJ5N7jzs/H9ZfOWjjxAFVxcf/3iGSFAAlWB4Y/tS0t6tsXnfw9n+YyBBPxW2X5kVU7wiftbOh5DIX+cvf+Q7pvDinvDQOkEBnGT59XMmKx2/223/pq8SsxHIMSg+cU1OwvzNiZXbfoY0XsPanElMmP274Jmv5kgMCuCkHbnWdcaNW3+fO+0TKV2zEIEcg/DQOjFDj/bGGzKfRhqvXeqs7T0SFZ+JBh5AAZyUnX/tGp2Ne3dbTeeNt8atwQnTY5r6D1Bp1+eLZDIXc9vOEhI52vyGbwj235JGAZwEueZnP6u9yac5rZ/C43qPUemZrxeEzFqs+48xv9C5wwxudUkiFMCJlN3QtoiU/Rm37VsJYhuBHAOTfZrCQ/8ZBGHxo0jj2NS/4eEhUu5LJrsbBXAi1/2k43c4M6/zRttTYE+kYM+/5VjCr9R1bRtEGscxHol/b9I7UQAn7Ojv+z/QY85usBrPxbr/eI7+A5tDvxDdgDSOswDCzFNSOiQogBMgs6H9DazsNzut12DdfzxH/73fzbGYG8v9VN5qxCL9EgyUUAAj3bR3t7qs/B+4M//Zr4THNZ2yOZYOUdTXTcUi/SvSKEMBkClIVIhQACMsl6q/VtctqtdjViGM4xAevDMS1j+vf8PDQ0ijDIXKnGIr5aAARlB+/ZzJJPQxp/WzPtI4zun/gTuyEuR+gCTKRdeynRqRZwTgkbUvM279N+yJl7l4sMdx5ph9hqR0uJTo2tGDNMq0BLDjrSN12zlmAESU3dR5GrF6g93yHo00jnP6/9IdRZLw5lPp2f0VvwQQnsveVBTAiAWsEl+1J18ZI+UijOMUHfpdiaj4/5BEOadVxUnKm4gCGAm5DR1nMusz7XFrUIbHW6TFl8iEwxJf/tgOpFEe6Qc6m5iVzc4YFMCIlKuV+rw9+QM4+pfj6D/4B2LlbmImQRpl2kGLcqZKzC2O2N9fzeEWejqmsYTL7HEX4Yq/chTA4e6MBEO/RBJlnFXZsS5dvySJAhgBocQ+YjVfpEjhor8yzQCUZt6AJMqH2e1SyQ6FAih3s24+0yOi99ktl2LuX448C/tITJQ/1V/iWUn6trSmyORnj+Sr5au2ADJB+gKdbDf43L88TGY3kXYfRxLlE8t7q1SiLT+SM9SqLQC2aq6yxr+tBsOsTAWQ3WUoyvweSZRz/Z9Yo5vemBrJf6MqrwTs29Ka4lJxqW5YgVFWthnAE1mSYDuSKKOotCo6tC5LEvoq2al0cg6VezZQlQXgFv3Vuu6MiHUCg6xcYzXzpFBkHkMSZTr6C/HwpmgFDW9bFA1vP4NVbBlJMIecprxVcxqrmoW1Kt7K7E8jthIogKOa/uvUJbrp3DiGWblGa0hSPOTHC8UnEUaZxiiTEG3bTUS7iehnRETSfZaVLe2bG/buW0T9G5YSW/MlLExnZWv2pwQ6OTfG/jRPOU1ETj0pp4nYaaC/do1L1X3+LUIq13P6kHfG3Ql2GjHSypFp8QDlHnpLf2L5g3hR4kkw2NNRp4zM0cJtov021t50IplMUalRTL6BlS2kEwFpL2TtCek4KR2XqpwB5Ho657PTINj5y1gApT4itg8jiZOjdvmOASLa/PJ/r1oQsahQFwWqJhRJaJJEQJSoygIQUudYDSsdDJtyzgB6iZgPIImKLoiBV/u16vsYUCdfr2pOx8U/5SyAoI9IIrzs8xRUfQVgSp14v1+ZIy0eFgmzzyAJFEBF679nYQ1LmFLeBGz5sp4DeKlAJC8hCRRARbN1aT77U3K4C7rMgnTIYtIIAgVQ2d+sptkqPgsnAMs+BSiKkCogCBRAZY9TtiYrb5KHzV7mXKOiKKYikkABVDTW8RnsNuHhH+UuAFMUIYMZAAqg4r/dyeyOxVYvN1MggyUACqDyD1XhWFwBOBIzgIAtxVgCoAAqfKBK5LPGi39GIllkgAI4FeaqDp7/V36sPYqiCM2KAqjwgWqMQxpXAZc9V+WzEsLt1SiAil8C2Izn/5e/ACyPDSt8vIoCqPSRSoLl6kiMIl+xwgwABVDp+z/rQAxOVped5WsRwjkAFECFLwFIl3C9yggMInesS6xwhxUKoMJnAEoXJcpjq5c711iLUjoxF0mgACp9BnBYSnhy1QgUABHTDCSBAqjsgUq8R4p4clXZB1FsAklUbEESKIDKngGY7C4pHMDHAOUuVreRSMLEy+9bBBRApRZA6TlTeAFnAUdgGCmnIZ8NMq3IAgVQuQxvj4Z3lLDZR2Ag1S62RHg5kkABVKySn39E8nt9kghbvsx07SJPWclzkAQKoGI1LHl6mNnpM7k92PLlHkg1p5GY8HVIAgVQ4d+x2mrSO7Dlyx2rN5GY2c91d+LTABRABQuHfxUd7s5g05cbk649LTSKViELFEDFEiN3RQO/t3EeYATOA4xdnWSd+iCSQAFUrETXzpdIWQdMGq+yLzerYTmRKc5Pb1qA566hACp5FlBcG/auw22BZR9NMdL1yyMi83aEgQKoWCYMfxAe/I+IxGAElHsW0Pw3caWTVyEJFEDFSq3avktI7YkGtmAElPs8QP1SIjHTMpvaO5EGCqBisUl/Kzxwew5DoNzBWmRPfK/LnLgOYaAAKlY2Cn8a9W82UsRLbcu+DBj/dk1kzhvaOB+3CKMAKlNT186MkHwreP77uDmo7JOAJNmTr3IsHf8G0kABVK4o983w4J1GQrzZutzs8ZdoYl6Z3dC2CGmgACpSomvnS8L69uCFH+AOwXLTHjmt13hkJX8m3WdZCAQFUJnTVTN4TbjvlkCKBzEayn0uoOl8VvHW5pzKfA5poAAqUnzFEwdI5Gulp7+UxXAoP3fO1xOkratz3Z1LkAYKoCJlTf5rYf/mwAzjLsGyz7DcJnJmXueJFfv5YE9HHRJBAVScpq6dGZLCh4tPfCpDEiCQci8FGs9lq3l1o83JO2XtGo1EUAAVJ7Fyxy0mHNpa2vPdEGmUnzP9U46Kz1iQbX7h+0gDBVCZYUTp94T7flg02d0Io+xrAU1ux01x5U94W2bToq8iEBRAxfFXPvYCiflEcec/5PAKsZHoAJ9i874fV17LB7I9Z3wfy4EK2CaI4H/L9Cy+zapfeoE79wY8534kmBIVH/9ENhrc+miOB85tXLYLV2JhBlA5inb/FVH/5v7w4K9xv/CIjDqH3LYb4rp++ek+NfQMdy8cg1BQABWjYcnTwySFC0u7ry+azJMIZETmnha5c7/sWM0XzVaWfiqzsf2NCAVLgIqS3bjgQrL8W73T1vocG49ARmpFMLydio9/PCdh7u5sOPzepq6deGgrZgAnX3zlI3eSCb5S2PGBrER4dMCIDcJUJ8UW/tzXtQvfFLeTO3DV4ImRWz9vAmYAr0Hm/jN+opOdF8U6bvKJcV/LSAoP/lpKz3ylQCI9USn996lV23chlTKP5/va5rGd+hyZ0gUogNdAus+ysnb+Lqtm8evcthvjxJg4jeyaoEDBvp9K8Pz3S0JqLcvAp+MrnsB73Y9zDOfk8Dnk1l1HIp12y6WONf5iRgG81gDvbnVzqTH36vrlp7tz/m8Mq6cTkHkwSMGem4rhgV8SKftOlvzX/BWP/gHJvHbZ+zoWkuW9X0guYa+FnZbLUlbTeUTKISKcBDy6Abn5TC8XyQY9ZlWHO/sLHkrgRBVBP4UH7pBg/08LJPKimPQX42H/rdy1B1dr/XlWQirX0zmfyFtNynofW/Faq3l1TDe9SSlv0v/6/SiAo9Tb3ZaIW6mNun7JXHfOl2PENkI5cWsDivrup2DfjzNm+FEm5a430dAtJbfwu4YlTw9X7VH+/gXjJQjfyFbib0SCs9lpEGvM2a7VdL6rkm1/9c+iAI5xJpA1dLdOzDkj1v5vHmlcMHgyZgVR30YKD60bNoP/5ZB2t5kg8xNSwYbE8p1PMtOovIhL1q7R2eYn2lh4iSi/i4mXkQSNum5xUTe8PqXrlxK7za/570MBHOuG2LrQzuXt29ibeE5s3s0+WzUI5aRNDIoUDWyh8ND6XDT4YEhBn03a32Gi9L0qCn9vtP1gcsUjh07FI7sphTMU8wzRXhtrZwVFuTnkNJR0ar5SNQuTOtlGKjGbiI/ttgoUwPGut+4/4ztsJd/ldt7sK38KQqmE7RKmyQw/StHQtiAa3JKRzK44kZREuXtIosc4yu8wJLtZzO6A7D11XdsGT/jXeHerW4j74wPDE5ikhVnGsbKmkoq1EqlZYnItrOIl9ieWtD/D5cSsuErMIpWYQ6z9sn0dKIAySG867cOK7a+4bf/q6bqlCKQSS6HYSya/lyT/PJncs8Uouzsn+T2KSn2eiFGknGFWdj+R7iWhgyLF58nkDhARiaGsUlQiktAIv+qNS0q4hpS8clZYiOpIeU2knEYWbiA2dUJUx2JSYoIEmSDOVipPzpiSjjUrjo13ONbisdvMyp9MyptCJ2JpiQIoVwlsaOti7f/KmfrRuD3hXbjN9RRbQkgwQFI6TFLqIwkGj/z8vx8XH2YCkZIhiYTC9Ku/V95OWX/8qRDbdS5bKWIrSfTyj0d+fuRHdhoqYvdDAZTR4Pr26bYTv0fXL2t2Zv2LV86pGgAK4FSYat7d6uaSjd8k7b471vYNT6XwjkxAAVSd7Mb5VxJbNzozPuNazW/FFUOAAqi+Epi3gFTsN7pucb0z819ibNciFEABVNWSoHtKLKvHfomVutKd9UVfj+lCKIACqDaZ+zrPJjv2M7vpgrjTenWclItQAAVQTfq2tKbcoOk7SscucGZfn9B1ZyIUQAFUm+GN7Uu1jt+ikp1j3FmfT7A7DqEACqCqzg1sPtPLBoXrmO0POa2fjFnj3mrh9mJAAVTbuYFN7Z2sEj9ku7HVmXVdUtcsRCiAAqi6IujueD3b/s0qPqvRmXFtXMWnIxRAAVTbsiAXRZ8ikk9Z4y+x7Unvt9lKIhhAAVST7KY544RqvsQsa+xJV9h2y6U2PjYEFECVyW1sn2hU/Homeqs9+f2uPeHdFooAUADVdn7gvrZ55NTcoJRzuj35A3GrebVCEQAKoMqkuzvbleVfSxK92Wpere3JVzjsNCIYQAFUVRFsapurOPV5kujN1ri3KrvlUgfvLgQUQJXJd8+fYpT6JBFdruuXRvakK1J4/gCgAKpM/z0LaxwnfD8p52qOTXCcyVfVWmPOZryzAFAAVUTWrtGZMbtWKyd5DUk41xp7obLGv81V8ZkIB1AA1aTQ0zEtEPd9TPoqjjXZ9oR3Jq3GcxkPJQGiI09JDg/+OkABjPYNLaSyG9vPZp36O5LiuSo1r2Q1vyWlx6wiPLS0ykR5Cg/fK8GLa4ck84RFzLehAKpIb3dbwlf6IuLY+1iCM3Td0pwet7rOql9GpGIIaFQeAQxFgw9ReOD24ahvoyWsesTkvpvIFu7i858uogCqVHbTnHFirHewlbyMTGGOql1UsJrelNINKwivOTvF9/kwQ9HAAxQdujcX9fcoYetZCTPfEbFuTXU9fBjnAOBPpDctaOQofBPbqUvIFJarxKySHnN2UtcuUSo5m/CcglNgpy/sp7BvA0WH1mVM+nGHtL+VouGfkFJ3xpc98uJf+nMoAPjTgdQ9JZaVmpVsxy4k1m8mE47VdYsiVb/C17WLSPlTEVIlbKdiL0VDD1E0sDUwg5tLUupj0t5/mtLwLQW7uK5x2a70a/l7UADw15cK//3ueafmrRKVljMrV9UsMLpuia9TC0gl5xCxhaBG/Ai/j6LBhykafLAUDTwYUjikyIo/LOHwXcpEGzxpeIi7NoRH+/eiAOCoFHo6poWGl5FOnsMiK0QKY7U/vaBqFnoq1WmpZBspbxKCOvZdnUz+BTKZJ8lknhQzvC1rMk9ZYkqB0t4fTDT8GxbZ6B+cuZ0vvj063n8NBQDHZWhzW70u8UJS1umsalYQlRaQmBqOt+Z1cq6n4jNi7E0lFZ9ObNchsD/e1YN+MvnnSXLPkcnsiszQtpzJPeMKqxxrf6dE2fslKD5k2/JIbPmOZ0fia0ABQNn1bWlN2QV/nhbTRnbqDGJ7PkXZGUTKYm9SScWnWuxN9ZTXQhxrIeW10Oi8q1FISv0khf1k8nvJ5PdGkt2di3LPGSoe8EgkEu3vY+KnJBp+gCR8WNh+JLnikUMn6itEAcAJk36gs4lKZq5SNE2UN5OV3yFkpnNUnCASesquzbMzJmKvRbE7weNYs6XccUdeqW2n/uf12jpxkvZnQxJliMJhkjBLEmVffqX4IZJSn5HCgYIpHSxJsZep1G+JyXrMdk6Uu5+Jdpkou50lekqJ2h2S/fSffyR3MqAAoDKOlVsX+ul0aRIrHs9ELSzUQsqdIspuZeJ6IqkViZJsSnGhyGHll0h7ISvHiHJE2TVM7BDruCIrqYk1ExGxihEpR1713wzTTGQMiQnIFBSZI1fGioRCUVpMMCQcZpWYgpaoYJOEmpVTELayzFaOlM4yyYsi5nkK0nuIo/1k6CCxHGTRB7ymqJfbdpYqOXcUAJx6ZdF9lpWmdK1jlVJByL4ScYWpjkVco9hXLCki1kcO2uyTEvcvDP5BIpIjv09ywlw88gsSseFhFhqIbJVWYTgcL+k0n7M9i/QBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATqL/DwAPZvtZ73WWAAAAAElFTkSuQmCC\">\n            <img id=\"splash-capriza-logo-extra\" alt=\"logo\" style=\"    height: 100%;    float: left;    margin-left: 15px;\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAYAAADktbcKAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH3AwfCxM7uBObawAAFUpJREFUeNrtnXt8HGW5x3/PO7vbJBuqyKWtp2Bs08xMktZgQItCjRWpWCkVkKuoXPxU5MCRi9ykIHz0I1RBEFCoinoAuQmUcvVS7SlHrbQ9rW13Z3bZ1qLBXrjUYkKT7M4854+dYhua5N3dmSRdn+/n0z+afeed9/b85r0+LyAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIQsSQFIEwkrS1tb2zp6dnMgAw8+ZMJvN3KRURAKHKaWlpObRQKCwgohMBxIM/M4Dnfd+/LJvNrpBSEgEQqpApU6bYhmEsATBhgCA9zHxaJpN5QkpLBECoItrb2+u6u7vXA3jvEEF3ep7X/uKLLzpSatGhpAiE4aSrq+s8DeMHgNpYLHa1lJgIgFBNXU6iT+qGZebjpMREAITqYnwJYQ+YOHFirRSZCIBQJTDzGyUE7+3s7OyRUhMBEKqlwSm1vITgy1FcGhREAIRqIJ/P3w2gT7O3cIeUmAiAUEXkcrkNRHSJhvHfm8lkfiElJgIgVBmO49wJ4AsAXt9bJ4GZF0yYMOEcKanokY1AwogxadKkd4wZM+YEAO9n5hgR5QA87jjOS1I6giAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAImoS2E7ClpaXZ87yjiegDzNwIoAHA/gD2A+AB2I7i1k8XwBpmXlVfX/+bVatWvRlWGmzbnsDMxwLoAPA+AM0AxuwWpBOAA+C3nuc9MVrdTVmWdQCA4wHMAnAYgMkAYiiejNsO4GUAOSL6k+/7SzKZzMqRSmvg3++UIK2HAhgX/PQqgBcA/KZQKDyYy+VeEXPbk8bGxrGxWOwYAB8F0A6gNbCXXbxGRA4zPw/gKdd1/4iQT0dWJABNTU0HEtE8pdSZzGyXEcVOZv4lgAcmTJjw2NKlSwtlGv5sZr4kMPxSzjcsZ+Yb+zufNE3zo0T06BDPbnNd19rbD6Zpnk9E3xzi+Wdd1z2zXz7ez8zXATgO//KUq4NLRAvj8fjCtWvXdpdZhhcz8/whgi1yXfcc4K1tvLcws86e/T4AjxqGcW0qlcpZlnUhgOsHe4CZn8pkMp8bwHAOisVimVFo0yuTyeTsVatW5QcL1NzcfBgzX8XMxwOoKSH+F4noVqXUj1Kp1FsnKqdOnbp/Pp/fMNTDzNza3+16rALluhbA+QDqmMsWpVoimgtg7pYtW/5i2/bNwUERXQGylFJ3MfNHynz/dCJaZFnWMsMwzk2lUjkAIKJ40HsZjN6BflBK1TDzUM/X716BhULhO8x8dpmibDHzLX19fVeZpnlFJpP5SakRMHPtUHkmouSuBuz7/mJmnqgZfQLA6Z7nnWzb9nTf92uISOtde6OmpkYVCoX9R5nx/zUWi501mPEHH8xbfN//bJn1PIWZ7/Q87+Lm5uZz0un08wDg+z5ptFd4nve2j2PJpwEtyzopFou5AC4FUBdiAb6Xmb+pG9i27S8rpVYD+EgI757hed4a0zTPHO5WY9v2jHw+vy74klY6JDuIiO6xLOtR0zT3iyK9pmnO9H3/eQATy3h8jeM4q6uwN99tGMYJ69ev3zpIPR+jlEoT0Vkh1HOj7/tLTdO8ARWe6NV+uKGhoca27R8D+AUG9uc+LPMWlmXdwcx3lth9GookEd1n2/Y3hisjpmmezcxLAPxHyFGfSES/b2pqCjVeZp5GRIsAJMuM4iZUn4cfn4jOSqVSawb5aH6RmZ8FcFCI71VENN+yrMd93x9TbiRaQ4CmpqYDDcN4mpk/MMKFTbZt38nM50f1Amb+GoCjhyEvRxPR8YjuSPZUpdRvbdvucBxnc0hxWhU8u8J13UdRfdzgOM7jg3z5z2PmuyOs5znM/M7IegCNjY1jR4nxw7Ks66I0/t2HBMPwjv0RvT+GJmZ+btq0acmRrjtm/kYVGv8DruveMEgPb07Exl9xe1VDGP+YWCz25Cgx/mMBzIdQKtP6+vq+P8JpWJHJZBZXWbmu6OrqOnegIY1pmu8F8DOMcq9bgw4B4vH4d5m5VHXZBuBpZn5BKbUVwD+DL8DBRNQWLH2U1JUMbpD9cRmFmQHwGBG5nue9opTymflAIjoEwKcAHDlKK2gLgCcBrGDmbUqpbmYeC+DdAGaiuOZeygTs50zTfDRCI+QgzXkU/f4n9hi3EX2ryoz/ZWae29nZuXOQ8fk9AErtmm8mokW+768kom1E1APgAN/3xxPRxwF8DOHOew0sALZtf7rE7naWiK5wHGcxAH+AMD8HcHlzc/PHfN9fAOD9OhH39PRci9JmndcS0YWO4ywbJMyNjY2NE2Ox2AIAp2F0uEd7EcCVrusuGqQM72hpaan3PO8qAJf1N7ZBuKOhoeFXmzZtCtPP/koiurmurm7xrg1dDQ0NNTU1NTMAXARgNjOvCfITGj09PTtjsdjCEKMcA+AszY9Bn1Lq9HQ6/fdBuv5noLgnRdvwAVzmuu6Dg9T7bcFw/GoiuriEei9dABobG8cy8+0lxPOdZDJ59VAbIHaRTqeXdHR0fHDLli3zAVwzWMG3trYeUigUShGim8ePH3+lzqaiXC7XCeCMpqame5VSD2O3tfkRYGEymfxPnTJMpVJdAL5m2/YDzPwcNFYRiOiQ2tra8wF8N6T0fnf8+PGX9y/nQGB+BeBXzc3NH/M8jxHyzH8ul3sDwLyQoiPLsh7W7Qky87m71t/3Rnt7e7y7u/v6EuZGnvE87/QgTzr5vrK5ufle3/efBvCeSjO/10zHYrFLobc0xQAucl33q7rGv4ulS5cWXNe9johOAjDgVymfz1+g2+0hoitd172s1B2F2Wz2Wd/3ZwJ4bYSM/0bXdeeVWoaO46z3fX8GgJc0G9slHR0dsYothugR13UvHaqc0+n0kkwm89vR3Je3LOsqACdrlt9NmUzmvsHCdHV1zQUwSfP1P6+vr5+rY/z9yjXFzB8CkA5dAIKv/0Waz3/Ldd3bK0mA4ziLAJwCoLA3NSUiXffQ9zuOc1O56chmsyuI6LwRaINPua57dQXp3qiUOnVv5bcXJm7evHl2hel9E8B/oQrW803TPAWA7urE4kwmo1NPuj2TPxcKhXNKFf23Jrcymb/7vn9SUB/hCUA8Hj+FiHQmL37nuu61YVSE67pPEtE53G9PcVdX19HQ2DzBzH/r6+u7oNJ0BGL0k2Fsg6/4vn92pcaUTqf/xMxaE21KqZMreRczPxrivoKRNP5pRPRjzbmfdYZhnDnI+HxXb+IAItLZmdqnlDozl8v1VpKHbDbrEtHloQoAM5+u1w74Kyie8gsFx3HuDSY3du9qal0lTUQLNm7cuCOMdBiG8XUUZ7OHgx9ks9lXQ4rr2wB2aFTcJwEYZTcYpR7b141/8uTJBxPRYs05n1cAzAnmXYbiWOhtrnsgnU6nwshLXV3dQgB/DUUA2tvb6wAcpfHcY5lMZm3YFeO67k/7/Wm6xmOvJxKJ0L7aqVTqrwAeGYZ22BeLxUJbn89kMv8EcI9G0HfZtm2X+57gaOo+S2Nj45h4PP4Y9CbQ+nzfP9F13U2aH6IPaob7Tlj5CYYQt4UiAF1dXdOhsbxARPcNQ10Rimfhh+K5co/ADtLIF0WeOaIXBjs8UmacD2vm7/Byhyyu6762LwtALBa7G8CHNcvpS9ls9n914/Z9X2dZO+s4zvow8+T7/qJQBADAVI1n8r7vL4m6omzbHg+NzS5EFPosczweX4aIJ7l83/9d2HGOGzduJYKNV0MwpcxXbNyXjd+27a8A+Lxm8O+VeqyaiCZphAnddrLZ7EZm/lvFAqCTAQDZoLuJiA1E6ySb53mhD0WCL3PUE13rw44wWJZbp/FlO6TMV7yxDxv/bGbW6noz8zOu615S4isMFHdBDtWu10aRPyJaE0YPQGfGfcsw1ZnWeXalVCSupph5W5SZMwzjtZFK91DOOAaJu3tfNP7m5uYWZv459CY/s4lE4rMocYLbNM06zfhfHU3ttX8PoG6kMrAXw67VCVdTU/OPiBT19Sjzx8zbI0q3Trx1ZdZJ375m/E1NTQf6vr8YwFiN4NuZec66detKrptCoaDVXg3D2B6RvbxesQBoNrDYcFQcMxc0C35MREmI9JCQ53lGROWm8+X6t7gWvqOjI6aUegB6O/MKRHRqJpMpy9dgTU1NQbN+aiKqd1VxI9fs4h04TD2AnTrhent73xVREg6IMn9EFFX8OvXT/e8gAFu2bLkZwDGa9fFVx3F+Xe67duzYodVefd/ffzS11/6qoTMuHTcclZfP51/VFIrxESUh0nwqpQ6OSFjGaYT5R7Ubv2maX0LxRKIOdzuOc2sl7wuOBusI64SRqnedHkBOp2xbW1sjF4GxY8e+pBn0QxGMGycBODjiLB4ZdoQTJ06shd4R65eq3Pg/SkTf0wz+u2QyeWFIr35Jw1CPjCDLipmnVywASimd00VUKBSOiroSg/PlnSNRoIZhfDjq/DFz6H4Hx44dezj2vAhloG7ohmo1/paWlkYiegQa9yoQ0QYAnyn3QM5e6jQ7EsLf0tJiQcMtuI4ALIfeqbIvRFR/Rr8C1bnx5pjJkycfHLJxnjIcbdU0zWlhRuj7vpZbcyJaWY3GP2nSpHcEM/464+EdSqk5Ie9s1CnX8aZpzgwz357nnVp212H3/wQHHv6g8dzspqam94Vt/KZp3tVPkP5H47kxiURiXmhW2dLSDGD2cDTY/oefKuz2vltTmF93XTddhfZvJBKJBzVvqPJ83z89lUqFWg6GYSzTMjqlLgrrncH5nS+HIgDB1+8BnbarlPpeGM4ldsVnWdadRPSZ3f+Yz+ef1PxifyUkH/jked5NGL5lsjPCElIi+rZO9x/ALxHiKc7RgmVZ3wDwCc3g87PZ7LNhpyGdTv8BGhPpzHy8bduheJ7u7u6+AhWszL1NABKJxEPQ2/I5Y+vWrV8PsfLe9hXP5XIbiOgFjSjepZT6b1S4dm+a5jwUnYUOFwml1P3B5F0l6f4sgDM0heKRajN+0zTPAXClZvD7Xde9MaKkeJoHshQz3zt16tT9K7SbIwFcXUkcbzOYYBeU1jFVZr7Ktu1KHBIo0zRvGiITus4fZ1qWdQ/KPOtumuYcIrplBNpvS319/UPlikBTU9NxRHS3ZvDOcePGPVlNxm/b9nQi0r1PcnlPT895iPCgl1JKt70ems/nn540adI7yjT+qSje0hULVQAAIB6PL0DRvbeOkt1kmuaPSs2IbdsTLMt6ZiiPJvl8/j7oOzz4vGVZD7a1tZXijllZlnVhcBtw7Qi14+Pr6+ufLXEYQ5ZlfVEp9QT0t/YuKPcG5tFIa2vrIcz8OPR8RnYahvHpkL0iv41UKrWGmZ/RDH5kIpFYEiw7lyT6zLwMRTfxFbFX9Vi3bt120zQvJaJ7NbuV5yYSiTmWZd2A4m0pA46DgquM5zHz5dBYusjlcr2WZV0HfVddJ/f09Bxt2/Y1SqkHB/Lk0tjYOMYwjFlEdAOA942C9vwRpVTGsqybfd9fmM1mXx7E8I8E8C2UdiNMNplM3lUtxt/Q0FBTKBQehsYJvICJnudttiwrkvQQ0bt3uUqLxWJf8zxvlmZvtF0ptd6yrBvz+fxdGzZs2DbIh2o6EV3DzMeFle4Buw+ZTOY+y7JmAjhbM66DANwO4Fbbtv/IzP9HRC8z8z8AjCWiyczcls/njyi1m+667s8sy/o89H2tj2PmH3qed7tlWb9mZoeIOoNhy0QimoLiFtH9Rlm7TgK4Vik137KsVQCWA3gZwOso7iB7D4CPo/SbeRnAvLDWu0cBVFNTcx/0PEYNO6lUao1lWbcB0D1SXAvg+ng8fq1lWb8notUANqHokWh8cEz/mKBdh5rWQccPXV1dF+y3335TmLmUjT9GEP6o3RNbYcLZ9/1zlVIrAJSy978GwPHBJZy7lHqfaOAADg/+hcHtrusuraJx/zXMfNJoTmMymZzf3d39ceg52XnLdgDM2P02rqjb66Cz5p2dnTt7e3s/Bb0NDpGSzWY3EtFp0NuoJPyLpclk8rIqMv5Tmfn60Z7OVatWvcnMJ2CYjs9HIgAAsHHjxh2JRKIDwFMjnVjHcX5NRCU7ayhjPOcMQ3ZWA/hLxO/4Q19f39xq6fqbpnk4M/8E+8hx5kwm8xel1LEAto/W9qq1br527dpuwzBOQvFaKR5hEXiIiE4G0BVB9B4RXcHMFw9DVv5GRB8GsCqi+J8yDGNWWO7SR5rW1tZxI7xSUxbpdHq1YRgzUYHr7iH4qe/7x0QqAMHERp/rupcQ0SwUb92NAl9TBBaheArwzyG+e6tSapbjOAuGS+Qcx9nc09NzFIp7HcJ6Zx7A9a7rnqDpy37U09jYOKZQKDwG4NB9Mf2pVGpNMPn9dIjR9jDzl13XPTsWi/VELgC7d8OTyeRUIroAxZnKMPgngFsMw2jTfcB13XXJZPKIYDmxEvddBWb+kWEYzel0eslwN45Nmzb1uK47D8Vrvyt1GLnU9/0jXNf9uq6Y7gsENwF/aF/Ow4YNG7a5rvupYB6rUu/KzxHRtEwm84OKy7bMCY48gO93dHQs3Lx581wiOgPAcSjt7vI3AfySiBb19vY+UU5XNUjHt9va2n7Y29t7NoDTmPkIzTHidgD3FwqFW3O53B7HYw3D6PQ8b6gdXaF6yA1m6Q8zTfNEItolCDoCnQfwJBH9wHGc35Td9fL91UPtYmPmUIYrRPRnDLHDk5lXB+N+E8XLYxeOZgPv7e3VuqPPcZyHWlpaHvd9/zRmPiOo57jOKwA8TkS3OY6zvF977dVor6itrX2bw5LQJlPa29vjO3fubPU8rw2ABaCJiHZdvVRA8ZDEa0S0jplXFwqF9ZXejbY3mpqaDlRKzSCiw5i5BXuu9b+Cojvu3xcKheVRvB8AbNu+mJmH2la82HXdEwb6cfLkyQcnEolZzNwGwMSeB322AniRiFb6vr9sONy0C9Ewbdq0ZF9f31EoOnKZhj0P9rxBRA4zLy8UCstKvUVYS4ylCkanAAjCcKCkCARBBEAQBBEAQRBEAARBEAEQBEEEQBAEEQBBEEQABEEQARAEQQRAEAQRAEEQRAAEQRABEARBBEAQBBEAQRBEAARBEAEQBEEEQBAEEQBBEEaSmBRB+PT29t4Ti8WeGCxMPB5/U0pKEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEATh35P/B+QbHlhJ+meNAAAAAElFTkSuQmCC\">\n\n        </div>\n    </div>\n\n\n</div>\n\n        \n";
},"useData":true});

//! Source: javascripts/init.js

try{
;
(function init_capriza() {
    console.log('starting parsing init.js');

    try {
        // Extract an object of the URL parameters
        window._urlParams = (window._urlParams || {});
        var match,
            pl = /\+/g,  // Regex for replacing addition symbol with a space
            search = /([^&=]+)=?([^&]*)/g,
            decode = function (s) {
                return decodeURIComponent(s.replace(pl, " "));
            },
            query = window.location.search.substring(1),
            hash = window.location.hash.substring(1);

        query += hash ? ("&" + hash) : "";

        while (match = search.exec(query))
            _urlParams[decode(match[1])] = decode(match[2]);

    } catch (ex) {
    }

    var ua = navigator.userAgent;


    window.take = function (key, data) {
        function _take(key) {
            if (!key) return;
            var i = 2;
            while ((window.take[key])) {
                if (key.match(/ \d*/)) {
                    key = key.replace(/ \d*/, " " + i);
                }
                else {
                    key += " " + i;
                }
                i++;
            }
            window.take[key] = Date.now();
        }


        _take(key);
        if (window.Capriza && Capriza.Profiler && Capriza.Profiler.on && key.indexOf("socketRoute") == -1) {
            if (typeof data == "boolean") {
                data = {async: !!data};
            }

            var profileEvent = new Capriza.Profiler.ProfileEvent(key, data);


            return function takeEnd(key) {
                if(key){
                  _take(key);
                }

                profileEvent.end();
                if (profileEvent.data.manualSend) {
                    Capriza.Profiler.events.push(profileEvent);
                }

            };

        }
        else {
            return _take || take;
        }

    };

    window.take.to_s = function () {
        if (this.s) return this.s;
        var s = "Take_Begin\n";
        for (var key in this) {
            if (this.hasOwnProperty(key) && typeof this[key] !== "function") {
                s = s.concat(key, "=", this[key] - this['start'], "\n");
            }
        }
        this.s = s;
        return s;
    };

    window.take.toJSON = function () {
        var obj = {};
        for (var key in this) {
            if (this.hasOwnProperty(key) && typeof this[key] === "number") {
                if (key.indexOf("/") > -1) {
                    obj[key] = this[key];
                } else {
                    obj[key] = this[key] - this['start'];
                }
            }
        }
        return obj;
    };


    // Allow to pass start take as cookie or as a query param (include the HTML load time to the perf results)
    function findStartTakeTimesrampCookie(){
        var name = 'startTakeTimestamp=';
        var start = document.cookie.indexOf(name);
        if(start == -1) return null;
        var end = document.cookie.indexOf(';', start);
        return document.cookie.substring(start+name.length, end == -1 ? undefined : end);
    }

    function clearStartTakeTimesrampCookie(){
        document.cookie = "startTakeTimestamp=" + "; expires=" + new Date("1980").toGMTString() + "; path=/;" + "domain=capriza.com";
    }

    var startTakeTimestampCookieVal = findStartTakeTimesrampCookie();
    if(window._urlParams.startTakeTimestamp){
        var timestamp = parseInt(window._urlParams.startTakeTimestamp);
        var oldTimestamp = localStorage.getItem("Capriza_startTakeTimestamp");   // keeping in local storage for cases where the page is refreshed and I want to ignore the startTakeTimestamp
        if(isNaN(timestamp) || oldTimestamp == window._urlParams.startTakeTimestamp){
          timestamp = Date.now();
        }else{
            localStorage.setItem("Capriza_startTakeTimestamp", window._urlParams.startTakeTimestamp);
        }
        window.take['start'] = timestamp;
    }else if(startTakeTimestampCookieVal){
        clearStartTakeTimesrampCookie();
        var timestamp = parseInt(startTakeTimestampCookieVal);
        if(isNaN(timestamp))
            timestamp = Date.now();
        window.take['start'] = timestamp;
    }else if (window.Capriza && window.Capriza.runStart){
        window.take['start'] = Capriza.runStart;
    }else{
        take("start");
    }

    window.take['htmlStart'] = window.Capriza && window.Capriza.runStart;

    if (window.Capriza) {
        window.Capriza.pageTimer = take['start'];
    }
    take("startJS");

    window.addEventListener("load", function () {
        Logger.debug('mobile window loaded at '+Date.now());
        take("loadEvent");
    }, false);

    window.Dispatcher = _.clone(Backbone.Events);

    function takeFirstMobilePage(pages){
        try {
            if (pages.toPage && pages.toPage[0].id != "start-page") {
                Dispatcher.off("page/change/after/callbackEnded", takeFirstMobilePage);
                // we might got firstMobilePage Time in Instrumentation Dispatcher.on('application/firstContext identity/show'
                if (window.Capriza.firstMobilePageTime) return;
                window.Capriza.firstMobilePageTime = Date.now();
                var takeData = {
                    type: "firstMobilePage",
                    source: 'firstMobilePage'
                };
                if (pages.toPage) {
                    var toViewModel = pages.toPage.data("pageView");
                    if (toViewModel) {
                        toViewModel = toViewModel.model;
                        takeData.mvp = toViewModel.mvp;
                        takeData.blueprint = toViewModel.blueprint;
                        takeData.login = toViewModel.login;
                        takeData.cnf = toViewModel.cnf;
                        takeData.name = toViewModel.get("name");
                    }
                }
                take("firstMobilePage", takeData);
            }
        } catch(ex){

        }
    }

    Dispatcher.on("page/change/after/callbackEnded", takeFirstMobilePage);

    var isMobile = !/Windows NT/i.test(ua || navigator.vendor) && /android|ip(hone|od|ad)|blackberry|symbian|pocket|windows (ce|phone)|iemobile|mobile|touch/i.test(ua || navigator.vendor);

    //For more information: https://developer.chrome.com/multidevice/user-agent
    window.Capriza = $.extend(window.Capriza, {
        device: {
            // Reference: http://detectmobilebrowsers.com/
            isMobile: isMobile,
            isDesktop: !(isMobile || window.isDesignerPreview || window.designerExtWin), // designerExtWin is indication for window of designer. yuck... we need to think of differences between isDesignerPreview and "isInDesignerWindow"
            ios5: /ip(hone|od|ad).*version\/5/i.test(ua),
            ios6: /ip(hone|od|ad).*version\/6/i.test(ua),
            ios7: /ip(hone|od|ad).* 7/i.test(ua),
            ios8: /ip(hone|od|ad).* (8|version\/8)/i.test(ua),
            ipad: /ipad/i.test(ua),
            ios: /ip(hone|od|ad)/gi.test(navigator.appVersion), // appVersion - taken from iScroll
            android: /android/i.test(ua),
            android2: /android\s2/i.test(ua),
            blackberry: /blackberry/i.test(ua),
            stock: /android/i.test(ua) && /webkit/i.test(ua) && !/chrome/i.test(ua),
            firefox: /firefox/i.test(ua),
            chrome: /chrome/i.test(ua),
            chromeWebView: /chrome/i.test(ua) && /Version\//i.test(ua),
            crosswalk: /crosswalk/i.test(ua),
            s3: /android.*9300/i.test(ua),
            xperiaZ: /C6603|C6602/i.test(ua),
            xperiaS: /LT26i/i.test(ua),
            ie11:/(Windows).*(rv:11.0)/i.test(ua),
            iosVersionNumber: function() {
                if (this.ios) {
                    var startStr = " OS ", startIndex = ua.indexOf(startStr);
                    var versionStr = ua.substring(startIndex+startStr.length, ua.indexOf(" like"));
                    var versionNumStr = versionStr.replace("_", ".");
                    return parseFloat(versionNumStr);
                }
                else {
                    return -1;
                }
            },
            fixIpadLandscape: function(reason) {
                var actionBarBottom, pageTop, headerTop, orientation, scrollY = window.pageYOffset;
                if (window.innerHeight > window.innerWidth) { // portrait
                    actionBarBottom = 0;
                    pageTop = 44;
                    headerTop = 0;
                    orientation = "portrait";
                } else { // landscape
                    actionBarBottom = 20 - scrollY;
                    pageTop = 44 + scrollY;
                    headerTop = scrollY;
                    orientation = "landscape";
                }

                if (Capriza.device.ios && Capriza.device.iosVersionNumber() < 8 && !Capriza.isPhonegap) {
                    Logger.debug(reason + "(" + orientation + "): setting action-bar bottom css to " + actionBarBottom+' ua is '+navigator.userAgent);
                    $(".dock-bottom, .loading-message").css("bottom", actionBarBottom);
                    $(".page").css("top", pageTop);
                    $("header.mobile").css("top", headerTop);
                }

            }
        },



        standalone: navigator.standalone,
        support: {
            WebSocket: 'WebSocket' in window || 'MozWebSocket' in window
        },
        isDevMode: /(devmode|local|xml|ile|editing)/.test(window.location.hash)
    });

    if (!window.isDesignerPreview) {
        $(window).on("orientationchange resize", function (e) {

            var newCalc = (window.innerHeight > 600 && window.innerWidth > 600) || Capriza.device.ipad;

            if (newCalc != Capriza.device.isLargeScreen) {
                Capriza.device.isLargeScreen = newCalc;
                Dispatcher.trigger('isLargeScreenChanged');
            }

        });
    }

    Capriza.device.isKeyboardShown = function() {

        var $viewport = $('.viewport');
        return $viewport.length > 0 && $viewport[0].getBoundingClientRect().top < 0;

    };
    Capriza.fullScreen = !window._urlParams["web"] && (!Capriza.isDevMode || window._urlParams["mini"]);

    Capriza.compatMode = !!Capriza.device.android2 || !! Capriza.device.blackberry ;

    Capriza.isStore = !!window._urlParams["store"];
    Capriza.relayConnector = window._urlParams["relay"];

//        Cordova 3.x
    Capriza.cordova = window._urlParams.cordova;

//        Phonegap 2.7.0
    Capriza.isPhonegap = window._urlParams.phonegap && window._urlParams.phonegap !== 'false';

    Capriza.isAppZapp = !Capriza.isStore && Capriza.isPhonegap;

//        Hard coded phase to keep unversioned cordova in sync with mobile versioning
    Capriza.cordovaPhase = 1;
    Capriza.medLevel = 4;

    // Flag that is being set every time the zapp is reloaded (like signout, invalid session, cnf, etc.)
    Capriza.isReloadFromZapp = !!window._urlParams["reloadFromZapp"];

    $.ajaxSetup({xhrFields:{withCredentials:true}});


    Capriza.getToken = function (token) {
        if (window.appData && appData.app_token) {
            return appData.app_token;
        }
        else {
            if (!Capriza.zappToken || token){
                Capriza.zappToken = token || location.pathname.replace("/", "");
            }
            return Capriza.zappToken;
        }
    };

    Dispatcher.on("runner/run", function (appData) {
        function isMonitored() {
            if (window.isDesignerPreview) return false;

            if (appData.config) {
                var config = appData.config;

                if (typeof config.monitor!== "undefined") return config.monitor;
            }
            if (appData.app) {
                if (appData.app.prod_stage == "free") {
                    return false;
                }
            }
            return true;

        }

        Capriza.isMonitored = isMonitored();
    });

})();

(function fixChromeLocalStorage() {
    if (document.URL.indexOf("chrome://") == 0) {
        var Cc = Components.classes, Ci = Components.interfaces;
        var ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
        var ssm = Cc["@mozilla.org/scriptsecuritymanager;1"].getService(Ci.nsIScriptSecurityManager);
        var dsm = Cc["@mozilla.org/dom/storagemanager;1"].getService(Ci.nsIDOMStorageManager);
        var principal = (ssm.getCodebasePrincipal || ssm.getSimpleCodebasePrincipal).call(ssm, ioService.newURI("http://mobile.capriza.com/", "", null));
        Object.defineProperty(window, "localStorage", { value: dsm.getLocalStorageForPrincipal(principal, "") });
    }
})();

(function regAppCacheEvents() {
    var appCache = window.applicationCache;

    if (!appCache) return;

    function handleCacheEvent(e) {
        Logger.debug('handleCacheEvent appcache event: '+ e.type+' appCache.status: '+appCache.status);
    }

    function handleCacheUpdateReady(e) {
        Logger.debug("[handleCacheUpdateReady] checking if mobile updated");
        if (Capriza.VersionManager.isMobileVersionUpdated()) {
            Logger.debug('handleCacheUpdateReady - New mobile version is now installed, cleaning blueprint and reloading.');
                Capriza.StateManager.cleanBlueprint({hideUnimessage: false}, function() { Utils.reload(); }, function() { Utils.reload(); });
        } else {
            Logger.debug('handleCacheUpdateReady but mobile is not changed. probably latest only.');
        }
    }

    function handleCachedEvent(e) {
        Logger.debug("handleCachedEvent - cache has finished update.");
        Logger.tag("appCacheUpdated");
        Capriza.firstRun = true;
    }

    function handleNoUpdateEvent(e) {
        Logger.debug("handleNoUpdateEvent - cache has no update.");
        Capriza.firstRun = false;
    }

    function handleDownloadingEvent(e) {
        Logger.debug("handleDownloadingEvent - cache is downloading. appCache.status: "+applicationCache.status);
        Logger.tag("appCacheUpdating");
        Capriza.firstRun = true;
    }

    function handleCacheError(e) {
        Logger.tag("appCacheError");
        Logger.warn('Warning: Cache failed to update! event :[' + JSON.stringify(e) + ']',e && e.message && e.reason && e , 'appCache');
    }

    // Fired after the first cache of the manifest.
    appCache.addEventListener('cached', handleCachedEvent, false);

    // Checking for an update. Always the first event fired in the sequence.
    appCache.addEventListener('checking', handleCacheEvent, false);

    // An update was found. The browser is fetching resources.
    appCache.addEventListener('downloading', handleDownloadingEvent, false);

    // The manifest returns 404 or 410, the download failed,
    // or the manifest changed while the download was in progress.
    appCache.addEventListener('error', handleCacheError, false);

    // Fired after the first download of the manifest.
    appCache.addEventListener('noupdate', handleNoUpdateEvent, false);

    // Fired if the manifest file returns a 404 or 410.
    // This results in the application cache being deleted.
    appCache.addEventListener('obsolete', handleCacheEvent, false);

    // Fired for each resource listed in the manifest as it is being fetched.
    appCache.addEventListener('progress', handleCacheEvent, false);

    // Fired when the manifest resources have been newly redownloaded.
    appCache.addEventListener('updateready', handleCacheUpdateReady, false);
})();


}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Cache.js

try{
(function (storage) {

    var backupStorage = {};

    window.ClientCache = {
        _id:function (id) {
            return id;
        },

        getItem:function (id) {
            return storage.getItem(this._id(id)) || backupStorage[id];
        },

        setItem:function (id, value) {
            id = this._id(id);
            try {
                storage.setItem(id, value);
            } catch(ex) {
                Logger.error('Error writing to localStorage, key=[' + id +"], current localStorage size =[" + this._size() + "]", ex, "localStorage");
                this.clear();
                backupStorage[id] = value;
            }
        },

        removeItem:function (key) {
            storage.removeItem(key);
            delete backupStorage[key]
        },

        clear:function () {
            _.keys(storage).forEach(function(key) {
                if (key.indexOf('identity') < 0 && key.indexOf('unique_token') < 0) {
                    storage.removeItem(key);
                }
            });
        },

        length:function () {
            return storage.length;
        },

        _size:function(){
            var size = 0;
            for(var i = 0, l = storage.length;i<l; i++){
                var k =storage.key(i);
                size += storage[k].length + k.length;
            }
            return size;
        },

        keys: function() {
            return Object.keys(storage);
        }
};

})(localStorage);
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/EncryptedCache.js

try{
;(function() {

var encCache = window.EncryptedCache = {
	get xkcd() {
	   return window.appData.xkcd;
	},

	setItem : function(id, value) {
		if (window.GibberishAES) {
			var val = JSON.stringify(value);
			var encrypted = GibberishAES.enc(val, encCache.xkcd);
			ClientCache.setItem(id, encrypted);
		}

	},

	getItem : function(id) {
		var data, decrypted;
		data = ClientCache.getItem(id);
		if (data) {
			try {
				decrypted = GibberishAES.dec(data, encCache.xkcd);
				decrypted = JSON.parse(decrypted);
			} catch (ex) {
				decrypted = undefined;
				logger.error("failed to decrypt data from local storage key:" + id, ex, "EncryptedCache", undefined, true);
			}
		}
		return decrypted;
	}
};

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/utils/Utils.js

try{
(function () {
    window.takeJSExecute = take("jsExecuteStart",true);

    window.Utils = (window.Utils || {});

    _.extend(Utils, {
        createCookie: function (name, value, days) {
            var expires = "";
            if (days) {
                var date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toGMTString();
            }
            document.cookie = name + "=" + value + expires + "; path=/;" + "domain=capriza.com";
        },

        readCookie: function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(";");
            for (var i = 0, ii = ca.length; i < ii; i++) {
                var c = ca[i];
                while (c.charAt(0) == " ")
                    c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0)
                    return c.substring(nameEQ.length, c.length);
            }
            return null;
        },

        eraseCookie: function (name) {
            this.createCookie(name, "", -1);
        },

        docCookies: {
            getItem: function (sKey) {
                if (!sKey || !this.hasItem(sKey)) {
                    return null;
                }
                return decodeURIComponent(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
            },
            removeItem: function (sKey, domain) {
                if (!sKey || !this.hasItem(sKey)) {
                    return;
                }
                var oExpDate = new Date();
                oExpDate.setDate(oExpDate.getDate() - 1);
                document.cookie = encodeURIComponent(sKey) + "=; expires=" + oExpDate.toGMTString() + "; path=/;" + (domain ? "domain=" + domain + ";" : "");
            },
            hasItem: function (sKey) {
                return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
            }
        },

        loadScript: function (url, id) {
            if (id && $("script#" + id).length > 0) return;
            var s = document.createElement("script");
            s.src = url;
            id && s.setAttribute("id", id);
            document.body.appendChild(s);
        },

        loadStylesheet: function (url, onload) {
            var s = document.createElement("link");
            s.rel = "stylesheet";
            s.href = url;
            onload && s.addEventListener("load", onload, false);
            document.head.appendChild(s);
        },

        caprizaMode: (function () {
            if (navigator.userAgent.toLowerCase().match(/capriza/)) return 'ShellMode';
            else return 'browser';
        })(),

        reload: function (message) {

            var messageText = message || Capriza.translator.getText("restarting"),
                msgObj = {type: "progress", messageText: messageText};
            Utils.showUnimessage(msgObj, true);

            // add a query param that notifies next run that it was loaded from within the zapp itself (as opposed to going back to the store and selecting the zapp again for example)
            var url = location.href,
                hash = location.hash,
                reloadParam = "reloadFromZapp=true";

            if(hash) url = url.split(hash)[0];

            if(Capriza.device.ios && url.indexOf(reloadParam) === -1) {
                url += (url.split("?")[1] ? "&" : "?") + reloadParam;
            }

            if(hash) url += hash;

            function browserReload() {
                if (window.location.href == url) window.location.reload();
                else window.location.replace(url);
            }

            //In IOS, try to perform the reload via WorkSimple (since app version 16), in order for the filer to be available after reload
            if (Capriza.cordova && Utils.isIOS && Capriza.cordova.split(".")[0] >= 16 &&
                Capriza.Capp && Capriza.Capp.messenger && Capriza.Capp.messenger.emit) {
                Capriza.Capp.messenger.emit('zapp/reload', url);

                //safety measure, if WorkSimple didn't reload, do it here
                setTimeout(browserReload, 3000);
            }
            else browserReload();
        },

        // http://blogorama.nerdworks.in/entry-JavaScriptfunctionthrottlingan.aspx
        throttle: function (delay, callback, accumulateData) {
            var previousCall = null;
            var theData = [];
            return function () {
                var time = new Date().getTime();

                //
                // accumulate arguments in case caller is interested
                // in that data
                //
                if (accumulateData) {
                    var arr = [];
                    for (var i = 0; i < arguments.length; ++i)
                        arr.push(arguments[i]);
                    theData.push(arr);
                }
                if (!previousCall ||
                    (time - previousCall) >= delay) {
                    previousCall = time;
                    callback.apply((accumulateData) ? { data: theData } : null, arguments);
                    theData = []; // clear the data array
                }
            };
        },

        // http://blogorama.nerdworks.in/entry-JavaScriptfunctionthrottlingan.aspx
        debounce: function (delay, callback, accumulateData) {
            var timeout = null;
            var theData = [];
            return function () {
                //
                // accumulate arguments in case caller is interested
                // in that data
                //
                if (accumulateData) {
                    var arr = [];
                    for (var i = 0; i < arguments.length; ++i)
                        arr.push(arguments[i]);
                    theData.push(arr);
                }

                //
                // if a timeout has been registered before then
                // cancel it so that we can setup a fresh timeout
                //
                if (timeout) {
                    clearTimeout(timeout);
                }
                var args = arguments;
                timeout = setTimeout(function () {
                    callback.apply((accumulateData) ? { data: theData } : null, args);
                    theData = []; // clear the data array
                    timeout = null;
                }, delay);
            };
        },

        stringifyCircular:function(object){

            var cache = [];
           var string= JSON.stringify(object, function(key, value) {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        // Circular reference found, discard key
                        return;
                    }
                    // Store value in our collection
                    cache.push(value);
                }
                return value;
            });
            cache = null; // Enable garbage collection
            return string;
        },

        decodeHtml: function(str) {
            return $('<span></span>').html(str).text();
        },

        noop: function() {},
        flattenObject: function (obj) {
            var flatObj = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key) && typeof obj[key] !== "object") {
                    flatObj[key] = obj[key];
                }
            }
            return flatObj;
        },

        loadPasscode:function(userId){

            return SharedUtils.readCookie(userId+"_passcode");



        },
        savePasscode:function(userId,passcode){
            this.createCookie("userId",userId,1000);
            return this.createCookie(userId+"_passcode",passcode,1000);
        },

        Links:{
            specialSchemes:['tel','mailto'],
            isSpecialLink:function(url){
                var regexSchemes=Utils.Links.specialSchemes.join('|');
                var regex= new RegExp('^('+regexSchemes+'):');
                return regex.test(url)

            },
            isFile: function (url) {
                return /\.(pdf|dwg|doc|ppt|docx|pptx|mpg|mpeg|avi|xls|xlsx|log|msg|txt|csv)$/.test(url)
            },
            extractFilename: function(path){
                if (!Utils.Links.isFile(path)){
                    return false;
                }
                var lastSlash = path.lastIndexOf('/');
                if(lastSlash == -1){
                    return path;
                }
                var filename =  path.substring(lastSlash + 1);
                return filename;
            },
            openExternal:function(url, fileName){
                window.open(url);
            },
            createExternalLink: function (link) {
                var $link;
                var href;
                if (link instanceof Backbone.View) {

                    href = link.model.get('href');

                    $link = link.$el= $("<a ></a>",
                        {id:link.model.uniqueControlId,href: link.model.get("href")});

                    $link.text(link.model.get("name"));


                    if(Utils.Links.isFile(href)){
                        var ext = href.substr(href.lastIndexOf(".") + 1);
                        $link.addClass('link-download');
                        $link.addClass(ext);
                    }



                } else {
                    $link = $(link);
                    href = $link.attr("href");

                }

                $link.click(function(e){
                    e.stopPropagation();
                    e.preventDefault();
                    Utils.Links.openExternal($(this).attr("href"));
                });
            },
            openExternalInBlank: function (url) {
                window.open(url, Capriza.cordova ? "_system" : "_blank");
            },
            openExternalInMiniBrowser: function (href) {
                var extraActions = Utils.Links.getExtraActionsForExternalLink(href);
                Capriza.Views.Utils.buildMiniBrowser(href, extraActions);
            },
            getExtraActionsForExternalLink: function (href) {

                var extraActions = [
                    {
                        name: "Open in Browser",
                        action: function() {
                            Utils.Links.openExternalApp(href);
                        }
                    }
                ];
                if (document.queryCommandSupported("copy")) {
                    extraActions.push({ name: "Copy Link", action: function (e) { Utils.copyToClipBoard(href); }});
                }
                return extraActions;
            },
            openExternalApp: function(defaultUrl, onError, iosLinkToStore, androidLinkToStore, iosUrl, androidUrl){
                var app = defaultUrl.substring(0,defaultUrl.indexOf("://"));
                var appData = {
                    iosApp: iosUrl || defaultUrl,
                    appStoreLink: iosLinkToStore,
                    androidApp : androidUrl || defaultUrl,
                    playStoreLink : androidLinkToStore || "https://play.google.com/store/search?q=" + app,
                    onError: onError || function(){
                        alert("Couldn't open "+app+", make sure the device supports this app download it and try again");
                    }
                };
                if (Capriza.cordova){
                    if (Capriza.device.ios) {
                        Capriza.Capp.messenger.emit('runExternalApp', appData);
                    }
                    else if (Capriza.device.android) {
                        top.Capriza.zappAPI["runExternalApp"](appData)
                    }
                } else if (defaultUrl){
                    Utils.Links.openExternalInBlank(defaultUrl);
                }
            }
        },

        raiseModalShield: function(){
            var $shieldModal = $(".global-shield.modal");
            if (!$shieldModal.length) {
                $shieldModal = Utils.shieldUp("modal", true, true);
            }
            return $shieldModal;
        },

        addDummyPage: function(){
            var dummyPageEl = $(".page.dummy-page");
            if (dummyPageEl.length) return dummyPageEl;
            $(".active.page").remove();
            var dummyPage = new Capriza.Model.Page(),
                dummyPageView = new Capriza.Views.DummyPage({ model: dummyPage}).render().show();
            $.capriza.activePage = dummyPageView.$el;
            return dummyPageView.$el;
        },

        raiseModalContainer: function(){
            var $container = $(".modal-page-container");
            if (!$container.length){
                $container = $("<div></div>").addClass("modal-page-container page-container modal-shown").appendTo(".viewport");
            }
            return $container;
        },

        moveShieldBeforeElement: function($shieldElement, $beforeElement){
            $shieldElement.insertBefore($beforeElement);
        },

        shieldUp: function (name, full, enableSideMenu) {
            var $shield = $("<div class='global-shield'>").addClass(name).toggleClass("full-shield", full).appendTo(".viewport");
            full && enableSideMenu && this.shieldClickOnSideMenu($shield);
            return $shield;
        },

        shieldDown: function (name) {
            $(".global-shield." + name).remove();
        },

        openSideMenu: function(e){
            var $sideBurger =$("#side-burger", ".page.active, .page.disabled");
            if ($sideBurger.length) {
                var burgerPos = $sideBurger[0].getBoundingClientRect();
                if ((e.clientX < (burgerPos.left + 43) && e.clientY < (burgerPos.top + 43) && $sideBurger.length) || $sideBurger.hasClass("close")) {
                    $sideBurger.click();
                }
            }
        },

        shieldClickOnSideMenu: function(activeFullShield){
            activeFullShield = activeFullShield || $(".global-shield.full-shield." + name);
            if (activeFullShield.length){
                activeFullShield.off("click", Utils.openSideMenu).on("click", Utils.openSideMenu);
            }
        },

        viewportOverlayForElement: function(elementName){
            var $viewportOverlay = $("#viewport-overlay").addClass("active "+ elementName);
            $viewportOverlay.off("click", Utils.openSideMenu).on("click", Utils.openSideMenu);

        },
        //
        removeViewportOverlayForElement: function(elementName){
            var $viewportOverlay = $("#viewport-overlay");
            if (elementName) {
                $viewportOverlay.removeClass(elementName);
            }
            if ($viewportOverlay.hasClass("active") && $viewportOverlay[0].classList.length == 1){
                $viewportOverlay.removeClass("active").off("click", Utils.openSideMenu);
            }
        },

        copyToClipBoard: function(text, name){
            if (!document.execCommand || !document.createRange) {
                Logger.debug("Copy to clipboard didn't execute");
                return;
            }
            var element = $("<span>"+text+"</span>");
            document.body.appendChild(element[0]);
            var selection = window.getSelection();
            var rangeToSelect = document.createRange();
            rangeToSelect.selectNodeContents(element[0]);

            selection.removeAllRanges();
            selection.addRange(rangeToSelect);
            if (document.execCommand("copy")){
                Utils.showUnimessage({type: "", messageText: (name || text) + " copied "}, false, true, false, 3500);
            } else {
                Utils.showUnimessage({type: "", messageText: "Failed to copy " + (name || text)},false, true, false, 3500);
            }

            element.remove();
        },

        removeContextMenu: function(e){
            if ($(".popup-opening").length) {
                $(".popup-opening").removeClass("popup-opening");
                return;
            }
            Logger.debug("Pop over cancel clicked");
            $('.extra-action').remove();
            Utils.shieldDown("extra-actions");
        },

        showContextMenu: function(options){
            if (!options.items ) return;

            function cancel(){
            }
            var $popOver =  $('<div class="extra-action">'),
                $rows = $('<ul class="rows"></ul>'),
                $cancel = $('<div class="cancel-action extra-clickable">Cancel</div>');
            if (options.bubble){
                $popOver.addClass("extra-bubble").append($('<div class="arrow-wrapper arrow-back"</div>'));
            }
            if (options.title){
                $rows.append($("<li class='extra-item extra-title'>"+options.title+"</li>"));
            }
            options.items.forEach(function(item){
                $rows.append($("<li class='extra-item extra-clickable'>"+item.name+"</li>").on("click", function(e){
                    if ($(".popup-opening").length) {
                        $(".popup-opening").removeClass("popup-opening");
                        return;
                    }
                    e.stopPropagation();
                    item.action(e);
                    Utils.removeContextMenu(e);
                }));
            });
            var $shield = Utils.shieldUp("extra-actions", true, true);
            $shield.on("click", Utils.removeContextMenu);
            $cancel.on("click", Utils.removeContextMenu);
            $popOver.append($rows).append($cancel).appendTo(".viewport");
            if (options.bubble){
                $popOver.append($('<div class="arrow-wrapper"></div>'));
            }
        },

        openAppString: function(browserDefault){
            return Capriza.cordova && Capriza.device.android ? "_system" : Capriza.device.isMobile ? "_self" : (browserDefault || "_blank");
        },

        blockEffect: function(){
            var message = $(".loading-message:not(.hidden), .unimessage.visible");
            if (message.length){
                function bounceEnd(e){
                    message.off(Utils.animationEnd, bounceEnd);
                    message.removeClass("bounce-effect");
                }
                message.on(Utils.animationEnd, bounceEnd);
                message.addClass("bounce-effect");
                return true;
            }
        },

        _blockDocument: function(e) {
            logger.log("block document: " + e.type + ": " + e.target.tagName + (e.target.id || ""));

            // block everything but these interactable items
            var interactableItems = '#side-burger, #side-menu, #header-overlay, #viewport-overlay, #feedback-page';

            Utils.blockEffect();

            if ($(e.target).closest($(interactableItems)).length != 0 || e.target.className.indexOf('loading-message') >= 0) {
                return;
            }

            // for touch devices - preventing default means disabling scroll. So we do it only on the form elements
            if (e.type !== "touchstart" || /^(INPUT|SELECT|BUTTON|TEXTAREA)$/.test(e.target.tagName.toUpperCase())) {
                e.preventDefault();
                e.stopPropagation();
            }
        },

        blockUI: function() {
            Logger.debug('blocking the UI');
            var element = Capriza.fullScreen ? document : $(".viewport")[0];
            if (Utils.isCachedMVPShown() && !Utils.isCachedMVPShown("mvppp")) {
                Logger.debug('not blocking the UI because of cached mvp is rendered');
                return;
            }
            element.addEventListener("click", Utils._blockDocument, true);
            element.addEventListener("mousedown", Utils._blockDocument, true);
            element.addEventListener("touchstart", Utils._blockDocument, true);
            element.addEventListener("touchmove", Utils._blockDocument, true);

            var $loadingMessage = $('.loading-message');
            if($loadingMessage.length > 0){
                $loadingMessage.addClass('blocking');
            }
            if($(".cdialog.confirm.page").length){
                $(".dialog-ok button, .dialog-ok").addClass("disabled block-ui");
            }
        },

        unblockUI: function() {
            Logger.debug('unBlocking the UI');
            Utils.loadStartTimer && clearTimeout(Utils.loadStartTimer);
            var element = Capriza.fullScreen ? document : $(".viewport")[0];
            element.removeEventListener("click", Utils._blockDocument, true);
            element.removeEventListener("mousedown", Utils._blockDocument, true);
            element.removeEventListener("touchstart", Utils._blockDocument, true);
            element.removeEventListener("touchmove", Utils._blockDocument, true);

            var $loadingMessage = $('.loading-message');
            if($loadingMessage.length > 0) {
                $loadingMessage.loadingMessage('option', 'topHeader', '');
                $loadingMessage.removeClass('blocking');
            }
            if($(".cdialog.confirm.page .dialog-ok.block-ui button").length){
                $(".dialog-ok.block-ui button, .dialog-ok.block-ui").removeClass("disabled block-ui");
            }
        },

        showMessage: function showMessage(message, timeout) {
            timeout = isNaN(timeout) ? 3000 : timeout;
            $('.loading-message').loadingMessage('update', {message: message, shouldShowLoadingIndicator: false});
            Logger.debug("[Utils] show message called. message: " + message + "; .loading-message visible: "+ !$('.loading-message').hasClass("hidden"));
            if (!$('.loading-message').hasClass("hidden")){
                Utils.hideUnimessages();
            }
            setTimeout(function () {
                $('.loading-message').loadingMessage('hide');
            }, timeout);
        },
        showLoading: function (message) {
            message = message || "Loading...";
            $('.loading-message').loadingMessage('update', {message: message, shouldShowLoadingIndicator: true});
            Logger.debug("[Utils] show loading message called. message: "+message + "; .loading-message visible: "+ !$('.loading-message').hasClass("hidden"));
            if (!$('.loading-message').hasClass("hidden")){
                Utils.hideUnimessages();
            }
        },

        hideLoading:function() {
            Logger.debug("[Utils] hide loading message called");
            $('.loading-message').loadingMessage('hide');
        },

//        overriden in override.js
        isMobileUpdated: function() {

        },
        wasCachedMVPShown:function(){
           return this.isCachedMVPShown("was-mvp");
        },
        shouldShowLoadingOnMVP: function(setValue) {
            if (setValue !== undefined){
                if (!Capriza.LoadingMassages){
                    Capriza.LoadingMassages = {};
                }
                Capriza.LoadingMassages.shouldShowLoadingOnMVP = setValue;
            }
            return Capriza.LoadingMassages && Capriza.LoadingMassages.shouldShowLoadingOnMVP;
        },

        isCachedMVPShown: function(cssClass) {

            return this.isCachedBlueprintShown();

            /*
            cssClass = cssClass || "mvp";
            var mvpPage = $('.'+ cssClass);
            var isMvpActive = mvpPage.length > 0 && mvpPage.hasClass('active');

            var activeDrillPage = $('.table-drill.active');

            //The mvp is in DOM - but the active page is it's drill page
            if (mvpPage.length > 0 && activeDrillPage.length > 0) {
                var drillPageView = activeDrillPage.data('pageView');

                var drillPageParentPageId = drillPageView.model.get('parentPage').get('id');
                var mvpPageId = mvpPage.data('pageView').model.get('id');

                var mvpDrillPageShown = drillPageParentPageId == mvpPageId;

                return isMvpActive || mvpDrillPageShown;
            }

            var activeIframe = $('#mini-browser.active');

            //The mvp is in DOM - but the active page is it's the iframe (user clicked on a link)
            if (mvpPage.length > 0 && activeIframe.length > 0) {
                return true;
            }
            return isMvpActive;
            */
        },

        isCachedBlueprintShown: function() {
            return Capriza.StateManager.isCachedBlueprintShown;
        },

        getHeaderViewFromPageView: function(pageView) {

            var pageModel = pageView && pageView.model;
            if (pageModel) {
                var presentationControls = pageModel.get('presentationControl');
                if (!presentationControls) {
                    var controls = pageModel.get('controls');
                    if (controls && controls.length > 0) {
                        presentationControls = controls[0];
                    }
                }

                if (presentationControls) {
                    var headerModel = this.findFirstOfType(Capriza.Model.ControlDB[presentationControls.id], 'header', 'panelType');
                    return headerModel && pageView.getView(headerModel.id);
                }

            }

        },

        getBrand: function() {
            var brandStr = ClientCache.getItem('brand-'+Capriza.getToken());
            if (brandStr) {
                try {
                    return JSON.parse(brandStr);
                } catch (ex) {
                    Logger.warn("could not parse brand from cache. value was '" + brandStr + "'");
                }
            }
        },

        setBrand: function(brand) {
            if (brand) {
                ClientCache.setItem('brand-'+Capriza.getToken(), JSON.stringify(brand));
                this.updateBrandStyle(brand);
            }
        },

        // Adds brand properties as CSS variables to a page style
        updateBrandStyle: function (brand) {
            var brandInfo = brand || this.getBrand();

            if (brandInfo) {
                $("#brandStyle").remove();

                var $v = $("<style id='brandStyle'/>").appendTo("head");

                $v.text(":root {--brand-primary-color: "
                    + brandInfo["primary-color"] + "; --brand-secondary-color: "
                    + brandInfo["secondary-color"] + ";}");
            }
        },

        isRunningInBackground: function() {
            return window._urlParams['zapp_offline'] === "true";
        },

        isInDevMode: function() {
            return window.location.hash.indexOf('devmode') >= 0
        },

        isInDashboard: function() {
            return window._urlParams["dashboard"] === "true";
        },

        findFirstOfType: function(model, type, prop) {

            var modelProp = prop || 'type';
            if (model.get(modelProp.toString()) === type) return model;
            if (!model.get('controls') || model.get('controls').length === 0) return undefined;
            var result;
            for (var i = 0; i < model.get('controls').length; i++){
                result = this.findFirstOfType(Capriza.Model.ControlDB[model.get('controls')[i].get('id')], type, prop);
                if (result) break;
            }
            return result;
        },

        escapeHTML: function(str) {
            return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },

        getAppName: function() {
            var ret, cachedTitle = localStorage.getItem("appTitle-" + Capriza.getToken());
            if (cachedTitle) {
                ret = cachedTitle;
            } else if (window.appData && window.appData.app_name) {
                ret = window.appData.app_name;
            } else {
                ret = document.title;
            }

            return Utils.escapeHTML(ret);
        },
        transitionEnd: "webkitTransitionEnd transitionend",
        animationEnd: "webkitAnimationEnd animationend",

        isNavigatorOnline: function () {
            var result = navigator.onLine;

            try {
                result = top.navigator.onLine;
            } catch (e) {
                // do nothing
            }
            return result;
        },

        // Moves focus to element inside container
        focusContainer: function (container) {
            var $v = $(":enabled, [tabindex]", container).not("[tabindex=-1]");

            $v.eq(0).focus();
        },

        singleStepMessages: [
            "workingOnIt",
            "almostThere",
            "fewMoreMoments",
            "takingLonger"
        ],

        // Shows Unimessage and blocks UI if required
        showUnimessage: function (message, isBlocking, isAllowedInMvp, singleStep, messageTimeOut) {
            if (isAllowedInMvp || !(this.isCachedMVPShown()
                || this.isCachedBlueprintShown())) {

                if (!((message.type == "progress")
                    && $("#identity-page.active #splash-message.active")[0])) {

                    Utils.hideUnimessages();
                    Utils.hideLoading();

                    if (isBlocking) {
                        this.isBlockingUnimessage = true;
                        this.blockUI();
                    }

                    var v = {model: new Backbone.Model(message)};

                    var unimessage = new Capriza.Views.Unimessage(v).show();
                    if (singleStep){
                        // display working on it after 3s
                        Utils.unimessageTimeout = setTimeout(function(){
                            Utils.unimessageTimeout && clearTimeout(Utils.unimessageTimeout);
                            if (!unimessage.update({messageText: Capriza.translator.getText(Utils.singleStepMessages[0])}, true)){
                                return;
                            }
                            Utils.unimessageTimeout = setTimeout(function(){
                                Utils.unimessageTimeout && clearTimeout(Utils.unimessageTimeout);
                                if (!unimessage.update({messageText: Capriza.translator.getText(Utils.singleStepMessages[1])}, true)){
                                    return;
                                }
                                Utils.unimessageTimeout = setTimeout(function(){
                                    Utils.unimessageTimeout && clearTimeout(Utils.unimessageTimeout);
                                    if (!unimessage.update({messageText: Capriza.translator.getText(Utils.singleStepMessages[2])}, true)){
                                        return;
                                    }
                                    Utils.unimessageTimeout = setTimeout(function(){
                                        Utils.unimessageTimeout && clearTimeout(Utils.unimessageTimeout);
                                        unimessage.update({messageText: Capriza.translator.getText(Utils.singleStepMessages[3])}, true);
                                    }, 6000);
                                }, 4000)
                            }, 5000)
                        }, 4000);
                    }
                    Logger.debug("[Utils] show unified message called. message: "+ JSON.stringify(message));
                    if (messageTimeOut){
                        messageTimeOut = typeof messageTimeOut == "number" ? messageTimeOut : 1500;
                        Utils.hideUnimessageTimeout = setTimeout(Utils.hideUnimessages.bind(this), messageTimeOut);
                    }
                }
            }
        },
        // Shows Unimessage and blocks UI if required
        updateUnimessage: function (message, isBlocking, isAllowedInMvp, immediateShow, messageTimeOut) {
            if (isAllowedInMvp || !(this.isCachedMVPShown()
                || this.isCachedBlueprintShown())) {

                if (!((message.type == "progress")
                    && $("#identity-page.active #splash-message.active")[0])) {

                    Utils.hideLoading();

                    if (isBlocking) {
                        this.isBlockingUnimessage = true;
                        this.blockUI();
                    }

                    var unimessage = $(".unimessage").data("view");
                    if (!unimessage || unimessage.isHidden()){
                        Logger.debug("[Utils] Update unimessage calling show. message: "+JSON.stringify(message));
                        Utils.showUnimessage(message, isBlocking, isAllowedInMvp, immediateShow, messageTimeOut);
                        return;
                    }
                    unimessage.update(message, immediateShow);
                    Logger.debug("[Utils] Updating unified message called. message: "+JSON.stringify(message));
                    if (messageTimeOut){
                        messageTimeOut = typeof messageTimeOut == "number" ? messageTimeOut : 1500;
                        Utils.hideUnimessageTimeout && clearTimeout(Utils.hideUnimessageTimeout);
                        Utils.hideUnimessageTimeout = setTimeout(Utils.hideUnimessages.bind(this), messageTimeOut);
                    }
                }
            }
        },

        // Unblocks UI if caused by blocking Unimessage
        unblockUnimessage: function () {
            if (Utils.isBlockingUnimessage) {
                delete Utils.isBlockingUnimessage;
                Utils.unblockUI();
            }
        },

        // Hides open Unimessages and unblocks UI if needed
        hideUnimessages: function (immediateHide) {
            Logger.debug("[Utils] hide unified message called");
            $(".unimessage").each(function () {
                var v = $(this).data("view");

                v.hide(immediateHide);
            });
            Utils.hideUnimessageTimeout && clearTimeout(Utils.hideUnimessageTimeout);

            Utils.unblockUnimessage();
        },

        isUnimessageShown: function () {
            var result = !!$(".unimessage").length;

            return result;
        },

        getCacheModes: function(cacheMode) {
            // when no cacheMode is sent, assume no cache for struct and no cache for state
            cacheMode = cacheMode || "none/none";
            var cacheModes = cacheMode.split("/");
            return {structMode: cacheModes[0], stateMode: cacheModes[1]};
        },

        openFeedback: function(){
            $("#feedback-page").remove();
            var feedbackPage = new Capriza.Views.SideMenu.FeedbackPage();
            feedbackPage.$el.addClass('transitioning');
            feedbackPage.render();
            feedbackPage.$el.removeClass('transitioning');
            return feedbackPage.$el;
        },
        findKey: function(obj, predicate){
            var requestedKey;
            _.some(obj, function(value, key){
                if (predicate(value)){
                    requestedKey = key;
                    return true;
                }
            });

            return requestedKey;
        },
        reportInteraction: function (interactionData){
            interactionData = _.extend({
                element: "General",
                interaction: "general",
                timestamp: Date.now()
            }, interactionData);
            if (interactionData && debug && debug.records && debug.interactions){
                Logger.debug("[LogUserInteractions] target class are: "+ interactionData.interaction);
                debug.interactions.push(interactionData);
                debug.records.push(interactionData);
            }
        },

        backToList: function(){
            Dispatcher.trigger('app/close');
        }

    });

    String.prototype.toCapitalizeCase = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };

    _.extend(String.prototype, {
        capitalize: function () {
            return this.charAt(0).toUpperCase().concat(this.slice(1));
        }
    });

    window.debugCallback= function() {
        console.log(arguments);
        window.debugArgs=arguments;
    }
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/utils/LocationParser.js

try{
(function () {
    window.Utils.LocationParser = {
        locationTypes: {
            "street"            :   [{key:"street_number", stringType:"long_name"}, {key:"route", stringType:"short_name"}],
            "city"              :   [{key:"locality", stringType:"long_name"}],
            "city_and_state"    :   [{key:"locality", stringType:"long_name", commaSeparator: true}, {key:"administrative_area_level_1", stringType:"short_name"}],
            "state"             :   [{key:"administrative_area_level_1", stringType:"long_name"}],
            "zip_code"          :   [{key:"postal_code", stringType:"long_name"}],
            "country"           :   [{key:"country", stringType:"long_name"}],
        },

        getLocation: function (geocode, locationType) {
            if (!geocode.length) return undefined;

            var locationPartsKeys = window.Utils.LocationParser.locationTypes[locationType];

            var mainResult = geocode.filter(function (address) {
                return address.types && address.types.indexOf("premise") >= 0;
            });
            if (!mainResult.length) {
                mainResult = geocode.filter(function (address) {
                    return address.types && address.types.indexOf("street_address") >= 0;
                });
            }
            if (!mainResult.length) {
                mainResult = geocode;
            }
            mainResult = mainResult[0];

            if (!locationPartsKeys) {
                if (locationType == "gps_coordinates") {
                    return mainResult.geometry.location.lat + "," + mainResult.geometry.location.lng;
                }
                // full_address
                return mainResult.formatted_address;
            }

            var locationParts = [];

            locationPartsKeys.forEach(function (locationPartKey, index) {
                mainResult.address_components.some(function (addressComponent) {
                    if (!addressComponent.types || addressComponent.types.indexOf(locationPartKey.key) < 0) return;

                    var address = addressComponent[locationPartKey.stringType];
                    if (!address){
                        address = addressComponent[0];
                    }
                    locationParts[index] = address;
                    return true;
                });

                if (locationParts[index]) return;

                geocode.some(function (result) {
                    if (result === mainResult) return;

                    if (!result.types || result.types.indexOf(locationPartKey.key) < 0) return;

                    var address = result.address_components[0][locationPartKey.stringType];
                    if (!address){
                        address = result.address_components[0][0];
                    }
                    locationParts[index] = address;
                    return true;
                });
            });

            return window.Utils.LocationParser.locationPartsToString(locationParts, locationPartsKeys);
        },

        locationPartsToString: function(locationParts, locationPartsKeys) {
            var address = "";
            locationPartsKeys.forEach(function (locationPartKey, index) {
                if (locationParts[index]) {
                    address += locationParts[index];

                    if (locationPartKey.commaSeparator) {
                        address += ",";
                    }

                    address += " ";
                }
            });

            if (!address) return undefined;

            var trimEnd = 1;
            if (address[address.length - 1] === ",") {
                trimEnd = 2;
            }

            return address.substr(0, address.length - trimEnd);
        }
    }
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/utils/DateHelper.js

try{
(function () {
    window.Utils.DateHelper = {

        formatsByLocale: {
            "af-za"         : "yyyy/MM/dd",
            "am-et"         : "d/M/yyyy",
            "ar-ae"         : "dd/MM/yyyy",
            "ar-bh"         : "dd/MM/yyyy",
            "ar-dz"         : "dd-MM-yyyy",
            "ar-eg"         : "dd/MM/yyyy",
            "ar-iq"         : "dd/MM/yyyy",
            "ar-jo"         : "dd/MM/yyyy",
            "ar-kw"         : "dd/MM/yyyy",
            "ar-lb"         : "dd/MM/yyyy",
            "ar-ly"         : "dd/MM/yyyy",
            "ar-ma"         : "dd-MM-yyyy",
            "ar-om"         : "dd/MM/yyyy",
            "ar-qa"         : "dd/MM/yyyy",
            "ar-sa"         : "dd/MM/yy",
            "ar-sy"         : "dd/MM/yyyy",
            "ar-tn"         : "dd-MM-yyyy",
            "ar-ye"         : "dd/MM/yyyy",
            "arn-cl"        : "dd-MM-yyyy",
            "as-in"         : "dd-MM-yyyy",
            "az-cyrl-az"    : "dd.MM.yyyy",
            "az-latn-az"    : "dd.MM.yyyy",

            "ba-ru"         : "dd.MM.yy",
            "be-by"         : "dd.MM.yyyy",
            "bg-bg"         : "dd.M.yyyy",
            "bn-bd"         : "dd-MM-yy",
            "bn-in"         : "dd-MM-yy",
            "bo-cn"         : "yyyy/M/d",
            "br-fr"         : "dd/MM/yyyy",
            "bs-cyrl-ba"    : "d.M.yyyy",
            "bs-latn-ba"    : "d.M.yyyy",

            "ca-es"         : "dd/MM/yyyy",
            "co-fr"         : "dd/MM/yyyy",
            "cs-cz"         : "d.M.yyyy",
            "cy-gb"         : "dd/MM/yyyy",

            "da"            : "dd-MM-yyyy", //Danish
            "da-dk"         : "dd-MM-yyyy", //Danish (Denmark)
            "de"            : "dd.MM.yyyy", //German
            "de-at"         : "dd.MM.yyyy", //German - Austria
            "de-ch"         : "dd.MM.yyyy", //German - Switzerland
            "de-de"         : "dd.MM.yyyy", //German - Germany
            "de-li"         : "dd.MM.yyyy", //German - Liechtenstein
            "de-lu"         : "dd.MM.yyyy", //German - Luxembourg
            "dsb-de"        : "d. M. yyyy",
            "dv-mv"         : "dd/MM/yy",

            "el-gr"         : "d/M/yyyy",
            "en"            : "M/d/yyyy",   //English
            "en-029"        : "MM/dd/yyyy", //English (Caribbean)
            "en-au"         : "d/MM/yyyy",  //English (Australia)
            "en-bz"         : "dd/MM/yyyy", //English (Belize)
            "en-ca"         : "dd/MM/yyyy", //English - Canada
            "en-gb"         : "dd/MM/yyyy", //English - Great Britain
            "en-ie"         : "dd/MM/yyyy", //English (Ireland)
            "en-in"         : "dd-MM-yyyy", //English (India)
            "en-jm"         : "dd/MM/yyyy", //English (Jamaica)
            "en-my"         : "d/M/yyyy",   //English (Malaysia)
            "en-nz"         : "d/MM/yyyy",  //English (New Zealand)
            "en-ph"         : "M/d/yyyy",   //English (Republic of the Philippines)
            "en-sg"         : "d/M/yyyy",   //English (Singapore)
            "en-tt"         : "dd/MM/yyyy", //English (Trinidad and Tobago)
            "en-us"         : "M/d/yyyy",   //English - United States
            "en-za"         : "yyyy/MM/dd", //English (South Africa)
            "en-zw"         : "M/d/yyyy",   //English (Zimbabwe)
            "es-ar"         : "dd/MM/yyyy", //Spanish - Argentina
            "es-bo"         : "dd/MM/yyyy", //Spanish - Bolivia
            "es-cl"         : "dd-MM-yyyy", //Spanish - Chile
            "es-co"         : "dd/MM/yyyy", //Spanish - Colombia
            "es-cr"         : "dd/MM/yyyy", //Spanish - Costa Rica
            "es-do"         : "dd/MM/yyyy", //Spanish - Dominican Republic
            "es-ec"         : "dd/MM/yyyy", //Spanish - Ecuador
            "es-es"         : "dd/MM/yyyy", //Spanish - Spain (Traditional)
            "es-gt"         : "dd/MM/yyyy", //Spanish - Guatemala
            "es-hn"         : "dd/MM/yyyy", //Spanish - Honduras
            "es-mx"         : "dd/MM/yyyy", //Spanish - Mexico
            "es-ni"         : "dd/MM/yyyy", //Spanish - Nicaragua
            "es-pa"         : "MM/dd/yyyy", //Spanish - Panama
            "es-pe"         : "dd/MM/yyyy", //Spanish - Peru
            "es-pr"         : "dd/MM/yyyy", //Spanish - Puerto Rico
            "es-py"         : "dd/MM/yyyy", //Spanish - Paraguay
            "es-sv"         : "dd/MM/yyyy", //Spanish - El Salvador
            "es-us"         : "M/d/yyyy",   //Spanish (United States)
            "es-uy"         : "dd/MM/yyyy", //Spanish - Uruguay
            "es-ve"         : "dd/MM/yyyy", //Spanish - Venezuela
            "et-ee"         : "d.MM.yyyy",
            "eu-es"         : "yyyy/MM/dd",

            "fa-ir"         : "MM/dd/yyyy",
            "fi-fi"         : "d.M.yyyy",
            "fil-ph"        : "M/d/yyyy",
            "fo-fo"         : "dd-MM-yyyy",
            "fr"            : "dd/MM/yyyy", //French
            "fr-be"         : "d/MM/yyyy",  //French - Belgium
            "fr-ca"         : "yyyy-MM-dd", //French - Canada
            "fr-ch"         : "dd.MM.yyyy", //French - Switzerland
            "fr-fr"         : "dd/MM/yyyy", //French - France
            "fr-lu"         : "dd/MM/yyyy", //French - Luxembourg
            "fr-mc"         : "dd/MM/yyyy", //French (Principality of Monaco)
            "fy-nl"         : "d-M-yyyy",   //Frisian - Netherlands

            "ga-ie"         : "dd/MM/yyyy",
            "gd-gb"         : "dd/MM/yyyy",
            "gl-es"         : "dd/MM/yy",
            "gsw-fr"        : "dd/MM/yyyy",
            "gu-in"         : "dd-MM-yy",

            "ha-latn-ng"    : "d/M/yyyy",
            "he"            : "dd/MM/yyyy",
            "he-il"         : "dd/MM/yyyy",
            "hi-in"         : "dd-MM-yyyy",
            "hr-ba"         : "d.M.yyyy.",
            "hr-hr"         : "d.M.yyyy",
            "hsb-de"        : "d. M. yyyy",
            "hu-hu"         : "yyyy. MM. dd.",
            "hy-am"         : "dd.MM.yyyy",

            "id-id"         : "dd/MM/yyyy",
            "ig-ng"         : "d/M/yyyy",
            "ii-cn"         : "yyyy/M/d",
            "is-is"         : "d.M.yyyy",
            "it"            : "dd/MM/yyyy", //Italian
            "it-ch"         : "dd.MM.yyyy", //Italian - Switzerland
            "it-it"         : "dd/MM/yyyy", //Italian - Italy
            "iu-cans-ca"    : "d/M/yyyy",
            "iu-latn-ca"    : "d/MM/yyyy",

            "ja-jp"         : "yyyy/MM/dd",

            "ka-ge"         : "dd.MM.yyyy",
            "kk-kz"         : "dd.MM.yyyy",
            "kl-gl"         : "dd-MM-yyyy",
            "km-kh"         : "yyyy-MM-dd",
            "kn-in"         : "dd-MM-yy",
            "ko-kr"         : "yyyy-MM-dd",
            "kok-in"        : "dd-MM-yyyy",
            "ky-kg"         : "dd.MM.yy",

            "lb-lu"         : "dd/MM/yyyy",
            "lo-la"         : "dd/MM/yyyy",
            "lt-lt"         : "yyyy.MM.dd",
            "lv-lv"         : "yyyy.MM.dd.",

            "mi-nz"         : "dd/MM/yyyy",
            "mk-mk"         : "dd.MM.yyyy",
            "ml-in"         : "dd-MM-yy",
            "mn-mn"         : "yy.MM.dd",
            "mn-mong-cn"    : "yyyy/M/d",
            "moh-ca"        : "M/d/yyyy",
            "mr-in"         : "dd-MM-yyyy",
            "ms-bn"         : "dd/MM/yyyy",
            "ms-my"         : "dd/MM/yyyy",
            "mt-mt"         : "dd/MM/yyyy",

            "nb-no"         : "dd.MM.yyyy", //Norwegian, Bokml (Norway)
            "ne-np"         : "M/d/yyyy",
            "nl"            : "d-M-yyyy",   //Dutch
            "nl-be"         : "d/MM/yyyy",  //Dutch - Belgium
            "nl-nl"         : "d-M-yyyy",   //Dutch - Netherlands
            "nn-no"         : "dd.MM.yyyy", //Norwegian, Nynorsk (Norway)
            "no"            : "dd.MM.yyyy", //Norwegian
            "no-no"         : "dd.MM.yyyy", //Norwegian
            "nso-za"        : "yyyy/MM/dd",

            "oc-fr"         : "dd/MM/yyyy",
            "or-in"         : "dd-MM-yy",

            "pa-in"         : "dd-MM-yy",
            "pl-pl"         : "yyyy-MM-dd",
            "prs-af"        : "dd/MM/yy",
            "ps-af"         : "dd/MM/yy",
            "pt-br"         : "d/M/yyyy",
            "pt-pt"         : "dd-MM-yyyy",

            "qut-gt"        : "dd/MM/yyyy",
            "quz-bo"        : "dd/MM/yyyy",
            "quz-ec"        : "dd/MM/yyyy",
            "quz-pe"        : "dd/MM/yyyy",

            "rm-ch"         : "dd/MM/yyyy",
            "ro-ro"         : "dd.MM.yyyy",
            "ru-ru"         : "dd.MM.yyyy",
            "rw-rw"         : "M/d/yyyy",

            "sa-in"         : "dd-MM-yyyy",
            "sah-ru"        : "MM.dd.yyyy",
            "se-fi"         : "d.M.yyyy",
            "se-no"         : "dd.MM.yyyy",
            "se-se"         : "yyyy-MM-dd",
            "si-lk"         : "yyyy-MM-dd",
            "sk-sk"         : "d. M. yyyy",
            "sl-si"         : "d.M.yyyy",
            "sma-no"        : "dd.MM.yyyy",
            "sma-se"        : "yyyy-MM-dd",
            "smj-no"        : "dd.MM.yyyy",
            "smj-se"        : "yyyy-MM-dd",
            "smn-fi"        : "d.M.yyyy",
            "sms-fi"        : "d.M.yyyy",
            "sq-al"         : "yyyy-MM-dd",
            "sr-cyrl-ba"    : "d.M.yyyy",
            "sr-cyrl-cs"    : "d.M.yyyy",
            "sr-cyrl-me"    : "d.M.yyyy",
            "sr-cyrl-rs"    : "d.M.yyyy",
            "sr-latn-ba"    : "d.M.yyyy",
            "sr-latn-cs"    : "d.M.yyyy",
            "sr-latn-me"    : "d.M.yyyy",
            "sr-latn-rs"    : "d.M.yyyy",
            "sv-fi"         : "d.M.yyyy",   //Swedish - Finland
            "sv-se"         : "yyyy-MM-dd", //Swedish - Sweden
            "sw-ke"         : "M/d/yyyy",
            "syr-sy"        : "dd/MM/yyyy",

            "ta-in"         : "dd-MM-yyyy",
            "te-in"         : "dd-MM-yy",
            "tg-cyrl-tj"    : "dd.MM.yy",
            "th-th"         : "d/M/yyyy",
            "tk-tm"         : "dd.MM.yy",
            "tn-za"         : "yyyy/MM/dd",
            "tr-tr"         : "dd.MM.yyyy",
            "tt-ru"         : "dd.MM.yyyy",
            "tzm-latn-dz"   : "dd-MM-yyyy",

            "ug-cn"         : "yyyy-M-d",
            "uk-ua"         : "dd.MM.yyyy",
            "ur-pk"         : "dd/MM/yyyy",
            "uz-cyrl-uz"    : "dd.MM.yyyy",
            "uz-latn-uz"    : "dd/MM yyyy",

            "vi-vn"         : "dd/MM/yyyy",

            "wo-sn"         : "dd/MM/yyyy",

            "xh-za"         : "yyyy/MM/dd",

            "yo-ng"         : "d/M/yyyy",

            "zh-cn"         : "yyyy/M/d",
            "zh-hk"         : "d/M/yyyy",
            "zh-mo"         : "d/M/yyyy",
            "zh-sg"         : "d/M/yyyy",
            "zh-tw"         : "yyyy/M/d",
            "zu-za"         : "yyyy/MM/dd",
        },

        getDateFormat: function() {
            try {
                var locale = window.navigator.userLanguage || window.navigator.language;
                if (!locale) return undefined;

                return window.Utils.DateHelper.formatsByLocale[locale.toLowerCase()];
            }
            catch (err) {
                //log
                return undefined;
            }
        }

    }
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/utils/Queue.js

try{
(function() {

    //queueTask
    var QueueTask = Utils.QueueTask = function(taskData){

        this.async = taskData && taskData.async || false;
        this.name = taskData && taskData.name;
        this.taskFunction = taskData && taskData.taskFunction;

    };
    _.extend(QueueTask.prototype, {
        run: function(finishCallback){
            Logger.info("[QueueTask] running task: " + this.name + ', in ' + (this.isAsync() ? 'async' : 'sync') + ' mode.' );
            this.taskFunction && this.taskFunction(finishCallback);
        },
        isAsync: function(){
            return this.async;
        }
    });


    //Queue of tasks (Utils.QueueTask)
    var Queue = Utils.Queue = function (name) {
        this.name = name;
        this._queue = [];
    };

    _.extend(Queue.prototype, {

        push: function(task){
            if (!task || !(task instanceof QueueTask))
                throw "[Queue-"+this.name+"] task is no a valid instance of 'Utils.QueueTask'";

            Logger.info ("[Queue-"+this.name+"] pushing new task to Queue: " + task.name + ", at index: " + this.getLength());
            this._queue.push(task);

            this.getLength() == 1 && this.processNext();
        },
        processNext: function(){
            var self = this,
                task = this._queue[0];

            if (!task) {
                this.trigger("empty");
                return;
            }

            Logger.info("[Queue-"+this.name+"] Processing next task: " + task.name);

            if (!task.isAsync()){
                task.run();
                this.shiftAndProcessNext();

            } else{
                task.run(function(){ self.shiftAndProcessNext(); });
            }
        },
        shiftAndProcessNext: function(){
            this._queue.shift();
            this.processNext();
        },
        getLength: function(){
            return this._queue.length;
        }
    }, Backbone.Events);
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Logger.js

try{
(function () {

    if (Capriza.Logger) return;

    window.logger = Capriza.Logger = {

        _logs: [],

        _tags: [],

        hideConsoleLogging : false,

        tag: function(tag){
            this.debug("Adding tag:"+tag);
            Capriza.Logger._tags.push(tag);
        },

        trace: function (message) {
            if (window._urlParams.trace) {
                logger._print2("trace", message)
            }
        },

        debug: function (message) {
            logger.log(message);
        },

        log: function (message) {
            logger._print2("log", message);
        },

        info: function (message) {
            logger._print2("info", message)
        },
        warn: function (message) {
            logger._print2("warn", message)
        },
        error: function (message, e, type, additionalMessage, mobileOnly) {
            logger._print2("error", message, e, additionalMessage);
            if (!window.testMode) {
                logger._sendLogToNapi(message, "error", e, type, additionalMessage, mobileOnly);
            }
        },
        // for designer
        exception: function(e, message) {
            logger.error(message, e);
        },
        _print2: function (level, message, e, additionalMessage) {

            var logMessage = level.toUpperCase() + " - " + new Date().toISOString().replace('T', ' ').replace('Z', '') + ": " + message + (additionalMessage ? ", additionalMessage:"+additionalMessage : "");

            if(!Capriza.Logger.hideConsoleLogging) {
                e && console[level](e, message) || console[level](message);
                additionalMessage && console[level]("additionalMessage:"+additionalMessage);
                e && e.stack && console[level](e.stack);
            }
            logger._logs.push(logMessage + (e ? ". EXCEPTION: " + e : ""));
        },

        _print: function(){
            //DON'T IMPLEMENT THIS EVER...
            //This function is overridden in override.js to solve unencrypted passwords in log in versions jan2014-dec2014 (engine mig version 34-66).
        },

        _suppressionRegex : /(.*closed unexpectedly,connection rejected.*|.*non fatal.*|.*terminated due to a long period.*)/i,
        _sendLogToNapi: function (msg, severity, exception, type, additionalMessage, mobileOnly) {
            if (severity == "error") {

                if (logger._suppressionRegex.test(msg)) {
                    logger.log("Suppressed inactivity log message");
                    return;
                }
            }
            if (window.ComManager && ComManager.serverMessageEndSent) {
                logger.log("Suppressed spam inactivity log message");
                return;
            }

            try {
                var path = '/logger/mobile/' + severity,
                    sessionId = window.appData ? window.appData.session_id : '',
                    appDataClone = null;
                if (window.appData) {
                    appDataClone = JSON.parse(JSON.stringify(window.appData));
                    appDataClone.xkcd = undefined; //TODO: talk to Fisher ->  GibberishAES && GibberishAES.MD5(appDataClone.xkcd);
                }
                else{
                    appDataClone = { noAppData:"noAppData", href: location.href };
                }

                var data = {
                    appData: appDataClone,
                    error:{errorType: type || "none"},
                    userAgent: navigator ? navigator.userAgent : "NA",
                    additionalMessage : additionalMessage || ""
                };

                if(exception) data.error.exception = exception;
                if(navigator && navigator.platform) data.platform = navigator.platform;
                if(navigator && navigator.language) data.language = navigator.language;

                if (!window.testMode) {
                    Capriza.Napi.send(path, {
                        msg: msg,
                        data: data,
                        sessionId: sessionId
                    });
                }

                if (Capriza.Capp && Capriza.Capp.messenger) {
                    Capriza.Capp.messenger.emit("zappError", {msg: msg, zappId: data.appData.app_id, zappName: data.appData.app_name});
                }
            } catch (e) {
                console.error("logger error...")
            }
            try {
                if (Capriza.isMonitored) {
                    Capriza.Feedback.send("#error #auto " + msg, {additionalMessage: additionalMessage, errorType: type || "none", mobileOnly: mobileOnly });

                }
            }
            catch (e) {
                console.error("Feedback error, not sent");
            }
        },

        get logs() {
            return logger._logs
        }


    };

    window.Logger = (window.Logger || Capriza.Logger);

    Dispatcher.on("appData", function(appData) {
        if(window._urlParams.showConsole) return;
        var hideConsole = (appData.config && appData.config.logInMemory);
        if(hideConsole)  window.Logger.log("Hiding console logging");
        window.Logger.hideConsoleLogging = hideConsole;
    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Mobile.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 5/1/13
 * Time: 1:46 PM
 * To change this template use File | Settings | File Templates.
 */

;(function() {

    var MobileView = Backbone.View.extend({
        className: "mobile-wrap viewport themed",
        initialize: function() {
            // build HTML wrapper
            this.$el.appendTo("body");

        }
    });

    Capriza.initMobile = function() {

        var viewport = new MobileView();

        function fixActionbar(){
            var offset = 0;

            // status bar stuff for phonegap < 3
            if (Capriza.device.ios7 && Capriza.isPhonegap && !Capriza.cordova){
                offset = 20;
                viewport.el.style.height = window.innerHeight - offset + 'px';
            }

            if (Capriza.device.android) {
                viewport.el.style.minHeight = window.innerHeight - offset + 'px';
            }

        }

        var prevHeight = window.innerHeight;
        function updateWhenRotationFinished(){
            var interval = window.setInterval(function () {
                if (prevHeight != window.innerHeight) {
                    window.clearInterval(interval);
                    fixActionbar();
                    prevHeight = window.innerHeight;
                }
            }, 20);
        }

        if (!Capriza.device.ipad) {
            fixActionbar();
        }

        window.addEventListener("orientationchange", function() {
            if (!Capriza.device.ipad) { // for ipads we fix the viewport differently
                updateWhenRotationFinished();
            }

            if (Capriza.device.ios7) {
                setTimeout(function() {
                    Logger.debug("scrolling to 0,0");
                    window.scrollTo(0,0);
                }, 500);

                if (Capriza.device.isTablet) {
                    setTimeout(function() { Capriza.device.fixIpadLandscape("orientationchange"); }, 500);
                }
            }

        });

        // fix for iphone (another phase of #8126) - when scrolling while the keyboard is up, the black area still happens.
        if (Capriza.device.ios7 && !Capriza.device.isTablet) {
            window.addEventListener("blur", function() {
                window.scrollTo(0,0);
            }, true);
        }

        // fix for ipad - on landscape the whole viewport (not to be confused with the element '.viewport') gets 20px extra that really need special attention.
        if (Capriza.device.ipad) {
            scrollTo(0,0);
            setTimeout(function() { Capriza.device.fixIpadLandscape("onload"); }, 0);
            window.addEventListener("scroll", function() {
                if ($(":focus").length === 0) {
                    Capriza.device.fixIpadLandscape("scroll");
                } else {
                    Logger.debug("not fixing ipad landscape - in focus");
                }
            });

            window.addEventListener("blur", function() {
                Capriza.device.fixIpadLandscape("blur");
            }, true);
        }

        if (window.appData && window.appData.vpn_access) {

            Logger.debug('calling healthcheck early...');
            $.ajax({
                url: ComManager.runtimeBaseUrl()  + '/health-check/status',
                type: "get",
                success: function(data, textStatus, XMLHttpRequest) {
                    Logger.debug('healthcheck went successfully.')
                },
                error: function(xhr, textStatus, errorThrown) {
                    Logger.debug('healthcheck went wrong.')
                },
                timeout: 10000
            });
        }


        if (Capriza.isStore) {
            Logger.debug('running inside the store');
            viewport.$el.addClass("store");
        }


        if (Capriza.device.ios){
            //this is very ugly, there is an ios issue that the only way to close the keyboard is clicking on "done" in the accessory bar
            $(".viewport")[0].addEventListener("click", function(e){},true);
        }
    };
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/NewWeb.js

try{
;(function() {

    var WebView = Backbone.View.extend({
        initialize: function() {
            // build HTML wrapper
            if (this.options.fullScreen) {
                this.$el = $("body").addClass("mobile-wrap viewport themed");
//                this.$el = $("<div>").addClass("mobile-wrap viewport themed").appendTo("body");
            } else {
                this.$el = $('<div class="nonmobile-wrap">' +
                    '<section class="app">' +
                    '<img src="'+Capriza.baseUrl+'/images/preview-iphone4-large.png" alt="Android" class="mobile-image">' +
                    '<div class="background"></div>' +
                    '<div class="viewport themed web"></div>' +
                    '</section>' +
                    '<section class="app-details">' +
                    '<img class="app-icon"/>' +
                    '<h1 class="app-name"></h1>' +
                    '<p class="app-description"></p>' +
                    '<span class="app-getit">Get this app on your mobile devices with this link: </span><img class="devices" src="'+Capriza.baseUrl+'/images/deviceIcons.png"/><br>' +
                    '<span class="app-url"></span>' +
                    '<span class="app-getit qr">Or scan it with a QR-Code scan app:</span> ' +
                    '<div class="app-qrcode"></div> ' +
                    '</section>' +
                    '</div>').appendTo(document.body);

                $("#new-splash").appendTo(this.$(".viewport"));
                if(window.devMode){
                    $("section.logo").remove();
                }

                if (window._urlParams["cdsk"]) {
                    this.$el.addClass("clean-desktop");
                }
            }
        },

        showDetails: function() {
            this.$(".app-details").addClass("active");
        }
    });

    $.capriza = $.capriza || {};
    _.extend($.capriza, {
        click: "click"
    });

    Capriza.initWeb = function() {
        var view = new WebView({ fullScreen: Capriza.fullScreen });
//        Dispatcher.trigger("app/loaded");

        if (!Capriza.fullScreen) $(".viewport").addClass("not-fullscreen");

        if (window.location.hash.indexOf('devmode') >= 0 || window.devMode) {
            return;
        }

        if (!Capriza.fullScreen && window.location.pathname.indexOf('maintest') < 0) {
            Logger.info("Web init zappToken: "+ (window.Capriza && Capriza.getToken()));
            $.getJSON(Config.url("/catalog/u_apps/" + Capriza.getToken() + "/u_app.json"))
                .done(function(data) {
                    if (data['success'] !== false && data['u_app']) {
                        var app = data['u_app'];
                        $(".app-details .app-name").text(Utils.decodeHtml(decodeURIComponent(app.name)));
                        $(".app-details .app-icon").attr("src", app.icon_url);
                        $(".app-details .app-description").text(Utils.decodeHtml(decodeURIComponent(app.description)));
                        $(".app-details .app-url").text(app.mobile_url);
//                        console.log(app);
                        if ("QrCode" in window) {
                            $(".app-qrcode").html(window.QrCode.create(app.mobile_url));
                        }

                        view.showDetails();
                    }
                })
                .fail(function(data){
                    Logger.error("Error when calling to api code: "+data.status+' error text '+data.statusText);
                });
        }
    };
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/PageVisibilityManager.js

try{
(function () {

    window.Capriza = $.extend({}, window.Capriza);

    Capriza.PageVisibilityManager = {
        init: function() {

            // Set the name of the hidden property and the change event for visibility
            var hidden, visibilityChange;
            if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support
                hidden = "hidden";
                visibilityChange = "visibilitychange";
            } else if (typeof document.mozHidden !== "undefined") {
                hidden = "mozHidden";
                visibilityChange = "mozvisibilitychange";
            } else if (typeof document.msHidden !== "undefined") {
                hidden = "msHidden";
                visibilityChange = "msvisibilitychange";
            } else if (typeof document.webkitHidden !== "undefined") {
                hidden = "webkitHidden";
                visibilityChange = "webkitvisibilitychange";
            }

            // If the page is hidden, pause the video;
            // if the page is shown, play the video
            function handleVisibilityChange() {
                if (document[hidden]) {
                    Logger.debug('zApp enters onPause');
                    Dispatcher.trigger("app/onPause");
                } else {
                    Logger.debug('zApp enters onResume');
                    Dispatcher.trigger("app/onResume");
                }
            }

            function handleiOSPageShow() {
                if (!document[hidden]) {
                    Logger.debug('zApp enters onResume');
                    Dispatcher.trigger("app/onResume");
                }

            }

            function handleiOSPageHide() {
                if (!document[hidden]) {
                    Logger.debug('zApp enters onPause');
                    Dispatcher.trigger("app/onPause");
                }

            }

            // Warn if the browser doesn't support addEventListener or the Page Visibility API
            if (typeof document.addEventListener === "undefined" ||
                typeof hidden === "undefined") {
                Logger.warn("Supports of Page Visibility API not found");
            } else {
                // Handle page visibility change
                if (Capriza.device.ios) {
                    window.addEventListener('pageshow', handleiOSPageShow, false);
                    window.addEventListener('pagehide', handleiOSPageHide, false);
                }
                document.addEventListener(visibilityChange, handleVisibilityChange, false);

            }

        }
    };


})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Config.js

try{
// Module Config
;
(function () {
  var apiUrl = "https://api.capriza.com";

  if (window.Capriza && Capriza.apiHost){
    apiUrl = Capriza.apiHost;
  } else {
    if (location.hostname.indexOf("zappdev") > -1) {
      apiUrl = apiUrl.replace("api", "apidev");

    }
    else if (location.hostname.indexOf("zapptest") > -1) {
      apiUrl = apiUrl.replace("api", "apitest");
    }
  }
  window.Config = {


    apiUrl:apiUrl,

    get napiUrl () {
      var napiApiPrefix = '/api';
      var napiUrl=this.apiUrl;
      return napiUrl
              .replace('api', 'napi')
              .replace(':3000', ':3100')
          + napiApiPrefix;
    },

    url:function (resource) {
      return this.apiUrl + resource;
    },

    assetVersions: {
      structure: {assetName: 'structure_version', fileName: 'structure.js', type: 'script'},
      style: {assetName: 'custom_css_version', fileName: 'style.css', type: 'style'}
    }
  };
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Runner.js

try{
// Module Runner
;(function() {

    function mobileActive() {
        if (!Runner.mobileActive) Dispatcher.trigger("mobile/active");
    }

    function onError(data) {
        if (!data){
            Logger && Logger.error("Runner Error - no data received");
            return;
        }

        var errorMsg = data.responseText || data.errors || data;
        Capriza.splashRenderAuthMessage && Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.authenticating), {fontColor: '#ff3333', isError: true});
        Logger.debug('got error from runAjax with '+errorMsg);
        if(data && data.app_data)
        {
            Dispatcher.trigger('mobile/error', data.app_data);
        }else{

            if (data && data.error_codes && data.error_codes.length > 0) {
                var errorCode = data.error_codes[0];
                var errorObj = window.errorCodes.getErrorObjForId(errorCode);

                if (errorObj && errorObj.message) {
                    Dispatcher.trigger('mobile/error', errorObj.message);
                    return;
                }

            }

            Dispatcher.trigger('mobile/error', data);

        }

    }
    window.Runner = {

        run: function(options) {


//           only show initial loading message when appropriate
            if (!Capriza.splashing) {
                //$.capriza.showLoadingCenter();
            }
            var self = this;
            options = _.extend({
                authenticate: false
            }, options);

            if (options.authenticate) {
                if (appData && appData.auth_url) {
                    // add the 'origin' param so that after authentication we are redirected back to this app
                    var authurl = appData.auth_url.url +'&origin=' + encodeURIComponent(window.location.href);
                    Logger.debug('authentication redirect: ' + authurl);
                    var messageOptions={
                        header1: 'Redirecting...',
                        p1: 'Redirecting to ' + appData.auth_url.name + " Authentication",

                        buttonStyle: 'display:none',
                        renderAction: function() {
//                            give capriza logo a chance to load on error page
                            setTimeout(function(){
                                window.location.assign(authurl);
                            },0)

                        }
                    };
                    Dispatcher.trigger("mobile/error",messageOptions);
                    return;
                }

                Capriza.loginModel = new Capriza.Model.Login({ title: "Capriza Remote Access" });
                if (Capriza.loginModel.get("user") === null) {
                    //$.capriza.hideLoadingCenter();
                    Dispatcher.trigger("login/show");
                } else if (Capriza.loginModel.get("user").pending){
                    Capriza.loginModel.on("change:user", function(model, user) {
                        Capriza.loginModel.off("change:user", arguments.callee);

                        if (user === null) {
                            //$.capriza.hideLoadingCenter();
                            Dispatcher.trigger("login/show");
                        } else if (user.pending) {

                        } else {
                            if(Capriza.loginModel.get("user").confirmed==true){
                                self.runSession();
                            }else{
                                Dispatcher.trigger("confirmation/show");
                            }

                        }
                    });
                }
                return;
            }

            if (window.appData) {
                appData.app_name = decodeURIComponent(appData.app_name);
                appData.ui_properties.logoUrl && pageManager.addLogo(appData.ui_properties.logoUrl);
                appData.ui_properties.isRTL && pageManager.setRTL(appData.ui_properties.isRTL);
                Dispatcher.trigger("title/change",  appData.app_name);
                this.setHomeIcon(appData.icon_url);

                // appData.ui_properties.showMobileFeatures holds the value that the app was recorded with
            }

            ComManager.registerNotifier({
                connecting: function(name) {
                    ComManager.transport = name;
                },
                connect : function(){
                },
                disconnect : function(msg){
                    if(!ComManager.serverMessageEndSent){
                        Logger.error("Connection with the server was closed unexpectedly,"+ (msg || ''), undefined, "ComManagerDisconnect");
                        pageManager.generateError({msg: Capriza.translator.getText(Capriza.translator.ids.disconnectedDueTo), closeZapp: true});
//                        pageManager.generateErrorPage({nonFatal: true, reason: 'Connection with the server was closed
// unexpectedly. Please run the app again.'});
                    }
                },
                message : function(msg){
                    handleResponse(msg);
                },
                error : function(data){

                    mobileActive();
                    Logger.error('got error on socket '+ data, undefined, "ComManagerError");
                    pageManager.generateErrorPage(data);
                },
                reconnected : function(){
                    if (!Capriza.support.WebSocket) return;
                    pageManager.hideReconnectingMessage();
                },
                reconnect: function(data) {
//                    Logger.debug("reconnect: " + JSON.stringify(data));
                },
                security: function(data) {
                    Logger.debug("notifier security");

                    Dispatcher.trigger('mobile/dataStoreRead');

                    if (window._urlParams.offline && window._urlParams.taskName === "bulk" && Capriza.device.ios) {
                        Dispatcher.trigger('mobile/performOnlineBulk');
                    }

                },
                reconnecting : function(data){
//                    Logger.debug("reconnecting: " + JSON.stringify(data));
                    if (!Capriza.support.WebSocket) return;
                    if(!ComManager.serverMessageEndSent)
                        pageManager.generateError({reconnect : true})
                }
            });

            //check if real websocket support or socket.io shim
            if(window.WebSocket && !window.WebSocket.__initialize){
                ComManager.initWebSockets();
            }
            else{
                //prevent connection before load event (no other way of doing this on android!!!)
                if(Capriza.device.android2){
                    setTimeout(function(){ComManager.initWebSockets()},2000);
                }else{
                    setTimeout(function(){ComManager.initWebSockets()},1000);
                }

            }

            Dispatcher.on("application/firstContext application/dialog application/contextNotFound application/fatalError", mobileActive);

            Dispatcher.on("mobile/active", function() {
                self.mobileActive = true;
                //$.capriza.hideLoadingCenter();
            });

            Dispatcher.on("mobile/splash/hidden", function() {
                self.mobileAfterSplash = true;
            });

            Dispatcher.trigger("runner/run", appData);
        },

        setIsTablet: function() {
            var calcHeight = $('.viewport').height();
            var calcWidth = $('.viewport').width();
            Capriza.device.isLargeScreen = (calcHeight > 600 && calcWidth > 600) || Capriza.device.ipad;

            Capriza.device.isTablet = (Capriza.device.isLargeScreen || window._urlParams.tablet=="1") && window._urlParams.tablet!="0";
        },

        initSession: function(){
            Logger.info("Init Session zapp token "+ (window.Capriza && Capriza.getToken()));
            var data = {
                appToken: Capriza.getToken()
            };

            if (!data.appToken) {
                logger.log('skipping startSession: no token');
                return;
            }
            this.setIsTablet();

            if (Capriza.device.isTablet) {
                Logger.debug('running as tablet');
                $("html").addClass("cp-isTablet");
            }
        },

        runSession: function() {
            Logger.info("Run Session zapp token "+ (window.Capriza && Capriza.getToken()));
            var data = {
                appToken: Capriza.getToken()
            };

            if (!data.appToken) {
                logger.log('skipping startSession: no token');
                return;
            }

            if (window.MBOOT && window.MBOOT.Config.cookies && !Utils.isRunningInBackground()) {
                Dispatcher.on("app/loaded", function() {
                    Dispatcher.trigger("identity/addSignOut");
                });
            }

            var timeoutId = setTimeout(function() {
                if (!window.devMode) {
                    Logger.debug('slow network detected from api.');
                    Logger.tag("slowApiConnect");
                    Dispatcher.trigger('message/slowNetworkMsg');
                }
            }, 4000);

            var self = this;
            var apiCallStarted = take("apiCallStarted");
            var start = Date.now();
            window.ComManager.startSession(data, function(err, appdata) {
                Logger.debug('start session response received after ' + (Date.now() - start) + ' milliseconds');
                clearTimeout(timeoutId);
                if (err) {
                    Logger.debug('start session ended in error');
                    take("apiCallFail");
                    onError(err);
                    return;
                }
                apiCallStarted("apiCallDone");
                Dispatcher.trigger('splash/setTimeout');
                var successParam = appdata && appdata.success;
                Logger.debug('start session ended with success: ' +successParam);
                if (successParam) {
                    self.startApplication(appdata, data.appToken);
                } else {
                    Logger && Logger.info("Runner Start session - no successParam sending appdata to to handle error");
                    onError(appdata);
                }
            });
        },

        startApplication: function(data, appToken) {
            Logger.debug('startApplication started');

            if (!data) {
                Logger.debug('No application data received');
                onError({responseText: "No application data received"});
                return;
            }

            if (!data.app_data) {
                Logger.debug('No application data received 2');
                onError(data);
                return;
            }
            var appData = window.appData = data.app_data;

            Logger.info('[startApplication] started with session id: ' + appData.session_id);

            Dispatcher.trigger("appData", appData);

            Logger.info('[startApplication] Check for version update');
            Capriza.VersionManager.checkForVersionUpdate();

            appData.app_name = Utils.decodeHtml(decodeURIComponent(appData.app_name));
            appData.description = Utils.decodeHtml(decodeURIComponent(appData.description));

            try {
                appData.ui_properties = (typeof appData.ui_properties === "string") && JSON.parse(appData.ui_properties.replace(/&quot;/g, '"'));

            } catch (ex) {
                appData.ui_properties = {};

            }

            var lang = appData.config.locale;
            if (lang) {
                Capriza.translator.init(lang);
            }

            var noMenuByFlag = appData.config.destroyGears;

            if (noMenuByFlag) {
                Dispatcher.trigger('sideburger/hide');
            }

            var currUniqueTokenString = ClientCache.getItem('unique_token');
            if (currUniqueTokenString) {
                var oldUT = JSON.parse(currUniqueTokenString);
                if (oldUT && oldUT.value && oldUT.xkcd) {
                    if (oldUT.value !== appData.unique_token.value) {
                        //not same user
                    }
                    else if (oldUT.xkcd !== appData.unique_token.xkcd) {
                        Logger.tag("xkcdChanged");
                        Logger.error("xkcd changed", undefined, "xkcdChanged", "user id:" + appData.unique_token.value, true);
                    }
                }
            }


            ClientCache.setItem('unique_token', JSON.stringify(appData.unique_token));
            ClientCache.setItem("appTitle-" + appToken, appData.app_name);
            ClientCache.setItem("appIcon-" + appToken, appData.icon_url);
            ClientCache.setItem("appDomain-" + appToken, appData.domain);

            var config = window.appData && window.appData.config;
            if (config && config.mvpTimeout) {
                ClientCache.setItem(Capriza.Views.MVPageView.zappDataKey + Capriza.getToken() + '-timeout', config.mvpTimeout);
            }

            if (config && config.brand) {

                var brand = config.brand && config.brand.global;

                var brandName = config.brandName;

                if (brandName) {
                    var secondaryBrands = config.brand.secondaryBrands || [];

                    brand = secondaryBrands.filter(function (brand) {
                            return brand.name === brandName;
                        })[0] || config.brand.global;
                }
                Utils.setBrand(brand);

            }

            Dispatcher.trigger('splash/detailsUpdated');

            Dispatcher.trigger("app/loaded");


            checkDebugRedirect();

            if (!appData.config.cacheMVP && appData.config.cacheMVP !== undefined) {
                Dispatcher.trigger('mvp/remove');
            }

            Logger.debug('startApplication ended');
        },

        setHomeIcon: function(icon_url) {
            $('#appleHomeIcon').remove();
            var $appleHomeIcon = $('<link id="appleHomeIcon" rel="apple-touch-icon-precomposed" href="'+icon_url+'"/>');
            var $chromeHomeIcon = $('<link id="chromeHomeIcon" rel="shortcut icon" href="'+icon_url+'"/>');
            $('head').append($appleHomeIcon).append($chromeHomeIcon);
        }
    };

    function checkDebugRedirect(){
        if (window._urlParams['local']) {
            var local = window._urlParams['local'];
            var appData = window.appData;
            var host = 'localhost';


            switch (local) {
                case "d":
                    local="mobile";
                    host="dor.il.capriza.com";
                    break;
                case "o":
                    local="mobile";
                    host="ori.il.capriza.com";
                    break;
                case "a":
                    local="mobile";
                    host="amit-pc.capriza.com";
                    break;
                case "b":
                    local="mobile";
                    host="bar.il.capriza.com";
                    break;
                case "j":
                    local="mobile";
                    host="jeremy-pc.capriza.com";
                    storeUrl = "http://" + host + '/capriza.store/?phonegap=' + phonegap + '&store=' + store + '&quickLogin=true';
                    break;
                case "w":
                    local="capriza/mobile";
                    host="omer.il.capriza.com";
                    break;
                case "jl":
                    local="mobile";
                    host="jonathanlandau.il.capriza.com";
                    break;
                case "m":
                    local="mobile";
                    host="maayan.il.capriza.com";
                    break;
                case "r": //For background run only
                    return;
                default:
                    if (window._urlParams['mobileHost']) {
                        host = window._urlParams['mobileHost'];
                    }
            }


            delete _urlParams.local;

            var env = /zapp(dev|test)/.exec(location.host);
            if (env) {
                _urlParams.env = env[1];
            } else {
                _urlParams.env = "prod";
            }
            var params = "?" + $.param(_urlParams);



            window.location = "http://" + host + "/" + local + "/maintest.html" + params + "#local;" + encodeURIComponent(JSON.stringify(appData));

        }

    }

    Dispatcher.on("app/online", function () {
        window.appData ? Utils.isCachedMVPShown() && Utils.reload()
            : Runner.runSession();
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/ViewportInit.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 4/30/13
 * Time: 11:16 AM
 * To change this template use File | Settings | File Templates.
 */

;
(function () {

    function runZapp(token){
        Logger.debug('viewportInit runZapp called');

        Backbone.history.start();

        Logger.info("Viewport run zapp, zapp token before change "+ (window.Capriza && Capriza.getToken()) + " => "+ token);
        Capriza.getToken(token);

        if ((typeof MBOOT !== 'undefined') && MBOOT.Config){
            MBOOT.Config.runZapp = true;
            MBOOT.Config.appToken = token || MBOOT.Config.appToken;
        }
        Dispatcher.trigger("runZapp/start");

        var parts = navigator.userAgent.split(/\s*[;)( ]\s*/);


        //Overcome modernizr bug that mistakenly doesnt detect flexbox in ff 23 and up
        parts.forEach(function(part, index) {

            if (/^Firefox/.test(part)){
                var versionStr = part.split("/").pop();
                var versionNum = parseFloat(versionStr);

                if (versionNum >= 23) {
                    $('html').removeClass('no-flexbox').addClass('flexbox');
                }
            }

            if (/^Android/.test(part)){
                var androidVerStr = parts[index+1];
                Capriza.device.androidVer = parseFloat(androidVerStr);
            }
        });

        Object.keys(Capriza.device).forEach(function(p) {
            // cp is to not brake 3rd parties, e.g mobiscroll has .ios selector
            if (Capriza.device[p] && typeof Capriza.device[p] !== 'function') $("html").addClass("cp-" + p);
        });

        if (Capriza.device.isMobile) {
            Capriza.initMobile();
        }
        else {
            Capriza.initWeb();
        }


        Dispatcher.trigger("app/initMessages");

        if (!window.devMode) {
            Capriza.splashInit && Capriza.splashInit();
        }

        if (!window.isDesignerPreview) Capriza.PageVisibilityManager.init();

        listenToStyleLoad();

        Utils.updateBrandStyle();
        $(".viewport").addClass("mc-classes").attr("id", "cprz");
        Dispatcher.trigger("header/init");
        Dispatcher.trigger("header/show");

        Capriza.Views.SideMenu.init();

        if (Runner.initSession && window.location.hash.indexOf('devmode') < 0 && !window.testMode && window.location.hash.indexOf('testmode') < 0 ) {
            Runner.initSession();
        }

        Capriza.StateManager.loadStructuresFromResource();
        if (window._urlParams['zapp_start_url'] || window.isDesignerPreview) {
            Logger.debug('Skipping MVP load because of zapp_start_url: '+window._urlParams['zapp_start_url']);
        }
        else{
            //load blueprint
            var ctxIx = window._urlParams['zapp_wc_cached_ctx'], stateId = window._urlParams['zapp_wc_unique_key'];
            Logger.debug("Going to load blueprint for ctxId = " + ctxIx + " and stateId = " + stateId );
            Capriza.StateManager.loadBlueprint({ctxId: ctxIx, stateId: stateId});
        }


        if (window.location.hash.indexOf('devmode') < 0 && !window.testMode && window.location.hash.indexOf('testmode') < 0 ) {
            if (window._urlParams['apiUrl']) {
                Config.apiUrl = window._urlParams['apiUrl'];
            }

            Runner.runSession();

        }
        else {
            Dispatcher.trigger("app/loaded");
        }
    }

    function onContentLoaded(e){
        Logger.debug('DOMContentLoaded called');
        if ((typeof MBOOT !== 'undefined') && MBOOT.Config && !MBOOT.Config.canRunZapp()) {
            Logger.info("Viewport running in hot view mode waiting for runZapp command");
            Dispatcher.on("runZapp", runZapp);
        } else {
            Logger.info("Viewport running fast, doesn't wait for runZapp command");
            runZapp();
        }
    }

    if (document.readyState !== "loading"){
        setTimeout(onContentLoaded, 0);
    } else {
        window.addEventListener("DOMContentLoaded", onContentLoaded, true);
    }

    /**
     * We need to know when the css is fully loaded in order to be able to remove the splash screen.
     * In the main.html that is returned from the api, there is a listener on the 2 important CSS files (mobile.css, style.css)
     * Once these are loaded, Capriza.resourcesLoaded[style/mobile] = true. If it is false, we will listen to the 'load' event
     * here, and trigger a 'styles/loaded' event.
     */
    function listenToStyleLoad(){
        Logger.debug("[ViewportInit] Checking if all stylesheets have been loaded.");
        var stylesToCheck = ["mobile.css", "style.css"],
            leftToLoad = 0;

        stylesToCheck.forEach(function(style) {
            var styleLoaded = Capriza && Capriza.resourcesLoaded && Capriza.resourcesLoaded[style]; //Capriza.resourcesLoaded is set in the main.html (api response)
            if (!styleLoaded) {
                var $styleElement = $("link[data-loadingresource='"+style+"']");
                if ($styleElement.length == 0) return;
                leftToLoad++;
                Logger.debug("[ViewportInit] Loading stylesheet: " + style);
                $styleElement.on('load', function(){
                    Logger.debug("[ViewportInit] Loaded stylesheet: " + style + ". Left to load: " + --leftToLoad);
                    if (leftToLoad == 0) stylesLoaded();
                });
            }

        });

        if (leftToLoad == 0) stylesLoaded();
    }

    function stylesLoaded(){
        Capriza.allStylesLoaded = true;
        Logger.debug("[ViewportInit] All style sheets are loaded, setting Capriza.allStylesLoaded = true. Triggerring 'styles/loaded'.");
        Dispatcher.trigger("styles/loaded");
    }

    window.addEventListener("hashchange", function(){
        if (window.location && window.location.hash && window.location.hash.indexOf("runzapp")){
            var runZapp = window.location.hash.split(/#|;/g).some(function(hashData){
                return hashData === "runzapp" || hashData === "runzapp=true"
            });
            if (runZapp) {
                Dispatcher.trigger("runZapp");
                return;
            }
        }
        Utils.reload();
    }, false);
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/NewSplash.js

try{
(function() {

    Capriza.splashing = true;

    var Splash = Capriza.Splash = {

        setDetails: function(details) {
            // in case of MVP or very very fast page display we don't want to update the splash details if the splash is already been removed
            if (!document.getElementById("new-splash") || !document.getElementById("new-splash").classList.contains("fade-out")) {
                Logger.debug('setting splash details');
                var img = $("#new-splash-app-icon img")[0];
                if (!img) return; // in LAN apps the splash is already removed but setDetails is called only after login

                if (window.isDesignerPreview) {
                    Dispatcher.off("mobile/active identity/show login/show confirmation/show mobile/error", hideOnReady);
                    Dispatcher.on("mobile/active identity/show login/show confirmation/show mobile/error", hideOnReady);
                }

                Splash.show();
                img.src = details.icon;
                $("#new-splash-app-name-inner-2").text(decodeURIComponent(details.name));

                var cprz = document.getElementById("cprz");
                if (cprz) {
                    cprz.appendChild(document.getElementById("new-splash"));
                    $("#home-button-container").removeClass("brand-primary-color");
                }

                $("#new-splash-loading").hide();

            }
            Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.loadingZapp));
        },

        getDetails: function() {
            Logger.log("Splash Zapp Token: " + (window.Capriza && Capriza.getToken()));
            var appToken = Capriza.getToken(),
//                    .replace("?local=mobile", ""),
                appTitle = ClientCache.getItem("appTitle-" + appToken) || (window.appData && window.appData.app_name),
                appIcon = ClientCache.getItem("appIcon-" + appToken) || (window.appData && window.appData.icon_url);

            if (appTitle && appIcon) return { name: appTitle, icon: appIcon };
        },

        show: function() {
            $("#new-splash").removeClass("loading");
            //if (Capriza.isStore) {
            //    var homeButtonContainer = $('#home-button-container');
            //    homeButtonContainer.removeClass('hidden').on('click', function() {
            //        Dispatcher.trigger('app/close');
            //    });
            //}
            document.addEventListener("click", this.block, true);
            document.addEventListener("mousedown", this.block, true);
            document.addEventListener("touchstart", this.block, true);
            document.addEventListener("touchmove", this.block, true);

        },

        block: function(e){
            e.preventDefault();
            e.stopPropagation();
        },

        setVisibility: function(visibility){
            Logger.info("[NewSplash] setting splash visibility to: " + visibility);
            $(".new-splash").css('visibility', visibility);
        },

        hide: function() {
            Capriza.splashing = false;
            Utils.hideUnimessages();
            function removeSplashfromDOM() {
                splashClearTimeout && window.clearTimeout(splashClearTimeout);
                if (!Capriza.SplashData){
                    Capriza.SplashData = {};
                }
                $(".new-splash-to-be-removed").remove();
                Capriza.SplashData.automatedStated = false;
                document.removeEventListener("click", this.block, true);
                document.removeEventListener("mousedown", this.block, true);
                document.removeEventListener("touchstart", this.block, true);
                document.removeEventListener("touchmove", this.block, true);
                logger.debug("[NewSplash] triggering mobile/splash/hidden.");
                Dispatcher.trigger("mobile/splash/hidden");
                Capriza.SplashData.suppressMessages = false;
                Capriza.SplashData.suppressTimeout && clearTimeout(Capriza.SplashData.suppressTimeout);
            }
            removeSplashfromDOM = removeSplashfromDOM.bind(this);
            if (Capriza.isStore) {
                removeSplashfromDOM();
            }
            else {
                logger.debug("[NewSplash] going to remove splash from DOM.");
                // Adding splash cleared timeout for cases that the transition is interrupted we want to make sure that the splash is removed and we remove all the listeners
                var splashClearTimeout = window.setTimeout(removeSplashfromDOM, 350);
                setTimeout(function() { //added setTimeout because otherwise sometimes 'transitionend' does NOT fire in Firefox (in chrome it works)!
                    $("#new-splash").on("transitionend transitionEnd webkitTransitionEnd", removeSplashfromDOM).addClass("fade-out");
                },0);
            }
        }
    }

    //options should include "fontColor, isError" if needed
    Capriza.splashRenderAuthMessage = function(message, options) {
        logger.debug("splashRenderAuthMessage called.");
        if (Capriza.SplashData) {
            if (Capriza.SplashData.stopDisplayMessages){
                return;
            }
            if (options && options.maxAutomations != undefined && message === "Automating..."){
                if (Capriza.SplashData.automatedStated){
                    var numberOfAutomationLeft = !options.maxAutomations ? 0 : (options.maxAutomations > 3 ? 3 : options.maxAutomations);
                    message = Capriza.SplashData.splashMessages[numberOfAutomationLeft];
                } else {
                    Capriza.SplashData.automatedStated = true;
                }
            }
            Logger.debug("[Loading-Message] Splash set text: " + message);
            Capriza.SplashData.displayMessage = message;
            if (!Capriza.SplashData.suppressMessages || (options && options.isError)) {
                logger.debug("[Loading-Message] Splash showing text: " + message);
                Utils.updateUnimessage({type: options && options.isError ? "error" : "progress",
                    messageText: Capriza.SplashData.displayMessage,
                    inSplash: true
                },false, false, true);
                $("#new-splash-loading-text").text(Capriza.SplashData.displayMessage);
                Capriza.SplashData.suppressMessages = true;
                Capriza.SplashData.suppressTimeout = setTimeout(function () {
                    Capriza.SplashData.suppressMessages = false;
                }, 2000);
            }
        } else {
            logger.debug("[Loading-Message] Splash text is: " + message);
            Utils.updateUnimessage({type: options && options.isError ? "error" : "progress",
                messageText: message,
                inSplash: true
            });
            $("#new-splash-loading-text").text(message);
        }
        if (options && options.isError) {
            if (!Capriza.SplashData){
                Capriza.SplashData = {};
            }
            Capriza.SplashData.stopDisplayMessages = true;
            $("#new-splash-loading-spinner").hide();
        } else {
            $("#new-splash-loading").hide();
            //$("#new-splash-loading-spinner").show();
        }
    };

    Capriza.splashInit = function() {
        logger.debug("splashInit called. Doing nothing");
        Capriza.SplashData = {};
        Capriza.SplashData.splashMessages = [];
        Capriza.SplashData.suppressMessages = false;

        Capriza.SplashData.splashMessages.push(Capriza.translator.getText(Capriza.translator.ids.almostThere));
        Capriza.SplashData.splashMessages.push(Capriza.translator.getText(Capriza.translator.ids.fewMoreMoments));
        Capriza.SplashData.splashMessages.push(Capriza.translator.getText(Capriza.translator.ids.gettingThere));
        Capriza.SplashData.splashMessages.push(Capriza.translator.getText(Capriza.translator.ids.stillAutomating));

    };

    var details = Splash.getDetails();
    if (details) {
        $(function() {
            Splash.setDetails(details);
        });
    } else {
        Dispatcher.on("splash/detailsUpdated", function() {
            Splash.setDetails({ name: appData.app_name, icon: appData.icon_url });
        });
    }

    /**
     Problems in the previous solutions:
     1. Using the 'requestAnimationFrame' - Creates a problem when the the Zapp enters "onPause" (switching to other tab, or moving the app to background) - althought the CSS loads, requestAnimationFrame doesn't fire.
     2. Listening to the load / readystatechange events - Waits for ALL the resources to load (including the icon of the splash screen). That causes sometimes to wait longer than necessary (and reach splashdidn'tclear error).
     */
    function hideOnReady(){
        logger.log("[NewSplash] checking if splash can be removed, Capriza.allStylesLoaded = " + !!Capriza.allStylesLoaded);
        logger.log('[NewSplash] current readystate: ' + document.readyState);

        function callHide(){
            Splash.hide();
            Dispatcher.off("mobile/active identity/show login/show confirmation/show mobile/error", hideOnReady);
        }

        if (Capriza.allStylesLoaded)
            callHide();
        else {
            logger.debug("[NewSplash] Not all styles are loaded, waiting for 'styles/loaded' event.");
            Dispatcher.on("styles/loaded", callHide);
        }
    }

    Dispatcher.on("mobile/active identity/show login/show confirmation/show mobile/error", hideOnReady);

    Dispatcher.on("splashDidntClear", function (type){
        logger.log('received event splash failure: ' + type);
        Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.splashLoadingFail),{fontColor:null, isError:true});
        if (Capriza.SplashData) {
            Capriza.SplashData.stopDisplayMessages = true;
            Capriza.SplashData.suppressTimeout && clearTimeout(Capriza.SplashData.suppressTimeout);
        }
    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/VersionManager.js

try{
(function(){

var VM = Capriza.VersionManager = {
    cachedResources: {}, //used for the removal of the resources once loaded

    checkForVersionUpdate: function (){

        var assetsChanged = appData.asset_versions ? Object.keys(appData.asset_versions).filter(function(asset){
            return VM.isAssetUpdated(asset);
        }) : [];

        if (assetsChanged.length > 0) Logger.debug("[VersionManager] Assets/Resources that were changed: " + assetsChanged.toString());
        else Logger.debug("[VersionManager] No assets were changed!");

        if (!VM.isMobileVersionUpdated() && assetsChanged.length == 0) return;

        Dispatcher.trigger('app/newVersionDownloading');
        Capriza.splashRenderAuthMessage && Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.newVersion), {fontColor: '#000000', isError: false});

        if (VM.isMobileVersionUpdated() && window.applicationCache.status === 4) {
            Logger.tag("updatingZappMobileVersion");
            Logger.info("[VersionManager] new mobile version. cleaning blueprint and reloading zapp.");
            Capriza.StateManager.cleanBlueprint({hideUnimessage: false}, Utils.reload, Utils.reload);
        }
        else if (assetsChanged.length > 0) {
            Logger.info("[VersionManager] Resources updated! fetching new assets: " + assetsChanged.toString());

            //1. start handlers Queue to prevent race condition.
            Logger.debug("[VersionManager] Start the engine message queue, and stop processing messages");
            Dispatcher.trigger('mobile/handlers/stop');

            if (assetsChanged.indexOf(Config.assetVersions.structure.assetName) != -1){
                //2. clean the blueprint in case the structure has updated
                Logger.debug("[VersionManager] Structures has been changed, cleaning the blueprint");
                Capriza.StateManager.cleanBlueprint({hideUnimessage: false});
            }

            //3. load the new resources
            var resourcesToLoad = [];
            assetsChanged.forEach(function(assetName){
                var deferred = $.Deferred(),
                    asset = Utils.findKey(Config.assetVersions, function(assetVersion){return assetVersion.assetName == assetName}),
                    fileName = Config.assetVersions[asset].fileName,
                    resourceURL = VM.getResourcePath(Config.assetVersions[asset].type, fileName),
                    newResourceURL = VM.generateResourceURL(resourceURL, assetName);

                Logger.debug("[VersionManager] Loading new resource: " + asset + ". old url: " + resourceURL);
                Logger.debug("[VersionManager] Loading new resource: " + asset + ". new url: " + newResourceURL);

                VM.loadResource(Config.assetVersions[asset].type, newResourceURL,
                    function(){ //success
                        Logger.debug("[VersionManager] New resource downloaded! --> " + asset);
                        Logger.debug("[VersionManager] Removing the old resource: " + resourceURL);
                        VM.removeResource(Config.assetVersions[asset].type, resourceURL);
                        Dispatcher.trigger('asset/loaded/' + asset); //update the structures in StateManager
                        deferred.resolve();
                    },
                    function(){//failure
                        Logger.debug("[VersionManager] resource failed to load! --> " + asset);
                        deferred.reject();
                    });

                resourcesToLoad.push(deferred);
            });

            //wait for all the resources to load, then continue.
            $.when.apply($, resourcesToLoad).done(function(){
                var ctxIx = window._urlParams['zapp_wc_cached_ctx'], stateId = window._urlParams['zapp_wc_unique_key'];

                Logger.debug("[VersionManager] Finished loading all resources, resuming to process engine messages from the queue");
                Dispatcher.trigger("mobile/handlers/resume");
            }).fail(function(){
                Logger.error("[VersionManager] Failed to load resource(s)", undefined, "Asset");
            });

        }
    },
    getResourcePath: function (resourceType, fileName) {
        var result = "", tagName, srcAttr;
        if (resourceType == 'script'){
            tagName = 'script';
            srcAttr = 'src';
        }
        else if (resourceType == 'style'){
            tagName = 'link';
            srcAttr = 'href';
        }

        $(tagName).each(function(index, el) {
            var src = this.getAttribute(srcAttr);
            if (src && src.indexOf(fileName) > -1) {
                result = src;
                VM.cachedResources[src] = el;
            }
        });
        return result;
    },

    isMobileVersionUpdated:function() {
        var appData = window.appData;
        if (!appData) return false;
        if (window.cappCache){
            return cappCache.getLoadedResources().some(function(resource){
                    return resource.url.indexOf('mobile.js') > -1 && resource.url.indexOf(appData.current_mobile_version) > -1;
                });
        }
        var oldFullPath = VM.getResourcePath('script', 'mobile.js');
        var newVersionNumber = appData.current_mobile_version;
        var result = oldFullPath && oldFullPath.indexOf(newVersionNumber) < 0;

        Logger.debug('[isMobileVersionUpdated] script url is: '+oldFullPath);
        Logger.debug('[isMobileVersionUpdated] mobile version number is: '+newVersionNumber);
        if (result) {
            Logger.debug('[isMobileVersionUpdated] the mobile version has been updated')
        }
        else {
            Logger.debug('[isMobileVersionUpdated] the mobile version has NOT been updated');
        }

        return result;
    },

    isAssetUpdated: function(assetName) {
        //old version is written in the html which is cached
        var oldResourceVersion = VM.getResourceVersion({assetName: assetName, fromCache:true}), newResourceVersion = VM.getResourceVersion({assetName: assetName});
        Logger.debug("[VersionManager] Checking if asset updated: " + assetName + ". oldVersion: " + oldResourceVersion + ", newVersion: " + newResourceVersion);
        return (!oldResourceVersion && newResourceVersion) || (newResourceVersion && oldResourceVersion != newResourceVersion);
    },

    getResourceVersion: function(params){
        if (!params || !params.assetName) return;
        if (params.fromCache) return Capriza.zappInfo && Capriza.zappInfo.asset_versions && Capriza.zappInfo.asset_versions[params.assetName];
        return window.appData && window.appData.asset_versions && window.appData.asset_versions[params.assetName];
    },

    loadResource: function(resourceType, url, callbackSuccess, callbackFailed){
        if (resourceType == 'script') VM.loadScriptResource(url, callbackSuccess, callbackFailed);
        if (resourceType == 'style') VM.loadStyleResource(url, callbackSuccess, callbackFailed);
    },

    removeResource: function(resourceType, url){
        var $el = $(VM.cachedResources[url]);
        if ($el.length == 0){
            var tagName, srcAttr;
            if (resourceType == 'script'){
                tagName = 'script';
                srcAttr = 'src';
            }
            else if (resourceType == 'style'){
                tagName = 'link';
                srcAttr = 'href';
            }

            $el = $(tagName + "[" + srcAttr + "='" + url + "']");
        }
        Logger.debug("[VersionManager] Removing resource element: " + $el[0]);
        $el.remove();
    },

    loadScriptResource: function(url, callbackSuccess, callbackFailed){
        Logger.debug("[VersionManager] loading script resource: " + url);
        var body = document.getElementsByTagName('body')[0];
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url;

        script.onload = callbackSuccess;
        script.onerror = callbackFailed;

        // Fire the loading
        body.appendChild(script);
    },

    loadStyleResource: function(url, callbackSuccess, callbackFailed){
        Logger.debug("[VersionManager] loading style resource: " + url);
        var body = document.getElementsByTagName('body')[0];
        var link = document.createElement('link');
        link.type = 'text/css';
        link.rel = 'stylesheet';
        link.href = url;

        link.onload = callbackSuccess;
        link.onerror = callbackFailed;

        // Fire the loading
        body.appendChild(link);
    },

    generateResourceURL: function (resourceURL, assetName){
        //assuming structureURL looks like: "http://.../<appId>/<version>/<fileName>.<ext>"
        var newResourceVersion = VM.getResourceVersion({assetName: assetName}),
            splitted = resourceURL.split('/'),
            oldAppId = splitted[splitted.length - 3],
            oldResourceVersion = splitted[splitted.length - 2],
            newUrl = resourceURL.replace(oldResourceVersion, newResourceVersion).replace(oldAppId, appData.app_id);

        return newUrl;
    }
}

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: templates/output/compiled-templates.js

this["Handlebars"] = this["Handlebars"] || {};
this["Handlebars"]["templates"] = this["Handlebars"]["templates"] || {};

Handlebars.registerPartial("settingsItem", Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\"settings-"
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + "\" class=\"settings-item "
    + escapeExpression(((helper = (helper = helpers['class'] || (depth0 != null ? depth0['class'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"class","hash":{},"data":data}) : helper)))
    + "\">\n    <i class=\"settings-item-icon "
    + escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"icon","hash":{},"data":data}) : helper)))
    + "\" data-icon=\""
    + escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"icon","hash":{},"data":data}) : helper)))
    + "\"\n       data-icon-active=\""
    + escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"icon","hash":{},"data":data}) : helper)))
    + "-full\">\n    </i>\n    <div class=\"settings-item-title\">"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, (depth0 != null ? depth0.text : depth0), {"name":"i18n","hash":{},"data":data})))
    + "</div>\n</div>\n";
},"useData":true}));

this["Handlebars"]["templates"]["accordion-header"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  return "";
},"useData":true});

this["Handlebars"]["templates"]["checkbox"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"checkbox\">\n    <div class=\"value\" tabindex=\"0\">\n        <i class=\"selected-icon icon-checkbox-selected\"></i>\n        <i class=\"unselected-icon icon-checkbox-unselected\"></i>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["cnfPage"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\"context-not-found-inner\">\n    ";
  stack1 = ((helper = (helper = helpers.addErrorCogs || (depth0 != null ? depth0.addErrorCogs : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"addErrorCogs","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n</div>\n<div id=\"context-not-found-message\">\n    <div id=\"cnfMessageTitle\">"
    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))
    + "</div>\n    <br>\n    <div id=\"cnfMessageDetail\">"
    + escapeExpression(((helper = (helper = helpers.content || (depth0 != null ? depth0.content : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"content","hash":{},"data":data}) : helper)))
    + "</div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["confirmation-page"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  return "<div class='page-content scroller'>\n    <div class='scroller-inner'>\n        <h2 class=\"top-header\">Almost Done...</h2>\n        <h2 class=\"bottom-header\">Check your Email</h2>\n\n        <div class=\"message\">\n            We need to verify your email address.<br />\n            Please check your email business email <br />\n            for a message from Capriza.\n        </div>\n        <div class=\"button-set\">\n            <button class=\"button\">\n                Refresh\n            </button>\n        </div>\n    </div>\n</div>\n\n\n";
  },"useData":true});

this["Handlebars"]["templates"]["confirmer"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.header : depth0), {"name":"if","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.button : depth0), {"name":"if","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"2":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "                <div class=\"confirmer-header content ss-dss_global ss-dss_noGutter\" >\n                    <div class=\"value\">\n                        "
    + escapeExpression(((helper = (helper = helpers.header || (depth0 != null ? depth0.header : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"header","hash":{},"data":data}) : helper)))
    + "\n                    </div>\n                </div>\n";
},"4":function(depth0,helpers,partials,data) {
  var stack1, helper, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, buffer = "                <div class=\"confirmer-button confirmer-btn"
    + escapeExpression(lambda((data && data.index), depth0))
    + " "
    + escapeExpression(((helper = (helper = helpers.cssClass || (depth0 != null ? depth0.cssClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"cssClass","hash":{},"data":data}) : helper)))
    + "\" >\n                    <button>\n                        ";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.iconClass : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n                        <span>"
    + escapeExpression(((helper = (helper = helpers.button || (depth0 != null ? depth0.button : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"button","hash":{},"data":data}) : helper)))
    + "</span>\n                    </button>\n                </div>\n";
},"5":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<i class='"
    + escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconClass","hash":{},"data":data}) : helper)))
    + "'></i>";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class=\"confirmer hidden\">\n    <div class=\"confirmer-container\">\n";
  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.items : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["content"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  return "<div class='content'></div>";
  },"useData":true});

this["Handlebars"]["templates"]["datepicker-button"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"datepicker "
    + escapeExpression(((helper = (helper = helpers.cssClass || (depth0 != null ? depth0.cssClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"cssClass","hash":{},"data":data}) : helper)))
    + " form-field value\">\n    <button class='value styleable-text'>\n        <i></i>\n    </button>\n    <input class=\"styleable-text\" type=\""
    + escapeExpression(((helper = (helper = helpers.inputType || (depth0 != null ? depth0.inputType : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputType","hash":{},"data":data}) : helper)))
    + "\" id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\" aria-roledescription=\""
    + escapeExpression(((helper = (helper = helpers.ariaDescription || (depth0 != null ? depth0.ariaDescription : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"ariaDescription","hash":{},"data":data}) : helper)))
    + "\" hidden/>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["datepicker-input"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"datepicker "
    + escapeExpression(((helper = (helper = helpers.cssClass || (depth0 != null ? depth0.cssClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"cssClass","hash":{},"data":data}) : helper)))
    + " form-field\">\n    <div class=\"value\">\n        <input class=\"styleable-text\" type=\""
    + escapeExpression(((helper = (helper = helpers.inputType || (depth0 != null ? depth0.inputType : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputType","hash":{},"data":data}) : helper)))
    + "\" id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\" aria-roledescription=\""
    + escapeExpression(((helper = (helper = helpers.ariaDescription || (depth0 != null ? depth0.ariaDescription : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"ariaDescription","hash":{},"data":data}) : helper)))
    + "\"/>\n        <span class=\"icon icon-label\">\n            <i class=\""
    + escapeExpression(((helper = (helper = helpers.iconLabel || (depth0 != null ? depth0.iconLabel : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconLabel","hash":{},"data":data}) : helper)))
    + "\"></i>\n        </span>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["datepicker"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"datepicker "
    + escapeExpression(((helper = (helper = helpers.cssClass || (depth0 != null ? depth0.cssClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"cssClass","hash":{},"data":data}) : helper)))
    + " form-field\">\n    <div class=\"value\">\n        <input class=\"styleable-text\" type=\""
    + escapeExpression(((helper = (helper = helpers.inputType || (depth0 != null ? depth0.inputType : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputType","hash":{},"data":data}) : helper)))
    + "\" id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\" aria-roledescription=\""
    + escapeExpression(((helper = (helper = helpers.ariaDescription || (depth0 != null ? depth0.ariaDescription : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"ariaDescription","hash":{},"data":data}) : helper)))
    + "\"/>\n        <span class=\"icon icon-label\">\n            <i class=\""
    + escapeExpression(((helper = (helper = helpers.iconLabel || (depth0 != null ? depth0.iconLabel : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconLabel","hash":{},"data":data}) : helper)))
    + "\"></i>\n        </span>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["dialog"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  return "            <input type=\"text\" name=\"dialogValue\" id=\"dialogValue\" value=\"\" placeholder=\"Type here\"/>\n";
  },"3":function(depth0,helpers,partials,data) {
  return "        <div data-role=\"fieldcontain\" class=\"ui-hide-label\">\n            <label for=\"dialogUsername\">Username:</label>\n            <input type=\"text\" name=\"username\" id=\"dialogUsername\" value=\"\" placeholder=\"Username\"/>\n        </div>\n";
  },"5":function(depth0,helpers,partials,data) {
  return "        <div data-role=\"fieldcontain\" class=\"ui-hide-label\">\n            <label for=\"dialogPassword\">Passowrd:</label>\n            <input type=\"password\" name=\"password\" id=\"dialogPassword\" value=\"\" placeholder=\"Password\"/>\n        </div>\n";
  },"7":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <a href=\"#\" id=\"dialog_cancel"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" data-role=\"button\" data-rel=\"back\" data-theme="
    + escapeExpression(((helper = (helper = helpers.theme || (depth0 != null ? depth0.theme : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"theme","hash":{},"data":data}) : helper)))
    + ">Cancel</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\"dialog"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" data-role=\"page\">\n    <div data-role=\"header\">\n        <h1>"
    + escapeExpression(((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"type","hash":{},"data":data}) : helper)))
    + "</h1>\n    </div>\n    <div data-role=\"content\">\n        <p>"
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "</p>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.dialog_textbox : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.dialog_username : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.dialog_password : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "        <a href=\"#\" id=\"dialog_ok"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" data-role=\"button\" data-rel=\"back\" data-theme="
    + escapeExpression(((helper = (helper = helpers.theme || (depth0 != null ? depth0.theme : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"theme","hash":{},"data":data}) : helper)))
    + ">OK</a>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.dialog_hasCancel : depth0), {"name":"if","hash":{},"fn":this.program(7, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </div>\n    <div data-role=\"footer\"></div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["dropdown"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  return " buttonDisabled";
  },"3":function(depth0,helpers,partials,data) {
  return " has-icon-button";
  },"5":function(depth0,helpers,partials,data) {
  return "    <div class=\"value\">\n";
  },"7":function(depth0,helpers,partials,data) {
  return "    <div class=\"focusable value\">\n";
  },"9":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <input id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\"\n                class=\"focusable styleable-text\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\" type=\""
    + escapeExpression(((helper = (helper = helpers.inputType || (depth0 != null ? depth0.inputType : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputType","hash":{},"data":data}) : helper)))
    + "\" value=\""
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "\"/>\n            <button class=\"icon clear\" tabindex=\"-1\" aria-label=\"Clear Text\">\n                <i class=\"fa fa-times-circle\"></i>\n            </button>\n";
},"11":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <span id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\" class=\"selected-content styleable-text\" aria-labelledby=\""
    + escapeExpression(((helper = (helper = helpers.labelId || (depth0 != null ? depth0.labelId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"labelId","hash":{},"data":data}) : helper)))
    + "\">"
    + escapeExpression(((helper = (helper = helpers.textValue || (depth0 != null ? depth0.textValue : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textValue","hash":{},"data":data}) : helper)))
    + "</span>\n";
},"13":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <button class=\"opener\" aria-label=\"Open Menu\" tabindex=\"-1\">\n                <i class=\""
    + escapeExpression(((helper = (helper = helpers.openerIcon || (depth0 != null ? depth0.openerIcon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"openerIcon","hash":{},"data":data}) : helper)))
    + "\"></i>\n            </button>\n";
},"15":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <span class=\"icon icon-label\">\n                <i class=\""
    + escapeExpression(((helper = (helper = helpers.iconLabel || (depth0 != null ? depth0.iconLabel : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconLabel","hash":{},"data":data}) : helper)))
    + "\"></i>\n            </span>\n";
},"17":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <button class=\"action-button "
    + escapeExpression(((helper = (helper = helpers.actionClass || (depth0 != null ? depth0.actionClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"actionClass","hash":{},"data":data}) : helper)))
    + "\">\n                <i class=\""
    + escapeExpression(((helper = (helper = helpers.textboxIcon || (depth0 != null ? depth0.textboxIcon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textboxIcon","hash":{},"data":data}) : helper)))
    + "\"></i>\n            </button>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\""
    + escapeExpression(((helper = (helper = helpers.textboxClass || (depth0 != null ? depth0.textboxClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textboxClass","hash":{},"data":data}) : helper)));
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.buttonDisabled : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += " form-field subtype-"
    + escapeExpression(((helper = (helper = helpers.subtype || (depth0 != null ? depth0.subtype : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"subtype","hash":{},"data":data}) : helper)));
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.hasIconButton : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\">\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.hasInput : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.program(7, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.hasInput : depth0), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.program(11, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.opener : depth0), {"name":"if","hash":{},"fn":this.program(13, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.hasIconLabel : depth0), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.button : depth0), {"name":"if","hash":{},"fn":this.program(17, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["header"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  return "            <div class=\"button extraAction ui-control ss-dss_global ss-dss_header_clientbutton ss-dss_no_margin_child_clientbutton ss-dss_grouping_grow_clientbutton ss-dss_primBgCol_clientbutton ss-mc654disp_clientbutton ss-dss_header_square ss-dss_header_any ss-dss_allButton ss-dss_textButton ss-dss_roundedButton ss-dss_squareButton ss-dss_centerIconButton ss-dss_capitalize_transform_text ss-mc701disp\" data-mc=\"mc701\">\n                <button class=\"value styleable-text\" tabindex=\"0\">\n                    <i class=\"fa fa-caret-down\"></i>\n                </button>\n            </div>\n";
  },"3":function(depth0,helpers,partials,data) {
  return "            <div class=\"content ui-control ss-dss_global ss-dss_primBgCol_content ss-dss_header_content ss-dss_grouping_grow_content ss-dss_no_margin_child_content ss-dss_header_any ss-dss_header_square\">\n                <div class=\"value\"></div>\n            </div>\n";
  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\"panel horizontal-layout has-dock group dock-top floating-bar panel-type-header header ui-control ss-dss_global ss-dss_primBgCol ss-dss_header ss-dss_grouping_grow ss-dss_no_margin_child\">\n    <div class=\"grouping\">\n        <div class=\"button ui-control back-button ss-dss_global ss-dss_primBgCol_button ss-dss_header_button ss-dss_grouping_grow_button ss-dss_no_margin_child_button ss-dss_header_any ss-dss_header_square ss-dss_textButton ss-dss_roundedButton ss-dss_squareButton ss-dss_centerIconButton ss-dss_allButton ss-dss_bold\">\n            <button class=\"value\">\n                <i class=\"fa fa-chevron-left\"></i>\n            </button>\n        </div>\n        <div  class=\"content ui-control ss-dss_global ss-dss_primBgCol_content ss-dss_header_content ss-dss_grouping_grow_content ss-dss_no_margin_child_content ss-dss_header_any ss-dss_grow ss-dss_text_overflow ss-dss_center_grow\">\n            <div class=\"value\">"
    + escapeExpression(((helper = (helper = helpers.appName || (depth0 != null ? depth0.appName : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"appName","hash":{},"data":data}) : helper)))
    + "</div>\n        </div>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.extraAction : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.program(3, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </div>\n</div>\n\n\n";
},"useData":true});

this["Handlebars"]["templates"]["identity-content"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "    <div class='identity-text'>"
    + escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"value","hash":{},"data":data}) : helper)))
    + "</div>";
},"useData":true});

this["Handlebars"]["templates"]["identity-listbox"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "                <option value=\""
    + escapeExpression(((helper = (helper = helpers.optionValue || (depth0 != null ? depth0.optionValue : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"optionValue","hash":{},"data":data}) : helper)))
    + "\" "
    + escapeExpression(((helper = (helper = helpers.selected || (depth0 != null ? depth0.selected : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"selected","hash":{},"data":data}) : helper)))
    + ">"
    + escapeExpression(((helper = (helper = helpers.optionText || (depth0 != null ? depth0.optionText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"optionText","hash":{},"data":data}) : helper)))
    + "</option>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\"field "
    + escapeExpression(((helper = (helper = helpers.klass || (depth0 != null ? depth0.klass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"klass","hash":{},"data":data}) : helper)))
    + "\">\n    <label class='text-label' for='"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "'>"
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + ":</label>\n    <div class=\"value\">\n        <select id=\""
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\">\n";
  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.options : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "        </select>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["identity-page"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <div class=\"icon-wrap\"><img id=\"identity-icon\" src='"
    + escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"icon","hash":{},"data":data}) : helper)))
    + "'/></div>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='page-content scroller'>\n    <div class='scroller-inner'>\n        <div id=\"identity-image-wrap\">\n            <img id=\"identity-image\" alt=\"\" border=\"0\"/>\n        </div>\n        <h2>Welcome</h2>\n        <h3>Sign in to <span class='identity-host'></span></h3>\n        <form novalidate>\n        <div class=\"fields\">\n\n        </div>\n        <div class='shouldSave'>\n            <input type='checkbox' id='identity-check'>\n            <label for='identity-check'>Save credentials on this device</label>\n        </div>\n        <div id=\"identity-submit-btn-wrap\" class=\"ss-dss_allButton ss-dss_stdButton ss-dss_button_full_width\">\n            <button id='identity-demo-submit-btn' class=\"value\" style=\"display: none\"></button>\n            <button id='identity-submit-btn' class=\"value\"></button>\n        </div>\n        <div class='identity-icon-wrap'>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.icon : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "            <span class='identity-host'></span>\n        </div>\n        <div class='identity-flash'></div>\n        </form>\n    </div>\n    <div id='splash-message'></div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["identity-passwordbox"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"field "
    + escapeExpression(((helper = (helper = helpers.klass || (depth0 != null ? depth0.klass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"klass","hash":{},"data":data}) : helper)))
    + "\">\n    <label class='text-label' for='"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "'>"
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + ":</label>\n    <div class=\"value\">\n        <input type=\"password\" id=\""
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" autocapitalize=\"none\" value=\""
    + escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"value","hash":{},"data":data}) : helper)))
    + "\"/>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["identity-textbox"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"field "
    + escapeExpression(((helper = (helper = helpers.klass || (depth0 != null ? depth0.klass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"klass","hash":{},"data":data}) : helper)))
    + "\">\n    <label class='text-label' for='"
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "'>"
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + ":</label>\n    <div class=\"value\">\n        <input type=\"email\" id=\""
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" autocapitalize=\"none\" value=\""
    + escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"value","hash":{},"data":data}) : helper)))
    + "\"/>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["image"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<img id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" src=\""
    + escapeExpression(((helper = (helper = helpers.src || (depth0 != null ? depth0.src : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"src","hash":{},"data":data}) : helper)))
    + "\" alt=\""
    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))
    + "\" class=\"image\"/>\n\n";
},"useData":true});

this["Handlebars"]["templates"]["link"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<a id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" href=\"#\" >";
  stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</a>\n";
},"useData":true});

this["Handlebars"]["templates"]["loadingMessage"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  return "            <div class=\"um-icon\">\n                <div class=\"um-spinner-bounce\"></div>\n                <div class=\"um-spinner-bounce\"></div>\n                <div class=\"um-spinner-bounce\"></div>\n            </div>\n";
  },"3":function(depth0,helpers,partials,data) {
  return "            <div class=\"um-error-icon\"></div>\n";
  },"5":function(depth0,helpers,partials,data) {
  return "has-icon";
  },"7":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "                <strong>"
    + escapeExpression(((helper = (helper = helpers.topHeader || (depth0 != null ? depth0.topHeader : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"topHeader","hash":{},"data":data}) : helper)))
    + "</strong><br />\n";
},"9":function(depth0,helpers,partials,data) {
  var stack1, buffer = "            <ul class='loading-message-buttons'>\n";
  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.actions : depth0), {"name":"each","hash":{},"fn":this.program(10, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "            </ul>\n";
},"10":function(depth0,helpers,partials,data) {
  var stack1, lambda=this.lambda, buffer = "                    <li><button>";
  stack1 = lambda((depth0 != null ? depth0.text : depth0), depth0);
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</button></li>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, buffer = "<div class='loading-message-content'>\n\n    <div class=\"um-details\">\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.shouldShowLoadingIndicator : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.actions : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n        <div class='um-message ";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.shouldShowLoadingIndicator : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.actions : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "'>\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.topHeader : depth0), {"name":"if","hash":{},"fn":this.program(7, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "            ";
  stack1 = ((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"message","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n        </div>\n    </div>\n    <div class=\"um-actions\">\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.actions : depth0), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["login-page"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "-->\n<!--<div class=\"linkedin\">-->\n<!--<a href=\""
    + escapeExpression(((helper = (helper = helpers.linkedinUrl || (depth0 != null ? depth0.linkedinUrl : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"linkedinUrl","hash":{},"data":data}) : helper)))
    + "\" class=\"auth_provider\">-->\n<!--<img alt='Linkedin' height='64' width='64' src='"
    + escapeExpression(((helper = (helper = helpers.linkedinIconUrl || (depth0 != null ? depth0.linkedinIconUrl : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"linkedinIconUrl","hash":{},"data":data}) : helper)))
    + "'/>-->\n<!--</a>-->\n<!--</div>-->\n        <!--";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class='page-content scroller'>\n    <div class='scroller-inner'>\n        <h2>Sign in to Capriza</h2>\n\n        <form>\n            <div class=\"fields\">\n                <div class='field username'>\n                    <label class='text-label' for='login-email'>Enter Email:</label>\n\n                    <div class=\"value\">\n                        <input type='email' id='login-email' autocapitalize=\"none\"/>\n                    </div>\n                </div>\n                <div class='field password'>\n                    <label class='text-label' for='login-password'>Password:</label>\n\n                    <div class=\"value\">\n                        <input type='password' id='login-password'/>\n                    </div>\n                </div>\n                <!--<div class='field shouldSave'>-->\n                <!--<input type='checkbox' id='identity-check'>-->\n                <!--<label for='identity-check'>Save password on this device</label>-->\n                <!--</div>-->\n\n            </div>\n\n            <div id=\"login-button-wrap\" class=\"button-wrap\">\n\n                <button id='login-button' class=\"button\">Sign In</button>\n            </div>\n            <div class=\"error-message\"></div>\n        </form>\n    </div>\n</div>\n\n\n<!--<h1>"
    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))
    + "</h1>-->\n<!--<div class=\"fields\">-->\n<!--<div class=\"field\">-->\n<!--<label for=\"login-email\">Email</label>-->\n<!--<div class=\"value\">-->\n<!--<input type=\"email\" id=\"login-email\" placeholder=\"john@example.com\" value=\""
    + escapeExpression(((helper = (helper = helpers.username || (depth0 != null ? depth0.username : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"username","hash":{},"data":data}) : helper)))
    + "\"/>-->\n<!--</div>-->\n<!--</div>-->\n<!--<div class=\"field\">-->\n<!--<label for=\"login-password\">Password</label>-->\n<!--<div class=\"value\">-->\n<!--<input type=\"password\" id=\"login-password\" placeholder=\"Required\"/>-->\n<!--</div>-->\n<!--</div>-->\n<!--<div class=\"field\">-->\n<!--<button>Sign In</button>-->\n<!--</div>-->\n<!--</div>-->\n        <!--";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.socialLogin : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "-->\n<!--<div class=\"register\">-->\n<!--Please Register to Use this App-->\n<!--</div>-->\n<!--<div class=\"website\">-->\n<!--<a href='http://www.capriza.com' target='_blank'>www.capriza.com</a>-->\n<!--</div>-->\n<!--<div class=\"error-message\"></div>-->\n";
},"useData":true});

this["Handlebars"]["templates"]["lookup"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"lookup form-field\">\n    <div class=\"value\">\n        <input id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "input\" value=\""
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "\"/>\n        <span class=\"button icon lookup\">\n            <a href=\"#\" class=\"button-inner\">\n                <span class=\"lookup\"></span>\n            </a>\n        </span>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["message-page"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class='page-content scroller'>\n    <div class='scroller-inner'>\n        <h2 class=\"top-header\">"
    + escapeExpression(((helper = (helper = helpers.topHeader || (depth0 != null ? depth0.topHeader : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"topHeader","hash":{},"data":data}) : helper)))
    + "</h2>\n        <h2 class=\"bottom-header\">"
    + escapeExpression(((helper = (helper = helpers.bottomHeader || (depth0 != null ? depth0.bottomHeader : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"bottomHeader","hash":{},"data":data}) : helper)))
    + "</h2>\n\n        <div class=\"message\">\n\n            ";
  stack1 = ((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"message","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n        </div>\n        <div class=\"button-set\">\n            <button class=\"button\" style=\""
    + escapeExpression(((helper = (helper = helpers.buttonStyle || (depth0 != null ? depth0.buttonStyle : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"buttonStyle","hash":{},"data":data}) : helper)))
    + "\">\n                "
    + escapeExpression(((helper = (helper = helpers.buttonText || (depth0 != null ? depth0.buttonText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"buttonText","hash":{},"data":data}) : helper)))
    + "\n            </button>\n        </div>\n    </div>\n</div>\n\n\n";
},"useData":true});

this["Handlebars"]["templates"]["noPrivateRuntime"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  return "<H1>Capriza Remote Access for this Zapp is busy or offline</H1>\n<h2>To enable Capriza Remote Access:</h2>\n<ol>\n    <li>Launch Capriza Builder on your computer</li>\n    <li>Click on 'Start Capriza Remote Access'</li>\n    <li>Hit refresh below</li>\n</ol>\n\n<button class='refresh' onclick=\"Utils.reload();\">Refresh Zapp</button>\n";
  },"useData":true});

this["Handlebars"]["templates"]["notifications"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"notif-div\">\n    <div class=\"notif-tri\"></div>\n    <div class=\"notif-title\">"
    + escapeExpression(((helper = (helper = helpers.notifTitle || (depth0 != null ? depth0.notifTitle : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"notifTitle","hash":{},"data":data}) : helper)))
    + "</div>\n    <ul class=\"notif-list\">\n\n    </ul>\n\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["onoff-switch"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"onoffswitch3\" id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\">\n    <div class=\"value\">\n        <div class=\"on-container\"></div>\n        <div class=\"off-container\"></div>\n        <div class=\"toggle-switch\"></div>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["popup-link"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"link\">\n    <label>";
  stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</label>\n    <span>"
    + escapeExpression(((helper = (helper = helpers.item || (depth0 != null ? depth0.item : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"item","hash":{},"data":data}) : helper)))
    + "</span>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["popup"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\"popup\">\n    <label>";
  stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  buffer += "</label>\n    <div class=\"value\">\n        <span>";
  stack1 = ((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"value","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</span>\n        <div class=\"icon\"/>\n    </div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["rocketman"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"background-white active\">\n    <div class=\"message\">\n        "
    + escapeExpression(((helper = (helper = helpers.msg || (depth0 != null ? depth0.msg : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"msg","hash":{},"data":data}) : helper)))
    + "\n    </div>\n</div>\n<div class=\"rocketman\">\n    <div class=\"body\">\n            <span class=\"ss-dss_background_primary\">\n                <span></span>\n                <span></span>\n                <span></span>\n                <span></span>\n            </span>\n        <div class=\"base\">\n            <span class=\"ss-dss_border_right_primary ss-dss_text_primary\"></span>\n            <div class=\"face ss-dss_background_primary\"></div>\n        </div>\n    </div>\n    <div class=\"longfazers\">\n        <span class=\"ss-dss_background_primary\"></span>\n        <span class=\"ss-dss_background_primary\"></span>\n        <span class=\"ss-dss_background_primary\"></span>\n        <span class=\"ss-dss_background_primary\"></span>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["send-feedback"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<header class=\"mobile\">\n    <div class='nav-bar'>\n        <div id='cancel-feedback'>\n            <i class='fa fa-times' role=\"button\" aria-label=\"Cancel Feedback\"></i>\n        </div>\n\n        <div id='feedback-page-title'>\n            "
    + escapeExpression(((helper = (helper = helpers.talkToUs || (depth0 != null ? depth0.talkToUs : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"talkToUs","hash":{},"data":data}) : helper)))
    + "\n        </div>\n\n        <div id='send-feedback'>\n            <i class='fa fa-check' role=\"button\" aria-label=\"Send Feedback\"></i>\n        </div>\n    </div>\n</header>\n\n\n<div class=\"content\" role=\"text\" aria-label=\""
    + escapeExpression(((helper = (helper = helpers.describeIssue || (depth0 != null ? depth0.describeIssue : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"describeIssue","hash":{},"data":data}) : helper)))
    + "\">\n    <i class='fa fa-comment-o'></i>\n    <textarea placeholder='"
    + escapeExpression(((helper = (helper = helpers.describeIssue || (depth0 != null ? depth0.describeIssue : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"describeIssue","hash":{},"data":data}) : helper)))
    + "'></textarea>\n</div>\n<footer>\n    <input name=\"allow-logs\" id=\"feedback-allow-logs\" checked type=\"checkbox\" >\n    <label for=\"feedback-allow-logs\">\n        <span class=\"instruction\">"
    + escapeExpression(((helper = (helper = helpers.includeInfo || (depth0 != null ? depth0.includeInfo : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"includeInfo","hash":{},"data":data}) : helper)))
    + "</span>\n        <span class=\"detail\">"
    + escapeExpression(((helper = (helper = helpers.helpUsScreenshot || (depth0 != null ? depth0.helpUsScreenshot : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"helpUsScreenshot","hash":{},"data":data}) : helper)))
    + "</span>\n    </label>\n</footer>\n";
},"useData":true});

this["Handlebars"]["templates"]["settings-item"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div id=\""
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\" class=\"settings-item\">\n    <i class=\"settings-item-icon "
    + escapeExpression(((helper = (helper = helpers['icon-class'] || (depth0 != null ? depth0['icon-class'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"icon-class","hash":{},"data":data}) : helper)))
    + "\"></i>\n    <div class=\"settings-item-title\">"
    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))
    + "</div>\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["settings-page-button"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"button ss-dss_global  ss-dss_textButton ss-dss_allButton\" >\n    <button class=\"value\">"
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "</button>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["settings-page-header"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"content ss-dss_global ss-dss_bgEmph ss-dss_secondText ss-dss_noGutter\" >\n    <div class=\"value\">\n        "
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["settings-page-toggle"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<div class=\"toggle onoffswitch3 ss-dss_stdSwitch ss-dss_noGutter\" >\n    <div class=\"toggle-description\">\n        <div class=\"toggle-text\">\n            "
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "\n        </div>\n        "
    + escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"description","hash":{},"data":data}) : helper)))
    + "\n    </div>\n    <div class=\"value\">\n        <div class=\"on-container\"></div>\n        <div class=\"off-container\"></div>\n        <div class=\"toggle-switch\"></div>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["settings-page"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "\n<div class=\"settings-header ss-dss_primBgCol ss-dss_primBgCol_content\">\n    <button class=\"close value\">\n        "
    + escapeExpression(((helper = (helper = helpers.doneText || (depth0 != null ? depth0.doneText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"doneText","hash":{},"data":data}) : helper)))
    + "\n    </button>\n    <div class=\"header-text value\">"
    + escapeExpression(((helper = (helper = helpers.settingsForText || (depth0 != null ? depth0.settingsForText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"settingsForText","hash":{},"data":data}) : helper)))
    + "</div>\n</div>\n<div class=\"settings-content\">\n\n</div>\n\n";
},"useData":true});

this["Handlebars"]["templates"]["sidemenu"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\"side-menu\" class=\"close\">\n    <div id=\"settings-title\" class=\"settings-docked-item\">\n        <div id=\"hero-mode\">Hero Mode!</div>\n        <div class=\"inner-text\">"
    + escapeExpression(((helper = (helper = helpers.appName || (depth0 != null ? depth0.appName : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"appName","hash":{},"data":data}) : helper)))
    + "</div>\n        <div id=\"side-close\" class=\"side-burger side-close\" role=\"button\" aria-label=\"Side Menu Close\"><i class=\"icon-sideburger\"></i><i class=\"fa fa-close\"></i></div>\n    </div>\n\n    <div class=\"settings-container\">\n        <div class=\"settings-item settings-profile\">\n            <div class=\"profile-pic\">\n                <i class=\"fa menu ca-profile-full\"></i>\n                <img class=\"avatar-container\">\n            </div>\n            <div class=\"settings-item-title\"></div>\n        </div>\n\n";
  stack1 = this.invokePartial(partials.settingsItem, '        ', 'settingsItem', depth0, {
    'text': ("back"),
    'icon': ("ca-zapp-grid-circle"),
    'class': (""),
    'name': ("close-zapp")
  }, helpers, partials, data);
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = this.invokePartial(partials.settingsItem, '        ', 'settingsItem', depth0, {
    'text': ("settings"),
    'icon': ("ca-settings-circle"),
    'class': ("network-dependant"),
    'name': ("zapp-settings")
  }, helpers, partials, data);
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = this.invokePartial(partials.settingsItem, '        ', 'settingsItem', depth0, {
    'text': ("sendFeedback"),
    'icon': ("ca-feedback"),
    'class': ("network-dependant"),
    'name': ("send-feedback")
  }, helpers, partials, data);
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = this.invokePartial(partials.settingsItem, '        ', 'settingsItem', depth0, {
    'text': ("realoadZapp"),
    'icon': ("ca-rotate"),
    'class': ("network-dependant hero-mode"),
    'name': ("reload-zapp")
  }, helpers, partials, data);
  if (stack1 != null) { buffer += stack1; }
  return buffer + "        <div id=\"zapp-details\" class=\"hero-mode\">Version: <span id=\"zapp-ver\"></span> -- MED: <span id=\"med-ver\"></span></div>\n    </div>\n\n    <div id=\"settings-sign-out\"\n         class=\"settings-item settings-docked-item network-dependant\">\n\n        <div class=\"inner-text\">"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "signOutOf", {"name":"i18n","hash":{},"data":data})))
    + " "
    + escapeExpression(((helper = (helper = helpers.appName || (depth0 != null ? depth0.appName : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"appName","hash":{},"data":data}) : helper)))
    + "</div>\n    </div>\n</div>\n";
},"usePartial":true,"useData":true});

this["Handlebars"]["templates"]["spinner"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<svg class=\"special-spinner "
    + escapeExpression(((helper = (helper = helpers.display || (depth0 != null ? depth0.display : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"display","hash":{},"data":data}) : helper)))
    + "\" width="
    + escapeExpression(((helper = (helper = helpers.width || (depth0 != null ? depth0.width : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"width","hash":{},"data":data}) : helper)))
    + " height=\""
    + escapeExpression(((helper = (helper = helpers.height || (depth0 != null ? depth0.height : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"height","hash":{},"data":data}) : helper)))
    + "\" viewBox=\"0 0 100 100\"\n     version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n    <title>loading</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"loading\" sketch:type=\"MSArtboardGroup\" fill=\"#888\">\n            <path d=\"M64.5187305,18.1440086 C60.0959389,16.1250148 55.1793502,15 50,15 C30.6700328,15 15,30.6700328 15,50 C15,69.3299672 30.6700328,85 50,85 C69.3299672,85 85,69.3299672 85,50 C85,42.575695 82.6883649,35.6913017 78.745583,30.0273082 L74.7240877,33.0033292 C78.0518043,37.8347439 80,43.6898591 80,50 C80,66.5685433 66.5685433,80 50,80 C33.4314567,80 20,66.5685433 20,50 C20,33.4314567 33.4314567,20 50,20 C54.3338265,20 58.4530179,20.9189619 62.1733436,22.5726553 L64.5187305,18.1440086 Z\" id=\"app-purchase-loading\" sketch:type=\"MSShapeGroup\">\n                <animateTransform attributeType=\"xml\"\n                                  attributeName=\"transform\"\n                                  type=\"rotate\"\n                                  from=\"0 50 50\"\n                                  to=\"360 50 50\"\n                                  dur=\"1s\"\n                                  repeatCount=\"indefinite\"\n                        />\n            </path>\n\n        </g>\n\n    </g>\n\n</svg>";
},"useData":true});

this["Handlebars"]["templates"]["tableRow"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<li class=\"row-wrap\" id=\""
    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))
    + "\">\n    <div class=\"row-box\"> </div>\n</li>";
},"useData":true});

this["Handlebars"]["templates"]["textbox"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  return " buttonDisabled";
  },"3":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <textarea id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "input\" class=\"focusable styleable-text\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\">"
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "</textarea>\n";
},"5":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <input id=\""
    + escapeExpression(((helper = (helper = helpers.inputId || (depth0 != null ? depth0.inputId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputId","hash":{},"data":data}) : helper)))
    + "\"\n                class=\"focusable styleable-text\" placeholder=\""
    + escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)))
    + "\"\n                type=\""
    + escapeExpression(((helper = (helper = helpers.inputType || (depth0 != null ? depth0.inputType : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"inputType","hash":{},"data":data}) : helper)))
    + "\" value=\""
    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))
    + "\"/>\n";
},"7":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "            <span class=\"icon icon-label\">\n            <i class=\""
    + escapeExpression(((helper = (helper = helpers.iconLabel || (depth0 != null ? depth0.iconLabel : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"iconLabel","hash":{},"data":data}) : helper)))
    + "\"></i>\n        </span>\n";
},"9":function(depth0,helpers,partials,data) {
  return " clear";
  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div id=\""
    + escapeExpression(((helper = (helper = helpers.uniqueControlId || (depth0 != null ? depth0.uniqueControlId : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uniqueControlId","hash":{},"data":data}) : helper)))
    + "\" class=\""
    + escapeExpression(((helper = (helper = helpers.textboxClass || (depth0 != null ? depth0.textboxClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textboxClass","hash":{},"data":data}) : helper)));
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.buttonDisabled : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += " form-field subtype-"
    + escapeExpression(((helper = (helper = helpers.subtype || (depth0 != null ? depth0.subtype : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"subtype","hash":{},"data":data}) : helper)))
    + "\">\n    <div class=\"value\">\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.multiline : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.program(5, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.hasIconLabel : depth0), {"name":"if","hash":{},"fn":this.program(7, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "        <button class=\"icon "
    + escapeExpression(((helper = (helper = helpers.actionClass || (depth0 != null ? depth0.actionClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"actionClass","hash":{},"data":data}) : helper)));
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.isClearButton : depth0), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\" tabindex=\"-1\" aria-label=\""
    + escapeExpression(((helper = (helper = helpers.ariaLabel || (depth0 != null ? depth0.ariaLabel : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"ariaLabel","hash":{},"data":data}) : helper)))
    + "\">\n            <i class=\""
    + escapeExpression(((helper = (helper = helpers.textboxIcon || (depth0 != null ? depth0.textboxIcon : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textboxIcon","hash":{},"data":data}) : helper)))
    + "\"></i>\n        </button>\n    </div>\n</div>\n";
},"useData":true});

this["Handlebars"]["templates"]["toast"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\"toast hidden\">\n    <div class=\"toast-container\">\n        <div class=\"toast-icon-container\">\n            <i class='"
    + escapeExpression(((helper = (helper = helpers.toastIconClass || (depth0 != null ? depth0.toastIconClass : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"toastIconClass","hash":{},"data":data}) : helper)))
    + "'></i>\n            <svg id=\"rotatingSvg\" class=\"special-spinner hidden\" width=\"35px\" height=\"35px\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n                <title>loading</title>\n                <desc>Created with Sketch.</desc>\n                <defs></defs>\n                <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n                    <g id=\"loading\" sketch:type=\"MSArtboardGroup\" fill=\""
    + escapeExpression(((helper = (helper = helpers.primaryColor || (depth0 != null ? depth0.primaryColor : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"primaryColor","hash":{},"data":data}) : helper)))
    + "\">\n                        <path d=\"M64.5187305,18.1440086 C60.0959389,16.1250148 55.1793502,15 50,15 C30.6700328,15 15,30.6700328 15,50 C15,69.3299672 30.6700328,85 50,85 C69.3299672,85 85,69.3299672 85,50 C85,42.575695 82.6883649,35.6913017 78.745583,30.0273082 L74.7240877,33.0033292 C78.0518043,37.8347439 80,43.6898591 80,50 C80,66.5685433 66.5685433,80 50,80 C33.4314567,80 20,66.5685433 20,50 C20,33.4314567 33.4314567,20 50,20 C54.3338265,20 58.4530179,20.9189619 62.1733436,22.5726553 L64.5187305,18.1440086 Z\" id=\"app-purchase-loading\" sketch:type=\"MSShapeGroup\">\n                            <animateTransform attributeType=\"xml\"\n                                              attributeName=\"transform\"\n                                              type=\"rotate\"\n                                              from=\"0 50 50\"\n                                              to=\"360 50 50\"\n                                              dur=\"1s\"\n                                              repeatCount=\"indefinite\"\n                                    />\n                        </path>\n                    </g>\n                </g>\n            </svg>\n        </div>\n\n        <div class=\"toast-text-container\">\n            <div class=\"text-major\">\n                "
    + escapeExpression(((helper = (helper = helpers.textMajor || (depth0 != null ? depth0.textMajor : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textMajor","hash":{},"data":data}) : helper)))
    + "\n            </div>\n            <div class=\"text-minor\">\n                "
    + escapeExpression(((helper = (helper = helpers.textMinor || (depth0 != null ? depth0.textMinor : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"textMinor","hash":{},"data":data}) : helper)))
    + "\n            </div>\n        </div>\n\n        <div class=\"toast-action-container\">\n            <div class=\"toast-action\">\n                ";
  stack1 = ((helper = (helper = helpers.toastActionText || (depth0 != null ? depth0.toastActionText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"toastActionText","hash":{},"data":data}) : helper));
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n            </div>\n        </div>\n\n\n    </div>\n\n</div>";
},"useData":true});

this["Handlebars"]["templates"]["unimessage"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <button class=\"mainAction\">"
    + escapeExpression(((helper = (helper = helpers.actionText || (depth0 != null ? depth0.actionText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"actionText","hash":{},"data":data}) : helper)))
    + "</button>\n";
},"3":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <button class=\"extraAction\">"
    + escapeExpression(((helper = (helper = helpers.extraActionText || (depth0 != null ? depth0.extraActionText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"extraActionText","hash":{},"data":data}) : helper)))
    + "</button>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\"um-topContainer\">\n    <div class=\"um-icon\">\n        <div class=\"um-spinner-bounce\"></div>\n        <div class=\"um-spinner-bounce\"></div>\n        <div class=\"um-spinner-bounce\"></div>\n    </div>\n    <div class=\"um-textContainer\">\n        <div class=\"um-message\">"
    + escapeExpression(((helper = (helper = helpers.messageText || (depth0 != null ? depth0.messageText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"messageText","hash":{},"data":data}) : helper)))
    + "</div>\n        <div class=\"um-detail\">"
    + escapeExpression(((helper = (helper = helpers.detailText || (depth0 != null ? depth0.detailText : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"detailText","hash":{},"data":data}) : helper)))
    + "</div>\n    </div>\n</div>\n<div class=\"um-action\">\n";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.actionText : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.extraActionText : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</div>\n";
},"useData":true});

//! Source: javascripts/Translator.js

try{
/**
 * Created by oriharel on 6/9/15.
 */
;(function() {

    Capriza.translator = {
        lang: "en-US",

        init: function(lang) {
            if (lang in this.languages)
                this.lang = lang;
            else {
                var first2 = lang.substring(0,2);
                if (first2 in this.languages)
                    this.lang = first2;
            }
            ClientCache.setItem('lang-'+Capriza.getToken(), this.lang);
        },

        getText: function(stringId) {
            return this.languages[this.lang][stringId] || stringId;
        },

        getLang: function() {
            return this.lang;
        }

    };

    Capriza.translator.ids = {
        authenticating: "authenticating",
        newVersion: "newVersion",
        loadingZapp: "loadingZapp",
        stillLoadingZapp: "stillLoadingZapp",
        somethingWrong: "somethingWrong",
        zappReloadAuto: "zappReloadAuto",
        couldNotUpdatePage: "couldNotUpdatePage",
        updating: "updating",
        mvpUpdating: "mvpUpdating",
        somethingIsWrong: "somethingIsWrong",
        retry: "retry",
        lastUpdated: "lastUpdated",
        mvpOffline: "mvpOffline",
        gotIt: "gotIt",
        mvpNewContentReady: "mvpNewContentReady",
        mvpTapToUpdate: "mvpTapToUpdate",
        waitingFor: "waitingFor",
        waitingForApplication: "waitingForApplication",
        disconnectedDueTo: "disconnectedDueTo",
        sorryLostConnection: "sorryLostConnection",
        tryAgainLater: "tryAgainLater",
        networkIssues: "networkIssues",
        pressAgain: "pressAgain",
        reconnect: "reconnect",
        inactivity: "inactivity",
        noDataAvailable: "noDataAvailable",
        showMore: "showMore",
        oneMoment: "oneMoment",
        slowConnection: "slowConnection",
        alertSplash: "alertSplash",
        splashLoadingFail: "splashLoadingFail",
        home: "home",
        settings: "settings",
        sendFeedback: "sendFeedback",
        signOutOf: "signOutOf",
        realoadZapp: "realoadZapp",
        clearHistory: "clearHistory",
        saveFormText: "saveFormText",
        rememberHistory: "rememberHistory",
        caching: "caching",
        areYouSureHistory: "areYouSureHistory",
        cancel: "cancel",
        noSettings: "noSettings",
        talkToUs: "talkToUs",
        includeInfo: "includeInfo",
        helpUsScreenshot: "helpUsScreenshot",
        settingsFor: "settingsFor",
        doneCaptial: "doneCaptial",
        describeIssue: "describeIssue",
        rocketMsg: "rocketMsg",
        incorrect: "incorrect",
        loading: "loading",
        almostThere: "almostThere",
        fewMoreMoments: "fewMoreMoments",
        gettingThere: "gettingThere",
        stillWorking: "stillWorking",
        takingLonger: "takingLonger",
        stillAutomating: "stillAutomating",
        workingOnIt: "workingOnIt",
        restarting: "restarting",
        signingOut: "signingOut",
        "sendingFeedback": "sendingFeedback",
        feedbackProblem: "feedbackProblem",
        feedbackSent: "feedbackSent",
        back: "back",
        reload: "reload",
        unHandleErrorTitle: "unHandleErrorTitle",
        unHandleErrorMsg: "unHandleErrorMsg"
    };

    Capriza.translator.languages = {};

    Capriza.translator.languages["en-US"] =  {
        authenticating:     "Authenticating...",
        newVersion:         "Downloading new version...",
        loadingZapp:        "Loading your Zapp...",
        stillLoadingZapp:   "Still loading your Zapp...",
        somethingWrong:     "Something's Wrong",
        zappReloadAuto:     "Zapp will reload automatically.",
        couldNotUpdatePage: "We couldn't update the page.",
        mvpUpdating:        "Updating...",
        somethingIsWrong:   "Something's Wrong",
        retry:              "Retry",
        lastUpdated:        "Last updated",
        mvpOffline:         "Looks like you're offline.",
        gotIt:              "Got it",
        mvpNewContentReady: "New Content is ready!",
        mvpTapToUpdate:     "Tap to update this page.",
        waitingFor:         "Waiting for ",
        waitingForApplication: "Waiting for the application...",
        disconnectedDueTo:  "Your session has expired.",
        sorryLostConnection:"Your connection was lost.",
        tryAgainLater:      "Please try again later.",
        networkIssues:      "The application failed due to network issues. Try to connect again.",
        pressAgain:         "Press again to exit",
        reconnect:          "Reconnect",
        inactivity:         "Session closed due to inactivity",
        noDataAvailable:    "No data available",
        showMore:           "Show More",
        oneMoment:          "One moment please...",
        slowConnection:     "Slow connection detected.",
        alertSplash:        "We seem to have encountered a technical problem.\nTech support has been notified.",
        splashLoadingFail:  "There was a problem launching this Zapp. Check your connection and try again",
        home:               "Home",
        settings:           "Settings",
        sendFeedback:       "Send Feedback",
        signOutOf:          "Sign Out of",
        realoadZapp:        "Reload Zapp",
        clearHistory:       "Clear History",
        saveFormText:       "Save form values to history",
        rememberHistory:    "Remember values entered into input fields and selected from dropdowns for quick reuse",
        caching:            "Caching",
        areYouSureHistory:  "Are you sure you want to clear your history ?",
        cancel:             "Cancel",
        noSettings:         "No Settings Available",
        talkToUs:           "Talk to us",
        includeInfo:        "Include troubleshooting info",
        helpUsScreenshot:   "Help us investigate with a screenshot and Zapp data",
        settingsFor:        "Settings for",
        doneCaptial:        "DONE",
        describeIssue:      "Describe the issue",
        rocketMsg:          "Working for you",
        incorrect:          "Incorrect",
        loading:            "Loading...",
        almostThere:        "Almost there...",
        fewMoreMoments:     "Just a few more moments...",
        gettingThere:       "Getting there...",
        stillWorking:       "Still working...",
        takingLonger:       "This will take a bit longer.",
        stillAutomating:    "Still automating...",
        workingOnIt:        "Working on it...",
        restarting:         "Restarting...",
        signingOut:         "Signing out...",
        sendingFeedback:    "Sending Feedback...",
        feedbackProblem:    "Problem sending feedback, please try again",
        feedbackSent:       "Feedback sent.",
        back:               "Back to List",
        reload:             "Restart",
        unHandleErrorTitle: "Something's wrong",
        unHandleErrorMsg:   "An unexpected error occurred"
    };

    Capriza.translator.languages["fr"] = {
        authenticating:     "Authentification en cours ...",
        newVersion:         "Nouvelle version tlcharge ...",
        loadingZapp:        "Chargement de votre zapp...",
        somethingWrong:     "Quelque-chose ne va pas",
        zappReloadAuto:     "Zapp se rechargera automatiquement",
        couldNotUpdatePage: "Nous ne pouvions pas mettre  jour la page",
        mvpUpdating:        "Mise  jour ...",
        somethingIsWrong:   "Quelque-chose ne va pas",
        retry:              "Recommencez",
        lastUpdated:        "Dernire mise  jour",
        mvpOffline:         "Vous tes dconnect",
        gotIt:              "A compris",
        mvpNewContentReady: "Le nouveau contenu est prt!",
        mvpTapToUpdate:     "Appuyez sur pour mettre  jour cette page.",
        waitingFor:         "En attendant ",
        waitingForApplication: "En attente de votre application...",
        disconnectedDueTo:  "Dconnect pour inactivit",
        sorryLostConnection:"Dsol, votre connexion a t soit perdu ou est temporairement indisponible. S'il vous plat ressayer plus tard ou utiliser la version de bureau, le cas chant.",
        tryAgainLater:      "Ressayez plus tard",
        networkIssues:      "L'application n'a pas russi en raison de problmes de rseau. Essayez de vous connecter  nouveau.",
        pressAgain:         "Appuyez de nouveau pour quitter",
        reconnect:          "Rebranchez",
        inactivity:         "Session ferme en raison de l'inactivit",
        noDataAvailable:    "Pas de donnes disponibles",
        showMore:           "Montre Plus",
        oneMoment:          "un instant s'il vous plat...",
        slowConnection:     "Connexion lente dtecte...",
        alertSplash:        "Nous semblons avoir rencontr un problme technique. Le support technique a t notifi.",
        splashLoadingFail:  "Il y avait un probleme pour lancer ce Zapp. Vrifiez votre connexion et ressayez",
        home:               "Accueil",
        settings:           "Rglages",
        sendFeedback:       "Envoyer des commentaires",
        signOutOf:          "Dconnexion de",
        clearHistory:       "Effacer historique",
        saveFormText:       "Enregistrer les valeurs de formulaire dans l'historique",
        rememberHistory:    "N'oubliez pas les valeurs entres dans les champs de texte et slectionns  partir des menus droulants pour rutilisation rapide",
        caching:            "Mise en cache",
        areYouSureHistory:  "tes-vous sr de vouloir effacer votre historique?",
        cancel:             "Annuler",
        noSettings:         "Pas de rglages disponibles",
        talkToUs:           "Parlez-nous",
        includeInfo:        "Inclure des informations de dpannage",
        helpUsScreenshot:   "Aidez-nous  explorer avec une capture d'cran et des donnes de Zapp",
        settingsFor:        "Rglages pour",
        doneCaptial:        "FINI",
        describeIssue:      "Dcrire le problme",
        rocketMsg:          "Travaillant pour vous",
        incorrect:          "Incorrect",
        loading:            "Chargement...",
        almostThere:        "Presque l...",
        fewMoreMoments:     "Juste quelques instants encore...",
        gettingThere:       "Pour vous y rendre...",
        stillWorking:       "Travaliller toujours...",
        takingLonger:       "C'est plus longue que prvu...",
        stillAutomating:    "Automatisation toujours...",
        workingOnIt:        "Travailler dessus...",
        signingOut:         "Dconnexion...",
        sendingFeedback:    "Envoi des commentaires...",
        feedbackProblem:    "Problme d'envoi de commentaires. Veuillez ressayer",
        feedbackSent:       "Commentaires envoys",
        back:               "Retour  la liste",
        reload:             "Redmarrer",
        stillLoadingZapp:   "Encore en train de charger votre app...",
        unHandleErrorTitle: "Quelque chose ne va pa",
        unHandleErrorMsg:   "Une erreur inattendue s'est produite"
    };

    var rx = /^[^,]+/g;
    var langParam = window._urlParams && window._urlParams.zapp_param_locale;
    var parsedLangHeader = Capriza.lang_header && rx.exec(Capriza.lang_header);
    var lang;


    if (langParam) {
        lang = langParam;
    }
    else if (parsedLangHeader && parsedLangHeader.length > 0) {
        lang = parsedLangHeader[0];
    }
    else {
        lang = navigator.language;
    }

    Capriza.translator.init(lang)

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Page.js

try{

(function () {
//    alert('start page');
    $.capriza = {};
    _.extend($.capriza, {
        usePageAnimation:true,
        pages:[],

        changePage:function (toPage, options) {
            options || (options = {});
            if (typeof toPage === "string") toPage = $(toPage);
            if (toPage.length === 0) return;
            var fromPage = this.activePage;
            if (!fromPage) {
                return;
            }
            if (fromPage === toPage) {
                return;
            }

            Dispatcher.trigger("page/beforeChange", { fromPage: fromPage, toPage:toPage });
            var prevPageNoTransition = (options.prevPageNoTransition === undefined ? false : options.prevPageNoTransition);
            this.doTransition(fromPage, toPage, { isModal: options.isModal, ignoreModalDrill: options.ignoreModalDrill, transitionName: options.transition, reverse: options.reverse, prevPageNoTransition: prevPageNoTransition, callback: function($toPage, removePrevPage) {
                Dispatcher.trigger("page/change/after", { fromPage: fromPage, toPage: toPage });

                if (fromPage.attr("id") === "start-page") {
                    fromPage.remove();
                }

                if (($toPage.hasClass('context-page') || $toPage.attr('id') === 'identity-page') && !($toPage.hasClass('table-drill')) && fromPage.hasClass('context-page')) {
                    var fromPageView = fromPage.data("pageView");

                    if (fromPageView && removePrevPage) {
                        fromPageView.destroy();
                    }
                }
                options.callback && options.callback();

                Dispatcher.trigger("page/change/after/callbackEnded", { fromPage: fromPage, toPage: toPage });
            } });

            this.activePage = toPage;

            if (!options.notInStack) {
                this.pushToStack(toPage);
            }
            if (options.replaceInStack) {
                this.pages.pop();
                this.pushToStack(toPage);

            }
        },

        miniBrowserBack: function($miniBrowser, $to){
            if ($miniBrowser.length === 0) return;
            Utils.hideUnimessages(true);

            var transitionEnd = function(){
                $miniBrowser.removeClass("active transitioning");
                $to.removeClass("pre");
                $miniBrowser.css({"-webkit-transform": "" ,
                    "-moz-transform": "",
                    "transform": "",
                    "z-index": ""});
                $miniBrowser.insertAfter("#side-menu");
                Dispatcher.trigger("page/back/after", { fromPage: $miniBrowser, toPage: $to });
                Dispatcher.trigger("page/change/after/callbackEnded", { fromPage: $miniBrowser, toPage: $to });
            };

            $miniBrowser.one(Utils.transitionEnd, transitionEnd);

            $to.addClass("active pre");
            setTimeout(function(){
                $miniBrowser.css({"-webkit-transform": "translateX(100%)" ,
                    "-moz-transform": "translateX(100%)",
                    "transform": "translateX(100%)"});
                $to.removeClass("pre");
            },16);

            this.activePage = $to;
            this.pages.pop();
            this.pushToStack($to);

        },

        toMiniBrowser: function($miniBrowser, $from){
            if ($miniBrowser.length === 0) return;
            $miniBrowser.appendTo(".viewport");
            $miniBrowser.css("z-index", $(".global-shield.modal").css("z-index"));

            var transitionEnd = function(){
                $from.removeClass("active");
                $miniBrowser.removeClass("pre");
                Dispatcher.trigger("page/change/after", { fromPage: $from, toPage: $miniBrowser });
                Dispatcher.trigger("page/change/after/callbackEnded", { fromPage: $from, toPage: $miniBrowser });
            };

            $miniBrowser.one(Utils.transitionEnd, transitionEnd);

            $miniBrowser.addClass("active pre transitioning");
            $miniBrowser.css({"-webkit-transform": "translateX(100%)" ,
                "-moz-transform": "translateX(100%)",
                "transform": "translateX(100%)"});
            setTimeout(function(){
                $miniBrowser.css({"-webkit-transform": "translateX(0)" ,
                    "-moz-transform": "translateX(0)",
                    "transform": "translateX(0)"});
                $miniBrowser.removeClass("pre");
            },16);

            this.activePage = $miniBrowser;
            this.pushToStack($miniBrowser);
        },

        pushToStack: function($page) {
            if (this.pages.indexOf($page) < 0) {
                this.pages.push($page);
            }
        },

        backPage:function (options) {
            if (this.pages.length === 0) return;
            options || (options = {});
            if (!options.notInStack) {
                this.pages.pop();
            }
            var toPage = this.pages[this.pages.length - 1];
            if (!toPage) {
                toPage = $("#start-page");
            }
            var fromPage = options.fromPage || this.activePage;
            var prevPageNoTransition = (options.prevPageNoTransition === undefined ? false : options.prevPageNoTransition);
            var fromPageView = fromPage.data('pageView');
            fromPageView && fromPageView.beforeBack && fromPageView.beforeBack(toPage);
            Dispatcher.trigger("page/back/before", { toPage: toPage });
            this.activePage = toPage;
            $.capriza.hideLoadingMsg();
            $(document).trigger("pagechange", { toPage:toPage });
            this.doTransition(fromPage, toPage, {isModal: toPage.hasClass("page-modal"), transitionName: options.transition, reverse: true, nextPageNoTransition: prevPageNoTransition, callback: function() {
                Dispatcher.trigger("page/back/after", { fromPage: fromPage, toPage: toPage });
                // clean the drill table when clicking on back
                if (fromPage.hasClass("table-drill") && !fromPage.hasClass("disabled")){
                    fromPage.remove();
                }
                Dispatcher.trigger("page/change/after/callbackEnded", { fromPage: fromPage, toPage: toPage });
            } });
        },

        doTransition:function ($from, $to, options) {
            //just in case the user is focus on an input field need to blur in order to dissmiss the keyboard
            document.activeElement.blur();
            //just in case the user is focus on an input field need to blur in order to dissmiss the keyboard
            document.activeElement.blur();
            var onUpdate = function(){
                $modalContainer.css({"height":"","width":""});
                fixModalContainerDimentions();
            };
            // there is a bug in firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1000957 that make use give the a fix height to the contianer.
            // the fix width is for large phone factor to make the container fit the content
            var fixModalContainerDimentions = function(){
                if ((!$to.hasClass("table-drill") || options.ignoreModalDrill) && $to.width()) {
                    $modalContainer.width("");
                    $modalContainer.width($to.width());
                }
                if (Capriza.device.firefox && !$(".active.table-drill").length && $modalContainer.height()){
                    Dispatcher.off("control/updates page/update/after", onUpdate);
                    var containerHeight = $modalContainer.height();
                    $modalContainer.height(containerHeight);
                    // this is mainly for table update, if the page was small and now it got bigger, fix it
                    $(".page-modal").hasClass("active") && Dispatcher.on("control/updates page/update/after", onUpdate);
                }
                Dispatcher.trigger("page/modal/sizeFixed", $to);
            };
            var removeTransitionFromModal = function(){
                clearTimeout(options.removeTransitionTimeout);
                $(this).off(Utils.transitionEnd, removeTransitionFromModal).removeClass("height-transition");
                fixModalContainerDimentions();
            };
            var transitionEnd = function () {
                //there is animation both on the opacity (animationend) and on the transform (webkitAnimationEnd) causes double trigger for one element
                $(this).off(Utils.animationEnd +" "+Utils.transitionEnd, transitionEnd);
                $(".viewport").removeClass("transitioning");
                $modalContainer.removeClass("expanding");
                if (options.removeModal){
                    var $shield = $(".global-shield.modal");
                    $to.removeClass("disabled").addClass("active");
                    $to.trigger("page/active");
                    $shield.remove();
                }
                $(".before").removeClass(options.transitionName + " before");
                if (!options.nextPageNoTransition) {
                    $to.removeClass(options.transitionName + " in" + reverseClass);
                }

                //prevent some wierd behaviour where the event is triggered from pages that are not in the dom anymore
                var fromId = $from.attr('id');
                if (fromId && $('#'+fromId).length === 0) {
                    $(document).trigger("pagechange", { toPage:$to });
                    Logger.debug('****** transition ended on non dom element: '+fromId);
                    return;
                }
                $from.hasClass("before") && $from.removeClass(options.transitionName + " before");
                if (!options.prevPageNoTransition) {
                    if ($from.is(".out, .disabled")/* || $from.is(".out, .disabled")*/) {
                        $from.removeClass(options.transitionName + " active out" + reverseClass);
                    }

                    if (options.transitionName == "slide"){
                        $from.css("transform","");
                    }
                    $('.page.out').each(function() {
                        var zombiePageViews = $(this).data('pageView');
                        if (zombiePageViews) zombiePageViews.destroy();
                    })
                }

                if (options.removeModal){
                    if ($to.hasClass("table-drill")){
                        $to.prevAll(".page.context-page").prevAll(".page:not(.mini-browser)").remove();
                    } else {
                        $to.prevAll(".page:not(.mini-browser)").remove();
                    }
                    $modalContainer.removeClass("modal-shown").remove();
                }

                // clean the dom from the property that enable us to animate container size change
                if (options.isModal){
                    $modalContainer[0].style["height"] = "";
                    $from.css({"margin-left": "", "padding-right": ""});
                    $to.css({"margin-left": "", "padding-right": ""});
                    if (options.modalToModal) {
                        options.removeTransitionTimeout = setTimeout(removeTransitionFromModal, 350);
                        $to.parent().addClass("height-transition").one(Utils.transitionEnd, removeTransitionFromModal).css({
                            "max-height": "",
                            "min-height": ""
                        });
                        if (!$.capriza.usePageAnimation || options.transitionName === "none"){
                            removeTransitionFromModal();
                        }
                    } else {
                        $modalContainer.css("box-shadow", $to.css("box-shadow"));
                        fixModalContainerDimentions();
                    }
                }
                $to.css("box-shadow", "");

                $(document).trigger("pagechange", { toPage:$to });
                options.callback && options.callback($to, options.removePrevPage);
            };
            var modalOpen = $(".global-shield.modal.active").length > 0,
                $modalContainer = $(".modal-page-container");
            $modalContainer.css("height","");
            //For Modal drill page use origin page height (no matter what is the drill page height)
            if (modalOpen && $to.hasClass("table-drill") && !options.ignoreModalDrill){
                $to.height($from.height());
            }
            // if there is transition from the engine use it, for modal use expand
            var modalTransitionName = options.transitionName ? options.transitionName : (!(modalOpen && options.isModal) ? "expand" : undefined);// ? "fade" : /*options. ? ( ? "slideup" :*/ "expand");/*expand*/
            if (options.isModal){
                $(window).off("resize", fixModalContainerDimentions).on("resize", fixModalContainerDimentions);

                //when moving to a modal page
                options.transitionName = modalTransitionName;
                if (modalOpen) {
                    options.modalToModal = true;
                } else {
                    // new modal need to give it shadow to the parent container to be displayed on the expend
                    $to.css("box-shadow", $to.find(".page-content,.dialog-body").css("box-shadow"));
                }
                $(".global-shield.modal").addClass("active");
            } else if (modalOpen) {
                options.nextPageNoTransition = true;
                options.transitionName = modalTransitionName;
                options.removeModal = true;
                // closing add a delay for the shield to make it close slower than the modal
                $(".global-shield.modal").addClass("closing").removeClass("active");

                $from.css("box-shadow", $from.find(".page-content,.dialog-body").css("box-shadow"));
                $modalContainer.css("box-shadow","");
            }
            options.removePrevPage = !options.isModal || options.modalToModal;

            for (var p in options) if (options[p] === undefined) delete options[p];

            options = _.extend({
                transitionName: "fade",
                reverse: false,
                prevPageNoTransition: false,
                nextPageNoTransition: false,
                callback: null
            }, options);

            options.sameSpotAnimation = options.sameSpotAnimation || options.transitionName == "fade";
            if (Capriza.device.android && navigator.userAgent.indexOf("Chrome")==-1 && Capriza.device.androidVer && Capriza.device.androidVer < 4.4 && options.transitionName === "fade") {
                options.transitionName = 'none';
            }

            if (!$.capriza.usePageAnimation || options.transitionName === "none") {
                $from.removeClass("active");
                // if moving between full page and modal page
                //(options.isModal && !options.modalToModal) && $from.addClass("disabled");
                if (options.isModal && !options.modalToModal) {
                    $from.addClass("disabled");
                    $from.trigger("page/disabled");
                }
                $to.addClass("active");
                $to.trigger("page/active");

                Dispatcher.trigger("page/change/beforeTransition", { toPage: $to, transition: options.transitionName });

                transitionEnd();

                return;
            }

            $(".viewport").addClass("transitioning");
            !options.modalToModal && $modalContainer.addClass("expanding");

            var reverseClass = options.reverse ? " reverse" : "";

            var $listenTo = options.nextPageNoTransition ? $from : $to;
            $listenTo.one("webkitAnimationEnd animationend", transitionEnd);

            // fix modal to modal transitions (and modal drill page
            if (options.isModal && options.modalToModal){
                var fromHeight = $from.outerHeight();
                // this hack is for page transition, when there are 2 pages in the Modal container they move to the center, this makes them be aligned
                var fixIncomingPosition = 0;
                if (options.reverse){
                    fixIncomingPosition = ($to.width() - $from.width())/2;
                    if (fixIncomingPosition > 0) {
                        $from[0].style["padding-right"] = fixIncomingPosition + "px";
                    } else {
                        fixIncomingPosition = 0;
                    }
                    $to[0].style["margin-left"] = ($from.width() + fixIncomingPosition) + "px";
                } else {
                    fixIncomingPosition = ($from.width() - $to.width())/2;
                    if (fixIncomingPosition > 0) {
                        $to[0].style["padding-right"] = fixIncomingPosition + "px";
                    } else {
                        fixIncomingPosition = 0;
                    }
                    $from[0].style["margin-left"] = ($to.width() + fixIncomingPosition) + "px";
                }
                // this is to animate the modal container
                $to.parent().css({"max-height": fromHeight, "min-height": fromHeight});
            }

            if (!options.nextPageNoTransition) {
                $to.addClass("active pre");
                $to.trigger("page/active");
                if (!options.removePrevPage) {
                    $from.addClass("disabled");
                    $from.trigger("page/disabled");
                }
                if (options.isModal) {
                    if (options.reverse) {
                        $from.addClass(options.transitionName + " before" );
                    } else {
                        if (options.sameSpotAnimation) {
                            $to.addClass(options.transitionName + " before");
                        }
                    }
                    if (!options.modalToModal){
                        $modalContainer.height($to.height());
                    }
                }
            }
            Dispatcher.trigger("page/change/beforeTransition", { toPage: $to, transition: options.transitionName });

            setTimeout(function() {
                if (!options.removePrevPage) {
                    $from.addClass("disabled");
                    $from.trigger("page/disabled");
                }
                if (!options.prevPageNoTransition && (options.removePrevPage || options.removeModal)) {
                    $from.addClass(options.transitionName + " out " + reverseClass);
                }

                if (!options.nextPageNoTransition) {
                    (options.isModal || !options.removeModal) && $to.addClass(options.transitionName + " in " + reverseClass);
                    $to.removeClass("pre");
                }

                //since we are in a timeout, other shit can happen here so in case $to are no longer in the DOM
                //invoke transitionEnd
//                Logger.debug('DOCUMENT POSITION****: '+$to.attr('id')+' position '+$to[0].compareDocumentPosition(document.body));
                if (($to.attr('id') && $to.attr('id').indexOf('start-page') < 0 && $to[0].compareDocumentPosition(document.body) > 30) ||
                    (options.prevPageNoTransition && options.nextPageNoTransition)){
                    transitionEnd();
                }
            }, 0);


        },

        fastClick: function(el, options) {
            if (!("FastClick" in window)) return;

            if (Capriza.device.chrome) return;

            options = _.extend({
                highlightDelay: null
            }, options);

            var $el = $(el);

            return new FastClick(el, {
                onClickCancelled: function(e) {
                    $el.addClass("click-cancelled").removeClass("clicked");
                    setTimeout(function() { $el.removeClass("click-cancelled"); }, 0);

                    if (options.highlightDelay) {
                        clearTimeout(this.addClassClickedTimeout);
                        this.addClassClickedTimeout = null;
                    }
                },

                onTouchStart: function(e) {
                    if (options.highlightDelay) {
                        clearTimeout(this.addClassClickedTimeout);
                        this.addClassClickedTimeout = setTimeout(function() {
                            $el.addClass("clicked");
                        }, options.highlightDelay);
                    } else {
                        $el.addClass("clicked");
                    }
                },

                onTouchEnd: function(e) {

                    if (options.highlightDelay && this.addClassClickedTimeout) {
                        clearTimeout(this.addClassClickedTimeout);
                        this.addClassClickedTimeout = null;
                    }

                    if (options.highlightDuration) {
                        clearTimeout(this.highlightDurationTimeout);
                        this.highlightDurationTimeout = setTimeout(function() {
                            $el.removeClass("clicked");
                        }, options.highlightDuration);
                    }
                    else {
                        $el.removeClass("clicked");
                    }
                },

                onBeforeClick: function() {
                    if (options.highlightDelay && this.addClassClickedTimeout) {
                        logger.log("click - generating flash highlight");
                        clearTimeout(this.addClassClickedTimeout);
                        $el.addClass("clicked");
                        this.addClassClickedTimeout = setTimeout(function() {
                            $el.removeClass("clicked");
                        }, 200);
                    }
                }
            });
        },

        currentScrollPosition: function() {
            var $page = $.capriza.activePage;
            if (!$page || $page.length === 0) return;

            var $tab = $(".tab-content.active", $page);
            if ($tab.length > 0) {
                return $tab[0].scrollTop;
            } else {
                return $page[0].scrollTop;
            }
        }
    });
    //    force css reflow on orientation change
    Dispatcher.on("orientation/change", function () {


    });
    $.extend(Capriza,{
        reflow:function(){
            var elem = document.documentElement;

            // force a reflow by increasing size 1px
            var width = elem.style.width,
                px = elem.offsetWidth + 1;

            elem.style.width = px + 'px';

            setTimeout(function () {
                // undo resize, unfortunately forces another reflow
                elem.style.width = width;
                elem = null;
            }, 0);
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/UiControl.js

try{
;(function() {
    Capriza.Views = {};

    Capriza.Views.createView = function(model, page, viewGetter, defaultView) {
        if (!model) return;

        viewGetter || (viewGetter = Capriza.Views.getViewByModel);
        var viewClass = viewGetter(model), newView;

        if (viewClass) {
            newView = new viewClass({ model: model, page: page });
        } else {
            newView = new (defaultView || Capriza.Views.UiControl)({ model: model, page: page });
        }

        Dispatcher.trigger("uiControl/created", newView);
        return newView;
    };

    Capriza.Views.validateDomReadyForModal = function(shouldAddDummyPageInDesigner){
        $from = $(".active.page");
        if (shouldAddDummyPageInDesigner || !$from.length || ["pagecontext-not-found","start-page"].indexOf($from[0].id) > -1){
            Utils.addDummyPage();
        }
        var $shield = Utils.raiseModalShield(),
            $modalContainer = Utils.raiseModalContainer();
        Utils.moveShieldBeforeElement($shield, $modalContainer);
        return $shield.length && $modalContainer.length && $(".active.page").length;
    };

    Capriza.Views.preparePageModal = function($page, options){
        $from = $(".active.page");
        var shouldAddDummyPageInDesigner = ((window.isDesignerPreview || window.designerLoaded) && ($from.attr("uniqueId") == $page.attr("uniqueId") && (!$from.attr("id") || $from.attr("id").indexOf("drill") == -1)) && !options.modalToModal);
        Capriza.Views.validateDomReadyForModal(shouldAddDummyPageInDesigner);
        $page.appendTo(".modal-page-container");
        return $page.addClass("page-modal");
    };

    Capriza.Views.initWidget = function(widgetName, obj) {
        Capriza.Model.Control.createApi(widgetName, obj.displayType);
        return $.widget("capriza." + widgetName, obj);
    };


    Capriza.Views.applyStyleFromString = function(el, styleStr, inheritedProps, model) {

        /**
         * NOTE: optional performance hit - going over props and for each prop visiting all the children, instead of vice versa
         * When this really hurts us we should take care of this.
         */

        _.each(styleStr.split(";"), function(prop) {
            if(!prop) {
                return;
            }
            var index = prop.indexOf(":"), name = prop.substr(0, index), value = prop.substr(index + 1);
            $(el).css(name, value);

            if (inheritedProps && inheritedProps.indexOf(name) >= 0) {
                $("*", el).each(function() {
                    $(this).css(name, "inherit");
                });
            }
        });
    };

    Capriza.Views.UiControl = Backbone.View.extend({
        render: function() {
            Logger.trace("UiControl.render: " + this.model.get("id")+' type: '+this.model.get("type"));

            _.bindAll(this, "blockEvents");

	        this.$el = this._render();
	        if(!this.$el) return null;
            this.$el
                .addClass("ui-control")
                .addClass(this.model.get("mcClass"))
                .data("uicontrol", this)
                .attr("data-mc", this.model.get("id"))
                .attr("data-mctemplid", this.model.get("mcTemplId"));

            this.setKey(this.model.get("key"));

            Dispatcher.trigger("uiControl/rendered", this);

            this.post();
            return this.$el;
        },

        _renderHendelbars: function(){
            var template = Handlebars.templates[this.template];
            this.presentationModel = this.getPresentationModel();
            this.$el = $(template(this.presentationModel));
            return this.$el;
        },

        _render: function(){},

        post: function() {

            this._post();
            this.applyMcSize();
            this.setMcStyle();
            this.setStyleSets();
            this.setShouldUseWebColor();
            this.setIsDisabled();
            this.setError();
            this.setTooltip();
            this.disablePropagation();
        },

        setKey: function(key) {
            var hasKey = (typeof key === "string");
            if (this.$label) {
                if (hasKey) this.$label.text(key);
                else {
                    this.$label.remove();
                    this.$label = null;
                }
            } else if (hasKey) {
                this.$label = $("<label>").text(key).attr("for", this.labelFor() || "").attr("id", this.labelId() || "").prependTo(this.$el);
            }
        },

        labelFor: function() {
            return this.getUniqueControlId() + "input";
        },

        labelId: function() {
            return this.getUniqueControlId() + "label";
        },

        disablePropagation: function() {},

        setMissing:function(){
            var missing = this.model.get("missing");
            var self = this;
            if(missing){
                this.removeFromPage();
                this.destroy();
            }
            else{//TODO: relevant for view reuse in _updateState
                delete this.destroyed;
            }
        },

        //stub to handle isReadOnly Control updates
        setIsReadOnly: function(){
            if (this.model.get("isReadOnly")) {
                this.$el.addClass("readonly");
                this.$el.find("input,textarea").prop({readOnly: true, tabIndex: -1});
            } else if (this.model.get("isReadOnly") === false) {
                this.$el.removeClass("readonly");
                this.$el.find("input,textarea").prop({readOnly: false, tabIndex: 0});
            }
        },

        renderOutsideEl: function(container) {//container is the same one used in the mobile schema definition
            var prefix = "ss-"+container+"-";
            var outerEl = $("<div>");
            if(this.model.get("styleSetIds")) outerEl.addClass(prefix + this.model.get("styleSetIds").join(" "+prefix));
            return outerEl.attr("data-"+container+"-mc", this.model.get("id")).appendTo(".viewport");
        },

        setTooltip: function(tooltip) {
            this.$el.attr("title", tooltip || this.model.get('tooltip'));
        },

        setIsDisabled: function () {
            if (this.model.get("isDisabled")) {

                if (this.model.get('disableOpts') === 'hidden') {
                    this.$el.addClass('hidden');
                }
                else {
                    this.$el.addClass("disabled");
                    this.$el[0].addEventListener('click', this.blockEvents, true);
                    this.$el[0].addEventListener('focus', this.blockEvents, true);
                    this.$el.find("input,textarea,radio,select").prop("disabled", true);
                }

            } else if (this.model.get("isDisabled")===false || this.model.get("isDisabled")===null) {
                if (this.model.get('disableOpts') === 'hidden') {
                    this.$el.removeClass('hidden');
                }
                this.$el.removeClass("disabled");
                this.$el.find("input,textarea,radio,button,select").prop("disabled", false);
                this.$el[0].removeEventListener('click', this.blockEvents, true);
                this.$el[0].removeEventListener('focus', this.blockEvents, true);
            }

            Dispatcher.trigger("uiControl/isDisabled/change", this);
        },

        blockEvents: function(e){
            if (this.shouldAllowClickWhenDisabled && this.shouldAllowClickWhenDisabled({event: e})) return;
            this.$el.find("button").prop("disabled", true);
            e.preventDefault();
            e.stopPropagation();
            Logger.info("user interacted with control '" + this.model.get('id') + "' of type '" + this.model.get('type') + "' while BLOCKED. event: " + e.eventType);
            Dispatcher.trigger("app/disabledControlInteracted", this);
        },

        setError: function() {
            var error = this.model.get('error');

            if (error) {
                this.$el.addClass('error');

                if (!this.$error) {
                    this.$error = $("<div class='error-text-container'><div class='error-message'></div></div>").insertAfter(this.$el.find("input,textarea,.selected-content"));
                    this.$errorLine = $('<div class="error-line"></div>').insertBefore(this.$el.find(".error-text-container"));
                }

                var self = this;

                if ((typeof error === "string")) {
                    this.$error.find('.error-message').text(error);

                    setTimeout(function() {

                        var errorMessage = self.$error.find('.error-message');
                        var errorMessageHeight = errorMessage.css('height');
                        errorMessage.css('transform', 'translate3d(0, -'+errorMessageHeight+', 0)');

                        setTimeout(function() {
                            self.$errorLine.addClass('active');
                            self.moveAllNextElementDown(self.$el, parseInt(errorMessageHeight), '0.3s', true);
                            self.$error.css('height', '100%');
                            errorMessage.css('transition', 'transform, 0.3s, cubic-bezier(0.4,0,0.2,1)');
                            errorMessage.css('transform', 'translate3d(0, 0, 0)');
                            Dispatcher.trigger("automation/control/error");
                        }, 50);
                    },0);
                }
                else {
                    setTimeout(function() {
                        self.$errorLine.addClass('active');
                        Dispatcher.trigger("automation/control/error");
                    }, 0);

                }


            }
            else {
                this.$el.removeClass('error');
                if (this.$error) {
                    this.$error.on('');
                    this.$error.remove();
                    this.$error = null;
                }
                if (this.$errorLine) {
                    this.$errorLine.remove();
                    this.$errorLine = null;
                }
                Dispatcher.trigger("automation/control/error");
            }

        },

        setStyleSets: function() {
            this.$el.addClass("ss-dss_global");
            if (this.model.get("styleSetIds")) this.$el.addClass("ss-" + this.model.get("styleSetIds").join(" ss-"));
        },

        setShouldUseWebColor: function() {
            if (this.model.get("shouldUseWebColor")) {
                var style = this.model.get("style");
                style && this.$el.css(style);
            }
        },


        setMcStyle: function(mcStyleParam) {
            var mcStyle  = mcStyleParam || this.model.get("mcStyle");
            mcStyle && typeof mcStyle === 'string' && this.applyStyleFromString(this.$el, mcStyle);
        },

        _post: function(){},

        destroy: function() {
            // nothing right now, need to fill this later
            //Logger.info("destroy for "+this.model.get("id")+" of type "+this.model.get("type"));
            this.destroyed = true;
            if(this._destroy) this._destroy();
            Dispatcher.off(null,null,this); // remove all listeners with the uiControl as context
        },

        applyMcSize: function(){

            if (this.model.get("mcSize")) {

                this.$el.css({width: this.model.get("mcSize").width});
            }
        },

        getPresentationModel : function() {
            return this.model.toJSON();
        },

        getUniqueControlId: function() {
            return this.options.page.getPageId().concat(this.model.get("id"));
        },

        /**
         * Sorts the attributes prior to setting them. sometimes an attribute must be set before
         * another (e.g. in Listbox items must be set before selectedIndex
         * @param attributes
         * @returns {*}
         */
        sortAttributes: function(attributes) {

            if (!this.attributesUpdateOrder) return attributes;

            var self = this;

            //verify that all attributes exist in the updatesOrder
            _.keys(attributes).forEach(function(keyAttr) {
                if (self.attributesUpdateOrder.indexOf(keyAttr) < 0) {
                    Logger.warn("attribute key "+keyAttr+' is not defined in the ordered attributes list');
                }
            });


            var sortedKeys = this.attributesUpdateOrder.filter(function(attr) {
                return _.keys(attributes).indexOf(attr) > -1;
            });

            var unsortedKeys = _.keys(attributes).filter(function(attr) {
                return self.attributesUpdateOrder.indexOf(attr) < 0 ;
            });

            var result = {};

            sortedKeys.forEach(function(key) {
                result[key] = attributes[key];
            });
            unsortedKeys.forEach(function(key) {
                result[key] = attributes[key];
            });

            return result;
        },

        update: function(attributes) {

            // don't update the element if it no longer exists in the DOM
            if (!this.existsInDOM() || this.destroyed) return;

            // notifications has no el currently because it's not a 'real' view, will be removed once modeled as a bubble
            if(this.$el) this.$el.prop("lastUpdated", Date.now());
            this._callSetters(attributes);
        },

        _callSetters: function(attributes){
            for (var p in attributes) {
                var setter = this["set".concat(p.capitalize())];
                setter && setter.call(this, attributes[p]);
            }
        },

        applyStyleFromString: function(el, styleStr) {
            Capriza.Views.applyStyleFromString(el, styleStr, this.inheritedProps, this.model);
        },

        applyStyleFromObject: function() {
            Capriza.Views.Utils.applyStyleOnElement(this.$el, this.model.get("style"));
        },

        setCss: function(el, name, value) {
            $(el).css(name, value);
        },

        setValidationMessage: function(msg) {

            var possibleOldError = this.$el.next();
            if (possibleOldError.hasClass('validation-message')) {
                $(possibleOldError).remove();
            }
            msg = msg || "";
            var $msg = $("<div class='validation-message'></div>").text(msg);
            this.$el.after($msg);
            this.$el.css({ marginBottom: "4px" });
        },

        removeFromPage: function() {
            var $el = this.getRepEl(), self = this;
            Dispatcher.trigger("control/remove/before", this);
            if ((window.isDesignerPreview || window.designerLoaded) && Capriza.Views.usePageUpdateAnimation) {
                $el.addClass("animated fadeOutRight");
                $el.on("animationend webkitAnimationEnd", function() {
                    self.removeEl.call(self, $el);
                });
            } else {
                this.removeEl.call(this, $el);
            }

        },

        removeEl: function($el){
            $el.remove();
            // TODO: merge these triggers to one with event bubbling
            Dispatcher.trigger("control/remove/after", self);
            this.trigger("control/remove/after");
        },

        getRepEl: function() {
            return this.$el;
        },

        replaceWith: function(otherView) {
            otherView.setReplacedAdditionalValues(this.getReplacedAdditionalValues());
            this.$el.replaceWith(otherView.render());
        },
        getReplacedAdditionalValues:function(){},
        setReplacedAdditionalValues:function(){},

        saveToPageState: function(key, val){
            var modelId = this.model.get('mcTemplId') || this.model.get("id"),
                page = this.options.page;

            if (page.model.get('type') === 'drillPage') page = page.model.get('parentPage');
            if(!page.state) page.state = {};
            if(!page.state[modelId]) page.state[modelId] = {};
            page.state[modelId][key] = val;
        },

        loadFromPageState: function(key){
            var modelId = this.model.get('mcTemplId') || this.model.get("id"),
                page = this.options.page;

            if (page.model.get('type') === 'drillPage') page = page.model.get('parentPage');
            return page.state && page.state[modelId] && page.state[modelId][key];
        },

        existsInDOM: function() {
            if(this.isInBubble(this.model.parent)) { // If this control is contained inside a bubble we want to act as if it always exist in DOM
                return true;
            } else {
                return document.getElementById(this.getUniqueControlId());
            }
        },

        isInBubble : function(parent) {
            if(parent){
                if(parent.get('panelType') && (parent.get('panelType') == 'bubble')){
                    return true;
                } else {
                   return this.isInBubble(parent.parent);
                }
            }else {
                return false;
            }
        },

        getClosestScrollingContainer: function(retrieveAll){
            var closestScrollingArea = this.$el.closest(".active " + (retrieveAll ? "" : ".panel-type-main>") + ".scrolling-area, .active .tab-content.active");
            return closestScrollingArea.length ? closestScrollingArea : $(".active " + (retrieveAll ? "" : ".panel-type-main>") + ".scrolling-area, .active .tab-content.active");
        },

        hasExtraData: function(prop) {
            return this.model.get("extraData") && this.model.get("extraData")[prop];
        },

        isOverflowed: function() {
            var thisTop = this.el.getBoundingClientRect().top;
            var viewportBottom = $('.viewport')[0].getBoundingClientRect().bottom;
            return thisTop > viewportBottom;
        },

        enableScrollingPropagation : function() {
            if ( Capriza.device.android){
                //this.getScrollingContainer().css("overflow-y", "auto");
                this.getClosestScrollingContainer().css("overflow-y", "auto");
            }
        },

        disableScrollingPropagation : function() {
            if ( Capriza.device.android){
               //this.getScrollingContainer().css("overflow-y", "hidden");
               this.getClosestScrollingContainer().css("overflow-y", "hidden");
            }

        },
        moveAllNextElementDown: function(currentObj, height, time, useTransition, alreadyOpen){
            while((currentObj = currentObj.next()).length ){
                var actual3d = height;
                if (!alreadyOpen){
                    actual3d = parseInt(currentObj.attr("height3d")) || 0;
                    actual3d += height;
                }
                var objZIndex = parseInt(currentObj.css("z-index"));
                currentObj.css({
                    "transition" :  useTransition ? "transform "+ time+" cubic-bezier(.21,.72,.71,.96)" : "",//0,0,0.25,1)",
                    "transform" : "translate3d(0, "+ actual3d +"px,0)",
                    "z-index" : "1",
                    "top" : "-"+ actual3d +"px",
                    "position": "relative"
                });

                currentObj.attr("height3d", actual3d );
                !alreadyOpen && objZIndex && currentObj.attr({"originalZIndex" : objZIndex});
            }
        },
        moveAllNextElementUp: function(currentObj, height, time, pageJumpGap){
            while((currentObj = currentObj.next()).length ){
                var actual3d = parseInt(currentObj.attr("height3d")) || 0;
                actual3d -= height;
                actual3d = Math.max(actual3d, 0);
                var finalTransform = actual3d + pageJumpGap == 0 ? "none" : "translate3d(0,  "+ (actual3d + pageJumpGap) +"px,0)";
                currentObj.css({
                    "transition" : "transform "+ time +" cubic-bezier(.21,.72,.71,.96)",
                    "transform" : finalTransform
                });
                currentObj.attr("height3d",actual3d);
                currentObj.on(Utils.transitionEnd, function(){
                    var this3d = parseInt($(this).attr("height3d")) || 0;
                    this3d = Math.max(this3d, 0);
                    var actualZIndex = $(this).attr("originalZIndex") || "";
                    $(this).css({"top": " -" + this3d + "px",
                        "transition": "none",
                        "z-index" : actualZIndex
                    });
                    !this3d && $(this).css({"position": ""});
                    $(this).off(Utils.transitionEnd);
                });
            }
        },
        //BlockingControl methods:

        //Notifies the page that this control is now blocking the page (e.g. the bubble is shown, and blocks other page interactions)
        notifyBlockPage: function(){
            this.options.page && this.options.page.addBlockingControl(this);
        },
        //this method is meant to be overridden by the respectful uiControl (e.g. bubble should implement it as "hideBubble")
        unblockPage: function(){
            this.options.page && this.options.page.removeBlockingControl(this);
        },

        reportInteraction: function(interactionData){
            if (!debug || !debug.interactions) return;
            var controlPath = document.activeElement.id;
            if (!controlPath){
                controlPath = this.$el.prop("id");
                if (document.activeElement.classList && document.activeElement.classList.length){
                    controlPath += " ." +document.activeElement.classList.toString().replace(/\s/g, ".");
                }
            }
            if (controlPath){
                controlPath = "#"+controlPath;
            }
            interactionData = _.extend({
                    element: "mc",
                    elementId: this.model.get("id"),
                    interaction: "general",
                    controlPath: controlPath
                }, interactionData);
            Logger.debug("[LogUserInteractions] a user interaction detected");
            Utils.reportInteraction(interactionData);
            //if (interactionData){
            //    Logger.debug("[LogUserInteractions] target class are: "+ interactionData.interaction);
            //    debug.interactions.push(interactionData);
            //
        },

        inheritedProps: ["color", "font-style", "font-weight", "line-height", "text-decoration"]
    });

    Capriza.Views.Utils = {

        wrapLinkWithPropagation: function(link) {
            var $aEl = $(link);
            $aEl.on("click", function(e) {
                e.stopPropagation();
            });
            return $aEl[0];
        },

        // overide.js
        addTelephoneLinks: function (html, controlAction) {
            if (!html) return html;

            // in desktop we want the target to open in new tab and not override the mobile tab
            var aTarget = Capriza.device.isDesktop ? "<a target='_blank'" : "<a target='_top'";

            if (!controlAction || controlAction === 'none') {
                    return html.toString().replace(/<a\s+href=(.*?)>.*?/gi, '');
            }

            var ret = html.toString();
            //Detect inline mailto or tel link, there shouldn't be the target='_top' attribute (the copy element in htmlfrag removes it)
            ret = ret.replace(/<a(.*?(["']mailto|['"]tel).*?)>/g, aTarget+"$1>");

            //Detect phone number only and replace with mobile tel link
            // within inner text content (/>([^><]*?)</g)
            //   replace only phone numbers
            //adding the ">" before and "<" after to simulate that the html is a inner content of div
            // (\+?((\(\d{2,5}\))|\d+)?[-\s]?\d+([-\s])*\d{3,9}(-\d+)*)|[\*\+]\d{3,10}\b alternative regex to detect all phone numbers
            ret = ">"+ret+"<";
            ret = ret.replace(/>([^><]*?)</g, function (match) {
                return match.replace(/\+?((\(\d{2,5}\))|\d+)?[-\s]?\d+[-\s]\d{3,9}(-\d+)*\b/g, aTarget+" class='telephone' href='tel:$&'>$&</a>");
                //return match.replace(/((\+?((\(\d{2,5}\))|\d+)?[-\s]?\d+([-\s]\d{3,9})+(-\d+)*)|((\(\d{2,5}\))+[-\s\+]\d{2,10})|\b([^\D]\d{5,10}))\b/g, aTarget+" class='telephone' href='tel:$&'>$&</a>");
            });

            return ret.substring(1,ret.length-1);
        },

        buildMiniBrowser: function(href, extraActions){
            function miniBrowserLoaded(){
                clearTimeout(miniBrowserError);
                miniBrowser.off("load", miniBrowserLoaded);
                Utils.hideUnimessages();
                setTimeout(function() {
                    Dispatcher.trigger("miniBrowser/loaded");
                },16);
            }

            miniBrowser.attr("src", href);
            var $pageMiniBrowser = $(".page.mini-browser");

            Utils.showUnimessage({type: "progress"});

            var miniBrowserError = setTimeout(function () {
                Utils.updateUnimessage({type: "error", messageText: "Failed to open link. Try to open in external browser or go back to the Zapp."}, false, false, true);
            }, 15000);
            miniBrowser.on("load", miniBrowserLoaded);

            var prevActivePage = $.capriza.activePage;
            $.capriza.toMiniBrowser($pageMiniBrowser, prevActivePage);

            // generating dummy header in order to go back to page
            var dummyHeader = $(Handlebars.templates['header']({appName: Utils.getAppName(), extraAction: extraActions}));
            // must clear header so header actions will refresh, Back button return to the real active page (and not the first active page), and extra actions will be updated
            $(".page.mini-browser .header").remove();
            $pageMiniBrowser.prepend(dummyHeader);
            miniBrowser.height($(".viewport").height() - dummyHeader.height());
            dummyHeader.find(".extraAction").on("click", function(e){
                e.stopPropagation();
                Utils.showContextMenu({items: extraActions, bubble: true});
            });
            $('.back-button', dummyHeader).on('click', function() {
                miniBrowserError && clearTimeout(miniBrowserError);
                $.capriza.miniBrowserBack($pageMiniBrowser, prevActivePage);
            }).css('visibility', 'visible');

            Dispatcher.trigger("miniBrowser/show");
        },

        createMiniBrowser: function ($el, control) {
            var launchType= control && control.get('contentAction'),
                openInNewWindow = control && control.get('openInNewWindow');

            //if (launchType === 'external' && Capriza.device.isMobile && $('a', $el).length === 0) return;

            $("a", $el).each(function () {
                var href = $(this).attr("href");
                var serverSideLinkOrdinal = $(this).attr("serverSideLinkOrdinal");

                if (launchType!="launchMap" && !serverSideLinkOrdinal && !Utils.Links.isSpecialLink(href) && (Capriza.device.isMobile || openInNewWindow)) {
                    Utils.Links.createExternalLink(this);
                } else {
                    this.addEventListener("click", function (e) {
                        if (!Utils.Links.isSpecialLink(href)) {

                            e.preventDefault();

                            if (!serverSideLinkOrdinal) {
                                Capriza.Views.Utils.buildMiniBrowser(href);
                                //miniBrowser.attr("src", href);
                                //var $pageMiniBrowser = $(".page.mini-browser");
                                //$.capriza.changePage($pageMiniBrowser, { transition: "slide" });
                                //
                                //// generating dummy header in order to go back to page
                                //var dummyHeader = $(Handlebars.templates['header']({appName: Utils.getAppName()}));
                                //if (!$(".page.mini-browser .header").length) {
                                //    $pageMiniBrowser.prepend(dummyHeader)
                                //}
                                //$('.back-button', dummyHeader).on('click', function() {
                                //    pageManager.onBackClick();
                                //}).css('visibility', 'visible');
                                //
                                //Dispatcher.trigger("miniBrowser/show");
                            }
                            else {

                                if (control) {
                                    control.api.clickInternalLink(parseInt(serverSideLinkOrdinal));
                                }

                            }

                        }
                    }, true);
                }
            });

        },

        cutHtml: function (html, len) {

            if (!html) return { changed: false };

            if (html.length <= len) return { changed: false, html: html };

            var count = 0, tags = [], re = /(<\s*(\w+)(?:\s[^>]*)?\s*>)|(<\/\s*\w+\s*>)/g, match;
            for (var i = 0; i < html.length; i++) {
                if (html[i] == "<") {
                    re.lastIndex = i;
                    match = re.exec(html);
                    i += match[0].length - 1;
                    if (match[1] !== undefined) // start tag
                        tags.push(match[2]);
                    else // end tag
                        tags.pop();
                } else {
                    count++;
                }

                if (count == len) {
                    var ret = html.substr(0, i + 1).concat("...");
                    var tag;
                    while (tag = tags.pop())
                        ret = ret.concat("</", tag, ">");
                    return { changed: true, html: ret };
                }
            }
            return { changed: false, html: html };
        },

        applyStyleOnElement: function($el, obj, innerSelector) {
            $el.css(obj);

            var inheritStyle = {};
            for (var p in obj) inheritStyle[p] = "inherit";
            $(innerSelector || "*", $el).css(inheritStyle);
        }
    };

    Capriza.Views.ScrollDetector = Backbone.View.extend({
        initialize: function() {
            this.positions = [];

            this._calc = _.bind(this.__calc, this);
            this._debounce = Capriza.device.isMobile ? Utils.debounce(100, _.bind(this.__debounce, this)) : _.bind(this.__debounce, this);
        },

        start: function() {
            this.bottomRef = Capriza.fullScreen ? window.innerHeight : $(".viewport")[0].getBoundingClientRect().bottom;
            window.addEventListener("scroll", this._calc, true);
            window.addEventListener("scroll", this._debounce, true);
            return this;
        },

        stop: function() {
            window.removeEventListener("scroll", this._calc, true);
            window.removeEventListener("scroll", this._debounce, true);
            return this;
        },

        __calc: function() {
            var rect = this.el.getBoundingClientRect();
//            console.log("el bottom: " + rect.bottom + ", " + this.bottomRef);
            this.positions.push(rect.bottom);
        },

        __debounce: function() {
            var self = this;
            var should = _.some(this.positions, function(x) { return (x - 60) <= self.bottomRef; });
//            Logger.debug("debounce (should=" + should + "): " + this.positions);
            this.positions = [];
            if (should) this.trigger("change");
        }
    });

    Capriza.Views.supportedActionControls = /(edit|delete|expand|collapse)/;

    Capriza.Views.usePageUpdateAnimation = true;

    Capriza.Views.uiState = {};

    var miniBrowser;
    Dispatcher.on("app/init", function() {
        $('#mini-browser').remove();
        var $miniBrowserPage = $("<div class='page mini-browser'/>").appendTo(".viewport");

        miniBrowser = $("<iframe id='mini-browser' sandbox='allow-same-origin allow-scripts allow-forms'></iframe>").appendTo($miniBrowserPage).css({
            height: $.capriza.viewportHeight()
        });

        miniBrowser.on("load", function() {
            Logger.debug('mini browser loaded...');
            Dispatcher.trigger('mobile/iframeLoaded');
        })
    });

    // http://stackoverflow.com/questions/7917592/html-cursor-showing-in-readonly-input-text
    $(document).on("focusin", "input[readonly]", function() {
        this.blur();
    });

    if (Capriza.device.isDesktop) {
        // prevent focusing element overlapped by global shield
        function onFocusCapture(event) {
            var gs = $(".global-shield")[0];

            gs && !$.contains(gs, event.target) && Utils.focusContainer(gs);
        }

        document.addEventListener("focus", onFocusCapture, true);
    }
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/GenericView.js

try{
(function() {
    Capriza.Views.GenericView = Capriza.Views.UiControl.extend({
        _render: function() {
            var self = this,
                presentationModel = _.extend({
                    uniqueControlId: this.getUniqueControlId(),
                    page: this.options.page,
                    view: this
                }, this.model.toJSON());

            var widgetName = this.model.get("type");

	        if(this.$el[widgetName] === undefined) return null;

            this.$el[widgetName](presentationModel);
            this.inited = true;

            this.$el.on(widgetName.toLowerCase() + "apicall", function(e, data) {
                if (!data || !data.action) {
                    Logger.error("No action passed from widget to api call");
                    return;
                }

                var action = data.action;
                self.model.api[action].call(self.model.api, data.data);
            });

            this.setIsReadOnly();

            return this.$el;
        },

        update: function(attributes) {
            this.$el.prop("lastUpdated", Date.now());

            if (!$.capriza[this.model.get("type")]) {
                Logger.debug("Warning: Cannot update non existing widget: " + this.model.get("type"));
                return;
            }

            var updateMethod = $.capriza[this.model.get("type")].prototype["update"];

            if (updateMethod) {
                this.$el[this.model.get("type")]("update", attributes);
            }

            for (var p in attributes) {
                var setterName = "set".concat(p.capitalize());
                this.$el[this.model.get("type")]("option", p, attributes[p]);
                var setter = $.capriza[this.model.get("type")].prototype[setterName];
                if (!setter) Logger.debug("Warning: Didn't find setter: " + setterName + " on " + this.model.get("type") + ", id=" + this.model.get("id"));
                else this.$el[this.model.get("type")](setterName, attributes[p]);
            }
        }
    });

    Capriza.Views.GenericCollection = Capriza.Views.GenericView.extend({
        initialize: function() {
            this.initControls(this.model.get("controls"));
        },

        initControls: function(controls) {
            var self = this;
            _.each(controls, function(control) {
                self.options.page.addView(control.get("id"), self.getView(control));
            });
        },

        getView: function(control) {
            return Capriza.Views.createView(control, this.options.page);
        },

        update: function(attributes) {
            if (attributes['controls']) {
                this.initControls(attributes['controls']);
                attributes['controls'] = attributes['controls'].map(function(control) { return control.toJSON(); });
            }

            Capriza.Views.GenericView.prototype.update.apply(this, arguments);
        },

        setIsLast: function(isLast) {
            this.$el.attr("data-is-last", isLast);
            this.inited && this.$el[this.model.get("type")]("setYesMore",this.model.get("yesMore"));
        },

        onMoreItemsArrived: function(startIndex) {
            this.initControls(this.model.get("controls").slice(startIndex));
            this.$el[this.model.get("type")]("option", "controls", this.model.get("controls").map(function(x) { return x.toJSON(); }));
            this.$el[this.model.get("type")]("onMoreItemsArrived", startIndex);
            this.setMcStyle();
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/PageView.js

try{
;(function() {
    Capriza.Views.PageView = Backbone.View.extend({
        className: "page",

        initialize: function() {
            if (this.model) {
                this.$el.attr("id", this.model.get("id"));
                this.$el.attr("uniqueId", this.model.get("uniqueId"));
            } else if (this.options.id) {
                this.$el.attr("id", this.options.id);
                this.$el.attr("uniqueId", this.options.uniqueId);
            }

            if (this.fullScreen) {
                this.ignoresHeader = true;
            }
        },

        render: function(options) {
            options = _.extend({
                append: true
            }, options);
            this.$el.data("pageView", this);
            if (this.ignoresHeader) this.$el.addClass("ignores-header");
            this._render();
            this._post();
            if (options.append){
                if (this.$pageContainer && this.$pageContainer.length){
                    this.$pageContainer.append(this.$el);
                    if (!this.$pageContainer.is(":last-child")) {
                        this.$pageContainer.appendTo(".viewport");
                    }
                } else {
                    $(".viewport").append(this.$el);
                }
            }
//            this.setHeight();
            this.trigger("page/rendered", this);
			Dispatcher.trigger("page/rendered", this, this.model);
            return this;
        },

        _render: function() {},
        _post: function() {},

        addContent: function($content) {
            if (!this.$el.children().length){
                $content.addClass("page-content");
            }
            this.$el.append($content);
            return this;
        },

        pageIsModal: function(){
            return this.getRoot && this.getRoot() && this.getRoot().get("isModal");
        },
        setPageAsModal: function(isModal){
            isModal && this.getRoot && this.getRoot() && this.getRoot().set("isModal", isModal);
        },

        show: function(options) {
            options = (options || {});
            $.capriza.changePage(this.$el, _.extend(options, {pageModel: this.model, isModal: this.pageIsModal()}));
            var $viewportOverlay = $("#viewport-overlay");
            if(!(this.state && this.state["overlayActive"]) && $viewportOverlay.hasClass("active") && $viewportOverlay[0].classList.length == 1){
                $viewportOverlay.removeClass('active');
            }
            $('#header-overlay').removeClass('active');
            return this;
        },

        clear: function() {
            this.$el.empty();
        },

        scrollTo: function(x, y) {
            var $activeTab = this.$(".tab-content.active");
            if ($activeTab.length > 0) {
                return $activeTab[0].scrollTop = y;
            } else {
                return this.el.scrollTop = y;
            }
        },

        destroy: function() {
            this.model && this.model.off( null, null, null );
            var $container = this.$el.parent();
            this.$el.remove();
            !$container.length && $container.remove();
            this.remove();
        }
    });

    Capriza.Views.ContextPage = Capriza.Views.PageView.extend({
        initialize: function() {
            var self = this;
            self._views = {};
            self._blockingControls = []; //a collection of blocking controls (e.g. bubble, dropdown)
            Capriza.Views.PageView.prototype.initialize.apply(this, arguments);
            this.$el.addClass("context-page");

            this.setPageAsModal($(".global-shield.modal.active").length > 0 && this.model.tableDrill);
            this.handlePageModal();

            this.addControls();
            //this.setHeader();

            this.model.on("page/controlChanged", function(control, attributes) {
                // search for the UiControl reference and execute proper API function on it
                var view = self.getView(self.getUpdatedControlId(control));
//                Logger.debug('updating view '+control.get("id"));

                if (view){
                    attributes = view.sortAttributes(attributes);
                    view.update(attributes);
                }
                else {
                    Logger.warn('control id '+control.id+' has no view!!');
                }

            });

            this.model.on("page/moreItems", function(control, startIndex) {

                var groupView = self.getView(control.get("id"));

                if (groupView) {
                    groupView.onMoreItemsArrived(startIndex);

                    /**
                     * NOTE: Until we have event bubbling, we need to manually let the application know about this event
                     */
                    Dispatcher.trigger("page/moreItems", { pageView: self, control: control });
                }

            });

            this.model.on("change:controls", function(model, controls, changes) {
                //_.each(self._views, function(view) {
                //    view.destroy();
                //});
                self.getViews(self.model.previousAttributes()["controls"] || []).forEach(function(view){
                    view.destroy();
                });
                self.addControls();
                self.clear();
                self.render();
            });

            this.model.on("page/controlAdded", function(controlId, parentId, index) {
                var groupView = self.getView(parentId);
                var model = Capriza.Model.Control.getById(controlId);

                if (model.get("type") == "clickAction") return; //for clickAction, the model just updates, there is no rendering..

                var view = groupView.getView(model);
                self.addView(controlId, view);
                groupView.addViewAtIndex(view, index);
                Dispatcher.trigger("page/controlAdded/after", { model: model, view: view, pageModel: self.model });
            });

            this.model.on("page/controlRemoved", function(controlId) {
                var view = self.getView(controlId);
                if (!view) return;

                view.removeFromPage();
                view.destroy();
                self.removeView(controlId);

            });

            this.model.on("page/controlModified", function(controlId) {
                var model = Capriza.Model.Control.getById(controlId);
                if (!model.parent || model.get("type") == "clickAction") return;

                var groupView = self.getView(model.parent.get("id"));
                if (!groupView) return;
                var oldView = self.getView(controlId);
                oldView.destroy();
                var newView = groupView.getView(model);
                self.addView(controlId, newView);
                oldView.replaceWith(newView);

                Dispatcher.trigger("page/controlModified/after", { model: model, newView: newView, pageModel: self.model });
            });

            this.model.on("page/update/after", function(){
                self.checkLastControl();
            });

            this.scrollListeners = [];
        },

        handlePageContainer: function(){
            if (this.pageIsModal()) {
                var containerName = (this.pageIsModal() ? "modal-" : "full-") + "page-container";
                this.$pageContainer = $("." + containerName);
                if (!this.$pageContainer.length) {
                    this.$pageContainer = $("<div></div>").addClass(containerName).addClass("page-container");
                }
            }
        },

        handlePageModal: function(){
            if (this.pageIsModal()){
                Capriza.Views.preparePageModal(this.$el, $(".global-shield").length);
                this.$pageContainer = $(".modal-page-container");
            }
        },

        getUpdatedControlId: function(control) {
            return control.get("id");
        },

        getViewByModel: function() {
            return Capriza.Views.getViewByModel.apply(this, arguments);
        },

        modelToView: Capriza.Views.modelToView,

        addControls: function() {
            var self = this;

            var controlIds = this.getControlsIds();

            if (controlIds) {
                _.each(controlIds, function(controlId) {
                    var control = Capriza.Model.Control.getById(controlId);
                    if(control.get("missing")) return;
                    var view = Capriza.Views.createView(control, self, self.getViewByModel);
                    self.addView(controlId, view);
                });

                this.checkLastControl();
            }
        },

        getControlsIds: function() {
            return _.map(this.model.get("root"),function(ctrl){
                return ctrl["id"] || ctrl;
            });
        },

        setScrolling: function () {
            var $scrollingArea = this.$('.scrolling-area, .tab-content'), self = this;
            this.scrollListeners && $scrollingArea.scroll(function(e){
                self.scrollListeners.forEach(function(callback) {
                    callback();
                })
            });
        },

        addScrollListener: function(listener) {
            this.scrollListeners.push(listener);
        },

        _render: function() {
            var self = this;
            _.each(this.getControlsIds(), function(controlId) {
                var view = self.getView(controlId);
                var $control = view.render();
                self.addContent($control, view.model);
            });

            this.$el.attr("id", this.getPageId());
            this.setScrolling();
            return this;
        },

        getView: function(modelId) {

            var view = this._views[modelId];

            return view;
        },

        getViews: function(controls) {
            var self = this;
            controls = controls || (this.model.get("root") || []).map(function(controlId) {
                return Capriza.Model.Control.getById(controlId);
            });
            return controls.map(function(control) { return self.getView(control.get("id")); }).filter(function(view) { return !!view; });
        },

        addView: function(modelId, view) {
            if(this._views[modelId] && !this._views[modelId].destroyed){
                Logger.warn("Overriding a not-destroyed view with id ["+modelId+"] and type ["+view.model.get("type")+"]");
                //this._views[modelId].destroy();
            }
            this._views[modelId] = view;
        },

        removeView: function(modelId) {
            delete this._views[modelId];

            var self = this;
            var model = Capriza.Model.Control.getById(modelId), controls = model.get("controls");
            if (controls && controls.length > 0) {
                controls.forEach(function(control) {
                    self.removeView(control.get("id"));
                });
            }
            var groupHeader = model.get("groupHeader");
            groupHeader && this.removeView(groupHeader.get("id"));
        },

        getPageId: function() {
            return "page" + this.model.get("id");
        },

        getRoot: function() {
            var controls = this.model.get("root");
            return controls && controls.length && Capriza.Model.Control.getById(controls[0]);
        },

        getBodyViews: function() {
            var bodyControls = this.getRoot() && this.getRoot().get("controls"), self = this, ret = [];
            if (bodyControls && bodyControls.length) {
                bodyControls.forEach(function(control) {
                    ret.push(self.getView(control.get("id")));
                });
            }
            return ret;
        },

        checkLastControl: function() {
            var self = this, root = this.getRoot(), lasts = [], lastsInTabs = [];

            if (!root) return;

            function getLastControl(model){
                if(typeof model == "string"){
                    model = Capriza.Model.Control.getById(model);
                }
                var retId = model.get("id");

                //TODO: remove grouping after it is not needed
                if((model.get("type")=="panel" || model.get("type")=="grouping") && ( model.get("dock") || !model.get("controls") || model.get("controls").length==0)){
                    return;
                }
                //Don't add table/tabular/topLevel/main to the below "if" we never wnt to detect the nested table as the last one so do not go there recursively.
                if ((model.get("type")=="panel" || model.get("type")=="grouping" || model.get("type") === 'tabController' || model.get('type') === 'tab') && model.get("controls")) {
                    model.get("controls").forEach(function (mdl) {
                        retId = getLastControl(mdl) || retId;
                    });
                }

                //save the last control in each tab (for infinite table for tabs)
                model.get('type') === 'tab' && lastsInTabs.push (retId);

                return retId;
            }

            function setIsLastForAll(model){
                if(typeof model == "string"){
                    model = Capriza.Model.Control.getById(model);
                }
                var modelId = model.get("id");

                if((model.get("type")=="panel" || model.get("type")=="grouping") && ( model.get("dock") || !model.get("controls") || model.get("controls").length==0)){
                    return;
                }
                var view =  self.getView(modelId);
                view && view.setIsLast && view.setIsLast(lasts.indexOf(modelId) > -1);

                if(/(panel|tabController|tab|table|tabular|topLevel|main)/g.test(model.get("type"))
                    && model.get("controls")) {
                    model.get("controls").forEach(function (mdl) {
                        setIsLastForAll(mdl);
                    });
                }
            }

            lasts = lasts.concat([getLastControl(root)], lastsInTabs);
            setIsLastForAll(root);
        },

        destroy: function() {
            this.getBodyViews().forEach(function(view) {
                view && view.destroy();
            });
            Capriza.Views.PageView.prototype.destroy.call(this);
        },

        replaceHeaderContent: function($content) {
            // don't show sideburger on podal pages, or drill pages that started in modal
            if (!this.pageIsModal()) {
                Dispatcher.trigger('sideburger/show', $content);
            }
        },

        //handles inner uiConrols that may block the page interaction (e.g. bubble, dropdown..)

        addBlockingControl: function(view){
            if (!view) return;
            var viewAlreadyExist = _.find(this._blockingControls, function(bc){ return bc.model.get("id") == view.model.get("id") });
            if (!viewAlreadyExist){
                this._blockingControls.push (view);
                Logger.debug("[PageView] added a blocking control: " + view.model.get("id") + ", for page: " + this.model.get("uniqueId"));
            }
        },
        popBlockingControl: function(){
            this._blockingControls.pop();
        },
        removeBlockingControl: function(view){
            var newBlockingControls = _.filter(this._blockingControls, function(bc){return bc.model.get("id") != view.model.get("id")});
            if (newBlockingControls.length != this._blockingControls)
                Logger.debug("[PageView] removed a blocking control: " + view.model.get("id") + ", for page: " + this.model.get("uniqueId"));
            this._blockingControls = newBlockingControls;
        },
        //iterativly calls unBlockPage() for each blockingControl in the stack, assuming the control will remove itself from the stack
        unblockAllBlockingControls: function(){
            var blockingConrolsCount = this._blockingControls.length;
            if (blockingConrolsCount > 0){
                for (var i = blockingConrolsCount - 1; i >= 0; i--){
                    this._blockingControls[i].unblockPage();
                }
            }
        }

    });

    Capriza.Views.BasePage = Capriza.Views.PageView.extend({
        initialize: function() {
            Capriza.Views.PageView.prototype.initialize.apply(this, arguments);
            this._initialize && this._initialize();
            _.bindAll(this, "changeControls", "controlChanged", "controlAdded", "controlRemoved", "controlModified");

            this.model.on("change:controls", this.changeControls);
            this.model.on("page/controlChanged", this.controlChanged);
            this.model.on("page/controlAdded", this.controlAdded);
            this.model.on("page/controlRemoved", this.controlRemoved);
            this.model.on("page/controlModified", this.controlModified);
        },

        changeControls: Utils.noop,
        controlChanged: Utils.noop,
        controlAdded: Utils.noop,
        controlRemoved: Utils.noop,
        controlModified: Utils.noop
    });

    Capriza.Views.LoadingPage = Capriza.Views.PageView.extend({
        _render: function() {
            this.$el.addClass("loading-page");
            this.addContent('<div class="spinner"></div>');
        }
    });

    Capriza.Views.DummyPage = Capriza.Views.PageView.extend({
        render: function(options) {
            options = _.extend({
                append: true
            }, options);
            this.$el.addClass("dummy-page");

            var $dummyHeader = $(Handlebars.templates['header']({appName: ""}));
            $dummyHeader.find(".back-button").css("visibility","hidden");
            Dispatcher.trigger("sideburger/show", $dummyHeader);

            this.$el.prepend($dummyHeader).appendTo(".viewport");
            return this;
        },
        show: function() {
            this.$el.addClass("active");
            return this;
        }
    });

    $(document).bind("pagechange", function( event, data ){
        var pageView = data.toPage.data("pageView"), pageModel = pageView && pageView.model;

        // TODO: roadblock 29/9/2013 - after that we should erase the "backable" and "popup" conditions
        if (pageModel && (pageModel.get("backControl") || pageModel.tableDrill )) {
            Dispatcher.trigger("backButton/show");
        } else if (data.toPage.attr("id") && data.toPage.attr("id").indexOf("mini-browser") > -1) {
            Dispatcher.trigger("backButton/show");
        } else {
            Dispatcher.trigger("backButton/hide");
        }

        Dispatcher.trigger("header/pageChange");

    });

    Dispatcher.on("page/beforeChange", function(e) {
        var pageView = e.fromPage.data("pageView"), uiState, uniqueId;

        if (!pageView || !pageView.model) return;

        var pageModel = pageView.model;

        if (pageModel.get("uniqueId") !== undefined) {
            uniqueId = pageModel.get("uniqueId");
            uiState = Capriza.Views.uiState["page" + uniqueId] || {};
            uiState.page = pageModel;
            uiState.selectedTab = pageView.currentSelectedTab();
            uiState.scrollPosition = $.capriza.currentScrollPosition();
        } else if (pageModel.tableDrill) {
            uniqueId = pageModel.get("parentPage").get("uniqueId");
            uiState = Capriza.Views.uiState["page" + uniqueId] || {};
            uiState.drillId = pageModel.get("root")[0];
            uiState.drillIndex = pageModel.get("parentPage").drillIndex;
            uiState.tableId = pageModel.get("tableId");
            uiState.drillScrollPosition = $.capriza.currentScrollPosition();
        }

        if (typeof uniqueId !== "undefined") {
            if (uiState) Logger.debug("saving ui state on page " + uniqueId + ": selectedTab=" + uiState.selectedTab + ", scrollPosition: " + uiState.scrollPosition + ", drillId=" + uiState.drillId + ", drillIndex=" + uiState.drillIndex + ", tableId=" + uiState.tableId + ", drillScrollPosition=" + uiState.drillScrollPosition);
            else Logger.debug("resetting ui state on page " + uniqueId);
            Capriza.Views.uiState["page" + uniqueId] = uiState;
        }



    });

    var listTableRegex = /^(list|table|tabular|table2)$/;
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/pages/MVPageView.js

try{
/**
 * Created by oriharel on 1/18/15.
 */

;(function() {
    var getText = Capriza.translator.getText.bind(Capriza.translator);

    Capriza.Views.MVPageView = Capriza.Views.ContextPage.extend({

            expiredHandler: undefined,
            mvpTimeout: undefined,

            initialize: function() {

                Capriza.Views.ContextPage.prototype.initialize.apply(this, arguments);

                this.mvpTimeout = ClientCache.getItem(Capriza.Views.MVPageView.zappDataKey+Capriza.getToken()+'-timeout') || 60000;

                if (this.model.mvp) this.$el.addClass('mvp');
                if (this.model.mvppp) this.$el.addClass('mvppp');

                Dispatcher.on('app/newVersionDownloading', function() {
                    var msg = {type: "progress",
                        messageText: getText("newVersion"),
                        detailText: getText("zappReloadAuto")};

                    Utils.showUnimessage(msg, false, true);
                });

                Dispatcher.on("app/offline", this._onOffline, this);
                Dispatcher.on("app/online", this._onOnline, this);
                _.bindAll(this, "rearmMVPTimeOut");
            },

            rearmMVPTimeOut: function() {
                Logger.debug('arming mvp timeout');
                if (this.expiredHandler) clearTimeout(this.expiredHandler);
                this.expiredHandler = setTimeout(function() {
                    Logger.error('[MVP] mvpTimerExpired triggered', undefined, "mvp");
                    Dispatcher.trigger('mvpTimerExpired', {cause: "mvpTimerExpired"});
                }, this.mvpTimeout);
            },

            // Cancels MVP updating timeout and shows Offline-toast
            _onOffline: function () {
                Logger.debug("MVP offline");
                clearTimeout(this.expiredHandler);

                var msg = {messageText: getText("mvpOffline"),
                    actionText: getText("gotIt"),
                    action: Utils.hideUnimessages.bind(Utils)};

                Utils.showUnimessage(msg, false, true);
            },

            // Starts MVP updating timeout and shows Updating-toast
            _onOnline: function () {
                Logger.debug("MVP online");
                this.rearmMVPTimeOut();

                if (Utils.isCachedMVPShown()) {
                    var s = getText("mvpUpdating");
                    var t = getText("lastUpdated") + " " + this.lastUpdateDate;

                    Utils.showUnimessage(
                        {type: "progress", messageText: s, detailText: t},
                        false, true);
                }
            },

            _render: function() {
                Capriza.Views.ContextPage.prototype._render.apply(this, arguments);
                Dispatcher.trigger("mobile/active");

                var errorCallback = function(data) {
                    Logger.tag("MVPError");
                    Logger.error('MVPageView update Error received', undefined, "mvp", JSON.stringify(data));

                    var messageText = getText("somethingIsWrong");
                    var detailText = getText("couldNotUpdatePage");
                    var actionText = getText("retry");

                    var msg = {type: "error", messageText: messageText,
                        detailText: detailText, actionText: actionText,
                        action: Utils.reload};

                    Utils.showUnimessage(msg, false, true);
                };

                Dispatcher.on('application/contextNotFound mvpTimerExpired handleResponseError', errorCallback, this);

                var timestamp = this.model.get('timestamp');
                moment.locale(Capriza.translator.getLang());
                var momentDate = moment(parseFloat(timestamp));

                this.lastUpdateDate = momentDate.fromNow();

                Logger.debug('showing mvp from: ' + this.lastUpdateDate);

                var _this = this;

                Dispatcher.on('page/change/after', function(options) {
                    if (options.toPage.hasClass('mvp')) {
                        if(options.toPage.hasClass("mvppp")) {
                        } else if (Capriza.Connection.isOnline) {
                            _this._onOnline();
                        } else {
                            _this._onOffline();
                        }
                    }
                    else if (!Utils.isCachedMVPShown()) {
                        $(".mvp").removeClass("mvp mvppp").addClass("was-mvp");
                        Utils.hideUnimessages();
                    }
                }, this);

                Logger.debug("[MVP] starting the expiration timer");

                Dispatcher.on('page/newPage', this.rearmMVPTimeOut);
                Dispatcher.on('mvp/newContentReady', function (options) {
                    Capriza.aboutToShowMVP = false;
                    clearTimeout(_this.expiredHandler);
                    Dispatcher.off('page/newPage', _this.rearmMVPTimeOut);
                    Dispatcher.off("app/offline", this._onOffline);
                    Dispatcher.off("app/online", this._onOnline);

                    Dispatcher.off(undefined, undefined, _this);

                    if(!options.newOnlinePageView){
                        Logger.debug('[MVP] MVP++ just got in sync with engine');
                        $(".mvp").removeClass("mvp mvppp").addClass("was-mvp");

                        Dispatcher.trigger("engineApi/unsyncedMessages", false);
                        return;
                    }
                    Logger.debug('[MVP] showing new content is ready msg');

                    Utils.hideUnimessages();
                    //var activePage =$('.page.active');
                    //if (activePage.length > 0) {
                    //    options.newOnlinePageView.$el.attr('style',activePage.attr('style'));
                    //}

                    options.newOnlinePageView.show({ transition: 'none' });

                }, this);

                Dispatcher.on("page/update/after", function (eventData){
                    if (Utils.isCachedMVPShown() && !eventData.response.cached) {
                        Dispatcher.trigger('mvp/newContentReady', {});
                    }
                }, this);

                Dispatcher.on("control/updates/before", function (response){
                    if (Utils.isCachedMVPShown("mvppp") && !response.cached && response.mvp) {
                        Dispatcher.trigger('mvp/newContentReady', {});
                    }
                    if (!Utils.isCachedMVPShown() && response.mvp) {
                        _this.$el.appendTo(".viewport");
                        _this.show();
                    }
                }, this);

                return this;
            }
        }
    );


    Capriza.Views.MVPageView = _.extend(Capriza.Views.MVPageView, {

        isMvp: true,

        zappDataKey: 'bgs-',

        writingQueue: [],

        backgroundHandler: function(response) {

            if(Utils.isCachedMVPShown("mvppp") || Utils.wasCachedMVPShown()) return;
            Logger.debug('has mvp in message '+response.resultType);
            // var zappDataStr = ClientCache.getItem(Capriza.Views.MVPageView.zappDataKey+Capriza.getToken())
            // if (!zappDataStr || response.resultType === 'newPage') {
            //     localMvpObj = [];
            // }
            // else {
            //     localMvpObj = JSON.parse(zappDataStr).mvp;
            // }

            //mark timestamp - this just received from the engine now.
            if (response.page) {
                response.page.timestamp = Date.now();

                //TODO - for debug purpose only. you can remove this.
                var momentDate = moment(parseFloat(response.page.timestamp));
                var formattedDate = momentDate.format('MM/DD/YYYY [at] hh:mma');
                Logger.debug('new mvp arrived. marking time: '+formattedDate);
            }

            var processedResponse = SharedUtils.processMvpResponse(response);

            this.saveMvp(processedResponse);

            this.reportToWrapper('background/mvpEnabled');

            // fix two issues: ticket #18069 - MVP on login page
            // 1. was called multiple times!
            // 2. identity/host/logout already triggered removing the whole file, so no need to also call remove mvp from this file
            Dispatcher.off("identity/host/logout", this._onClearMVP).on("identity/host/logout", this._onClearMVP, this);
            Dispatcher.off("mobile/error", this._onClearMVPAndNotifyWrapper).on("mobile/error", this._onClearMVPAndNotifyWrapper, this);
        },

        _onClearMVP: function() {
            Logger.debug("[MVPageView] : _onClearMVP is called");
            $(".mvp").removeClass("mvp mvppp").addClass("was-mvp");
            Utils.hideUnimessages();
            this.removeCachedMVP();
        },

        _onClearMVPAndNotifyWrapper: function() {
            Logger.debug("[MVPageView] : _onClearMVPAndNotifyWrapper is called");
            this._onClearMVP();
            Dispatcher.trigger('mvp/remove');
        },

        saveMvp: function(localMvpObj) {
            Logger.debug('saveMvp started with '+localMvpObj.resultType+' resultType');
            // var mvpStoreKey = 'bgs-'+Capriza.getToken();

            if (localMvpObj.resultType === 'newPage') {
                this.writingQueue = [localMvpObj];
            }
            else {
                this.writingQueue.push(localMvpObj);
            }

            // if (localMvpObj.resultType !== 'newPage') {
            //     var zappDataStr = ClientCache.getItem(mvpStoreKey);
            //     var zappData = zappDataStr && JSON.parse(zappDataStr);
            //     var localMvpMessages = fileMvp || zappData && zappData.mvp;
            //
            //     localMvpMessages && localMvpMessages.push(localMvpObj);
            // }



            Dispatcher.trigger('mvp/saveMvpInFile', this.writingQueue);
        },

        reportToWrapper: function(event, payload) {

            if (Capriza.Capp && Capriza.Capp.messenger) {
                Logger.debug("reporting to wrapper: "+event);
                payload = payload || {};
                var zappId = window.appData && window.appData.app_id;
                var args = _.extend(payload, {zappId: zappId});
                Capriza.Capp.messenger.emit(event, args);
            }
            else {
                Logger.debug("NOT reporting to wrapper: "+event);
            }
        },

        removeCachedMVP: function() {
            ClientCache.removeItem(Capriza.Views.MVPageView.zappDataKey+Capriza.getToken());
            ClientCache.removeItem(Capriza.Views.MVPageView.zappDataKey+Capriza.getToken()+'-mvpId');
        },


        loadMVP: function() {
            Logger.debug('loadMVP started');
            var mvpStoreKey = 'bgs-'+Capriza.getToken();

            function loadMvpCallback(fileMvp) {
                if($(".context-page.active").length) {
                    Logger.debug("returned to loadMvpCallback after new page already arrived, no need to do fallback to localstorage");
                    return;
                }

                var zappDataStr = ClientCache.getItem(mvpStoreKey);
                var zappData = zappDataStr && JSON.parse(zappDataStr);
                var localMvpMessages = fileMvp || zappData && zappData.mvp;

                if (localMvpMessages && !Utils.isInDevMode()) {
                    $.capriza.activePage = $([]);

                    Logger.debug('handling mvp ['+localMvpMessages.length+'] messages appCache status: '+applicationCache.status+' Capriza.firstRun: '+Capriza.firstRun);
                    take('loadingMVP');
                    Capriza.aboutToShowMVP = true;

                    localMvpMessages.forEach(function(message, i) {
                        message.cached = true;
                        setTimeout(function(){
                            if($("#error-page.active").length == 1) return;
                            handleResponse(message)
                        }, i*50);
                        //handleResponse(message);
                    });
                    //setTimeout(function(){Dispatcher.trigger("app/loaded")}, localMvpMessages.length*50);
                    Logger.debug("handling mvp - ended");
                    Logger.tag("MVPShown");
                    // Capriza.Views.MVPageView.removeCachedMVP();
                    //Dispatcher.trigger("mobile/active");
                    if(localMvpMessages[0] && localMvpMessages[0].mvppp ) {
                        Dispatcher.trigger("engineApi/unsyncedMessages", true);
                    }
                }
                else {
                    Logger.debug('zapp has no MVP or in dev mode');
                }
            }

            Utils.getMvpFromFile(mvpStoreKey, loadMvpCallback);

        }
    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/pages/CNFPageView.js

try{
/**
 * Created by maayankeenan on 4/19/15.
 */
;(function() {
    Capriza.Views.CNFPageView = Capriza.Views.ContextPage.extend({

        initialize: function () {
            Capriza.Views.ContextPage.prototype.initialize.apply(this, arguments);
        },

        _render: function () {
            Capriza.Views.ContextPage.prototype._render.apply(this, arguments);

            if (!window.isDesignerPreview){
                $('.cnf-restart', this.$el).on('click', function(){
                    Utils.reload();
                });
            } else {
                $('.cnf-restart', this.$el).on('click', function(){
                    window.DesignerDispatcher.trigger("mobile/restart");
                });
            }

            return this;
        }

    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/pages/SettingsPageView.js

try{
/**
 * Created by omer on 20/7/15.
 */

;(function() {

    Capriza.Views.SettingsPage = Capriza.Views.PageView.extend({

        id: "settings-page",
        fullScreen:true,

        _render: function () {
            var self = this;
            if (!this.$settingsPage) {
                var settingsForText = Capriza.translator.getText(Capriza.translator.ids.settingsFor)+" "+Utils.getAppName();
                var doneText = Capriza.translator.getText(Capriza.translator.ids.doneCaptial);
                this.$settingsPage = this.$el.append(Handlebars.templates["settings-page"]({settingsForText: settingsForText, doneText: doneText}));
                this.$content = this.$(".settings-content");
            }
            this.$settingsPage.appendTo(".viewport");
            this.populateSettings();
            this.$(".close").on("click", function () {
                self._leave();
            });


            self.$el.addClass("slideup in active");
            self.$el.one("animationend webkitAnimationEnd", function () {
                self.$el.removeClass("slideup in");
                $(".nonmobile-wrap").removeClass("transitioning");

                Dispatcher.trigger('settingsPage/open');
            });
            $(".nonmobile-wrap").addClass("transitioning");


        },

        allEnabledSettings: function () {

            var settings = [
                {type: "header", text: Capriza.translator.getText(Capriza.translator.ids.caching), enabled: Capriza.CacheManager.isHistAllowed},
                {
                    type: "toggle",
                    text: Capriza.translator.getText(Capriza.translator.ids.saveFormText),
                    description: Capriza.translator.getText(Capriza.translator.ids.rememberHistory),
                    isOn: Capriza.CacheManager.isHistEnabled,
                    handler: function (on) {
                        Capriza.CacheManager.setHistEnabledState(on);
                    },
                    enabled: Capriza.CacheManager.isHistAllowed
                },
                {
                    type: "button", text: Capriza.translator.getText(Capriza.translator.ids.clearHistory), handler: function ($btn) {
                        Capriza.Confirmer.confirm({
                            items: [
                                {header: Capriza.translator.getText(Capriza.translator.ids.areYouSureHistory)},
                                {
                                    button: Capriza.translator.getText(Capriza.translator.ids.clearHistory),
                                    iconClass: "icon-trash",
                                    cssClass: "clear-history-confirmer-button",
                                    handler: function () {
                                        $btn.addClass("disabled").find("button").prop({disabled:"disabled"});
                                        Capriza.CacheManager.clearAllHist();
                                    }
                                },
                                {button: Capriza.translator.getText(Capriza.translator.ids.cancel), iconClass: "icon-close"}
                            ]
                        });
                    },
                    enabled: Capriza.CacheManager.isHistAllowed
                }
            ];

            var enabled = settings.filter(function (item) {
                if (typeof item.enabled == "function") {
                    return item.enabled();
                }
                else if (item.enabled === undefined) {
                    return true;
                }
                else {
                    return item.enabled;
                }
            });

            if (enabled.length == 0) {
                return [{type: "header", text: Capriza.translator.getText(Capriza.translator.ids.noSettings)}];
            }

            return enabled;

        },

        populateSettings: function () {
            var self = this;
            var settings = this.allEnabledSettings();
            self.$content.empty();
            var handlers = {
                button: function ($el, item) {
                    $el.find("button").on("click", function (e) {
                        item.handler($el, e);
                    })
                },
                toggle: function ($el, item) {
                    var on = true;
                    if(typeof item.isOn == "function") {
                        on = item.isOn();
                    }
                    else if(item.isOn !== undefined){
                        on = item.isOn;
                    }
                    $el.toggleClass("on", on);

                    $el.on("click", function () {
                        $el.toggleClass("on");
                        item.handler($el.hasClass("on"));
                    })

                }
            };

            settings.forEach(function (item) {
                var $el = $(Handlebars.templates["settings-page-" + item.type](item)).appendTo(self.$content);
                handlers[item.type] && handlers[item.type]($el, item);
            });

        },


        _leave: function () {
            var self = this;
            self.$el.addClass("slideup reverse out");
            self.$el.one("animationend webkitAnimationEnd", function () {
                self.$el.removeClass("slideup reverse out active");
                $(".nonmobile-wrap").removeClass("transitioning");
                self.$settingsPage.remove();
            });
            $(".nonmobile-wrap").addClass("transitioning");


        }
    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/RuntimeParams.js

try{
;(function() {

Capriza.RuntimeParams = function(type) {
	this._type = type;
	this._initListeners();
};

Capriza.RuntimeParams.prototype = {
		get rtParamsKey() {
			var tokenOrId = (window.appData && appData.app && appData.app.master_app_id) || Capriza.getToken();
            return "rtParams-" + this._type + "-" + this._getUserId() + "-" + tokenOrId;
		},
		
		setRTParam : function(key, value) {
			var currentRTParams = EncryptedCache.getItem(this.rtParamsKey) || {};
			var oldRTParamValue = currentRTParams[key];
			currentRTParams[key] = value;
			
			EncryptedCache.setItem(this.rtParamsKey, currentRTParams);

			if (currentRTParams[key] != oldRTParamValue)
				Dispatcher.trigger("runtimeParams/rtParamChanged", [{ key : key, value : currentRTParams[key] }]);
		},
		
		verifyRTParam : function(key, value, equalsCallback) {
			var currentRTParams = EncryptedCache.getItem(this.rtParamsKey) || {};
			if (currentRTParams.hasOwnProperty(key) && (equalsCallback ? !equalsCallback(currentRTParams[key], value) : currentRTParams[key] != value))
				this.clearRTParams([key]);
		},
		
		clearRTParams : function(rtParams) {
			var currentRTParams = EncryptedCache.getItem(this.rtParamsKey) || {}, removedRTParams = [];
			(rtParams || Object.keys(currentRTParams)).forEach(function(rtParamKey) {
				if (currentRTParams.hasOwnProperty(rtParamKey)) {
					delete currentRTParams[rtParamKey];
					removedRTParams.push({ key : rtParamKey, value : null });
				}
			});
			
			if (removedRTParams.length == 0) return;
			
			EncryptedCache.setItem(this.rtParamsKey, currentRTParams);
			Dispatcher.trigger("runtimeParams/rtParamChanged", removedRTParams);
		},
		
		_initListeners : function() {
			var $this = this;
			Dispatcher.on("security/ready", function() {
				var rtParams = EncryptedCache.getItem($this.rtParamsKey);
				Logger.debug("onSecurityReady, has rtParams:" + !!rtParams);
				if (rtParams) // && !Utils.isRunningInBackground()
					Capriza.EngineApi.sendEvent(null, null, null, { type : "rtParams", value : rtParams });
			});
			
			Dispatcher.on("rtParams/invalid", function(data) {
				$this.clearRTParams(data.rtParams);
			});
		},
		
		_getUserId : function() {
			return window.appData && window.appData.user_id || 0;
		}
};

Dispatcher.on("runtimeParams/rtParamChanged", function(data) {
	var rtParamsEventObj = {};
	data.forEach(function(rtParamObj) { rtParamsEventObj[rtParamObj.key] = rtParamObj.value; });
	Capriza.EngineApi.sendEvent(null, null, null, { type : "rtParams", value : rtParamsEventObj });
});

if (!window.EncryptedCache) {
	window.EncryptedCache = {
		setItem : function() {},
		getItem : function() {}
	};
}

})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/CacheManager.js

try{
;(function() {

	var cm =Capriza.CacheManager = {


        _getUserId:function(){
            return window.appData && window.appData.user_id || 0;
        },
		
		get histKey(){
            var tokenOrId = window.appData && appData.app && appData.app.master_app_id || Capriza.getToken();
            return "hist-" + cm._getUserId() + "-" + tokenOrId;
        },
		
        getControlKey:function(model){
            return model.get("cacheData") && model.get("cacheData").key;
        },
		
		getPersonalizedRTParamKey:function(model){
			return (model.get("cacheData") && model.get("cacheData").rtParamKey);
		},

        _exampleHistStorage:{ // key is hist-8-5813 where userId is 8 and masterZapp id is 5813

            disabled:true,
            "mc53":[
                {
                    text:"some item",
                    additionals:[
                        {mcId:"mc66",text:"description of some item"}
                        //...
                    ]
                }
                //...
            ]

        },

        setHistory:function(model, data){
            if(!cm.isHistEnabled()) return;
            
			var controlKey = cm.getControlKey(model);
			if (!controlKey) return;
			
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};
            var currentMc = currentHist[controlKey] || [];
            var newItem;
            var currentItemIndex = -1;
            var currentItem = currentMc.filter(function(itm, idx){
                    if(itm.text == data.text) currentItemIndex = idx; // Assuming we always have one match
                    return itm.text == data.text;
            })[0] || ((newItem = true) && {});


            if(currentItemIndex > -1) currentMc.splice(currentItemIndex, 1);
            if(newItem){
                currentItem = data;
            }
            else if(data.additional){
                currentItem.additional = data.additional;
            }

            currentMc.splice(0, 0, currentItem);
            currentHist[controlKey] = currentMc;

            EncryptedCache.setItem(key, currentHist);
        },

		setPersonalizedRTParam:function(model, text) {
			var controlRTParamKey = cm.getPersonalizedRTParamKey(model);
			if (controlRTParamKey) rtp.setRTParam(controlRTParamKey, text);
		},
		
		verifyPersonalizedRTParam:function(model, text) {
			var controlRTParamKey = cm.getPersonalizedRTParamKey(model);
			if (controlRTParamKey) rtp.verifyRTParam(controlRTParamKey, text, function(oldVal, newVal) { return (oldVal && oldVal.trim()) == (newVal && newVal.trim()); });
		},
		
        getHistory:function(model){
            if(!cm.isHistEnabled()) return [];
            
			var controlKey = cm.getControlKey(model);
			if (!controlKey) return [];
			
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};

            return (currentHist[controlKey] || []).map(function(itm, idx){//TODO: think maybe to put hist flag on save ?
                itm.hist = true;
                itm.histIdx = idx;
                return itm;
            });
        },

        removeHistory:function(model){
            var controlKey = cm.getControlKey(model);
			if (!controlKey) return;
			
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};

            delete currentHist[controlKey];
        },

        removeItemFromHist: function(model, idx){
            var controlKey = cm.getControlKey(model);
			if (!controlKey) return;
			
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};
            if(!currentHist[controlKey] || currentHist[controlKey].length <= idx) return;
            currentHist[controlKey].splice(idx, 1);

			EncryptedCache.setItem(key, currentHist);
        },

        clearAllHist:function(){
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};
            var newHist = {};
            if (currentHist.hasOwnProperty("disabled")) {
                newHist.disabled = currentHist.disabled;
            }
			EncryptedCache.setItem(key, newHist);
			cm.clearPersonalizedRTParams();
            Capriza.Model.Caching.refreshAllCachedControls();
        },
		
		clearPersonalizedRTParams:function(rtParams){
			rtp.clearRTParams(rtParams);
		},

        isHistAllowed:function(){
            return window.appData && appData.config.clientCacheEnable !== false;
        },

        isHistEnabled:function(){
            if(!cm.isHistAllowed()) return false;
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};
            return !currentHist.disabled;
        },

        setHistEnabledState:function(enabled){
            var key  = cm.histKey;
            var currentHist = EncryptedCache.getItem(key) || {};
            currentHist.disabled = !enabled;
			
            EncryptedCache.setItem(key, currentHist);
            Capriza.Model.Caching.refreshAllCachedControls();
        }
    }
	
	var rtp = new Capriza.RuntimeParams("personalized");

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/Confirmer.js

try{
/**
 * Created by omer on 20/7/15.
 */

;(function() {

    Capriza.Confirmer = {

        confirm: function(options) {
            var self = this;
            var $confirmerEl  = $(Handlebars.templates['confirmer'](options));
            this.$confirmShield = Utils.shieldUp("confirmShield",true).css({"background":"rgba(0,0,0,0)","transition":"background-color 0.2s"});
            this.$confirmShield.on("click",function(e){
                self.hideConfirm();
            });
            this.$confirmShield[0].offsetWidth;

            $('.viewport').append($confirmerEl);
            var height = $confirmerEl[0].offsetHeight;
            $confirmerEl.css({transform: "translateY("+(height)+"px)"});

            $confirmerEl.velocity({
                translateY: height
            }, {
                duration: 30,
                easing: 'out',
                complete: function() {
                    $confirmerEl.removeClass('hidden');
                }
            }).bind(this)

                .velocity({
                    translateY: 0
                }, {
                    duration: 250,
                    easing: 'ease-in-out'
                }).bind(this);


            options.items.forEach(function(itm,idx){
                if(itm.button){
                    $(".confirmer-btn"+idx+" button").on("click", function(){
                        itm.handler && itm.handler();
                        self.hideConfirm();
                    })
                }
            });
            this.$confirmShield.css({"background":"rgba(0,0,0,0.4)"});

        },

        hideConfirm: function() {
            var $confirmerEl = $('.confirmer');
            var height = $confirmerEl[0].offsetHeight;

            this.$confirmShield.css({"background":"rgba(0,0,0,0)"});
            $confirmerEl.velocity({
                translateY: height
            }, {
                duration: 250,
                easing: 'out',
                complete: function() {
                    $confirmerEl.remove();
                    Utils.shieldDown("confirmShield");
                }
            })
        }
    }


})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/login/LoginManager.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 1/20/14
 * Time: 12:54 PM
 * To change this template use File | Settings | File Templates.
 */

;(function() {

    Capriza.LoginManager = {

        credentialsSavedForHosts: {}, //holds the hosts we have credentials for. key(host)-value(true/false)
        credentialsSavedForContexts: {}, //holds the login context ids we have credentials for.
        loggedInHosts: {}, //holds the hosts relevant for login (pending or logged-in). true = logged in, false = pending.
        loggedInContexts: {}, //holds the context ids relevant for login (pending or logged-in). true = logged in, false = pending.
        autoLoginPerformed: undefined, //holds the context of the last auto-login that was performed, or nothing/false if no auto login was performed.
        firstLoginCtx: undefined,
        sendMsgHandler: undefined,
        messagesForBulk: [], //holds the messages to be sent as bulk in the background run

        LOGIN_VERSION: 4,

        credentialsTypes:{
            IDENTITY_KEYS: "identityKeys", //mobile controls
            LOGIN1_KEYS:"login1Keys" //username1, 2, 3, password (used for NTLM)
        },

        _getUserId:function(){
           return window.appData && window.appData.user_id || 0;
        },

        _getIdentityLocalStorageKey: function(host){
            var l4Prefix ="identity" + this.LOGIN_VERSION + "-",
                user_Id = this._getUserId();

            //Login 4 keys
            return l4Prefix + user_Id + "-" + host
        },

        _writeCredentialsToLocalStorageKey: function(credentials, localStorageKey) {
            var val = JSON.stringify(credentials);
            var encrypted = GibberishAES.enc(val, window.EncryptedCache.xkcd);

            ClientCache.setItem(localStorageKey, encrypted);
        },

        _saveCredentialsOnLocalStorageKey: function(credByHost, credentialsType, localStorageKey) {
            var creds = this._getSpecificSavedCredentials(localStorageKey) || { loginVersion:this.LOGIN_VERSION };

            //in case it is taken from an old key we need to discard old structure and recreate it for new key (will not impact older zapps on same device)
            if(creds.loginVersion != this.LOGIN_VERSION) creds = {loginVersion:this.LOGIN_VERSION};
            if(!creds[credentialsType]) creds[credentialsType] = {};


            creds[credentialsType] = $.extend(true, {}, creds[credentialsType], credByHost);

            this._writeCredentialsToLocalStorageKey(creds, localStorageKey);
        },

        saveCredentialsForType: function(credentials, credentialsType, host) {
            var key = this._getIdentityLocalStorageKey(host), credByHost = {};
            credByHost[host] = credentials;
            this._saveCredentialsOnLocalStorageKey(credByHost, credentialsType, key);
            Capriza.LoginManager.credentialsSavedForHosts[host] = true;
        },

        _exampleCredentials: {
            loginVersion:4,
            identityKeys:{
                "hostname1":{
                    "key1":{},//Some mc model
                    "key2":{},//Some mc model
                    "key3":{}//Some mc model
                },
                "hostname2":{
                    //.....
                }
            },
            login1Keys:{
                "hostname1":{username:"aaa",password:"sdfsd",additionalExampleLogin2Field:"..."},
                "hostname2":{username:"afgbfaa",password:"nytt",additionalOtherExampleLogin2Field:"..."}
            }
        },

        clearCredentials: function(){
            Capriza.LoginManager.credentialsSavedForHosts && Object.keys(Capriza.LoginManager.credentialsSavedForHosts).forEach(Capriza.LoginManager.clearCredentialsForHost);
        },

        clearCredentialsForHost: function(host){
            var key = Capriza.LoginManager._getIdentityLocalStorageKey(host);//, credByHost ={};
            Capriza.LoginManager.credentialsSavedForHosts[host] = false;
            ClientCache.removeItem(key);
        },

        _decryptCredentials:function(identity, localStorageKey){
            var decrypted;
            if (identity) {
                try {
                    decrypted = GibberishAES.dec(identity, window.EncryptedCache.xkcd);
                    decrypted = JSON.parse(decrypted);
                } catch (ex) {
                    decrypted = undefined;
                    var hash_xkcd = "no MBOOT Security";
                    if (typeof MBOOT !== 'undefined' && MBOOT.Security.ec){
                        hash_xkcd = MBOOT.Security.ec.hash().update(window.EncryptedCache.xkcd).digest('hex');
                    }
                    logger.error("failed to decrypt identity data from local storage key: " + localStorageKey + ", hash(xkcd): " + hash_xkcd , ex, "login");
                }
            }
            return decrypted;
        },

        _getSpecificSavedCredentials:function(localStorageKey){
            var identity, decrypted;
            identity = ClientCache.getItem(localStorageKey);
            decrypted = this._decryptCredentials(identity, localStorageKey);
            return decrypted;
        },

        isLoginRequired: function(){
            //if there are no hosts and no login contexts -> no login required.
            var loginRequiredInTheZapp = Object.keys(Capriza.LoginManager.loggedInHosts).length > 0 || Object.keys(Capriza.LoginManager.loggedInContexts).length > 0;
            return loginRequiredInTheZapp;
        },

        isLoginPending: function(){
            return !!(Capriza.LoginManager.getHostPendingLogin() || Capriza.LoginManager.getContextPendingLogin());
        },

        getHostPendingLogin: function(){
            return Utils.findKey(Capriza.LoginManager.loggedInHosts, function (loggedInHost) { return !loggedInHost });
        },

        getContextPendingLogin: function(){
            return Utils.findKey(Capriza.LoginManager.loggedInContexts, function (loggedInContext) { return !loggedInContext });
        },

        // overrides in designer (Designer.js)
        shouldPerformAutoLogin: function () {
            return true;
        },
        shouldSaveLoginPageCredentialsModel: function () {
            return true;
        },

        getSavedCredentialsForType: function (credentialsType, host) {
            var key = this._getIdentityLocalStorageKey(host),
                identity = ClientCache.getItem(key),
                decrypted = this._decryptCredentials(identity, key);

            if(decrypted && decrypted.loginVersion == this.LOGIN_VERSION){
                decrypted = decrypted[credentialsType];
                if(decrypted) decrypted = decrypted[host];
                if(decrypted) decrypted.loginVersion = this.LOGIN_VERSION;
            }

            return decrypted;
        },

        logOut: function(clearCredentials, reload){
            if (typeof clearCredentials === "undefined") {
                clearCredentials = true;
            }
            if (typeof reload === "undefined") {
                reload = true;
            }

            var authorizationCookiesMgr = typeof MBOOT === 'undefined' ? Capriza.AuthorizationCookiesMgr : MBOOT.AuthorizationCookiesMgr;
            authorizationCookiesMgr.clearCookies(); //todo: clear only the zapp specific cookies and not all
            if (clearCredentials) {
                Capriza.LoginManager.clearCredentials();
            }

            if (!reload) return;

            var msg = Capriza.translator.getText("signingOut");
            if (Capriza.cordova) {
                setTimeout(function () { Utils.reload(msg)}, 4000);
                Dispatcher.on('identity/host/logout/dataRemoved', function () { Utils.reload(msg) });
            }
            else Utils.reload(msg);
        },


        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        BUTTON_IDENTITY_KEY : "login_submit_button",
        CHECKBOX_IDENTITY_KEY : "login_save_credentials_checkbox",

        credentialsSavingAllowed:function(page){
            if (Capriza.LoginManager.loginPageView && Capriza.LoginManager.loginPageView.model.get("contextId") == page.get("contextId")){
                return Capriza.LoginManager.loginPageView._isSaveCredentialsChecked();
            } //else
            return !!page.getModelForIK(this.CHECKBOX_IDENTITY_KEY);
        },

        _verifySignOutVisibility: function(page){

            if(!Capriza.LoginManager.firstLoginCtx){
                Capriza.LoginManager.firstLoginCtx = page.get('contextId');
            }
            if(Capriza.LoginManager.firstLoginCtx == page.get('contextId')){
                Dispatcher.trigger("identity/removeSignOut");
            }else{
                Dispatcher.trigger("identity/addSignOut");
            }
        },

        renderLoginPageIfNeeded: function(loginPageModel){
            if(loginPageModel.shouldNotRender || !Capriza.Connection.isOnline) return;
            if ($('.context-page.active').length > 0 && !Utils.isCachedMVPShown()) return;
            Capriza.LoginManager.showLoginPage(loginPageModel, 'none');
            loginPageModel.shouldNotRender = true;
        },

        tryToPerformAutoLogin:function(page, transition){

            Logger.debug('[LOGIN] tryToPerformAutoLogin');
            var host = page.get('host'), autoLoginPerformed = false, self = this;

            function showAuthenticatingMsg(msg) {
                if (Capriza.splashing) {
                    Capriza.splashRenderAuthMessage && Capriza.splashRenderAuthMessage(msg /*+host(pagesCount > 1 ? "Page "+pagesCount : "")*/, {fontColor: '#000000', isError: false});
                    Dispatcher.trigger('splash/setTimeout');
                }
                else if(!Utils.isCachedBlueprintShown()){
                    Utils.showMessage(msg, 4000);//TODO: it is hidden by loading
                }
            }

            if (this.credentialsSavingAllowed(page)) {
                this.sendMsgHandler = this.sendMsgHandler || function(message){
                        Logger.debug('[LoginManager] auto login sendMsgHandler started - saving message: ' + message.responseType);
                        Capriza.LoginManager.addMessageForBulk(message);
                    };
                //We store all messages that were sent (we record login messages)
                Logger.debug('registering to sendMessages event for auto login');
                Dispatcher.off("sendMessage" , this.sendMsgHandler);
                Dispatcher.on("sendMessage" , this.sendMsgHandler);
            }


            self._verifySignOutVisibility(page);

            /////////////////////////////////////////
            var isSSO = Capriza.LoginManager.isPageSSO(page);
            var firstTry = !this.credentialsSavedForHosts[host];
            Capriza.LoginManager.loggedInHosts[host] = false;
            Capriza.LoginManager.loggedInContexts[page.get("contextId")] = false;
            Capriza.LoginManager.credentialsSavedForHosts[host] = false;
            Capriza.LoginManager.credentialsSavedForContexts[page.get("contextId")] = false;

            if(isSSO){
                //remove checkbox from model
                var checkboxModel = page.getModelForIK(self.CHECKBOX_IDENTITY_KEY);
                if(checkboxModel){
                    checkboxModel.removeFromParent();
                    delete page._identityKeysToModel[self.CHECKBOX_IDENTITY_KEY];
                }

                if(firstTry) {
                    Logger.debug('tying airwatch sso');
                    Capriza.Capp.mdm.getSsoCredentials(
                        function success(awData) {
                            Logger.debug("recieved airwatch SSO credentials");
                            var SSOLoginModel = {
                                AWSSO: true,
                                username: {
                                    type: "textbox",
                                    text: awData.username
                                },
                                password: {
                                    type: "passwordbox",
                                    text: awData.password
                                }
                            };
                            showAuthenticatingMsg(Capriza.translator.getText(Capriza.translator.ids.authenticating));
                            self.performAutoLogin(SSOLoginModel, page);
                        },
                        function failure() {
                            Logger.warn("[LoginManager] failed to get airwatch SSO credentials");
                        });

                    autoLoginPerformed = true;
                }
            }

            if(!isSSO) {//not used SSO
                var loginModel = this.getSavedCredentialsForType(this.credentialsTypes.IDENTITY_KEYS ,host);
                if (loginModel && this.credentialsSavingAllowed(page)) {

                    showAuthenticatingMsg(Capriza.translator.getText(Capriza.translator.ids.authenticating));
                    autoLoginPerformed = this.performAutoLogin(loginModel, page);
                }
                else {
                    Logger.debug('[LoginManager] Not doing auto login');
                }
            }

            if(autoLoginPerformed){
                //!!! if we return a true, then the page will not be rendered and we need to handle events correctly.
                var render = function(){ Capriza.LoginManager.renderLoginPageIfNeeded(page); }
                Dispatcher.off("application/dialog/before", render);
                Dispatcher.once("application/dialog/before", render);
                Capriza.LoginManager.setAuthenticationTimeout(page);
            }
            else{
                page.shouldNotRender = true;
            }
            Capriza.LoginManager.autoLoginPerformed = autoLoginPerformed ? page.get("contextId") : false;
            return autoLoginPerformed;
        },

        performAutoLogin: function(loginModel, page) {
            var self = this,
                valuesPopulated = false,
                host = page.get('host');
            var identityKeys = page.getIdentityKeys();

            function setTextToModel(model, text){
                model.set('text', text);
                model.api.setText({value: text, auto: true});
                valuesPopulated = true;
            }

            function setPasswordToModel(model, text){
                model.set('text', text);
                model.api.setText({
                    value: text,
                    encrypt: true,
                    auto: true
                });
                valuesPopulated = true;
            }

            function setSelectedIndexToModel(model,selectedIndex){
                model.api.setSelectedIndex({value: selectedIndex, auto: true});
                model.set("selectedIndex", selectedIndex);
                valuesPopulated = true;
            }

            function populateFieldFromModel(model, saved){
                switch(model.get("type")){
                    case "textbox":
                    case "combobox":
                        setTextToModel(model,saved.text);
                        break;
                    case "passwordbox":{
                        setPasswordToModel(model, saved.text);
                        break;
                    }
                    case "listbox": {
                        setSelectedIndexToModel(model,saved.selectedIndex);
                        break;
                    }
                }
            }

            function populateField(model, val){
                switch(model.get("type")){
                    case "textbox":
                        setTextToModel(model, val);
                        break;
                    case "passwordbox":{
                        setPasswordToModel(model, val);
                        break;
                    }
                    case "listbox": {
                        setSelectedIndexToModel(model, val);
                        break;
                    }
                }
            }

            function populateLogin4Model(savedCred){
                var allPopulated =
                    identityKeys.every(function(ikey){
                        if(ikey == self.BUTTON_IDENTITY_KEY || ikey == self.CHECKBOX_IDENTITY_KEY) return true;
                        var model = page.getModelForIK(ikey),
                            saved = savedCred[ikey];
                        if(!model || !saved){
                            return false;
                        }
                        populateFieldFromModel(model, saved);
                        return true;
                    });
                return allPopulated;
            }

            if(loginModel.AWSSO || loginModel.loginVersion == this.LOGIN_VERSION){//SSO || V4
                valuesPopulated = populateLogin4Model(loginModel);
            }
            else if(identityKeys.length > 0 && _.filter(identityKeys,function(k){return k=="username"}).length > 0  && loginModel["username"] && (typeof loginModel["username"] === "string") ){
                //for login1 (backward) compatibility
                _.each(identityKeys,function(ikey){
                    if(ikey == self.BUTTON_IDENTITY_KEY || ikey == self.CHECKBOX_IDENTITY_KEY) return;
                    var model = page.getModelForIK(ikey),
                        val = loginModel[ikey];
                    if(model && val){
                        populateField(model, val);
                    }
                });
            }

            if(valuesPopulated &&
                page.getModelForIK(self.BUTTON_IDENTITY_KEY) &&
                Capriza.LoginManager.shouldPerformAutoLogin() &&
                !this.credentialsSavedForHosts[host] ) {

                Dispatcher.trigger("login/autoLogin/start", page.get('contextId'));

                page.getModelForIK(self.BUTTON_IDENTITY_KEY).api.click({value: '', auto: true});

                this.credentialsSavedForHosts[host] = true;
                this.credentialsSavedForContexts[page.get("contextId")] = true;
                Logger.tag("autoLoginPerformed");
                return true;
            }
            else {
                Logger.debug('Not performing auto login. valuesPopulated: '+valuesPopulated+
                    ' page.getModelForIK(self.BUTTON_IDENTITY_KEY): '+JSON.stringify(page.getModelForIK(self.BUTTON_IDENTITY_KEY)));
            }

            return false;
        },

        showLoginPage: function(page, transition){
            Capriza.LoginManager.loginPageView && Capriza.LoginManager.loginPageView.destroy();
            Capriza.LoginManager.loginPageView = new Capriza.Views.LoginPage({model:page}).render();
            Capriza.LoginManager.loginPageView.show({ transition: transition });
        },

        autoLoginFailed: function(page){
            Capriza.LoginManager.showLoginPage(page, "none");
            Capriza.LoginManager.autoLoginPerformed = false;

            var loginContextId = page && page.get('contextId');
            if (loginContextId) {
                Dispatcher.trigger("login/autoLogin/failed", loginContextId);
            }
        },

        loginSuccess: function(){
            if (Capriza.LoginManager.autoLoginPerformed)
                Capriza.LoginManager.autoLoginSuccess();
            else
                Capriza.LoginManager.manualLoginSuccess();
        },

        manualLoginSuccess: function(){
            Logger.info("[LoginManager] login success!");
            Dispatcher.trigger("identity/addSignOut");

            var pendingHost = Utils.findKey(Capriza.LoginManager.loggedInHosts, function(loggedInHost){return !loggedInHost}),
                pendingCtx = Utils.findKey(Capriza.LoginManager.loggedInContexts, function(loggedInCtx){return !loggedInCtx}),
                pendingPage = Capriza.Model.PageDB[pendingCtx];

            if (pendingHost) Capriza.LoginManager.loggedInHosts[pendingHost] = true;

            if (pendingCtx) {
                Capriza.LoginManager.loggedInContexts[pendingCtx] = true;
                if (pendingHost) Capriza.LoginManager.credentialsSavedForHosts[pendingHost] = false;
                Capriza.LoginManager.credentialsSavedForContexts[pendingCtx] = false;

                //Probably successful login! (can/might be a separate error page or reset password)
                if (Capriza.LoginManager.credentialsSavingAllowed(pendingPage)) {
                    Logger.debug("[LoginManager] saving credentials is allowed, saving credentials.");
                    Capriza.LoginManager.saveLoginPageCredentialsModel(pendingPage);
                }
                else Logger.debug("[LoginManager] saving credentials is not allowed, NOT saving credentials.");
            }

            Logger.debug("[LoginManager] setting host " + pendingHost + (pendingCtx ? (", and ctx " + pendingCtx) : "") + " as logged in");
            Capriza.LoginManager.autoLoginPerformed = undefined; // clear the auto login flag
        },

        autoLoginSuccess: function(){
            Logger.info("[LoginManager] auto-login success!");
            var pendingPageCtxId = Utils.findKey(Capriza.LoginManager.loggedInContexts, function(loggedIntoCtx){return !loggedIntoCtx}),
                pendingPage = Capriza.Model.PageDB[pendingPageCtxId];
            Logger.debug("[LoginManager] setting page ctxId " + pendingPageCtxId + " as successfull login");
            pendingPage.shouldNotRender = true;
            Capriza.LoginManager.manualLoginSuccess();
            if(!Capriza.LoginManager.credentialsSavingAllowed(pendingPage) && Capriza.LoginManager.isPageSSO(pendingPage)){
                Logger.debug("[LoginManager] (sso) credentials were saved to file");
                Capriza.LoginManager.writeCredentialsToFile();
            }

            Dispatcher.trigger("login/autoLogin/succeed", pendingPageCtxId);
        },

        isPageSSO: function(page){
            var inAWWrapper = !!Capriza.Capp && !!Capriza.Capp.mdm && !!Capriza.Capp.mdm.getSsoCredentials;
            var identityKeysAreDefault = !!page.getModelForIK("username") && !!page.getModelForIK("password");
            var AWEnabledAndSSOEnabled = window.appData && window.appData.uapp_org_mdm == "airwatch" && window.appData.config && !window.appData.config.disableAirwatchSSO;
            var isSSO = Capriza.device.ios && inAWWrapper && identityKeysAreDefault && AWEnabledAndSSOEnabled;

            return isSSO;
        },

        setAuthenticationTimeout: function(page){
            var config = window.appData && window.appData.config;
            var authenticatingTimeout = (config && config.displayAuthenticatingTimeout) || 60000;

            if(!Utils.isCachedBlueprintShown()) {
                var timer = setTimeout(function () {
                    !page.shouldNotRender && Logger.warn("Authenticating message left on for over " + authenticatingTimeout + "ms, might be due to incorrect zap configuration. (failure scenario needs to be recorded in login page.)");
                    Capriza.LoginManager.renderLoginPageIfNeeded(page);
                }, authenticatingTimeout);

                Dispatcher.once("loading/automationMessage", function () {
                    clearTimeout(timer);
                });
            }
        },

        ///////////////////////////////

        getLoginModelToStore: function(page){
            var self = this;
            var loginModelToStore = {};
            var identityKeys = page.getIdentityKeys();
            if(identityKeys.length > 0){
                identityKeys.forEach(function(ikey){
                    if(ikey == self.BUTTON_IDENTITY_KEY || ikey == self.CHECKBOX_IDENTITY_KEY) return;
                    loginModelToStore[ikey] = page.getModelForIK(ikey).toJSON();

                });
            }

            return loginModelToStore
        },

        validCredentials:function(page){
            return page.getIdentityKeys().some(function(ik){
                var model = page.getModelForIK(ik);
                return (model.get("type") == "textbox" || model.get("type") == "passwordbox") && model.get("text") && model.get("text").length > 0;
            });
        },

        writeCredentialsToFile: function () {
            Logger.debug('[LoginManager] writeCredentialsToFile started. bulk message collection length: ' + Capriza.LoginManager.messagesForBulk.length);

            if (Capriza.LoginManager.messagesForBulk.length == 0) {
                Logger.debug("[LoginManager] writeCredentialsToFile aborted! no messages for bulk to write");
                return;
            }

            var pendingContext = Capriza.LoginManager.getContextPendingLogin();
            if (pendingContext) {
                Logger.debug("[LoginManager] writeCredentialsToFile aborted! Context " + pendingContext + " is pending login, waiting for more message before writing to file");
                return;
            }

            Logger.debug('unregistering messages');
            Dispatcher.off("sendMessage", this.sendMsgHandler);

            var entireMessage = {type: "bulk", messages: Capriza.LoginManager.messagesForBulk};
            var encrypted = GibberishAES.enc(JSON.stringify(entireMessage), window.EncryptedCache.xkcd);
            var hosts = _.reduce(Capriza.LoginManager.credentialsSavedForHosts, function(savedHosts, credentialsSavedForHost, host){
                savedHosts = savedHosts || [];
                if (credentialsSavedForHost) savedHosts.push(host);
                return savedHosts;
            }, []);

            Logger.debug("[LoginManager] writeCredentialsToFile - writing hosts: " + hosts);

            Dispatcher.trigger('login/success', {encryptedLoginMessages: encrypted, hosts: hosts});

        },

        saveLoginPageCredentialsModel:function(page){
            if (!this.shouldSaveLoginPageCredentialsModel()) return;
            var host = page.get('host');
            if(!this.validCredentials(page))return;
            Logger.debug("[LoginManager] saveLoginPageCredentialsModel: credentials are valid");
            Capriza.LoginManager.credentialsSavedForContexts[page.get("contextId")] = true;
            var loginModelToStore = this.getLoginModelToStore(page);
            this.saveCredentialsForType(loginModelToStore, Capriza.LoginManager.credentialsTypes.IDENTITY_KEYS, host);

            if (Capriza.LoginManager.messagesForBulk.length > 0) {
                this.writeCredentialsToFile();
            }
            else {
                Logger.error('failed to write login msgs from auto-login');
            }
        },

        clearLoginState: function () {
            Capriza.LoginManager.loggedInHosts = {};
            Capriza.LoginManager.loggedInContexts = {};
            Capriza.LoginManager.autoLoginPerformed = false;
            Capriza.LoginManager.credentialsSavedForHosts = {};
            Capriza.LoginManager.credentialsSavedForContexts = {};

        },

        addMessageForBulk: function(message){
            Capriza.LoginManager.messagesForBulk.push (message);
        }
    };

    Dispatcher.on ("mobile/login/success", Capriza.LoginManager.loginSuccess);
    Dispatcher.on ("login/auto/failed", Capriza.LoginManager.autoLoginFailed);
    Dispatcher.on("identity/host/logout", Capriza.LoginManager.logOut);
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/login/LoginPage.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 1/20/14
 * Time: 12:22 PM
 * To change this template use File | Settings | File Templates.
 */
;(function() {

    Capriza.Views.LoginPage = Capriza.Views.ContextPage.extend({

        initialize: function() {

            Capriza.Views.ContextPage.prototype.initialize.apply(this, arguments);

            var self = this;

            this.model.on("page/controlModified", function(controlId) {
                var view = self.getView(controlId);
                if(view.model.get("identityKey")){
                    view.$el.attr("data-identitykey",view.model.get("identityKey"));
                }
            });

        },

        getIKView: function(ik){
            var model = this.model.getModelForIK(ik);
            var id = model && model.get("id");
            return id && this.getView(id);
        },

        getFilteredKeys:function(){
            var identityKeys = this.model.getIdentityKeys();
            var ret = {};
            identityKeys.forEach(function(ikey){
                if(ikey != Capriza.LoginManager.BUTTON_IDENTITY_KEY && ikey != Capriza.LoginManager.CHECKBOX_IDENTITY_KEY){
                    ret[ikey] = ikey;
                }
            });
            return ret;
        },

        _isSaveCredentialsChecked: function(){
            return this.getIKView(Capriza.LoginManager.CHECKBOX_IDENTITY_KEY) && this.getIKView(Capriza.LoginManager.CHECKBOX_IDENTITY_KEY).getChecked();
        },

        _setSaveCredentialsChecked: function(val){
            var IKView = this.getIKView(Capriza.LoginManager.CHECKBOX_IDENTITY_KEY);

            if (IKView) {
                IKView.setChecked(!!val);
                IKView.model.set("checked", !!val);
            }
        },


        _render: function() {
            Logger.debug('rendering login page');
            Capriza.Views.ContextPage.prototype._render.apply(this, arguments);

            var host = this.model.get('host');
            var self = this;
            var IKView = this.getIKView(Capriza.LoginManager.CHECKBOX_IDENTITY_KEY);


            if(IKView){

                var config = window.appData && window.appData.config;
                if (!config || config && !config.dontSaveCredentialsByDefault){
                    this._setSaveCredentialsChecked(true);
                }
            }



            $('input[type="password"]', this.$el).on('keypress', function(e) {
                if (e.which === 13) {
                    $(this).blur();
                    self.getIKView(Capriza.LoginManager.BUTTON_IDENTITY_KEY) && self.getIKView(Capriza.LoginManager.BUTTON_IDENTITY_KEY).model.api.click();
                }
            });

            self.model.getIdentityKeys().forEach(function(ikey){
                //var view = self.getIKView(ikey);
                //var $elm = view && view.$el;
                //$elm && $elm.attr("data-identitykey",ikey);
                self.getIKView(ikey).$el.attr("data-identitykey",ikey);
            });

            if(self.getIKView(Capriza.LoginManager.BUTTON_IDENTITY_KEY) && self.getIKView(Capriza.LoginManager.BUTTON_IDENTITY_KEY).$el.hasClass("identity-demo-submit-btn")) {
                //seek attention
                setTimeout(function () {
                    $(".identity-demo-submit-btn", self.$el).toggleClass("animated tada")
                }, 2000);
                clearInterval(this.attentionSeekInterval);
                this.attentionSeekInterval = setInterval(function () {
                    $(".identity-demo-submit-btn", self.$el).toggleClass("animated tada")
                }, 4000);
            }

            //set the first context as the login only when rendering the page (auto-login is not the first context the user sees)
            this.model.verifyLoginAsFirstContext && this.model.verifyLoginAsFirstContext();

            Capriza.LoginManager.loginPageView = this;

        }

    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/EngineApi.js

try{
;
(function () {
    Capriza.EngineApi = {

        holdMessages:false,
        unsyncedMessages:false,
        messages : [],

        Actions: {
            textbox: ["setText", "submit"],

            autocomplete: ["setText", "blur", "selectItem"],

            button: ["click"],

            bubble: ["click"],

            clickAction: ["click"],

            checkbox: ["setChecked"],

            combobox: ["setText", "openPopup", "selectMenuItem", "closePopup"],

            content: ["clickInternalLink"],

            calendarInput: ["setDates", "nextMonth", "prevMonth"],

            datepickerInput: ["setDate"],

            calendarButton: ["setDates", "nextMonth", "prevMonth"],

            datepickerButton: ["setDate"],

            file: ["setFile"],

            group: ["next", "previous", "setPage", "getMoreItems", "doAction", "setIsSelected"],

            groupSelector: ["setIsSelected"],

            image_link: ["click"],

            link: ["click"],

            listbox: ["setSelectedIndex"],
            listboxmulti: ["setSelectedIndex"],

            radiogroup: ["setSelectedIndex"],

            lookup: ["setText", "openList"],

            menu: ["selectMenuItem"],

            popup: ["openPopup", "closePopup", "selectMenuItem"],

            record: ["setIsSelected", "doAction"],

            "image-with-2-text-group": ["setIsSelected", "doAction"],

            action: ["click"],

            onoffswitch3: ["setOn", "setOff"],

            "list-tree": ["fetchBranch", "setSelectedItem"]
        },

        sendEvent: function (contextId, controlId, action, data) {
            var event  =  {
                type: "mcAction",
                controlId: controlId,
                contextId: contextId,
                action: action
            };

            var mobileEvent = _.clone(event);
            _.extend(event, data);

            if(data.encrypt) {
                data.value = "******";
            }

            Logger.debug("sending event "+JSON.stringify(_.extend(mobileEvent, data)));

            Dispatcher.trigger('sendMessage', event, event.controlId);
            Capriza.pageTimer = Date.now();

            if(Capriza.EngineApi.unsyncedMessages && event.type == "mcAction" && !event.auto){//TODO: ignore some messages types like snapshot
                pageManager.addMobId(event);
                var model = Capriza.Model.Control.getById(controlId);
                var etaActions = model.get("eta"), etaAction = etaActions && etaActions[event.action], isETABlocking = etaAction && etaAction.blocking;

                if(model.get("detachMode") && isETABlocking){
                    event.ackRequired = true;
                    var msg = { type: "progress" };
                    Utils.showUnimessage(msg, true, true, !etaAction.maxAutomations);

                    // Capriza.Toast.show({textMajor: Capriza.translator.getText(Capriza.translator.ids.waitingFor) + domain + "...",
                    //     toastIconClass: "rotating icon-loading", blockUI:true});
                    Capriza.EngineApi.messages.blockingMsg = {
                        msgId:      event.msgId,
                        controlId:  controlId,
                        action:     action
                    };

                    function ackRecieved(data){
                        if(!Capriza.EngineApi.messages.blockingMsg || extractIdNumber(data.msgId) <= extractIdNumber(Capriza.EngineApi.messages.blockingMsg.msgId)) return;
                        if(Utils.isUnimessageShown()){
                            // if(Capriza.Toast.isBlocking()){
                            if (Utils.isBlockingUnimessage) {
                                var blockingMsg = Capriza.EngineApi.messages.blockingMsg ;
                                var control = Capriza.Model.ControlDB[blockingMsg.controlId];
                                var etaActions = control.get("eta"), etaAction = etaActions && etaActions[blockingMsg.action];
                                etaLoadingState = { msgId : blockingMsg.msgId, blocking : etaAction.blocking };
                                if(etaAction){
                                    var loadingStopBlocking = function(){
                                        Utils.unblockUnimessage();
                                        // Capriza.Toast.unblock();
                                    };
                                    var loadingStop = function(){
                                        // Capriza.Toast.hide();
                                        Utils.hideUnimessages();
                                        Dispatcher.off("loading/stopBlocking", loadingStopBlocking);
                                        Dispatcher.off("loading/stop", loadingStop);
                                    };
                                    if(etaAction.blocking){
                                        // Stay Blocking
                                        Dispatcher.once("loading/stopBlocking", loadingStopBlocking);
                                    }
                                    else if(etaAction.nonBlocking){
                                        Utils.unblockUnimessage();
                                        // Capriza.Toast.unblock();
                                    }
                                    else { // No eta
                                        // Capriza.Toast.hide();
                                        Utils.hideUnimessages();
                                    }

                                    if(etaAction.nonBlocking || etaAction.blocking){
                                        Dispatcher.on("loading/stop", loadingStop);
                                    }
                                }
                                else { // No eta
                                    // Capriza.Toast.hide();
                                    Utils.hideUnimessages();
                                }
                            }
                            else{
                                // Capriza.Toast.hide();
                                Utils.hideUnimessages();
                            }
                        }
                        Capriza.EngineApi.messages.blockingMsg = undefined;
                        Dispatcher.off("message/ack", ackRecieved);
                    }

                    Dispatcher.on("message/ack", ackRecieved);
                }

				event.deferred = true;
                if (Capriza.EngineApi.canSendMessages)
					pageManager.triggerEvent(event);
				else
                    Capriza.EngineApi.messages.push(event);
            }
            else {
                pageManager.triggerEvent(event); // TODO(amit): move pageManager.triggerEvent to EngineApi.sendEvent after versioning task ends
                etaHandler.apply(this, [event.msgId].concat(Array.prototype.slice.call(arguments)));
            }
        }
    };

    Capriza.EngineApi.Actions.list = Capriza.EngineApi.Actions.group;
    Capriza.EngineApi.Actions.table = Capriza.EngineApi.Actions.group;
    Capriza.EngineApi.Actions.tabular = Capriza.EngineApi.Actions.group;
    Capriza.EngineApi.Actions.table2 = Capriza.EngineApi.Actions.group;
    Capriza.EngineApi.Actions.passwordbox = Capriza.EngineApi.Actions.textbox;

    function etaHandler(msgId, contextId, controlId, action, data) {
        var control = Capriza.Model.ControlDB[controlId];
        if (!control) return;

        var etaActions = control.get("eta"), etaAction = etaActions && etaActions[action];
		if (!etaAction) return;

        etaLoadingState = {};
		if (etaAction.blocking === true || etaAction.nonBlocking === true) {
            etaLoadingState = { msgId : msgId, blocking : etaAction.blocking };
			if (etaAction.blocking) {
				Logger.debug("ETA Handler showing blocking loading");
                Utils.loadStartTimer && clearTimeout(Utils.loadStartTimer);
                Utils.loadStartTimer = setTimeout(function() { Dispatcher.trigger("loading/start", {waitForNewPage: etaAction.waitForNewPage, maxAutomations: etaAction.maxAutomations}); }, 0);
				$.capriza.showLoadingMsg(undefined, { duration : null });
			} else if (etaAction.nonBlocking) {
				Logger.debug("ETA Handler showing non blocking loading");
//				$.capriza.showLoadingMsg(true, { duration : null });
                Utils.loadStartTimer && clearTimeout(Utils.loadStartTimer);
                Utils.loadStartTimer = setTimeout(function() { Dispatcher.trigger("loading/start", {nonBlocking: true, waitForNewPage: etaAction.waitForNewPage, maxAutomations: etaAction.maxAutomations}); }, 0);
			}
		}
    }

    function extractIdNumber(msgId) {
        msgId = /mob(-?\d+)/.exec(msgId || "");
        return Number((msgId && msgId[1]) || undefined);
    }

	Dispatcher.on("engine/message", function(response) {


        if(Utils.isCachedBlueprintShown() && response.structure && response.structure[0].login) return;
        if(Capriza.EngineApi.messages.blockingMsg) return;
		if (response.resultType === 'loading' || response.resultType === 'snapshot' || response.resultType === 'dataStoreWrite'|| response.resultType === 'tiles' || response.stopBlocking === false) return;

		var responseId = extractIdNumber(response.effectiveMobileMsgId), loadingStateId = extractIdNumber(etaLoadingState.msgId);
		if (isNaN(responseId) || isNaN(loadingStateId) || loadingStateId <= responseId) {
			Logger.debug("engine message --> hide loading and stop blocking, loadingStateId:" + loadingStateId + " responseId:" + responseId);
			Dispatcher.trigger("loading/stop");
			$.capriza.hideLoadingMsg();
            Utils.hideUnimessages();
		} else if (!etaLoadingState.blocking) {
			Logger.debug("engine message --> stop blocking");
			Dispatcher.trigger("loading/stopBlocking");
            Utils.unblockUnimessage();
		}
	});

    Dispatcher.on("engineApi/unsyncedMessages", function(value){
        Capriza.EngineApi.unsyncedMessages = value;
    });

	Capriza.EngineApi.canSendMessages = false;
    Dispatcher.on("security/ready", function(){
        ////Login with bulk for time saving
        //var loginBulk = Capriza.LoginManager.getLoginMessages();
        //if(loginBulk) {
        //    pageManager.triggerEvent(SharedUtils.getBulkMsg(loginBulk.messages.map(function(msg){
        //        return pageManager.addMobId(msg)
        //    })));
        //    Capriza.LoginManager.loginBulkSent = true
        //}

        Capriza.EngineApi.canSendMessages = true;
        if(Capriza.EngineApi.messages.length > 0) {
            Capriza.EngineApi.messages.forEach(function(msg){ pageManager.triggerEvent(msg); });
            Capriza.EngineApi.messages = [];
        }
    });


    etaLoadingState = {};

//    performance monitoring

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/Control.js

try{
(function() {

    if (!Capriza.Model) {
        Capriza.Model = {};
    }


    var ApiImpl = {
        getImpl: function(model) {
            var impl = ApiImpl[model.get("type")];
            if (impl) return new ApiImpl[model.get("type")](model);
        }
    };

    function createApiImpl(type) {
        ApiImpl[type] = function(model) {
            this.model = model;
        };

        _.each(Capriza.EngineApi.Actions[type], function(action) {
            ApiImpl[type].prototype[action] = function(value) {
                var controlId = this.model.get("id");

                if (this.model.get("isPhantom")) {
                    Logger.info("Not sending event for phantom: " + controlId);
                    return;
                }

                var data = (_.isObject(value) && value.hasOwnProperty("value")) ? value : { value: value };
                Capriza.EngineApi.sendEvent(this.model.getContextId(), controlId, action, data);

            };
        });
    }

    Object.keys(Capriza.EngineApi.Actions).forEach(createApiImpl);

    var Control = Capriza.Model.Control = Backbone.Model.extend({
        initialize: function(attributes, options) {
//            Logger.debug("initializing control: " + JSON.stringify(this.toJSON()));
            var controls = this.get("controls"), self = this;
            self.parent = options && options.parent;
            self.pages = options && options.pages;
            if (controls) {
                this.set("controls", controls.map(function(c) {
                    c.pages = self.pages;
                    if (c instanceof Backbone.Model) {
                        return c;
                    }
                    else {
                        return new Control(c, { parent: self});
                    }
                }));
            }
            this.api = ApiImpl.getImpl(this);


            // styleSetIds cache
            var ssIds = this.get("styleSetIds"),
                mcKey = (this.get("mcTemplId") || this.get("id")) + (this.get("isBox") ? "box" : "");
            if (ssIds) Capriza.Model.StyleSetDB[mcKey] = ssIds;
            else if (Capriza.Model.StyleSetDB[mcKey]) this.set("styleSetIds",Capriza.Model.StyleSetDB[mcKey]);
            else Logger.warn("No StyleSets in message for " + this.get("id") + " and in cache for key " + mcKey);

            if (this.get("click") && !(this.get("click") instanceof Backbone.Model)) {
                this.set("click", new Control(this.get("click"), { parent: this, pages: this.pages }));
            }

            if (this.get("groupHeader") && !(this.get("groupHeader") instanceof Backbone.Model)) {
                this.set("groupHeader", new Control(this.get("groupHeader"), { parent: this, pages: this.pages }));
            }

            if (!(options && options.dontCache)) {
                Capriza.Model.ControlDB[this.get("id")] =  this;
            }

            Dispatcher.trigger("control/created", this);
        },

        set: function(key, value, options) {

            if (typeof key == "object"){
                options = value;
            }
            if (key.controls){

                for (var i  = 0; i < key.controls.length; i++){
                    key.controls[i] = new Control(key.controls[i], {parent: this});
                    key.controls[i].addPage(this.pages);
                }
            }

            if (key.click && !(key.click instanceof Backbone.Model)) {
                key.click = new Control(key.click, { parent: this, pages: this.pages });
            }

            if (key.groupHeader && !(key.groupHeader instanceof Backbone.Model)) {
                key.groupHeader = new Control(key.groupHeader, { parent: this, pages: this.pages });
            }

            Backbone.Model.prototype.set.apply(this, arguments);
//            Logger.debug('invoking controlChanged for key='+key+' value='+value+' options='+options);
            var self = this;
            //this.pages = this.pages || this.get('pages');
            _.each(this.pages, function(page) {
                var data;
                if (_.isObject(key) || key == null) {
                    data = key
                } else {
                    data = {};
                    data[key] = value;
                }
                if (!options || !options.silent) {
                    page.controlChanged(self, data);
                }
            });
        },

        setControls: function(controls) {
            for (var i  = 0; i < controls.length; i++){
                var existingControl = Capriza.Model.Control.getById(controls[i].id);
                if (existingControl) {
                    var subcontrols = controls[i].controls;
                    delete controls[i].controls;
                    existingControl.set(controls[i]);
                    subcontrols && existingControl.setControls(subcontrols);
                    existingControl.api = ApiImpl.getImpl(existingControl);
                    controls[i] = existingControl;
                }
                else {
                    controls[i] = new Control(controls[i], {parent: this});
                }
                controls[i].addPage(this.pages);
            }

            Backbone.Model.prototype.set.call(this, "controls", controls);

            var self = this;
            _.each(this.pages, function(page) {
                page.controlChanged(self, { controls: controls });
            });
        },

        toJSON: function() {
            var ret = Backbone.Model.prototype.toJSON.call(this);

            if (ret.controls) {
                ret.controls = ret.controls.map(function(c) { return c.toJSON(); });
            }

            return ret;
        },

        addPage: function(page) {
            if (!page) return;
            function doAddPage(p) {
                if (self.pages){
                    if (self.pages.indexOf(p) === -1) {
                        self.pages.push(p);
                    }

                } else {
                    self.pages = [ p ];
                }
            }


            var self = this;
            if (!_.isArray(page)) page = [ page ];
            _.each(page, function(p) {
                doAddPage(p);
            });

            var controls = this.get("controls");
            if (controls) {
                _.each(controls, function(innerControl) {
                    innerControl.addPage(page);
                });
            }

            var clickControl = this.get("click");
            if (clickControl) clickControl.addPage(page);

            var groupHeader = this.get("groupHeader");
            if (groupHeader) groupHeader.addPage(page);
        },

        getTablesInGroup: function() {
            var result = [];

            if (this.get('controls')) {
                this.get("controls").forEach(function(control) {
                    if (/table|tabular/.test(control.get('type'))) {
                        result.push(control.get('id'));
                    }
                    result = result.concat(control.getTablesInGroup());
                });
            }

            return result;
        },

        removePage: function(page) {
            if (this.pages) {
                var index = this.pages.indexOf(page);
                if (index > -1) {
                    this.pages.splice(index, 1);
                }
            }

            var controls = this.get("controls");
            if (controls) {
                _.each(controls, function(innerControl) {
                    innerControl.removePage(page);
                });
            }
        },

        remove: function() {
            recursiveRemove(this);
        },

        removeFromParent : function(){
            var self =this;
            if (self.parent) {
                var parent = self.parent;
                var parentControls = parent.get("controls"), index = parentControls.map(function(c) { return c.get("id") }).indexOf(self.get("id"));
                parentControls.splice(index, 1);
            }
            this.removeFromContext();
        },

        getContextId: function() {
            var contextId = "", pageId = "";

            function getPageContextId(pg){
                if(pg.get("contextId")) {
                    return pg.get("contextId");
                }
                else if(pg.get('parentPage')){
                    return getPageContextId(pg.get('parentPage'));
                }
                else{
                    return undefined;
                }
            }

            if(this.pages){
                var pages = this.pages;
                _.each(pages, function(page) {
                    var ctxId = getPageContextId(page);
                    if (contextId==="" && ctxId) {
                        contextId = ctxId;
                    }
                    pageId = page.get("id");
                });
            }
            else {//TODO: should add this also ?????????????????
                contextId = this.parent ? this.parent.getContextId() : "";
            }

            if (contextId === "" && pageId != "context-not-found") {
                Logger.error('ERROR, there is no context id associated to this control ', undefined, "controlModel", "Control id: " + this.get('id'));
            }
            return contextId;
        },

        removeFromContext: function() {
            var self = this;
            _.each(this.pages, function(page) {
                page.removeControl(self.get("id"));
            });
            delete Capriza.Model.ControlDB[this.get("id")];
        },

        compare: function(otherControl) {

            var toJson = this.toJSON(), otherJson = otherControl.toJSON();

            if (toJson.drillPage || otherJson.drillPage) {

                var thisDrillPageJson = toJson.drillPage, otherDrillPageJson = otherJson.drillPage;
                delete toJson.drillPage;
                delete otherJson.drillPage;
            }

            return JSON.stringify(toJson) === JSON.stringify(otherJson);
        },

        isInControl : function(control) {
            var foundId = false,
                current = this;

            while (!foundId && current) {
                foundId = current.get('id') === control.get('id');
                current = current.parent;
            }
            return foundId;
        }

    }, {
        getById: function(id) {
            return Capriza.Model.ControlDB[id];
        },

        createApi: function(type, baseType, methods) {
            if (arguments.length === 2) {
                methods = Capriza.EngineApi.Actions[baseType];
            } else {
                methods = Capriza.EngineApi.Actions[baseType].concat(methods)
            }

            Capriza.EngineApi.Actions[type] = methods;
            createApiImpl(type);
        }
    });

    function recursiveRemove(control) {

        if (control.get('controls')) {
            for (var i = 0; i < control.get('controls').length; i++){
                recursiveRemove(control.get('controls')[i]);
            }
        }


        delete Capriza.Model.ControlDB[control.get('id')];
    }

    Capriza.Model.ControlDB = {};

    Capriza.Model.StyleSetDB = {};

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/State.js

try{
/**
 * Created by omer on 9/2/16.
 */
;(function() {

    var getText = Capriza.translator.getText.bind(Capriza.translator);

    Capriza.Views.BlueprintPageView = Capriza.Views.ContextPage.extend({

            expiredHandler: undefined,
            blueprintTimeout: undefined,

            initialize: function() {
                var self = this;
                Capriza.Views.ContextPage.prototype.initialize.apply(this, arguments);

                this.blueprintTimeout = ClientCache.getItem(Capriza.Views.MVPageView.zappDataKey+Capriza.getToken()+'-timeout') || 60000;
                this.$el.addClass("blueprint");

                Dispatcher.on('app/newVersionDownloading', function() {
                    var msg = {type: "progress",
                        messageText: getText("newVersion"),
                        detailText: getText("zappReloadAuto")};

                    self.mvpLoadingMessageTimeout = setTimeout(function(){
                        Utils.shouldShowLoadingOnMVP(true);
                    }, 3000);
                    Utils.showUnimessage(msg, false, true);
                });

                Dispatcher.on("app/offline", this._onOffline, this);
                Dispatcher.on("app/online", this._onOnline, this);
                Dispatcher.on("app/disabledControlInteracted", this._onOnline, this);
                _.bindAll(this, "rearmBlueprintTimeOut", "clearBlueprintTimeOut");
            },

            clearBlueprintTimeOut: function () {
                if (this.expiredHandler) clearTimeout(this.expiredHandler);
            },

            rearmBlueprintTimeOut: function() {
                Logger.debug('arming blueprint timeout');
                this.clearBlueprintTimeOut();
                this.expiredHandler = setTimeout(function() {
                    Logger.error('[Blueprint] blueprintTimerExpired triggered', undefined, "blueprint");
                    Dispatcher.trigger('blueprintTimerExpired', {cause: "blueprintTimerExpired"});
                }, this.blueprintTimeout);
            },

            // Cancels Blueprint updating timeout and shows Offline-toast
            _onOffline: function () {
                Logger.debug("Blueprint offline");
                this.clearBlueprintTimeOut();

                var msg = {type: "error",
                    messageText: getText("mvpOffline"),
                    actionText: getText("gotIt"),
                    action: Utils.hideUnimessages.bind(Utils)};

                Utils.showUnimessage(msg, false, true);
            },

            // Starts MVP updating timeout and shows Updating-toast
            _onOnline: function (force) {
                var self = this;
                Logger.debug("Blueprint online");
                this.rearmBlueprintTimeOut();

                if (force) {
                    var s = getText("mvpUpdating");
                    var t = getText("lastUpdated") + " " + this.lastUpdateDate;

                    if (Utils.blockEffect()){
                        return;
                    }
                    Utils.showUnimessage(
                        {type: "progress"},
                        false, true);
                    clearTimeout(this.mvpUpdatingTimeout);
                    this.mvpUpdatingTimeout = setTimeout(function(){
                        // if unimassage is still display show this
                        Utils.updateUnimessage(
                            {type: "progress", messageText: s, detailText: t},
                            false, true, true);
                        // if after another 3 seconds still need to display messages show the loading automated messages
                        clearTimeout(self.mvpLoadingMessageTimeout);
                        self.mvpLoadingMessageTimeout = setTimeout(function(){
                            Utils.shouldShowLoadingOnMVP(true);
                        }, 4000);
                    }, 6000);
                }
            },

            _render: function() {
                Capriza.Views.ContextPage.prototype._render.apply(this, arguments);
                Dispatcher.trigger("mobile/active");
                Dispatcher.trigger("engineApi/unsyncedMessages", true);

                var errorCallback = function(data) {
                    Dispatcher.off('application/contextNotFound blueprintTimerExpired handleResponseError', errorCallback, this);
                    Logger.tag("BlueprintError");
                    Logger.error('Blueprint update Error received', undefined, "blueprint", JSON.stringify(data));

                    var messageText = getText("somethingIsWrong");
                    var detailText = getText("couldNotUpdatePage");
                    var actionText = getText("retry");

                    var msg = {type: "error", messageText: messageText,
                        detailText: detailText, actionText: actionText,
                        action: Utils.reload};

                    Utils.showUnimessage(msg, false, true);
                };

                Dispatcher.on('application/contextNotFound blueprintTimerExpired handleResponseError', errorCallback, this);

                var timestamp = this.model.get('timestamp');
                moment.locale(Capriza.translator.getLang());
                var momentDate = moment(parseFloat(timestamp));
                this.lastUpdateDate = momentDate.fromNow();

                Logger.debug('showing blueprint from: ' + this.lastUpdateDate);

                var _this = this;

                Logger.debug("[Blueprint] starting the expiration timer");

                if (Capriza.Connection.isOnline) {
                    this._onOnline(this.model.get("cacheShowLoading"));
                } else {
                    this._onOffline();
                }
                this.rearmBlueprintTimeOut();

                Dispatcher.on('blueprint/newContentReady', function (options) {
                    Logger.debug("received blueprint/newContentReady");
                    _this.clearBlueprintTimeOut();

                    _this.$el.removeClass("blueprint");
                    Dispatcher.trigger("engineApi/unsyncedMessages", false);
                    Dispatcher.off("app/offline", _this._onOffline);
                    Dispatcher.off("app/online", _this._onOnline);
                    Dispatcher.off("app/disabledControlInteracted", this._onOnline);
                    Dispatcher.off('application/contextNotFound blueprintTimerExpired handleResponseError', errorCallback, _this);
                    clearTimeout(_this.mvpUpdatingTimeout);
                    clearTimeout(_this.mvpLoadingMessageTimeout);
                    Utils.shouldShowLoadingOnMVP(false);
                    if (this.model.get("cacheShowLoading")) Utils.hideUnimessages();

                    if(options && options.newOnlinePageView) {
                        options.newOnlinePageView.show({ transition: 'none' });
                    }
                }, this);

                Dispatcher.trigger("mobile/blueprint/rendered");

                return this;
            }
        }
    );

    var _defaultControlStateProps = ["id", "type"];
    var _excludeStateProps = ["controls","styleSetIds", "eta"];
    var _defaultControlStructureProps = ["id", "type", "styleSetIds", "eta"];

    var caprizaToken = Capriza.getToken(),
        structKeyPref = "struct-" + caprizaToken + "-",
        stateKeyPref = "state-" + caprizaToken + "-",
        defaultStructKey = structKeyPref + "default",
        modelToken = "modelId-" + caprizaToken;

    var maxStructsPerZapp = 10,
        maxStatesPerPage = 20,
        statesPerPage = {};

    Capriza.Model.State = {

        controlStateProps:{
            content:    ["value"],
            textbox:    ["text"],
            listbox:    ["items", "selectedIndex"]
        },

        extractState:function(ctxId){
            var page = Capriza.Model.ContextPage.getByContextId(ctxId);
            if(!page) {
                Logger.error("Failed to extract state, page not found.", undefined, "State", "ctxId:" + ctxId );
                return;
            }
            var retState = {
                contextId: ctxId,
                controls:{}
            };

            function processControlsDFS(controls, pos){
                if(!controls) return;
                pos = pos || "0";
                controls.forEach(function(ctrl, idx){
                    var subPos = pos + "-" + idx;
                    if (!(ctrl instanceof Backbone.Model)) { // TODO <- do this better
                        ctrl = Capriza.Model.Control.getById(ctrl);
                    }
                    retState.controls[ctrl.get("id")] = getControlState(ctrl);
                    retState.controls[ctrl.get("id")].pos = subPos;
                    processControlsDFS(ctrl.get("controls"), subPos);
                });
            }

            //ForDebugging
            function processControlsBFS(controls){
                if(!controls) return;
                var queue = controls;
                while(queue.length > 0){
                    var ctrl = queue.shift();
                    if (!(ctrl instanceof Backbone.Model)) { // TODO <- do this better
                        ctrl = Capriza.Model.Control.getById(ctrl);
                    }
                    retState.controls[ctrl.get("id")] = getControlState(ctrl);
                    ctrl.get("controls") && ctrl.get("controls").forEach(function(subctrl){
                        queue.push(subctrl);
                    });
                }

            }

            function getControlState(ctrl){
                //var controlState = {};
                //_defaultControlStateProps.forEach(function(prop){
                //    controlState[prop] = ctrl.get(prop)
                //});
                //
                //Capriza.Model.State.controlStateProps[ctrl.get("type")] && Capriza.Model.State.controlStateProps[ctrl.get("type")].forEach(function(prop){
                //    if(ctrl.get(prop)) {
                //        controlState[prop] = ctrl.get(prop)
                //    }
                //});

                var controlState = _.clone(ctrl.attributes); //TODO: filter to include only dynamics ? or by flag/flavor
                _excludeStateProps.forEach(function(prop){
                    delete controlState[prop];
                });
                return controlState;
            }

            var pageControls = page.get("controls");

            processControlsDFS(pageControls);

            return retState;
        },

        saveState: function(ctxId, state) {
            if(!sm.structs[ctxId]) return;

            var stateId = (state && state.stateId) || "default";
            // save state only for pages with state cacheMode=persist
            var cacheStateMode = Utils.getCacheModes(sm.structs[ctxId].cacheMode).stateMode;
            //#20264 - allways save the last state of the login, we might need it in case of failed auto-login
            if (/^(persist|session)$/.test(cacheStateMode) || sm.structs[ctxId].login) {
                sm.states[ctxId] = sm.states[ctxId] || {};
                sm.statesUpdated[ctxId] = sm.statesUpdated[ctxId] || {};

                //check if we need to save the state before or after (default) user interaction
                //we save states that were updated at least once in the current run in sm.statesUpdated
                if (sm.statesUpdated[ctxId][stateId] && sm.structs[ctxId].cacheOnlyBeforeInteraction){
                    Logger.info("Blueprint saveState: cacheOnlyBeforeInteratcion = 'true' and state '" + stateId + "' already updated in ctx '"+ ctxId +"'. Not overriding state.");
                    return;
                }

                sm.states[ctxId][stateId] = sm.states[ctxId][stateId] || {};
                sm.statesUpdated[ctxId][stateId] = true;

                //set all of the new state's (EXCEPT "controls") properties to the old state (override)
                Object.keys(state).forEach(function (propKey) {
                    if (propKey != "controls"){
                        sm.states[ctxId][stateId][propKey] = state[propKey];
                    }
                    else{ //prop key == "controls":

                        //make sure current state has "controls"
                        sm.states[ctxId][stateId].controls = sm.states[ctxId][stateId].controls || {};

                        //update each control: if it's a "diff" message, deep-extend the control's state.
                        //if it's not a "diff" message ("missing" or "table") override the state, NOT extend.
                        Object.keys(state.controls).forEach(function (controlId){
                            var control = Capriza.Model.Control.getById(controlId);

                            //special case 1 - "table": not a diff/incremental message, requires special treatment
                            if (control && control.get("type") == "table"){
                                sm.states[ctxId][stateId].controls[controlId] = sm.states[ctxId][stateId].controls[controlId] || {};

                                //In case it's "moreItems", extend the table controls with "moreItems" controls
                                if (state.controls[controlId].hasOwnProperty("moreItems") && state.controls[controlId].moreItems.controls){
                                    //var tableChildControls = sm.states[ctxId][stateId].controls[controlId].controls || [];
                                    //sm.states[ctxId][stateId].controls[controlId].controls = tableChildControls.concat(state.controls[controlId].moreItems.controls);

                                    //todo
                                }
                                //if the table message is not "moreItems", override the entire table state
                                else {
                                    sm.states[ctxId][stateId].controls[controlId] = state.controls[controlId];
                                }
                            }
                            //special case 2 - "isMissing": if the control is missing, we need to override the state
                            else if (state.controls[controlId].missing){
                                sm.states[ctxId][stateId].controls[controlId] = state.controls[controlId];
                            }
                            //default case: deep extend the current state with the new one assuming the message is a "diff"/incremental message
                            else {
                                sm.states[ctxId][stateId].controls[controlId] = sm.states[ctxId][stateId].controls[controlId] || {};
                                $.extend(true, sm.states[ctxId][stateId].controls[controlId], state.controls[controlId]);
                            }
                        });
                    }
                });

                //update timestamp
                sm.states[ctxId][stateId].pageProps = sm.states[ctxId][stateId].pageProps || {};
                sm.states[ctxId][stateId].pageProps.timestamp = Date.now();

                //$.extend(true, sm.states[ctxId][stateId], state);
                // mark states to persist according to maxStates per page
                statesPerPage[ctxId] = statesPerPage[ctxId] || [];
                if(stateId !== "default" && statesPerPage[ctxId].indexOf(stateId) < 0) {
                    if(statesPerPage[ctxId].length >= maxStatesPerPage ) {
                        statesPerPage[ctxId].shift();
                    }
                    statesPerPage[ctxId].push(stateId);
                }
            }
            if (sm.readyForCaching && (cacheStateMode === "persist" || stateId !== "default")) {
                var statesToPersist = {};
                Object.keys(sm.states).forEach(function(ctxId){
                    var currentState = sm.states[ctxId],
                        cacheModes = sm.structs && sm.structs[ctxId] && Utils.getCacheModes(sm.structs[ctxId].cacheMode),
                        persistState = cacheModes.stateMode == "persist",
                        stateIds = Object.keys(currentState);
                    // when do we save the state for a context?
                    // a. we are told to persist it
                    // b. we have a stateId other than default on it - so we persist only the state ids
                    if(persistState) {
                        statesToPersist[ctxId] = statesToPersist[ctxId] || {};
                        statesToPersist[ctxId]["default"] = sm.states[ctxId]["default"];
                    }
                    stateIds.forEach(function(stateId) {
                        if(stateId !== "default") {
                            statesToPersist[ctxId] = statesToPersist[ctxId] || {};
                            if(statesPerPage[ctxId].indexOf(stateId) > -1) {
                                statesToPersist[ctxId][stateId] = sm.states[ctxId][stateId];
                            } else {
                                // since saving to the file system does deep extend, it's not enough to not pass the
                                // states we don't want to persist. we need to mark them as null so that they
                                // will be overridden in the file system, and later cleaned up in the background.
                                // Yes, I don't like this as well... :-(
                                statesToPersist[ctxId][stateId] = null;
                            }
                        }
                    });
                });

                //if running in the dashboard preview, don't cahce the blueprint pages (it causes problems in the dual preview windows: mobile + tablet)
                !Utils.isInDashboard() && sm.saveStructureStateToCache({states: statesToPersist});
            }
        }
    };

    Capriza.Model.Structure = {

        extractStructure:function(ctxId){
            var page = Capriza.Model.ContextPage.getByContextId(ctxId);
            if(!page) {
                Logger.error("Failed to extract state, page not found.", undefined, "State", "ctxId:" + ctxId );
                return;
            }


            function processControlsDFS(controls){
                if(!controls) return;

                return _.map(controls,function(ctrl){
                    var obj = {};
                    if (!(ctrl instanceof Backbone.Model)) { // TODO <- do this better
                        ctrl = Capriza.Model.Control.getById(ctrl);
                    }

                    _defaultControlStructureProps.forEach(function(prop){
                        if(ctrl.get(prop)) {
                            obj[prop] = ctrl.get(prop)
                        }

                    });

                    if(ctrl.get("controls") && ctrl.get("controls").length > 0) {
                        obj["controls"] = processControlsDFS(ctrl.get("controls"));
                    }

                    return obj;
                });
            }

            var pageControls = page.get("controls");

            var retStructure = {
                id: page.get("id"),
                contextId: page.get("contextId"),
                controls:processControlsDFS(pageControls)
            };


            return retStructure;
        }

    };

    //An object for cache abstraction - write and reads from the device's file system when available, with localStorage fallback.
    //run init(), before use.
    var BlueprintCache = Capriza.BlueprintCache = {
        blueprintData: {}, //holds the blueprint structure read from the file system set the params.readBlueprintData = true.
        fileSystemAvailable: null,
        inWritingProcess: false, //when reading/writing we may have to wait for the current writing process to end.
        writeAgainWhenFinished: false, //when calling saveChanges() while writing, we will call it again after current write finishes

        init: function(callback){
            BlueprintCache.fileSystemAvailable = BlueprintCache.fileSystemAvailable || (Utils.getFiler && !!Utils.getFiler());
            Logger.debug("[Blueprint Cache] file system available? : " + BlueprintCache.fileSystemAvailable);
            var readTimeout;

            if (BlueprintCache.fileSystemAvailable){
                var readFromFileTimeout = true;
                if (BlueprintCache.inWritingProcess){
                    Logger.debug("[Blueprint Cache] init() called during writing to the file, abort reading from file and return current known data");
                    readTimeout && clearTimeout(readTimeout);
                    callback(BlueprintCache.blueprintData);
                }
                else {
                    Utils.getBlueprintFromFile(null, function (blueprintData) {
                        if (!BlueprintCache.inWritingProcess){
                            BlueprintCache.blueprintData = blueprintData || {};
                            Logger.debug("[Blueprint Cache] got blueprint from fileSystem with keys: " + Object.keys(BlueprintCache.blueprintData));
                        }
                        else{
                            Logger.debug("[Blueprint Cache] finished reading while data is being written, ignoring read data: " + Object.keys(BlueprintCache.blueprintData));
                        }

                        readTimeout && clearTimeout(readTimeout);
                        callback(BlueprintCache.blueprintData);
                    });
                }

                readTimeout = setTimeout(function(){
                    Logger.debug("[Blueprint Cache] Couldn't read blueprint data from file in 5 seconds");
                }, 5000);
            }
            else{
                callback(BlueprintCache);
            }
        },

        getItem: function(key){
            if (BlueprintCache.fileSystemAvailable){
                return BlueprintCache.blueprintData[key];
            }
            else {  //falling back to localStorage
                return ClientCache.getItem(key);
            }
        },

        //should not be widely used.. please use getItem abstraction
        getItemFromLocalStorage: function(key){
            return ClientCache.getItem(key);
        },

        setItem: function (key, value, both){
            if (BlueprintCache.fileSystemAvailable){
                BlueprintCache.blueprintData[key] = value;
            }

            //both: means to in every case save the data to the clientCache.
            //we need it because unfortunately we have to save the modelId also in the localStorage because
            //we need to use these in run.js before we can use the loginMessageWriter to load it from the file due
            //to mboot dependency in underscore and backbone when defining the Dispatcher in which is used in
            //LoginMessageWriter
            if (both || !BlueprintCache.fileSystemAvailable) {
                ClientCache.setItem(key, value);
            }
        },

        removeItem: function(key){
            if (BlueprintCache.fileSystemAvailable){
                delete BlueprintCache.blueprintData[key];
            }
            else{
                ClientCache.removeItem(key);
            }
        },

        saveChanges: function(successCallback, errorCallback){
            if (BlueprintCache.fileSystemAvailable){
                Logger.debug("[Blueprint Cache] Going to save blueprint in file, keys: " + Object.keys(BlueprintCache.blueprintData));
                if (BlueprintCache.inWritingProcess){
                    Logger.debug("[Blueprint Cache] saveChanges called during writing process, setting writeAgainWhenFinished=true and aborting.");
                    BlueprintCache.writeAgainWhenFinished = true;
                    return;
                }
                BlueprintCache.inWritingProcess = true;
                Utils.saveBlueprintInFile(BlueprintCache.blueprintData, function(){
                    //success
                    Logger.debug("[Blueprint Cache] writing to file success! writeAgainWhenFinished: " + BlueprintCache.writeAgainWhenFinished);
                    if (BlueprintCache.writeAgainWhenFinished){
                        BlueprintCache.writeAgainWhenFinished = false;
                        BlueprintCache.inWritingProcess = false;
                        BlueprintCache.saveChanges();
                    }
                    else {
                        BlueprintCache.inWritingProcess = false;
                        successCallback && successCallback();
                    }
                }, errorCallback);
            }
            else if (successCallback){
                successCallback()
            }
        },

        keys: function(){
            if (BlueprintCache.fileSystemAvailable){
                return Object.keys(BlueprintCache.blueprintData);
            }
            else {
                return ClientCache.keys();
            }
        },

        clear: function(){
            if (BlueprintCache.fileSystemAvailable){
                BlueprintCache.blueprintData = {};
            }

            //always clear the localStorage
            ClientCache.keys().filter(function (key) {
                return key.indexOf(structKeyPref) == 0 || key.indexOf(stateKeyPref) == 0;
            }).forEach(function (key) {
                ClientCache.removeItem(key);
            });
            ClientCache.removeItem(modelToken);

        }
    };

    var sm = Capriza.StateManager = {
        structs:{},
        states:{},
        statesUpdated: {}, //saves the states (and state ids) that were updated in this run (session) - to support cacheOnlyBeforeInteraction flag.
        disabledControls: [],
        defaultStructure: null,

        disableWhiteListType: ['clientbutton', 'clientlink', 'panel', 'bubble', 'content', 'tabController', 'tab', 'main', 'topLevel'],

        initBlueprintCache: function(callback){
            callback && BlueprintCache.init(callback);
        },

        setModelId: function(modelId) {

            //after showing uniMessage "zapp is downloading", wait for the next loadState/getIdentity.. engine message, and clear the message.
            Dispatcher.once("blueprint/removeNewVersionMessage", function(){
                Logger.debug("[Blueprint] removing 'downloading new version' message.");
                Utils.hideUnimessages();
                //clear blueprint timeout
                Dispatcher.trigger("blueprint/newContentReady");
            });

            var msg = {type: "progress",
                messageText: getText("newVersion"),
                detailText: getText("zappReloadAuto")};
            this.mvpLoadingMessageTimeout = setTimeout(function(){
                Utils.shouldShowLoadingOnMVP(true);
            }, 3000);

            Utils.showUnimessage(msg, true, true);

            function setModelIdAfterInitCache(){
                BlueprintCache.setItem(modelToken, modelId, true);
                BlueprintCache.saveChanges();
            }

            // invalidate all structs and states - call cleanBlueprint which will also init the blueprint cache.
            sm.cleanBlueprint({performInit: true, andSave: false}, setModelIdAfterInitCache); //the save will happen after.
        },

        cacheStyleSets: function(ctrl) {
            var ssIds = ctrl.styleSetIds,
                mcKey = (ctrl.mcTemplId || ctrl.id) + (ctrl.isBox ? "box" : "");
            if (ssIds) Capriza.Model.StyleSetDB[mcKey] = ssIds;

            ctrl.controls && ctrl.controls.forEach(function(control) {
                sm.cacheStyleSets(control);
            });
        },

        addStructure: function(structure) {
            (structure || []).forEach(function(struct) {
                // extend id from unique id that is the same, just as string:
                var structIdNum = Number(struct.uniqueId);
                if(struct.id === undefined && !isNaN(structIdNum)) {
                    struct.id = structIdNum;
                }
                // in case we are going to override the controls property, cache styleSets for the controls in
                // the struct.
                // i.e. in a table, the style sets are passed on the two dummy controls in the struct and
                // not in the state for each control
                sm.cacheStyleSets(struct);

                // check if we should persist the structure or not
                // cacheMode : persist/persist - save struct and state to fs/ls
                //           : persist/session - save struct to fs/ls, save state in memory
                //           : none/none - you don't really need this comment to figgure our what it means... :-)
                var cacheModes = Utils.getCacheModes(struct.cacheMode);
                if(/^(persist|session)$/.test(cacheModes.structMode)) {
                    sm.structs[struct.ctxId] = struct;
                }
            });
        },

        updateStructure: function(structMsg) {
            var ctxId = structMsg.ctxId,
                structKey = structKeyPref + ctxId,
                currentStruct = sm.structs[ctxId];

            if(!currentStruct) return;
            var stateCacheMode = Utils.getCacheModes(currentStruct.cacheMode).stateMode;
            // construct the new struct from the old one, while iterating update it accordingly
            function removeFromStruct(allControls, controlsToRemove) {
                if(!(allControls && allControls.length > 0) || !(controlsToRemove && controlsToRemove.length > 0)) return;

                var allCnt = allControls.length;

                while(allCnt--) {
                    var current = allControls[allCnt];
                    var removeCnt = controlsToRemove.length;
                    while(removeCnt--) {
                        if(current.id === controlsToRemove[removeCnt]) {
                            allControls.splice(allCnt, 1);
                            controlsToRemove.splice(removeCnt,1);
                            if(stateCacheMode === "persist" || stateCacheMode === "session") {
                                if(sm.states && sm.states[ctxId] &&
                                    sm.states[ctxId]["default"] && sm.states[ctxId]["default"].controls)
                                    delete sm.states[ctxId]["default"].controls[current.id];
                            }

                            break; // break from iteration over removed array
                        }
                    }
                    if(current.controls && current.controls.length > 0 ) removeFromStruct(current.controls, controlsToRemove);
                    if(controlsToRemove.length === 0) {
                        break; // break from iteration over all controls
                    }
                }
            }


            function findControlInStruct(controls, controlId) {
                for(var i=0; i< controls.length; i++){
                    if(controls[i].id === controlId) {
                        return controls[i];
                    }
                    if(controls[i].controls && controls[i].controls.length > 0) {
                        var innerControl = findControlInStruct(controls[i].controls, controlId);
                        if(innerControl) return innerControl;
                    }
                    if(controls[i].groupHeader){
                        if(controls[i].groupHeader.id === controlId) {
                            return controls[i].groupHeader;
                        }
                        if (controls && controls[i].groupHeader.controls && controls[i].groupHeader.controls.length > 0) {
                            var headerControl = findControlInStruct(controls[i].groupHeader.controls, controlId);
                            if (headerControl) return headerControl;
                        }
                    }
                }
                return null;
            }

            function replaceControlInStruct(controls, newControl) {
                if(!controls || controls.length === 0) return;
                for(var i=0; i< controls.length; i++){
                    if(controls[i].id === newControl.struct.id) {
                        controls[i] = newControl.struct;
                        if(stateCacheMode === "persist" || stateCacheMode === "session") {
                            sm.states[ctxId] = sm.states[ctxId] || {};
                            sm.states[ctxId]["default"] = sm.states[ctxId]["default"] || {};
                            sm.states[ctxId]["default"].controls = sm.states[ctxId]["default"].controls || {};
                            sm.states[ctxId]["default"].controls[newControl.struct.id] = newControl.state;
                        }
                        return true;
                    }
                    if(controls[i].controls && controls[i].controls.length > 0) {
                        var innerControl = replaceControlInStruct(controls[i].controls, newControl);
                        if(innerControl) return true;
                    }
                }
                return false;
            }

            if(structMsg.removed && structMsg.removed.length) {
                var removedClone = _.clone(structMsg.removed);
                removeFromStruct(currentStruct && currentStruct.controls, removedClone);
            }

            // handle added
            if(structMsg.added) {
                var added = Object.keys(structMsg.added).map(function(mcIdKey) {
                    var addedObj = structMsg.added[mcIdKey];
                    return { id: mcIdKey, index: addedObj.index, parent: addedObj.parent, struct: addedObj.struct, state: addedObj.state};
                });

                added.forEach(function(addedObj) {
                    var parentControl = findControlInStruct(currentStruct.controls, addedObj.parent);
                    parentControl.controls = parentControl.controls || [];
                    parentControl.controls.splice(addedObj.index, 0, addedObj.struct);
                    if(stateCacheMode === "persist" || stateCacheMode === "session") {
                        sm.states[ctxId] = sm.states[ctxId] || {};
                        sm.states[ctxId]["default"] = sm.states[ctxId]["default"] || {};
                        sm.states[ctxId]["default"].controls = sm.states[ctxId]["default"].controls || {};
                        sm.states[ctxId]["default"].controls[addedObj.struct.id] = addedObj.state;
                    }
                });
            }

            // handle modified
            if(structMsg.modified) {
                Object.keys(structMsg.modified).forEach(function(controlId) {
                    replaceControlInStruct(currentStruct.controls, structMsg.modified[controlId]);
                });
            }

            //ClientCache.setItem(structKey, JSON.stringify(currentStruct));
            sm.structs[structMsg.ctxId] = currentStruct;
            //sm.saveStructureStateToCache();
        },

        mergeStructureState:function(params){
            if(!params) return;

            var state = params.state,
                ctxId = params.ctxId || state.ctxId || state.contextId,
                structure = params.structure ? params.structure : (sm.structs[ctxId] || {}),
                unsynced = params.unsynced;

            // create clone so that we don't override the initial data!!!
            structure = JSON.parse(JSON.stringify(structure));
            state = JSON.parse(JSON.stringify(state));

            var isRecordMode = (window.isDesignerPreview || window.designerLoaded) && $("html").attr("designer-state") === "simplify";

            function processControlsDFS(controls, isDisabled){
                if(!controls) return;

                // TODO: move filter out hidden controls if not in record mode in designer to the engine.
                // This is a temp solution, if this is still in the code 1 year from now, go blame Dror!
                if(!isRecordMode) {
                    controls = _.filter(controls, function(ctrl) {
                        return (ctrl && ctrl.hidden) ? undefined : ctrl;
                    });
                }
                if(!controls || controls.length == 0) return;
                // end of ugly code that compensates for Dror's laziness

                return _.map(controls,function(ctrl){
                    var result = _.clone(ctrl);
                    if(state.controls[ctrl.id]){
                        delete result.missing;
                        if(state.controls[ctrl.id].phase && !state.controls[ctrl.id].controls){
                            state.controls[ctrl.id].controls = [];
                        }
                        _.extend(result, state.controls[ctrl.id]);
                    }
                    if(isRecordMode && result.missing) {
                        delete result.missing;
                        result.isPhantom = true;
                    } else if(result.missing && ctrl.alt) {
                        var controls = result.controls;
                        result = $.extend(true, {}, ctrl.alt, {alt: ctrl.alt, altDisplayed: true});
                        if(!result.controls && controls) result.controls = controls;
                    }
                    if(isDisabled){
                        if(!result.detachMode) {
                            if(sm.disableWhiteListType.indexOf(result.type) < 0) {
                                result.isDisabled = true;
                                sm.disabledControls.push(result.id);
                            }
                            if(result.click) {
                                result.click.isDisabled = true;
                                //sm.disabledControls.push(result.click.id);
                            }
                        }
                    }
                    if(result.controls && result.controls.length > 0) {
                        result["controls"] = processControlsDFS(result.controls, isDisabled);
                    }
                    if (result.groupHeader) {
                        result.groupHeader = processControlsDFS([result.groupHeader], isDisabled)[0];
                    }
                    if (result.click){
                        result.click = processControlsDFS([result.click], isDisabled)[0];
                    }
                    return result;
                });
            }

            sm.disabledControlsState = [];
            structure.controls = processControlsDFS(structure.controls, unsynced);
            _.extend(structure, state.pageProps);

            return structure;
        },

        mergeStates: function(oldState, newState){
            oldState = oldState || {};
            newState = newState || {};

            //remove missing for controls that were missing, and a new state was received for these (that is not missing).
            if (newState.controls) {
                oldState.controls = oldState.controls || {};
                _.forEach(newState.controls, function (control, id) {
                    oldState.controls[id] = oldState.controls[id] || {};
                    _.extend(oldState.controls[id], control);
                    if (oldState.controls[id].missing && !control.missing) oldState.controls[id].missing = undefined;
                    if (oldState.controls[id].phase && !control.phase) oldState.controls[id].phase = undefined;
                });
            }

            if (newState.pageProps){
                oldState.pageProps = _.extend({}, oldState.pageProps, newState.pageProps);
            }

            return oldState;
        },

        loadStructureStateFromCache: function(callback) {

            //sm.loadStructuresFromResource();    --> moved to viewportInit.js before loading blueprint
            sm.loadDefaultStructure(function(){
                sm.loadStatesFromCache(function(){
                    Dispatcher.trigger("blueprint/loaded");
                    callback && callback();
                    debug.blueprintInitialCache = JSON.parse(JSON.stringify(sm));
                });
            });
        },

        /**
         * Not in use for the moment (structures are loaded from resource (Structure.js) and are cached using the appCache
         */
        loadStructuresFromCache: function(callback){

            sm.initBlueprintCache(function(){
                var allKeys = BlueprintCache.keys(),
                    structKeys = allKeys.filter(function (key) {
                        return key.indexOf(structKeyPref) == 0;
                    });

                structKeys.forEach(function (key) {
                    var suffix = key.replace(structKeyPref, '');
                    switch (suffix) {
                        case "default" :
                            sm.defaultStructure = BlueprintCache.getItem(key).replace(structKeyPref, '');
                            break;
                        default:
                            var struct = BlueprintCache.getItem(key);
                            sm.structs[suffix] = typeof struct == "string" ? JSON.parse(struct) : struct;
                    }
                });

                Logger.debug("[Blueprint] Structures loaded from cache: " + Object.keys(sm.structs));
                callback && callback();
            });
        },

        loadStatesFromCache: function(callback){
            sm.initBlueprintCache(function() {
                var allKeys = BlueprintCache.keys(),
                    stateKeys = allKeys.filter(function (key) {
                    return key.indexOf(stateKeyPref) == 0;
                });

                stateKeys.forEach(function (key) {
                    var suffix = key.replace(stateKeyPref, ''),
                        state = BlueprintCache.getItem(key);
                    sm.states[suffix] = typeof state == "string" ? JSON.parse(state) : state;
                    statesPerPage[suffix] = Object.keys(sm.states[suffix] || []);
                    // remove default from statesPerPage
                    var defaultIndex = statesPerPage[suffix].indexOf("default");
                    if (defaultIndex > -1) statesPerPage[suffix].splice(defaultIndex, 1);
                });

                Logger.debug("[Blueprint] States loaded from cache: " + Object.keys(sm.states));

                callback && callback();
            });
        },

        /**
         * loads the structures from the resource file (structure.js) into sm.structs in sync mode.
         * assuming structures.js (Capriza.structManager) has already been loaded.
         */
        loadStructuresFromResource: function(){
            Logger.info("Trying to load structures from resource. StructManager exits? " + !!Capriza.structManager);
            if (Capriza.structManager && Capriza.structManager.getContextIds && Capriza.structManager.getStruct) {
                Capriza.structManager.getContextIds().forEach(function(ctxId) {
                    sm.structs[ctxId] = Capriza.structManager.getStruct(ctxId, Capriza.device.isTablet);
                });
                Logger.debug("[Blueprint] Initialized structs from resource: " + Object.keys(sm.structs));
            }
        },

        /**
         * Loads the default structure (MVP) from the cache and saves it in sm.defaultStructure
         */
        loadDefaultStructure: function(callback){
            sm.initBlueprintCache(function(){
                sm.defaultStructure = BlueprintCache.getItem(defaultStructKey);
                sm.defaultStructure = sm.defaultStructure ? sm.defaultStructure.replace(structKeyPref, '') : sm.defaultStructure;
                Logger.debug("[Blueprint] Default structure (MVP) id is loaded: " + sm.defaultStructure);
                callback && callback();
            });
        },

        saveStructureStateToCache: function(params) {

            function saveStructureStateToCache() {
                var structs = params.structs, states = params.states;
                if (structs) {
                    Object.keys(structs).forEach(function (key) {
                        switch (key) {
                            case "default" :
                                BlueprintCache.setItem(defaultStructKey, structKeyPref + sm.defaultStructure, true);
                                break;
                            default:
                            {
                                var structStr = typeof structs[key] == "string" ? structs[key] : JSON.stringify(structs[key]);
                                BlueprintCache.setItem(structKeyPref + structs[key].ctxId, structStr);
                            }
                        }
                    });
                }

                if (states) {
                    Object.keys(states).forEach(function (ctxId) {
                        if (states[ctxId]) {
                            Object.keys(states[ctxId]).forEach(function (stateId) {
                                if (states[ctxId][stateId] === null)
                                    delete states[ctxId][stateId];
                            });
                        }
                        var state = typeof states[ctxId] == "string" ? states[ctxId] : JSON.stringify(states[ctxId]);
                        BlueprintCache.setItem(stateKeyPref + ctxId, state);
                    });
                }

                BlueprintCache.saveChanges();
            }

            //if running in the dashboard preview, don't cahce the blueprint pages (it causes problems in the dual preview windows: mobile + tablet)
            sm.allowSaveBlueprint() && sm.initBlueprintCache(saveStructureStateToCache);
        },

        allowSaveBlueprint: function() {
            return !Utils.isInDashboard();
        },

        saveDefaultStructureToCache: function(){
            BlueprintCache.setItem(defaultStructKey, structKeyPref + sm.defaultStructure, true);
            BlueprintCache.saveChanges();
        },

        removeDefaultStructureFromCache: function(){
            BlueprintCache.removeItem(defaultStructKey);
            BlueprintCache.saveChanges();
        },

        loadBlueprint: function(params) {
            Logger.debug('[loadBlueprint] load started');

            Capriza.StateManager.loadStructureStateFromCache(function(){sm.blueprintLoaded(params)});
        },

        blueprintLoaded: function (params){
            Logger.info("[loadBlueprint] blueprint loaded");

            if(sm.structs) {
                Object.keys(sm.structs).forEach(function(key) {
                    if(key !== "default") {
                        Logger.debug("[loadBlueprint] caching stylesets for ctx " + key);
                        sm.cacheStyleSets(sm.structs[key]);
                    }
                });
            }

            var ctxId = (params && params.ctxId) || (sm.defaultStructure),
                stateId = (params && params.stateId) || "default";
            if(!ctxId) {
                Logger.debug('[loadBlueprint] No context found');
            } else {
                Logger.debug('[loadBlueprint] extracting structure and state for context: ' + ctxId);
                var state = (params && params.state) || (sm.states && sm.states[ctxId] && sm.states[ctxId][stateId]),
                    structure = sm.structs && sm.structs[ctxId];

                if(!state) Logger.debug("[loadBlueprint] no state found for ctx = " + ctxId + " and stateId = " + stateId);
                if(!structure) Logger.debug("[loadBlueprint] no structure found for ctx " + ctxId);
                var pageState = structure && state && Capriza.StateManager.mergeStructureState({state: state, structure: structure, unsynced: true});
            }

            if(pageState) {
                sm.isCachedBlueprintShown = true;
                Logger.debug('[loadBlueprint] zapp has blueprint, starting to show it. setting isCachedBlueprintShown=true');
                sm.showBlueprint(pageState);
                Dispatcher.trigger("mobile/blueprint/loaded");
            } else {
                Logger.debug('[loadBlueprint] zapp has no blueprint. setting isCachedBlueprintShown=false');
                Dispatcher.trigger("mobile/blueprint/noBlueprint");
                sm.isCachedBlueprintShown = false;
            }
        },

        /**
         * Updates the isDisabled of all the controls that were updated in the current loadState.
         * if these were formaly disabled (mvp), and are not disabled in the update, will not be disabled anymore
         */
        restoreDisabled: function(state) {
            if (!state.controls || sm.disabledControls.length === 0) return;

            sm.disabledControls = sm.disabledControls.filter(function(ctrId){
                var ctrl = findControlInState(state.controls, ctrId);
                if (ctrl) {
                    ctrl.isDisabled = "isDisabled" in ctrl ? ctrl.isDisabled : false;
                    return false; //take this control out of the disabledControls
                }
                return true;
            });
        },

        cleanBlueprintFromMemory: function () {
            //synced code:
            sm.states = {};
            sm.structs = {};
            sm.defaultStructure = undefined;
            sm.newDefaultStructure = undefined;
            sm.isCachedBlueprintShown = false;
            sm.statesUpdated = {};
        },

        cleanBlueprint: function(params, successCallback, errorCallback) {

            sm.cleanBlueprintFromMemory();

            //unsynced code:
            params = _.extend({performInit: true, andSave: true, hideUnimessage: true}, params);
            function cleanBlueprintAfterInitCache() {
                Logger.debug("[Blueprint] clean blueprint is called");

                BlueprintCache.clear();
                params && params.hideUnimessage && Utils.hideUnimessages();
                if (params && params.andSave) BlueprintCache.saveChanges(successCallback, errorCallback);
                else if (successCallback) successCallback();
            }

            if (params.performInit)
                sm.initBlueprintCache(cleanBlueprintAfterInitCache);
            else
                cleanBlueprintAfterInitCache();
        },

        showBlueprint: function(pageState) {
            $.capriza.activePage = $([]);

            Logger.debug('[loadBlueprint] handling started. appCache status: ' + applicationCache.status + ' Capriza.firstRun: ' + Capriza.firstRun);
            take('loadingBlueprint');

            Capriza.EngineApi.Handlers.newStateWithStructure(pageState, {blueprint: true});

            Logger.debug("[loadBlueprint] handling blueprint ended");
            Logger.tag("BlueprintShown");
        },

        //search recursively in the context structure for the controlId's structure and return it.
        getStructureForControl: function (ctxId, controlId){
            var ctxStructure = sm.structs[ctxId];

            function getStructureRecursive(root){
                if (!root) return;
                if (root.id == controlId) return root;

                //else, keep searching in it's controls..
                var controlFound;
                if (root.controls && Array.isArray(root.controls)){
                    root.controls.forEach(function (control){
                        controlFound = controlFound || getStructureRecursive(control);
                        if (controlFound) return controlFound;
                    });
                }

                return controlFound;
            }

            if (!ctxStructure || !ctxStructure.controls || !Array.isArray(ctxStructure.controls)) return;

            return getStructureRecursive(ctxStructure);
        },

        /**
         * @returns a flat array of control ids from the structure of the given context top-down, dfs
         */
        getStructureControlsSorted: function(contextId){
            var controlsSorted = [];

            function getControlsRecursive(control){
                if (!control) return;
                control.id && controlsSorted.push(control.id);
                control.controls && control.controls.forEach(getControlsRecursive);
            }

            if (sm.structs && sm.structs[contextId]) getControlsRecursive(sm.structs[contextId]);
            return controlsSorted;
        },

        checkIfShouldBeMVP: function(ctxId){
            //if we havn't set a "newDefault" in this session, we look for it (ctxId is a candidate).
            //if we have the structure for ctxId and it is not login
            if (sm.readyForCaching && !sm.newDefaultStructure && sm.structs[ctxId] && !sm.structs[ctxId].login && sm.allowSaveBlueprint()) {
                //if it is persistant (cached), it's the new MVP
                if (Utils.getCacheModes(sm.structs[ctxId].cacheMode).structMode == "persist") {
                    Logger.debug("[Blueprint] saving structure '" + ctxId + "' as default (MVP)");
                    sm.newDefaultStructure = ctxId;
                    sm.defaultStructure = ctxId;
                    sm.saveDefaultStructureToCache()
                }
                else { //otherwise there is no MVP in this session.
                    sm.newDefaultStructure = 'none'; //this is for next time we need check for potential MVP.
                    sm.defaultStructure = undefined;
                    sm.removeDefaultStructureFromCache();
                }
            }
        }

    };

    Dispatcher.on("mobile/error identity/host/logout", sm.cleanBlueprint);

    Dispatcher.on("asset/loaded/structure", function(){
        Logger.debug("[Blueprint] updating new structures in Capriza.StateManager");
        $.capriza.activePage = $([]);
        sm.loadStructuresFromResource();
    });

    Dispatcher.on("login/auto/failed", function(){
        sm.isCachedBlueprintShown = false;
    })

    /**
     * Searches in controls map, and if doesn't find it there looks in every entry for nested controls.
     *
     * @param controls : a map of id ==> control data, e.g. { "mc123" : { ... }, "mc456" : { ... } }
     * @param ctrId : the id of the control to find
     * @returns the data of the control
     */
    function findControlInState(controls, ctrId) {
        if (controls[ctrId]) {
            return controls[ctrId];
        } else {
            for (var id in controls) if (controls.hasOwnProperty(id)) {
                var res = getDescendant(controls[id], ctrId);
                if (res) return res;
            }
        }
    }

    /**
     *
     * @param control : e.g. { id: "kuku", controls: [ ... ] }
     * @param id : the id of the control to find
     * @returns the data of the control
     */
    function getDescendant(control, id) {
        var controls = control.controls;
        if (controls) {
            for (var i= 0,ii=controls.length;i<ii;i++) {
                var child = controls[i];

                if (child.id === id) return child;

                var res = getDescendant(child, id);
                if (res) return res;
            }
        }
    }

    function showErrorAndReload(){

        var messageText = getText("somethingIsWrong"),
            detailText = getText("couldNotUpdatePage"),
            actionText = getText("retry");

        function reload(){
            //Utils.updateUnimessage({type: "progress", messageText: getText("restarting"), actionText: null, detailText: null});
            setTimeout(Utils.reload, 4000); //if nothing happens within 4 seconds, reload.
            sm.cleanBlueprint({performInit: false, andSave: true, hideUnimessage: false}, Utils.reload, Utils.reload);
        }
        Utils.showUnimessage({type: "error", messageText: messageText,
            detailText: detailText, actionText: actionText,
            action: reload}, false, true);
    }

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/LoadingMessage.js

try{
;
(function () {

    //function blockDocument(e) {
    //    logger.log("block document: " + e.type + ": " + e.target.tagName + (e.target.id || ""));
    //
    //    // block everything but these interactable items
    //    var interactableItems = '#side-burger, #side-menu, #header-overlay, #viewport-overlay, #feedback-page';
    //
    //    if ($(e.target).closest($(interactableItems)).length != 0 || e.target.className.indexOf('loading-message') >= 0) {
    //        return;
    //    }
    //
    //    var $loadingMessage = $('.loading-message');
    //    $loadingMessage.loadingMessage('option', 'topHeader', Capriza.translator.getText(Capriza.translator.ids.oneMoment));
    //    $loadingMessage.loadingMessage('update');
    //    if (/^(INPUT|SELECT|BUTTON|TEXTAREA)$/.test(e.target.tagName.toUpperCase())) {
    //        $loadingMessage.loadingMessage('show');
    //    }
    //
    //    // for touch devices - preventing default means disabling scroll. So we do it only on the form elements
    //    if (e.type !== "touchstart" || /^(INPUT|SELECT|BUTTON|TEXTAREA)$/.test(e.target.tagName.toUpperCase())) {
    //        e.preventDefault();
    //        e.stopPropagation();
    //    }
    //}
    //
    //function blockUI() {
    //    Logger.debug('blocking the UI');
    //    var element = Capriza.fullScreen ? document : $(".viewport")[0];
    //    if (Utils.isCachedMVPShown()) {
    //        Logger.debug('not blocking the UI because of cached mvp is rendered');
    //        return;
    //    }
    //    element.addEventListener("click", blockDocument, true);
    //    element.addEventListener("mousedown", blockDocument, true);
    //    element.addEventListener("touchstart", blockDocument, true);
    //    element.addEventListener("touchmove", blockDocument, true);
    //
    //    $('.loading-message').addClass('blocking');
    //}
    //
    //function unblockUI() {
    //    var element = Capriza.fullScreen ? document : $(".viewport")[0];
    //    element.removeEventListener("click", blockDocument, true);
    //    element.removeEventListener("mousedown", blockDocument, true);
    //    element.removeEventListener("touchstart", blockDocument, true);
    //    element.removeEventListener("touchmove", blockDocument, true);
    //
    //    var $loadingMessage = $('.loading-message');
    //    $loadingMessage.loadingMessage('option', 'topHeader', '');
    //    $loadingMessage.removeClass('blocking');
    //}

    Dispatcher.on("app/initMessages", function () {
//    setTimeout(function () {
        if (!$('.viewport .loading-message')[0]) {
            Capriza.LoadingManager = {};
            $('.viewport').append($('<div></div>').loadingMessage().css('visibility', 'hidden'));
            $('.loading-message').loadingMessage('hide', function () {
                $('.loading-message').css('visibility', 'visible');
            });
        }
    });
//    }, 500);

    Dispatcher.on('message/show', function (options) {

        // Format the passed in options to work with the loading message
        var text = options.buttonText;
        var callback = options.buttonAction;
        var actions = [
            {text: text, callback: callback}
        ];

        // Determine whether we should show the loading indicator
        var shouldShowLoadingIndicator = true;
        if (text) {
            shouldShowLoadingIndicator = false;
        }

        // Update the options object
        options['actions'] = actions;
        options['shouldShowLoadingIndicator'] = shouldShowLoadingIndicator;

        // Refresh the loading message
        $('.loading-message').loadingMessage('update', options);
//        $('.loading-message').loadingMessage('show');
    });


    Dispatcher.on('message/slowNetworkMsg', function (options) {

        if (window.location.hash.indexOf('devmode') > -1 || window.testMode) return;
        if (window.isDesignerPreview) return;
        Logger.tag("slowConnection");

        Dispatcher.trigger('message/showCustom', {message: Capriza.translator.getText(Capriza.translator.ids.slowConnection), shouldShowLoadingIndicator:false})
    });

    Dispatcher.on('message/showCustom', function (options) {

        // Refresh the loading message
        $('.loading-message').loadingMessage('update', options);
    });

    Dispatcher.on("loading/stopBlocking", function () {
        Utils.unblockUI();

        if(this.enableRocketman) {
            clearTimeout(this.rocketmanTimer);
            delete this.rocketmanTimer;
            if (this.rocketmanActive) {
                RocketmanSplash.hideSplash();
                delete this.rocketmanActive;
            }
        }
    });


    Dispatcher.on("loading/stop", function () {
        this.loading = false;
        $('.loading-message').loadingMessage('hide');
        Utils.unblockUI();

        if(this.enableRocketman) {
            clearTimeout(this.rocketmanTimer);
            delete this.rocketmanTimer;
            if (this.rocketmanActive) {
                RocketmanSplash.hideSplash();
                delete this.rocketmanActive;
            }
        }
    });

    Dispatcher.on("loading/start", function (options) {
        if (!Utils.shouldShowLoadingOnMVP() && (Utils.isCachedMVPShown() || Utils.isUnimessageShown() || $('#context-not-found').length > 0)) return;
        this.loading = true;
        options = options || {};

        if (!options.nonBlocking) {
            Utils.blockUI(options);
        }

        // if were on splash dont display loading message

        if (Capriza.designerMode && Capriza.designerMode === "simplify") return;
        if(!Capriza.splashing) {

            var $loadingMessage = $('.loading-message');
            $loadingMessage.loadingMessage('update', _.extend(options, {
                topHeader: "",
                iconOnly: !((options && options.message) || Utils.isCachedBlueprintShown()),
                actions: []
            }));
            Utils.removeViewportOverlayForElement("irrecoverable-message");
            $loadingMessage.removeClass('irrecoverable-message');
            $('.loading-message-buttons', $loadingMessage).remove();
        }
    });

    Dispatcher.on("loading/showOnMVP", function(options){

    });

    Dispatcher.on('dialog/show', function (options) {

        // Parse the options to format for the loading message widget
        var topHeader = '',
            message = '',
            actions = [],
            shouldShowLoadingIndicator = false;
        if (options.msg) {

            if (options.msg.indexOf('terminated') > -1) {
                message = Capriza.translator.getText(Capriza.translator.ids.disconnectedDueTo);
            } else if (options.msg.indexOf('inactive') > -1) {
                //message = 'Sorry, your connection has either been lost or is temporarily unavailable. Please try again later or use the desktop version, if applicable.';
                topHeader = Capriza.translator.getText(Capriza.translator.ids.sorryLostConnection);
                message = Capriza.translator.getText(Capriza.translator.ids.tryAgainLater);
            } else if (options.msg.toLowerCase().indexOf('replay') > -1) {
                //message = 'The application failed due to network issues. Try to connect again.';
                message = Capriza.translator.getText(Capriza.translator.ids.networkIssues);
            }else if (options.msg.toLowerCase().indexOf('inactivity') > -1) {
                //message = 'The application failed due to network issues. Try to connect again.';
                message = Capriza.translator.getText(Capriza.translator.ids.disconnectedDueTo);
            } else {
                message = options.msg;
            }
        }

        if (options.vpnAlert) {
            topHeader = 'Connecting to VPN...';
            message = 'One moment please.';
            shouldShowLoadingIndicator = true;
        }
        if (options.ie) {
            topHeader = 'Please Switch Browsers';
            message = 'We currently do not support IE.'
        }

        if (options.refreshButton === undefined) options.refreshButton = true;
        if (options.refreshButton) {
            actions[0] = {
                text: Capriza.translator.getText(Capriza.translator.ids.reconnect),
                callback: function () {
                    Utils.reload();
                }
            };
        }

        var $loadingMessage = $('.loading-message');
        $loadingMessage.loadingMessage('clear');
        $loadingMessage.loadingMessage('update', {
            topHeader: topHeader,
            iconOnly: false,
            message: message,
            actions: actions,
            shouldShowLoadingIndicator: shouldShowLoadingIndicator
        });

        if (options.refreshButton) {
            Utils.viewportOverlayForElement("irrecoverable-message");
            $loadingMessage.addClass('irrecoverable-message');
            $loadingMessage.transition({y: 0});
        }
    });

    Dispatcher.on('dialog/hide', function (options) {
        $('.loading-message').loadingMessage('hide');
    });


    function exposeApi(widget) {
        _.extend($.capriza, {

            showLoadingMsg: function (isClient, options) {
                widget.update(isClient, options);
            },

            hideLoadingMsg: function () {
                widget.hide();
            }
        });
    }

    var emptyFunc = function () {
    };
    exposeApi({ show: emptyFunc, hide: emptyFunc });

    $.widget("capriza.loadingMessage", {

        options: {
            topHeader: "", /* Message title */
            message: "", /* Loading bar text */
            iconOnly: false,
            actions: [
//                {text: 'Button 1', callback: function (){}}
            ], /* Action performed on button click */
            shouldShowLoadingIndicator: true, /* Whether or not to show the loading spinner */
            duration: 1000                                          /* How long to display the loading indicator */
        },

        // Create the basic loading message container structure
        _create: function () {

            // Complete the loading message template with the options hash
            // and append it to the widget element
            this.element.addClass('loading-message with-animation').addClass('clearfix');
            this._renderTemplate();

            this.displayMessages = [];
            this.displayMessages.push(Capriza.translator.getText(Capriza.translator.ids.almostThere));
            this.displayMessages.push(Capriza.translator.getText(Capriza.translator.ids.fewMoreMoments));
            this.displayMessages.push(Capriza.translator.getText(Capriza.translator.ids.gettingThere));
            this.displayMessages.push(Capriza.translator.getText(Capriza.translator.ids.stillWorking));

            // Set up the widget to respond to Capriza hide and show messages
            exposeApi(this);
        },

        _renderTemplate: function() {
            var _this = this;

            // xperiaZ makes the loading indicator to jitter. ticket #8500
            var xperiaZModels = ["C6603", "C6602"];
            if (Capriza.device.stock && (Capriza.device.xperiaZ || Capriza.device.xperiaS)){
                this.options.shouldShowLoadingIndicator = false;
            }

            // Build the handlebars template
            this.element.html(Handlebars.templates['loadingMessage'](this.options));

            // the loading indicator doesn't render well in linux designer
            if (window.isDesignerPreview && navigator.platform == "Linux x86_64") {$('.loading-indicator', this.element).addClass('designer-linux-loading-indicator')}

            // Add functionality to the buttons
            this.element.find('.loading-message-buttons li').each(function (index, button) {
                var callback = _this.options.actions[index].callback;
                $(button).click(function() {
                    callback.apply();
                });
            });

        },

        // Refresh the loading message view when options are changed
        option: function (optionName, value) {

            // Update the options
            this._super(optionName, value);

            // Refresh the view
            this.update(undefined, true);
        },

        // Update the widget with the current options
        update: function (options, skipShow) {
            var _this = this;

            if (options && options.message == "Automating..." && !this.showingIcon && options.maxAutomations != undefined){
                _this.automating = true;
                // on MVP page we don't need to display the "Still working..." message
                var firstMessage = Utils.isCachedMVPShown() ? 2 : 3;
                var numberOfAutomationLeft = !options.maxAutomations ? 0 : (options.maxAutomations > firstMessage ? firstMessage : options.maxAutomations);
                options.message = this.displayMessages[numberOfAutomationLeft];

                if (this.suppressTimeout){
                    clearTimeout(this.suppressTimeout);
                }
            }
            if (options && options.iconOnly){
                options.message = Capriza.translator.getText(Capriza.translator.ids.workingOnIt);
            }

            //we use this to show the last message that arrived within the suppress messages timeout
            if (options && options.message){
                this.newMessageAvailable = true;
                Logger.debug("[Loading-Message] General set message text: " + options.message);
            }

            // Update the options
            this._setOptions(options);

            if (this.suppressMessages || (Utils.isCachedBlueprintShown() && !(options && options.message))) return;

            if (options && options.message){
                this.newMessageAvailable = false;
                Logger.debug("[Loading-Message] General will show message text: " + options.message);
            }
            // Refresh the view
            this.element.empty();

            // Hide the indicator while we update its contents
            if (this.element.hasClass('hidden')){
                var prevVisibility = this.element.css('visibility');
                this.element.css('visibility', 'hidden');
                _this._renderTemplate();
                _this.hide(function () {
                    if (!skipShow) {
                        _this.element.css('visibility', 'visible');
                        _this.show('', _this.options);
                    } else _this.element.css('visibility', prevVisibility);
                });
            } else {
                _this.suppressMessages = true;
                _this.longStep.call(_this);
                if (_this.suppressTimeout){
                    clearTimeout(_this.suppressTimeout);
                }
                _this.suppressTimeout = setTimeout(function(){
                    _this.suppressMessages = false;
                }, _.random(3900,4900));
                _this._renderTemplate();
            }

        },

        // for long steps add a message after 5 seconds
        longStep: function(timeout){
            var _this = this;
            timeout = timeout || 9000;
            if (_this.longStepTimeout){
                clearTimeout(_this.longStepTimeout);
            }
            if (_this.automating) {
                _this.longStepTimeout = setTimeout(function () {
                    _this.suppressMessages = false;
                    if (_this.newMessageAvailable){
                        _this.update();
                    } else {
                        _this.option("message", Capriza.translator.getText(Capriza.translator.ids.takingLonger));
                    }
                    _this.suppressMessages = false;
                }, timeout);
            }
        },

        runSingleStepMessages: function(){
            function setNextMessage(messageIndex, timeout, nextTimeoutCallback){
                _this.suppressTimeout = setTimeout(function () {
                    if (_this.element.hasClass('hidden')){
                        clearTimeout(_this.suppressTimeout);
                        return;
                    }
                    var options = {
                        message: Capriza.translator.getText(Utils.singleStepMessages[messageIndex]),
                        iconOnly: false
                    };
                    Logger.debug("[Loading-Message] showing single step next message: "+ options.message);
                    _this.suppressMessages = false;
                    _this.update.call(_this, options);
                    _this.longStep.call(_this);
                    nextTimeoutCallback && nextTimeoutCallback();
                }, timeout);
            }
            var _this = this;

            setNextMessage(1, 5000, setNextMessage.bind(_this, 2, 4000, setNextMessage.bind(_this, 3, 6000,  function(){setTimeout(function () {
                    _this.suppressMessages = false;
                }, _.random(3500, 4500))}
            )));
        },

        // Bring the loading indicator into view
        show: function (isClient, options) {
            // avoid showing two loading indications at once (identity page & generic) but allowing error messages
            if ($("#identity-page.active #splash-message.active").length > 0  && this.options.shouldShowLoadingIndicator) return;

            if (!Utils.shouldShowLoadingOnMVP() && ($('.page.mvp').length > 0 || $(".page.blueprint").length > 0)) return;

            var _this = this;
            $.extend(this.options, options);
            this.element.removeClass('hidden');
            this.suppressMessages = true;
            if (this.options.iconOnly){
                this.element.addClass("um-icon-only");
                this.showingIcon = true;
                if (this.suppressTimeout){
                    clearTimeout(this.suppressTimeout);
                }
                this.suppressTimeout = setTimeout(function () {
                    _this.showingIcon = false;
                    _this.element.removeClass("um-icon-only");
                    _this.longStep.call(_this);
                    if (_this.options.maxAutomations) {
                        _this.suppressTimeout = setTimeout(function () {
                            _this.suppressMessages = false;
                        }, _.random(3500, 4500));
                    } else {
                        _this.runSingleStepMessages.call(_this);
                    }
                }, 6000);
            } else {
                this.longStep.call(this);
                if (this.suppressTimeout){
                    clearTimeout(this.suppressTimeout);
                }
                this.suppressTimeout = setTimeout(function(){
                    _this.suppressMessages = false;
                }, _.random(3900,4900));
            }
            if (Utils.shouldShowLoadingOnMVP()){
                this.element.removeClass("with-animation");
                this.element.css("transform", "translate(0px, 0px)");
                this.element.addClass("with-animation");
                Utils.hideUnimessages(true);
            } else {
                Utils.hideUnimessages();
                if (!this.element.hasClass('animating')){
                    _this.element.addClass('animating');
                    setTimeout(function () {
                        _this.element.transition({y: 0}, function () {
                            _this.element.removeClass('animating');
                        });
                    }, 10);
                }
            }

            this._configureTimer(isClient || this.options.isClient);
        },

        // Slide the loading indicator out of view
        hide: function (callback) {
            var _this = this;
            this.isServer = undefined;

            if (this.options.waitForNewPage && this.options.isSingleStep && this.options.singleStepMessageTimeout) {
                Logger.debug("Clearing single step timeout");
                clearTimeout(this.options.singleStepMessageTimeout);
            }

            this.clear();
            if (this.element.hasClass('hidden')) {
                callback && callback.apply(_this, arguments);
                return;
            }

            var offset = this.element.height();

            this.element.transition({y: offset}, function () {
                _this.element.removeClass("um-icon-only");
                _this.element.addClass('hidden');
                Dispatcher.trigger("loadingMessage/hide/end");
                if (callback) {
                    callback.apply(_this, arguments);
                }
            });

            Utils.removeViewportOverlayForElement("irrecoverable-message");
        },

        clear: function(){
            this.suppressMessages = false;
            this.automating = false;
            clearTimeout(this.suppressTimeout);
            clearTimeout(this.longStepTimeout);
            clearTimeout(this.timeoutId);
        },

        // Configure the timer that controls how long the loading indicator should display
        _configureTimer: function (isClient) {
            clearTimeout(this.timeoutId);
            if (isClient && !this.isServer) {
                var self = this;
                if (this.options.duration)
                    this.timeoutId = setTimeout(function () {
                        self.timeoutId = undefined;
                        self.hide();
                    }, this.options.duration);
            } else if (!isClient) {
                this.isServer = true;
            }
        }
    });

    var RocketmanSplash = Capriza.RocketmanSplash = {
        showSplash: function () {
            var $rocketman = Handlebars.templates.rocketman({msg: Capriza.translator.getText(Capriza.translator.ids.rocketMsg)});
            $('.context-page.active').append($rocketman);

            setTimeout(function () {
                // Fade in message
                $('.background-white .message').addClass('active');
            }, 300);

            // Style the rocketman
            $('.rocketman').velocity({
                translateX: $('.viewport').width() * 1.5 - 50
            }, {
                duration: 300,
                delay: 150,
                complete : function() {
                    $('.rocketman').addClass('active');
                }
            });
        },

        hideSplash: function () {
            $('.rocketman').velocity({
                translateX: $('.viewport').width() * 2
            }, {
                duration: 300,
                begin: function () {
                    $('.background-white .message').removeClass('active');
                },
                complete: function () {
                    $('.rocketman').remove();
                    $('.background-white').removeClass('active');
                    $('.background-white').remove();
                }
            });
        }
    };

})();


}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/ToastManager.js

try{
/**
 * Created by oriharel on 1/9/15.
 */

;(function() {

    Capriza.Toast = {
        show: function(options) {

            var brand = Utils.getBrand();

            if (brand) {
                options = _.extend({primaryColor: brand['primary-color']}, options);
            }
            else {
                options = _.extend({primaryColor: '#888'}, options);
            }

            var $toastEl = $('.toast');
            clearTimeout(Capriza.Toast._hideTOHandler);
            if(options.blockUI){
                Capriza.Toast.block();
            }

            if ($toastEl.length > 0) {
                this.update($toastEl, options);
            }
            else {
                $toastEl = $(Handlebars.templates['toast'](options));

                //$toastEl.css('y', 100);
                $('.viewport').append($toastEl);
                $toastEl.velocity({
                    translateY: 80
                }, {
                    duration: 50,
                    easing: 'out',
                    complete: function() {
                        $toastEl.removeClass('hidden');
                    }
                }).bind(this)
                    .velocity({
                        translateY: -4
                    }, {
                        duration: 250,
                        easing: 'out'
                    }).bind(this)
                    .velocity({
                        translateY: 0
                    }, {
                        duration: 250,
                        easing: 'ease-in-out'
                    }).bind(this);
            }

            var actionHidden = options.toastActionText === undefined;
            $('.toast-action-container', $toastEl).toggleClass('hidden', actionHidden);

            var timedCallback = function() {
                setTimeout(function(){
                    options.toastActionCallback();
                }, 100);
            };

            if (!actionHidden) {
                $toastEl.off('click').on('click', timedCallback);
                $('.toast-action-container', $toastEl).on('click', function(){
                    $(this).addClass('clicked');
                });
            }


            this.fixRotating($toastEl, options);

            if(options.hideAfter){
                Capriza.Toast._hideTOHandler = setTimeout(function(){
                    Capriza.Toast.hide();
                },options.hideAfter);
            }
        },

        update: function($toastEl, options) {

            $('i', $toastEl).removeClass().addClass(options.toastIconClass);
            $('.text-major', $toastEl).text(options.textMajor || '');
            $('.text-minor', $toastEl).text(options.textMinor || '');
            $('.toast-action', $toastEl).html(options.toastActionText || '');
        },

        fixRotating: function($toastEl, options) {

            var rotatingSvg = document.getElementById("rotatingSvg");

            if (options.toastIconClass === 'rotating icon-loading') {
                $('i', $toastEl).addClass('hidden');
                rotatingSvg.setAttribute('class', 'special-spinner');
            }
            else {
                $('i', $toastEl).removeClass('hidden');
                rotatingSvg.setAttribute('class', 'special-spinner hidden');
            }
        },

        hide: function(options) {
            var $toastEl = $('.toast');

            $toastEl.velocity({
                translateY: 80
            }, {
                duration: 250,
                easing: 'out',
                complete: function() {
                    $toastEl.remove();
                }
            });
            Capriza.Toast.unblock();
        },

        isShown: function(){
            return !!$('.toast')[0];
        },

        isBlocking: function(){
            return Capriza.Toast.isShown() && Capriza.Toast._blocked;
        },

        block: function(){
            Capriza.Toast._blocked = true;
            Utils.blockUI();
        },

        unblock: function(){
            Capriza.Toast._blocked = false;
            Utils.unblockUI();
        }
    }


})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/pageManager.js

try{
/**
 * Created by JetBrains WebStorm.
 * User: yuval
 * Date: 10/4/11
 * Time: 9:38 AM
 */

(function(){

//on simulate mode the engine logger is injected instead of this dummy logger
    try {
        Element.to_s = function(node) {
            if (!node) return "NONE";
            if (node.nodeType === 3) return "#text:" + node.nodeValue;
            if (node.nodeType === 1) return node.tagName + (node.id ? "#" + node.id : "") + (node.getAttribute("class") ? "." + node.getAttribute("class").split(" ").join(".") : "");
        };
    } catch(ex) {}


    function setZoom(toEnabled) {
        var $meta = $("meta[name='viewport']"), val = toEnabled ? "yes" : "no";
        if ($meta.length) {
            var content = $meta.attr("content"), newContent = [];
            content = content.split(",");
            for (var i = 0, ii = content.length; i < ii; i++) {
                if (!/(user-scalable|((minimum|maximum)-scale))/.test(content[i]))
                    newContent.push(content[i]);
            }
            val = "user-scalable=" + val;
            newContent.push(val);
            if (!toEnabled) {
                newContent.push("minimum-scale=1,maximum-scale=1");
            } else {
                newContent.push("minimum-scale=0.1,maximum-scale=10");
            }
            newContent = newContent.join(",");
            $meta.attr("content", newContent);
        } else {
            $("head").prepend("<meta>", { name: "viewport", content: "user-scalable=" + val });
        }
    }

    window.pageManager = {
        enableZoom: function() {
            setZoom(true);
        },

        disableZoom: function() {
            setZoom(false);
        },

        currentControls: [],

        onBackClick: function() {

            if ($.capriza.activePage.hasClass("page mini-browser active")) {
                $.capriza.backPage({ transition: "slide" });
                $("#mini-browser").attr("src", "");
                Dispatcher.trigger("miniBrowser/hide");
                return;
            }

            var pageView = $.capriza.activePage.data("pageView"), pageModel = pageView && pageView.model;

            // TODO: roadblock 29/9/2013 this should be erased (no backable and popoup anymore)
            if (pageModel && pageModel.get("backable")) {
                this.triggerEvent({ type: "back" });
                return;
            }
            // TODO: end of roadblock to-be-erased section

            if (pageModel && pageModel.get("backControl")) {
                this.triggerEvent({ type: "back", id: pageModel.get("backControl").id });
                $.capriza.showLoadingMsg();
                return;
            }

            // TODO: roadblock 29/9/2013 this should be erased (no backable and popoup anymore)
            if (pageModel && pageModel.get("popup")) {
                this.triggerEvent({ type: "close" });
                return;
            }
            // TODO: end of roadblock to-be-erased section


            if (pageModel && pageModel.tableDrill && !Capriza.device.isTablet) {
                $.capriza.backPage({ transition: "slide" });
                return;
            }

            $.capriza.backPage();
        },

        setRTL: function(isRTL) {
          Capriza.isRTL = isRTL;
        },

        generateDialog: function(response) {
            function doGenerateDialog() {
                Dispatcher.trigger("application/dialog/before");
                var dialogPage = $("<div>").cdialog(response);
                dialogPage.on("cdialogok", function(e, data) {
                    if(!response.clientOnly){
                        response.retVal = true;
                        response.value = data.value || response.value;
                        response.username = data.username || response.username;
                        response.password = data.password || response.password;
                        var event = {
                            type : 'closeDialog',
                            dialog : response
                        };
                        _this.triggerEvent(event);
                    }
                    $.capriza.currentDialog = undefined;
                });
                dialogPage.on("cdialogcancel", function(e, data) {
                    if(!response.clientOnly){
                        var event = {
                            type : 'closeDialog',
                            dialog : response
                        };

                        _this.triggerEvent(event);
                    }
                    $.capriza.currentDialog = undefined;
                });
                $.capriza.currentDialog = dialogPage;

                Dispatcher.trigger("application/dialog");
            }

            var _this = this;
            try {
                if ($.capriza.activePage && $.capriza.activePage.prop("id") && $.capriza.activePage.prop("id").indexOf("dialogpmt") > -1 &&
                    $.capriza.currentDialog){
                    $.capriza.currentDialog.remove();
                    $.capriza.currentDialog = undefined;
                }
            }
            catch (ex) {
                Logger.error('Error');
            }

            doGenerateDialog();
        },

        generateError: function(options) {
            function hideError() {

                errorMsg.removeClass("shown");
                errorMsg.one("transitionend webkitTransitionEnd", function() {
                    errorMsg.removeClass("active");
                });

                $(document).unbind("pagechange", hideError);
            }

            function onScrollWindow() {
                errorMsg.css("top", top);
                $(window).unbind("scroll", onScrollWindow);
            }

            options || (options = {});
            var top = 0;

            if (options.errorType && options.errorType == 'connectionLost' &&  Utils.isCachedBlueprintShown() && $(".unimessage").length) return;

            if (options.reconnect) {
                Logger.warn('got a reconnect error msg '+options.reconnect+' '+options.msg);
            } else {
                if ((Capriza.cordova || Capriza.isPhonegap) && Capriza.isStore &&
                    (
                        options.msg.indexOf('terminated') > -1 ||
                        options.msg.indexOf('handshake') > -1 ||
                        options.msg.indexOf('inactive') > -1 ||
                        options.msg.indexOf('inactivity') > -1 ||
                            options.closeZapp
                    )) {
                    Dispatcher.trigger('app/close', {Timeout: true});
                    Logger.error('got disconnection message from the relay, send logs');
                } else {
                    Dispatcher.trigger("loading/stopBlocking");
                    Dispatcher.trigger('dialog/show', options);
                }
            }
        },

        hideReconnectingMessage: function() {
        },

        generateErrorPage: function(response) {
            try {
                //Logger through an exception and splash was stuck so, trying.
                var loglevel = response.fatal ? "error" : "debug";
                var msg = 'got error ';
                if(typeof response === "string"){
                    msg += response;
                }
                else{
                    msg += response.reason;
                }

                Logger[loglevel](msg, undefined, response.errorType);

            }
            catch (exc) {}

            if (response.nonFatal) {
                this.generateError({ msg: response.reason, errorType: response.errorType });
            } else {
                var error = {
                    pageId: "errorPage"
                };

                if (response.page) {
                    if (response.page.id)
                        error.pageId += response.page.id;

                    // TODO this API is obsolete and this whole method (generateErrorPage) should be dusted off ASAP
                    if (response.page.backable || response.page.popup) {
                        error.pageId += "_backable";
                        error.addBackButton = true;
                    }
                }

                if (response.vpnAccess) {
                    Dispatcher.trigger('dialog/hide');
                    appData.skipVpnError = true;
                    Logger.debug('app has vpn access ('+response.data+')');

                    var errorMesage = 'This Zapp may be private to a specific organization and as such, requires a VPN connection.' +
                        ' Please contact your system administrator for instructions how to install a VPN client on your device.<br><br><div id="refresh-msg-div">The app will refresh itself in<div id="refresh-counter">5 seconds</div></div>';

                    var refreshFunc = function() {
                        appData.skipVpnError = false;
                        Utils.reload();
                    };
                    var renderAction = function(){

                        var clearInter = function() {
                            clearInterval(intervalId);
                        };

                        var counter = 5;
                        var intervalId = setInterval(function(){
                            var refreshCounterElement = $('#refresh-counter');
                            $(refreshCounterElement).text(counter-1+' seconds');
                            counter--;
                            if (counter === 0 && $(refreshCounterElement).length > 0) {
                                refreshFunc();
//                            }
//                            if (counter === -1) {
                                clearInter();
                            }
                        }, 1000);
                    };

                    var messageOptions={
                        topHeader:"VPN Connection Unavailable",
                        message:errorMesage,
                        buttonText:"Cancel",
                        buttonAction:function(){
                            $('#refresh-msg-div').empty();
                            var btnElement = $('.button');
                            $(btnElement).text('Retry');
                            $(btnElement).click(function(){
                                refreshFunc();
                            });

                        },
                        renderAction: renderAction
                    };

                    Dispatcher.trigger("message/show",messageOptions);
                }
                else {

                    var $page = $(Handlebars.templates.errorPage(error));
                    var content = $page.children("div[data-role='content']");
                    content.append($("<div></div>").text(response.reason));
                    if (response.errorImg) {
                        var image = {
                            src: response.errorImg,
                            width : '100%'
                        };
                        content.append($(Handlebars.templates.image(image)));
                    }

                    if (response.page && response.page.backable) {
                        $("#customBackBtn_" + error.pageId, $page).click(function() {
                            // TODO: check how to reset the zoom (setting maximum-scale doesn't work)
                            // pageManager.disableZoom();
                            pageManager.onBackClick();
                        });
                    }

                    $page.appendTo('.viewport');
                    $.capriza.changePage($page);
                    // Check that Utils exists just in case the error occurred before loading the Utils
                    if (window.Utils) {
                        var message = {
                            type: "error",
                            messageText: Capriza.translator.getText("unHandleErrorTitle"),
                            detailText: Capriza.translator.getText("unHandleErrorMsg"),//"An error occurred",
                            actionText: Capriza.translator.getText("reload"),
                            action: Utils.reload
                        };
                        if (Capriza.isStore) {
                            message.extraActionText = Capriza.translator.getText("back");
                            message.extraAction = Utils.backToList;
                        }
                        Utils.updateUnimessage(message, false, true);
                    }
                    pageManager.enableZoom();
                }
            }
        },

        updateControls: function(controlChanges) {
            _.each(controlChanges, function(update) {
                var model = Capriza.Model.Control.getById(update.id);
                if((Utils.isCachedMVPShown() || Utils.wasCachedMVPShown()) && Capriza.mcLastMobId[update.id] !== update.lastMsgId) { // TODO: make this work for all pages and not just MVP++ after dror implement in engine
                    Logger.debug("Discard unsync'ed (mvppp) controlUpdate for " + update.id + " lastId : "+Capriza.mcLastMobId[update.id] + " this id: " + update.lastMsgId);
                    return;
                }
                if (!model) return;
                if (update.validationError) {
                    model.set("validationMessage", update.validationMessage);
                } else {
                    var controls = update.data.controls;
                    delete update.data.controls;
                    model.set(update.data);
                    controls && model.setControls(controls);
                }
                model.trigger("control/updated");
            });
        },

        refreshControls: function(controls) {
            Logger.trace('refreshControls started with '+controls);

            if (typeof controls !== 'object') {
                controls = JSON.parse(controls);
            }

            if (!(controls instanceof Array)) controls = [controls];
            controls.forEach(function(control) {
                var model = Capriza.Model.Control.getById(control.id);
                if (!model) {
                    Logger.error('No Model found for '+control.id);
                    return;
                }

                Logger.debug('refreshing '+control.id);

                var newModel = new Capriza.Model.Control(control, { parent: model.parent });

                newModel.addPage(model.pages);

                _.each(model.pages, function(page) {
                    page.trigger("page/controlModified", model.get("id"));
                });
            });
            Dispatcher.trigger("page/update/after", {pageView: $.capriza.activePage.data('pageView')});
        },

        addLogo: function(url) {
            var img = new Image();
            img.src = url;
            $(".capriza-logo").fadeOut(function() { $(this).remove(); });
            var logoArea = $("<div class='capriza-logo'></div>").append(img).hide();
            $(".ui-mobile-viewport").addClass("has-logo").prepend(logoArea.fadeIn());
        },

        /**
         * protocol is as follows:
         * 2 options are possible:
         *
         * 1) initial download message indicates that download is ready (pending=false), so we show the download dialog
         *
         * 2) initial download message indicates that download is NOT ready (pending=true), so we show a dialog saying "preparing download..."
         *    when another message comes with pending=false/undefined, then we change the dialog to the download dialog.
         *
         * @property resultType - always "download"
         * @property pending - boolean
         * @property src - the URL to download from. Also used as the unique ID for the download (for additional messages - pending/failed etc.)
         * @property suggestedFilename
         * @property failed - true indicates that the download failed
         */
        downloadFile: function(response) {

            var $dialog, download = Capriza.downloads[response.src] || {}, filename = response.suggestedFilename;

            if (!filename) {
                var srcArr = response.src.split("/");
                filename = decodeURIComponent(srcArr[srcArr.length - 1]);
            }

            if (response.failed) {
                $dialog = download["$dialog"];
                if ($dialog && $dialog.length) {
                    clearInterval(download.waitInterval);
                    delete download.waitInterval;
                    $dialog && $dialog.cdialog("setText", _.sanitize(filename) + "<br><br>Download has failed :-(").off("cdialogcancel", download["cancelDownload"]);
                    $(".dialog-content", $dialog).addClass("error");
                }

                return;
            }

            if (!response.pending) {
                if (Capriza.cancelDownloads[response.src]){
                    return;
                }

                $dialog = download["$dialog"];
                var text = "You are about to open :<br><br><b>" + _.sanitize(filename) + "</b><br><br>Are you sure?";
                if ($dialog && $dialog.length) {

                    clearInterval(download.waitInterval);
                    delete download.waitInterval;
                    $dialog.cdialog("setText", text).cdialog("enable").off("cdialogcancel", download["cancelDownload"]);
                    $(".dialog-ok button, .dialog-ok", $dialog).removeClass("disabled");
                    var timeout = setTimeout(function() {
                        $(".dialog-ok button, .dialog-ok", $dialog).addClass("disabled");
                        $(".dialog-content", $dialog).addClass("error");
                        $dialog.cdialog("setText", "You are about to open :<br><br><b>" + _.sanitize(filename) + "</b><br><br>Download timeout, please try again");
                    }, 90000);
                    $dialog.on("cdialogok", function() {

                        Utils.Links.openExternal(response.src, filename);
                        clearTimeout(timeout);
                    });

                } else {

                    $dialog = $("<div>").cdialog({ type: "confirm", header: "Open File", text: text, transition: "none", id: Date.now() })
                        .on("cdialogok", function() {
                            Logger.debug('clicking ok on dialog');
                            Utils.Links.openExternal(response.src,filename);
                        });

                }


            } else {

                var cancelDownload = function() {
                    pageManager.triggerEvent({ "type" : "cancelDownload", "src": response.src });
                };
                delete Capriza.cancelDownloads[response.src];

                $dialog = $("<div>").cdialog({ type: "confirm", header: "Open File", text: filename + "<br><br>preparing download&nbsp;&nbsp;&nbsp;&nbsp;", transition: "expand", id: Date.now() })
                    .on("cdialogcancel", function() {
                        cancelDownload();
                        clearInterval(interval);
                        delete Capriza.downloads[response.src];
                        Capriza.cancelDownloads[response.src] = true;
                    });

                $(".dialog-ok button, .dialog-ok", $dialog).addClass("disabled");

                var counter = 1;
                var interval = setInterval(function() {
                    var msg = filename + "<br><br>preparing download";
                    for (var dotsCount = 0 ; dotsCount < counter; dotsCount++) msg += '.';
                    for (var i = 0; i < 4 - counter; i++) msg += "&nbsp;";
                    $dialog.cdialog("setText", msg);
                    counter++;

                    if (counter > 4) {
                        counter = 0;
                    }
                }, 500);

                Capriza.downloads[response.src] = {
                    "waitInterval": interval,
                    "$dialog": $dialog,
                    "cancelDownload": cancelDownload
                };
            }
        }
    };

    Capriza.downloads = {};
    Capriza.cancelDownloads = {};

    var errorMsg;

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/widgets/widgets.js

try{
(function($) {

    var testElement = document.createElement('div');

    var transformPrefix = "transform" in testElement.style ? "transform" : "webkitTransform";
    var transformProperty = $.capriza.transformProperty = transformPrefix === "webkitTransform" ? "-webkit-transform" : "transform";

    //wont work on input like '<div class=">fff">'
    _.sanitize = function (text) {
        if (typeof text == "string") {
            return text.replace(/<br\/?>/ig, " ").replace(/(<([^>]+)>)/ig, "");
        }
        return null;
    };

    var mapping = {"ban-circle":"ban","bar-chart":"bar-chart-o","beaker":"flask","bell-alt":"bell","bell":"bell-o","bitbucket-sign":"bitbucket-square","bookmark-empty":"bookmark-o","building":"building-o","calendar-empty":"calendar-o","check-empty":"square-o","check-minus":"minus-square-o","check-sign":"check-square","check":"check-square-o","chevron-sign-down":"chevron-circle-down","chevron-sign-left":"chevron-circle-left","chevron-sign-right":"chevron-circle-right","chevron-sign-up":"chevron-circle-up","circle-arrow-down":"arrow-circle-down","circle-arrow-left":"arrow-circle-left","circle-arrow-right":"arrow-circle-right","circle-arrow-up":"arrow-circle-up","circle-blank":"circle-o","cny":"rub","collapse-alt":"minus-square-o","collapse-top":"caret-square-o-up","collapse":"caret-square-o-down","comment-alt":"comment-o","comments-alt":"comments-o","copy":"files-o","cut":"scissors","dashboard":"tachometer","double-angle-down":"angle-double-down","double-angle-left":"angle-double-left","double-angle-right":"angle-double-right","double-angle-up":"angle-double-up","download-alt":"download","download":"arrow-circle-o-down","edit-sign":"pencil-square","edit":"pencil-square-o","ellipsis-horizontal":"ellipsis-h","ellipsis-vertical":"ellipsis-v","envelope-alt":"envelope-o","exclamation-sign":"exclamation-circle","expand-alt":"expand-o","expand":"caret-square-o-right","external-link-sign":"external-link-square","eye-close":"eye-slash","eye-open":"eye","facebook-sign":"facebook-square","facetime-video":"video-camera","file-alt":"file-o","file-text-alt":"file-text-o","flag-alt":"flag-o","folder-close-alt":"folder-o","folder-close":"folder","folder-open-alt":"folder-open-o","food":"cutlery","frown":"frown-o","fullscreen":"arrows-alt","github-sign":"github-square","google-plus-sign":"google-plus-square","group":"users","h-sign":"h-square","hand-down":"hand-o-down","hand-left":"hand-o-left","hand-right":"hand-o-right","hand-up":"hand-o-up","hdd":"hdd-o","heart-empty":"heart-o","hospital":"hospital-o","indent-left":"outdent","indent-right":"indent","info-sign":"info-circle","keyboard":"keyboard-o","legal":"gavel","lemon":"lemon-o","lightbulb":"lightbulb-o","linkedin-sign":"linkedin-square","meh":"meh-o","microphone-off":"microphone-slash","minus-sign-alt":"minus-square","minus-sign":"minus-circle","mobile-phone":"mobile","moon":"moon-o","move":"arrows","off":"power-off","ok-circle":"check-circle-o","ok-sign":"check-circle","ok":"check","paper-clip":"paperclip","paste":"clipboard","phone-sign":"phone-square","picture":"picture-o","pinterest-sign":"pinterest-square","play-circle":"play-circle-o","play-sign":"play-circle","plus-sign-alt":"plus-square","plus-sign":"plus-circle","pushpin":"thumb-tack","question-sign":"question-circle","remove-circle":"times-circle-o","remove-sign":"times-circle","remove":"times","reorder":"bars","resize-full":"expand","resize-horizontal":"arrows-h","resize-small":"compress","resize-vertical":"arrows-v","rss-sign":"rss-square","save":"floppy-o","screenshot":"crosshairs","share-alt":"share","share-sign":"share-square","share":"share-square-o","sign-blank":"square","signin":"sign-in","signout":"sign-out","smile":"smile-o","sort-by-alphabet-alt":"sort-alpha-desc","sort-by-alphabet":"sort-alpha-asc","sort-by-attributes-alt":"sort-amount-desc","sort-by-attributes":"sort-amount-asc","sort-by-order-alt":"sort-numeric-desc","sort-by-order":"sort-numeric-asc","sort-down":"sort-asc","sort-up":"sort-desc","stackexchange":"stack-overflow","star-empty":"star-o","star-half-empty":"star-half-o","sun":"sun-o","thumbs-down-alt":"thumbs-o-down","thumbs-up-alt":"thumbs-o-up","time":"clock-o","trash":"trash-o","tumblr-sign":"tumblr-square","twitter-sign":"twitter-square","unlink":"chain-broken","upload-alt":"upload","upload":"arrow-circle-o-up","warning-sign":"exclamation-triangle","xing-sign":"xing-square","youtube-sign":"youtube-square","zoom-in":"search-plus","zoom-out":"search-minus"};

    var widgets = {

        listbox: {

            _create: function() {
                this.element.addClass("listbox").attr("id", this.options.uniqueControlId);

                var valElement = $('<div class="pulldownmenu value"><div class="parent"><span></span><div class="pulldownmenu-icon"></div></div></div>').appendTo(this.element);
                this.proxyElement = $("span", valElement);
                this.selectElement = $('<select id="' + this.options.uniqueControlId + 'select"></select>').appendTo(valElement);

                var self = this;
                if (!this.options.enableMobiscroll) {
                    this.selectElement.on("change", function (e) {
                        self._setTextOnProxy();
                        self._trigger("change", e, { selectedIndex: self.selectElement.prop("selectedIndex") });
                    });
                }

            },

            setSelectedIndex: function(index) {
                var self = this;
                if(Array.isArray(index)){
                    var options = this.selectElement.prop('options');
                    Array.prototype.forEach.call(options, function (option, optionIndex) {
                        option.selected = index.indexOf(optionIndex) > -1;
                    });
                }else{
                    this.selectElement.prop("selectedIndex", index);
                    setTimeout(function() {
                        self.selectElement.prop("selectedIndex", index);
                    }, 0);
                }

                this._setTextOnProxy();
            },

            htmlEncode: function(value) {
                return $('<div/>').text(value).html();
            },

            setItems: function(values) {

                var $select = $('select', this.element);
                $select.empty();

                var selectedIndex = $select.prop("selectedIndex"), self = this;
                _.each(values, function(item) {
                    var option = $('<option value="'+item.id+'">'+self.htmlEncode(item.value)+'</option>');
                    item.disabled && option.prop("disabled", true);
                    $select.append(option);
                });
                $select.prop("selectedIndex", selectedIndex);
                this._setTextOnProxy();
            },

            _setTextOnProxy: function() {
                var selectedIndex = this.selectElement.prop("selectedIndex");
                if (selectedIndex == -1) {
                    this.proxyElement.text("");
                } else {
                    this.proxyElement.text(this.selectElement[0].options[selectedIndex].textContent);
                }

            }
        },

        realButton: {

            _create: function() {

                if (this.element.prop("tagName").toUpperCase() !== "BUTTON") {
                    this.$button = $("<button>").appendTo(this.element);
                } else {
                    this.$button = this.element;
                }

                this.$button.addClass("real-button");
                this.option("$button", this.$button);

                if (!this.element.attr("id")) {
                    this.element.attr("id", this.options.uniqueControlId);
                }

                this.setText(this.options.name || " ");
                if (this.options.subtype) {
                    this.setSubtype(this.options.subtype);
                }
                if(this.options.icon)
                    this.setIcon(this.options.icon);

                this.fastclick = $.capriza.fastClick(this.$button[0], {highlightDuration: 500});

                var self = this;
                this.element.on("click", function(e) {
                    self._trigger("_click");
                    e.stopPropagation();
//                    return false;
                });
            },

            setText: function(text) {
                this.$button.text(_.sanitize(text));
            },

            setSubtype: function(subtype) {
                this.subtype && this.$button.removeClass("btn-" + this.subtype);
                this.subtype = subtype;
                this.$button.addClass('btn-' + subtype);
            },

            setIcon: function(iconClass) {
                var icon = this.$button.children("i");
                if (icon.length==0)
                    icon = $("<i></i> ");

                var newIconClass = iconClass;
//                if (iconClass.indexOf('icon-') > -1) {
//                    newIconClass = this.getNewIcon(iconClass);
//                }

                var iconDisplay = this.options.iconDisplay;
                if (iconDisplay) {
                    icon.attr("class",newIconClass+' '+iconDisplay);
                }
                else {
                    icon.attr("class",newIconClass);
                }


                if (iconDisplay === 'icon_right') {
                    icon.appendTo(this.$button);
                }
                else {
                    icon.prependTo(this.$button);
                }

            },

            getNewIcon: function(oldClass) {

                var iconClassValue = oldClass.replace('icon-', '');
                var newIcon = mapping[iconClassValue];

                if (newIcon) {
                    return 'fa fa-'+newIcon;
                }
                else {
                    return 'fa fa-'+iconClassValue;
                }

            }
        },

        paginatorButton: {
            _init: function() {
                var _this = this;
                this.element.addClass("paginator-button").addClass(this.options.type);
                if (this.options.disabled)
                    this.element.addClass("disabled");
                this.element.on("click", function(e) {
                    if (_this.options.disabled)
                        e.stopPropagation();
                    else {
                        _this.options.disabled = true;
                        _this.element.addClass("disabled");
                        _this._trigger("_click", e);
                    }
                });
            }
        },

        pulldownmenu: {
            _create: function() {
                var _this = this;
                this.$pulldownmenu = this.element;
                var parent = $("<div class='parent'>").appendTo(this.element).on("click", _.bind(this.toggleItems, this));
                var $label = $("<span></span>").text(this.options.name || "").appendTo(parent);
                var icon = $("<div class='pulldownmenu-icon'></div>").appendTo(parent);
                this.element.addClass("pulldownmenu value");

                this._initItems();

                this.fillItems(this.options.items);

                if (typeof this.options.selectedIndex === "number") {
                    this.setSelectedItem(this.options.selectedIndex);
                }
            },

            _initItems: function() {
                var _this = this;
                this.$items = $("<ul class='children'></ul>").appendTo(this.$pulldownmenu);
                this.$items.delegate("li.child", "click", function(e) {
                    widgets.pulldownmenu.hideItems.apply(_this, arguments);
                    var $li = $(this), index = $li.data("index");
                    _this._trigger("_itemclick", e, { value: $li.text(), index: index });
                    if (!_this.options.dontUpdate) {
                        _this.setValue($(this).text());
                        _this.setSelectedItem(index);
                    }
                });
            },

            toggleItems: function(e) {
                this.isOpen ? this.hideItems(e) : this.showItems(e);
                return false;
            },

            showItems: function(e) {
                var self = this;
                this.element.addClass("open");
                var menuHeight = this._calcHeight(this.options.items);
                this.element.addClass("opening");
                this.$items.transition({height: menuHeight, opacity: 1}, 150, 'linear', function(){
                    Dispatcher.trigger("menu/open", this);
                    self.element.removeClass("opening");

                    // #8903. Causes the menu to refresh. Sometimes it is not refreshed and the menu is half-transitioned.
                    self.$items.get(0).getBoundingClientRect();
                });
                this.isOpen = true;
            },

            hideItems: function(e) {
                var _this = this;
                this.element.addClass("closing");
                this.$items.transition({height: 0, opacity: 0}, 150, 'linear', function(){
                    _this.$pulldownmenu.removeClass("open");
                    Dispatcher.trigger("menu/close", this);
                    _this.element.removeClass("closing");
                });
                e.stopPropagation();
                this.isOpen = false;
            },

            fillItems: function(items, container) {
                var self = this;
                container = (container || self.$items);
                container.empty();
                this._setOption("items", items);
                _.each(items, function(item, index) {
                    $("<li class='child'>" + item + "</li>").data("index", index).appendTo(container || self.$items);
                });
            },

            setSelectedItem: function(index) {
                if (typeof index !== 'number') return;

                $("li.child", this.$items).each(function(i, li) {
                    if (index === i) {
                        $(li).addClass("selected");
                    } else {
                        $(li).removeClass("selected");
                    }
                });
            },

            _calcHeight: function(items) {
                var $items = $("<div class='children'></div>").appendTo(this.$pulldownmenu);
                widgets.pulldownmenu.fillItems.call(this, items, $items);
                $items.css("height", "auto");
                var ret = $items.height();
                $items.remove();
                return ret;
            },

            setValue: function(val) {
                $(".parent span", this.element).text(val || "");
            }
        },

        cdialog: {
            _init: function() {
                var _this = this;
                var types = { alert : "Alert", prompt : "Prompt", confirm : "Confirm", promptAuth : "Authentication", promptPassword : "Password" };
                var $body, $content, $buttonBar;

                this.element.attr("id", "dialog" + this.options.id).addClass("cdialog " + this.options.type).addClass("page").data("page", true).appendTo(".viewport");
                $("<div class='dialog-header'><h1 class='value'>" + (this.options.header || types[this.options.type]) + "</h1></div>").appendTo(this.element);
                $body = $("<div>").addClass("dialog-body").appendTo(this.element);
                $content = $("<div class='dialog-content'></div>").html(this.options.text || "").appendTo($body);
                switch (this.options.type) {
                    case "prompt":
                        $('<div class="textbox ss-dss_stdInput"><div class="value"><input type="text" name="dialog-value" id="dialog-value" placeholder="Type here"/></div></div>').appendTo($content);
                        break;
                    case "promptAuth":
                        $('<div class="textbox ss-dss_stdInput"><label for="dialog-username">Username:</label><div class="value"><input type="text" placeholder="Username" id="dialog-username"/></div></div>').appendTo($content);
                    case "promptPassword":
                        $('<div class="textbox ss-dss_stdInput"><label for="dialog-password">Passowrd:</label><div class="value"><input type="password" placeholder="Password" id="dialog-password"/></div></div>').appendTo($content);
                        break;
                    default:
                        break;
                }
                $buttonBar = $("<div class='button-bar'></div>").appendTo(this.element);
                $("<div class='ss-dss_button_full_width ss-dss_allButton ss-dss_bold ss-dss_textButton'><button class='value'><i class='fa fa-check'></i>" + (this.options.okButton || "OK") + "</div>").addClass("dialog-ok").appendTo($buttonBar).on("click", function(e) {
                    if (this.querySelector("button").classList.contains("disabled")) return false;
                    var data = {
                        value: $("#dialog-value", _this.element).val(),
                        username: $("#dialog-username", _this.element).val(),
                        password: $("#dialog-password", _this.element).val()
                    };
                    onDialogButtonPress("ok", e, data);
                });
                if (this.options.type !== "alert") {
                    $("<div class='ss-dss_button_full_width ss-dss_allButton ss-dss_bold ss-dss_textButton'><button class='value'><i class='fa fa-times'></i>Cancel</div>").addClass("dialog-cancel").appendTo($buttonBar).on("click", function(e) {
                        if (this.querySelector("button").classList.contains("disabled")) return false;
                        onDialogButtonPress("cancel", e);
                    });
                }

                function onDialogButtonPress(method, e, data){
                    _this._trigger(method, e, data);

                    // remove the dialog element, not necessarily the last element...
                    var newPages = [];
                    $.capriza.pages.forEach(function(item){
                       if (!item.hasClass('cdialog'))
                            newPages.push(item);
                    });

                    $.capriza.pages = newPages;
                    var latestPage = $.capriza.pages[$.capriza.pages.length - 1];
                    var pageView = latestPage && latestPage.data('pageView');
                    if (pageView) {
                        pageView.show({ transition: _this.options.transition, ignoreModalDrill: true, reverse: true , callback: function(){
                            _this.element.remove();
                        }});
                    }
                    else {
                        _this.element.remove();
                        //also remove it from the active page pointer
                        if ($.capriza.activePage && $.capriza.activePage.hasClass('cdialog')) {
                            $.capriza.activePage = latestPage;
                        }
                    }

                }

                $(".cdialog.active").removeClass("active");
                var modalToModal =  $(".page.active.page-modal").length;
                Capriza.Views.preparePageModal(this.element, {modalToModal: modalToModal});
                if (modalToModal){
                    this.options.transition = "fade";
                }
                $.capriza.changePage(this.element, { transition: this.options.transition, ignoreModalDrill: true, isModal: true});
            },

            setText: function(text) {
                $(".dialog-content", this.element).html(text);
            },

            enable: function() {
                $("button", this.element).removeClass("disabled");
            },

            disable: function() {
                $("button", this.element).addClass("disabled");
            }
        },

        link: {

            options: {
                zoomEffect: null,
                icon: null
            },

            _create: function() {
//                if (this.element.prop("tagName").toLowerCase() !== "a") return;
                this.$text = $("<span>").text(_.sanitize(this.options.name) || " ");
                this.$inner = $("<a class='value styleable-text' href='#'>").append(this.$text);
                this.element.attr("id", this.options.uniqueControlId || "").addClass("link").append(this.$inner);

                var _this = this;

                //this.fastClick = $.capriza.fastClick(this.element[0]);

                this.$inner.on("click", function() {
                    if (!_this.options.isDisabled) {
                        _this._trigger("_click");
                        return false;
                    }
                });

                if (this.options.zoomEffect) {
                    this.element.on("click", function() {
                        $(this).addClass('zoom');
                    });
                    this.element.on("webkitAnimationEnd animationend", function() {
                        $(this).removeClass('zoom');
                    });
                }

                this.setIcon(this.options.icon);
            },

            setIsDisabled: function(disabled){
                this._setOption("isDisabled", disabled);
            },

            setText: function(text) {
                this._setOption("name", text);
                this.$text.text(_.sanitize(this.options.name));
            },

            setIcon: function(iconClass) {
                if (!iconClass) {
                    this.element.removeClass("has-icon");
                    $("i:first", this.element).remove();
                    return;
                }

                this.element.addClass("has-icon");

                var icon = this.$inner.children("i");
                if (icon.length==0)
                    icon = $("<i></i> ").prependTo(this.$inner);

                var newIconClass = iconClass;
                if (iconClass.indexOf('icon-') > -1) {
                    newIconClass = this.getNewIcon(iconClass);
                }

                icon.attr("class",newIconClass);
            },

            getNewIcon: function(oldClass) {

                var iconClassValue = oldClass.replace('icon-', '');
                var newIcon = mapping[iconClassValue];

                if (newIcon) {
                    return 'fa fa-'+newIcon;
                }
                else {
                    return 'fa fa-'+iconClassValue;
                }

            }

//            setIsDisabled: function (isDisabled) {
//                this.element.toggleClass("disabled", isDisabled);
//            }

        },

        image: {
            _create: function () {
                var _this = this;
                this.element.attr("id", this.options.uniqueControlId || "").addClass('image-container');


                this.$imageElement = $("<img>");
                this.$placeHolder = $("<img class='image image-placeholder'>");
                this.$imageElement.addClass("image").attr("alt", this.options.alt || this.options.key || "");
                if (this.options.style && this.options.style.width) {
                    this.$imageElement.css("width", this.options.style.width + "px");
                    this.$imageElement.css("height", this.options.style.height + "px");
                }


                this.$imageElement.appendTo(this.element);
                //this.$placeHolder.appendTo(this.element);

                //setTimeout(function(){
                //    _this.$placeHolder[0].style.cssText = document.defaultView.getComputedStyle(_this.$imageElement[0], "").cssText;
                //}, 0);



                var height = this.$imageElement.height();

                this.element.on("click", function (e) {

                    if (_this.options.enableZoom) {
                        var $originalViewport;
                        $.swipebox([
                            {href: _this.options.src, title: _this.options.key || "Image"}
                        ],
                            {beforeOpen: function () {

                                if(Capriza.device.isMobile)
                                $('.viewport').css({visibility: 'hidden'});
                                $originalViewport = $('meta[name="viewport"]');
                                $originalViewport.remove();
                                $("<meta>", {content: "width=device-width, initial-scale=1, user-scalable=yes, maximum-scale=3.0", name: 'viewport'}).appendTo('body');
                                $("<meta>", {content: "initial-scale=1, user-scalable=yes, , maximum-scale=3.0", name: 'viewport', media: '(device-height: 568px)'}).appendTo('body');

//                               stock browser doesn't handle code meta viewport updates until orientation change. Doubling image size.
                                if (Capriza.device.stock) {
                                    var loadListener = setInterval(function () {
                                        logger.log('interval');
                                        var $swipeImg = $('#swipebox-overlay img');
                                        if ($swipeImg.length == 0) {
                                            return;
                                        }

                                        clearInterval(loadListener);

                                        $swipeImg.css({width: $swipeImg.width() * 2})

                                    }, 100);


                                }
                                setTimeout(function(){
                                        $('#swipebox-close').on('touchend',function(e){
                                            e.stopPropagation();
                                            return false;
                                        })
                                    }
                                    ,0)
                            }, afterClose: function () {
                                $('meta[name="viewport"]').remove();
                                $originalViewport.appendTo('body');
                                if(Capriza.device.isMobile){
                                    $('.viewport').css({visibility: ''});

                                }
                                return false;
                            }
                            }
                        );

                        return false;
                    }
                    return _this._trigger("_click");
                });
            },

            onLoad: function(callback) {
                this.$imageElement.on('load', callback);
            },

            addClassToImage: function(className) {
                this.$imageElement.addClass(className);
            },

            hidePlaceHolder: function() {
                this.$placeHolder.addClass('hidden');
            },

            removeClassToImage: function(className) {
                this.$imageElement.removeClass(className);
            },

            setSrc: function(src) {
                this.options.src=src;
                this.$imageElement.attr("src", src);
            },

            setBackgroundImage: function(src, position, size) {
                this.$imageElement.css('background', "url("+src+") no-repeat scroll "+position+" transparent").css('background-size',size).css('color', 'transparent');
                this.$imageElement.attr("src", 'data:image/png;base64,R0lGODlhFAAUAIAAAP///wAAACH5BAEAAAAALAAAAAAUABQAAAIRhI+py+0Po5y02ouz3rz7rxUAOw==');
            }
        },

        file: {
            _create: function () {
                function uploadFile (filePath,file) {
                    function nameFinder(filePath, seperator) {
                        if (filePath.indexOf(seperator) == -1) {
                            return filePath;
                        }
                        var fileName = filePath.split(seperator);
                        return fileName[fileName.length - 1];
                    }

                    function getFileName(filePath){
                        var fileName = nameFinder(filePath, '/');
                        fileName = nameFinder(fileName, '\\');
                        return fileName;
                    }

                    function uniqueness(fileName){
                        var name = fileName;
                        // Relay does not support multiple files with same name in same session
                        $.capriza.fileSequence = $.capriza.fileSequence || {};
                        if($.capriza.fileSequence[fileName]) name = name.replace(/\.(?=[^.]*$)/, "_" + $.capriza.fileSequence[fileName]+ ".");
                        $.capriza.fileSequence[fileName] = ($.capriza.fileSequence[fileName] || 0) + 1;
                        return name;
                    }

                    var _this=this;
                    var fileName = getFileName(filePath);
                    fileName = uniqueness(fileName); // Relay does not support multiple files with same name in same session
                    _this.$input.val(fileName);
                    var uploadForm = new FormData();
                    uploadForm.append(fileName, file);

                    if (window.isDesignerPreview) {
                        // save file input to allow for privileged access in the designer
                        Capriza.localFile = $fileInput[0];
                        _this._trigger('set', 'file', {fileLocation: filePath});

                    } else {
						var uploadPath = appData.session_id + "/" + fileName;
                        var uploadUrl = appData.runtime_base_url + "/imageUpload/" + uploadPath;
                        Logger.debug('upload url: ' + uploadUrl);

                        Dispatcher.trigger('loading/start');
                        Logger.debug('uploadForm: ' + uploadForm);

                        $.ajax({
                            url: uploadUrl,
                            data: uploadForm,
                            processData: false,
                            contentType: false,
                            type: 'PUT',
                            success: function (data) {
                                _this._trigger('set', 'file', {fileLocation: uploadPath});
                            },
                            error: function (e) {
                                alert('File format not allowed, please choose a different file.');
                                Logger.debug('Failed to upload file. ' + e);
                            },
                            complete: function () {
                                Dispatcher.trigger('loading/stop');
                            }
                        });
                    }
                }

                var _this = this;
                this.element.addClass("file").addClass("actionableInput").attr("id", this.options.uniqueControlId);
                var $wrapper = $('<div/>').css({height: 0, width: 0, 'overflow': 'hidden'});

                var $ctrlToDisplay = $('<div>');

                var placeholder = this.options.placeholder ? " placeholder='" + this.options.placeholder + "' " : "";
                this.$input = $('<input type="text" readonly=""' + placeholder + '>').addClass('styleable-text').appendTo($ctrlToDisplay);

                if (this.options.icon) {
                    var $icon = $('<span>').addClass("icon icon-label").appendTo($ctrlToDisplay);
                    $('<i>').addClass(this.options.icon).appendTo($icon);
                }

                var $fileInput = $('<input>', {id: this.options.uniqueControlId + "_file", name: this.options.uniqueControlId + "_file", type: 'file'});
                $fileInput.attr("tabindex", -1).appendTo(this.element);

                $ctrlToDisplay.addClass('value').appendTo(this.element);
                $ctrlToDisplay.attr("aria-roledescription", "file upload");
                $fileInput.wrap($wrapper);

                $fileInput.change(function () {
                    var filePath=$fileInput.val();
                    var file=$fileInput.prop('files')[0];
                    uploadFile.call(_this,filePath, file);
                });

                $ctrlToDisplay.click(function () {
                    $fileInput.click();
                });
            }
        },

        swipe: {
            options: {
                swipeRightArgs: [],
                swipeLeftArgs: []
            },

            removeSwipe: function() {
                this.element.off('touchstart mousedown');
                this.element.off('touchmove mousedown');
                this.element.off('touchend mousedown');
                this.element.data('swipe', false);
            },

            _create: function() {
                var self = this;
                this.element.on('touchstart mousedown', function(e) {
                    if (self.options.onStart) {
                        requestAnimationFrame(self.options.onStart);
                    }
                    var curX, curY;
                    if (window.event && event.touches && event.touches.length === 1) {
                        var startX = event.touches[0].pageX, startY = event.touches[0].pageY;
                        self.element.off('touchmove mousemove').on('touchmove mousemove', function(e) {
                            e.stopPropagation();

                            curX = event.targetTouches && event.targetTouches[0].pageX - startX;
                            curY = event.targetTouches && event.targetTouches[0].pageY - startY;

                            if (Math.abs(curX) > Math.abs(curY)) {
                                event.preventDefault();
                            }
                        });

                        self.element.off('touchend mouseup').on('touchend mouseup', function(e) {

                            if (Math.abs(curX) > Math.abs(curY)+100) {

                                if (curX < 0) {
                                    self.options.swipeRight.apply(this, self.options.swipeRightArgs);
                                }
                                else{
                                    self.options.swipeLeft.apply(this, self.options.swipeLeftArgs);
                                }

                                curX = 0;
                                curY = 0;

                            }
                        });
                    }
                });
            }
        },

        mouseSwipe: {
            options: {
                swipeRightArgs: [],
                swipeLeftArgs: []
            },

            _create: function() {
                var self = this;
                this.element.on('mousedown', function(e) {

                    self.options.onStart && self.options.onStart();

                    var curX, curY;
                    var startX = e.pageX, startY = e.pageY;
                    self.element.off('mousemove').on('mousemove', function(e) {

                        curX = e.pageX - startX;
                        curY = e.pageY - startY;

                        if (Math.abs(curX) > Math.abs(curY)) {
                            e.preventDefault();
                        }
                    });

                    self.element.off('mouseup').on('mouseup', function(e) {

                        if (Math.abs(curX) > Math.abs(curY)+100) {
                            if (curX < 0) {
                                self.options.swipeRight.apply(this, self.options.swipeRightArgs);
                            }
                            else{
                                self.options.swipeLeft.apply(this, self.options.swipeLeftArgs);
                            }

                            curX = 0;
                            curY = 0;

                        }
                    });
                });
            }
        },

        drag: {

            calcVelocity: function(distance, startTime, endTime) {

                var totalTime = endTime-startTime;

                return distance/totalTime;

            },

            shouldCompleteAction: function(velocity, curXAbs) {
                var threshold = this.options.threshold || 0.75;
                return (velocity > 0.4 || curXAbs >= this.element.parent().width()*threshold);
            },

            reset: function(curItemX) {
                this.options.onCancel(curItemX, this.element, this.step, transformProperty);
            },

            NO_DRAG: 0,
            SIGNAL_START: 1,
            START_TRIGGERED: 2,

            _create: function() {
                this.step = {swiping: false, toSet: undefined, isStarted:self.NO_DRAG};
                //isStarted == 0 => no drag occurred (self.NO_DRAG)
                //isStarted == 1 => drag signal from touchmove (self.SIGNAL_START)
                //isStarted == 2 => start event sent from requestAnimationFrame (self.START_TRIGGERED)

                this.onTouchStart = _.bind(this.onTouchStart, this);
                this.onTouchMove = _.bind(this.onTouchMove, this);
                this.onTouchEnd = _.bind(this.onTouchEnd, this);
                this.update = _.bind(this.update, this);

                this.element.on('touchstart', this.onTouchStart);
            },

            update: function() {
                if (this.options.isSwipeDisable && this.options.isSwipeDisable())
                    return;
                if(this.step.direction && this.step.isStarted == this.SIGNAL_START){
                    this.step.isStarted = this.START_TRIGGERED;
                    this.options.onStart && this.options.onStart(this.step);
                }
                if (this.step.toSet !== undefined) {
                    this.options.dragCallback(this.step, transformProperty);
                }
                this.options.animationFrameId && cancelAnimationFrame(this.options.animationFrameId);
                this.options.animationFrameId = requestAnimationFrame(this.update);
            },

            onTouchStart: function(e) {
                e.stopPropagation();

                requestAnimationFrame(this.update);
                if (event.touches.length === 1 && !(this.options.isSwipeDisable && this.options.isSwipeDisable())) {
                    var touchObj = this.touchObj = {
                        curItemX: this.element[0].getBoundingClientRect().left,
                        startTime: Date.now()
                    };

                    touchObj.startX = event.touches[0].pageX;
                    touchObj.startY = event.touches[0].pageY;
                    this.element.off('touchmove').on('touchmove', this.onTouchMove);
                    this.element.off('touchend touchcancel').on('touchend touchcancel', this.onTouchEnd);
                }
            },

            onTouchMove: function(e) {
                e.stopPropagation();
                var curX = this.touchObj.curX = event.targetTouches[0].pageX - this.touchObj.startX;
                var curY = this.touchObj.curY = event.targetTouches[0].pageY - this.touchObj.startY;

                if (Math.abs(curX) > Math.abs(curY)*1.2) {

                    this.step.pageX = event.targetTouches[0].pageX;
                    this.step.curX = curX;
                    this.step.toSet = this.touchObj.curItemX + curX;

                    event.cancelable && event.preventDefault();

                    if(!this.step.isStarted){
                        this.step.isStarted = this.SIGNAL_START;
                    }

                    if (curX > 0) {
                        this.step.direction = 'right';
                    }
                    else {
                        this.step.direction = 'left';
                    }
                }
            },

            onTouchEnd: function(e) {
                this.element.off('touchmove');
                e.stopPropagation();
                this.options.animationFrameId && cancelAnimationFrame(this.options.animationFrameId);
                if (!this.step.toSet) return;
                this.step.toSet = undefined;
                this.step.isStarted = this.NO_DRAG;

                if (this.touchObj.curX === undefined || isNaN(this.touchObj.curX)) return;

                var endTime = Date.now(), velocity = this.calcVelocity(Math.abs(this.touchObj.curX), this.touchObj.startTime, endTime),
                    curXAbs = Math.abs(this.touchObj.curX),
                    completeAction = this.options.shouldCompelteAction ?
                                            this.options.shouldCompelteAction(velocity, curXAbs) :
                                            this.shouldCompleteAction(velocity, curXAbs);

                if (completeAction && !(this.options.isSwipeDisable && this.options.isSwipeDisable())) {
                    if (this.step.direction === 'right') {
                        this.options.swipeLeft.apply(this, [this.element,velocity, curXAbs]);
                    }
                    else {
                        this.options.swipeRight.apply(this, [this.element, velocity, curXAbs]);
                    }
                }
                else {
                    this.reset(this.touchObj.curItemX);
                }
            }
        },

        rotatingSpinner: {
            _create: function() {
                var options = _.extend({display: 'hidden'}, this.options);

                var brand = Utils.getBrand();

                if (brand) {
                    options = _.extend({primaryColor: brand['primary-color']}, options);
                }


                this.element.append(Handlebars.templates['spinner'](options));
            }
        },

        sticky: {
            _create: function () {
                _.bindAll(this, "initSticky", "doStickyScroll");

                this.placeholder = document.createElement('div');
                this.$scrollingArea = undefined;
                this.initSticky();
                document.removeEventListener('DOMNodeInserted', this.initSticky);
                document.addEventListener('DOMNodeInserted', this.initSticky);
            },

            initSticky: function () {
                var self = this;

                var $newScrollingArea = $(".scrolling-area");
                if (this.$scrollingArea && this.$scrollingArea.length && $newScrollingArea.length && this.$scrollingArea[0] === $newScrollingArea[0]) return;
                if (this.$scrollingArea) {
                    this.$scrollingArea.off('scroll', this.doStickyScroll);
                }
                this.$scrollingArea = $newScrollingArea;

                var $scrollingArea = this.$scrollingArea;
                if (!$scrollingArea.length) return;

                var $stickyEl = this.$stickyEl = this.element;

                this.isAdded = false;
                this.stickyParentPosition = {};
                this.scrollablePosition = {};
                this.stickyTop = "";

                setTimeout(function () {
                    self.stickyParentPosition = $stickyEl[0].getBoundingClientRect();
                    self.stickyTop = $stickyEl[0].style.top;
                    self.scrollablePosition = $scrollingArea.position();
                    self.placeholder.style.width = $stickyEl.width() + 'px';
                    self.placeholder.style.height = $stickyEl.height() + 'px';
                }, 0);

                $scrollingArea.off('scroll', this.doStickyScroll);
                $scrollingArea.on('scroll', this.doStickyScroll);
            },

            doStickyScroll: function() {
                if (this.$scrollingArea.scrollTop() >= (this.stickyParentPosition.top - this.scrollablePosition.top) && !this.isAdded) {
                    this.$stickyEl.addClass('sticky');
                    this.$stickyEl.css({top: this.scrollablePosition.top + 'px', width: this.placeholder.style.width});
                    this.$stickyEl[0].parentNode.insertBefore(this.placeholder, this.$stickyEl[0]);
                    this.isAdded = true;
                } else if (this.$scrollingArea.scrollTop() < (this.stickyParentPosition.top - this.scrollablePosition.top) && this.isAdded) {
                    this.$stickyEl.removeClass('sticky');
                    this.$stickyEl[0].parentNode.removeChild(this.placeholder);
                    this.$stickyEl[0].style.top = this.stickyTop;
                    this.isAdded = false;
                }
            },

            _destroy: function () {
                if (this.$scrollingArea) {
                    this.$scrollingArea.off('scroll', this.doStickyScroll);
                }
            }
        }
    };

    widgets['popupmenu'] = _.extend(_.extend({}, widgets.pulldownmenu), {
        toggleItems: function(e) {
            this.isOpen ? this.hideItems(e) : this.openEmpty(e);
            return false;
        },

        openEmpty: function() {
            var self = this;
            this.$pulldownmenu.addClass("open");
            this.$items.empty();
            this.$items.css({ height: 50, opacity: 1 });
            $("<div class='popupmenu-loading'></div>").appendTo(this.$items);
            this._trigger("_openpopup");
            this.element.addClass("opening");
            this.$items.on("transitionend webkitTransitionEnd", function() {
                Dispatcher.trigger("menu/open", this);
                self.element.removeClass("opening");
            });
            this.isOpen = true;
        },

        fillItems: function(items) {
            if (!items || !items.length) return;
            if (!this.isOpen) {
                this.element.addClass("open");
                this.$items.empty();
                this.isOpen = true;
            }
            $(".popupmenu-loading", this.element).remove();
            widgets.pulldownmenu.fillItems.apply(this, arguments);
            var menuHeight = this._calcHeight(items);

            if (this.element.parents('.active').length > 0) {
                this.$items.css({ height: menuHeight, opacity: 1 });
            }

        },

        hideItems: function() {
            this._trigger("_closepopup");
            widgets.pulldownmenu.hideItems.apply(this, arguments);
        }
    });

    widgets["loadingShellMode"] = {
        _create: function() {
            this.element.addClass("spinner loading-shellmode").appendTo(".viewport");
        }
    };

    var widgetPrototype = Capriza.widgetPrototype = {
        onInserted: function(callback) {
            var _this = this;
            $(document).bind("DOMNodeInserted", function(e) {
                var element = _this.element.get(0);
                if (element === e.target || (element.compareDocumentPosition(e.target) & element.DOCUMENT_POSITION_CONTAINS)) {
                    $(document).unbind("DOMNodeInserted", arguments.callee);
                    callback(e);
                }
            });
        },

        _create: function() {
            this.options.onInserted && this.onInserted(this.options.onInserted);
        }
    };

    _.each(widgets, function(widget, name) {
        var proto, name = "capriza." + name;
        if (!widget.base) {
            proto = _.extend(_.extend({}, widgetPrototype), widget);
            $.widget(name, proto);
        } else {
            proto = _.extend(_.extend({}, widgetPrototype), widget.proto);
            $.widget(name, widget.base, proto);
        }
    });

    // http://stackoverflow.com/questions/8320530/webkit-bug-with-hover-and-multiple-adjacent-sibling-selectors/8320736#8320736
    if (Capriza.device.stock) {
        $("<style>body {-webkit-animation: bugfix infinite 5s;}@-webkit-keyframes bugfix {from {padding:0;}to {padding:0;}}</style>").appendTo("head");
    }

})(jQuery);

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/widgets/ActionableText.js

try{
(function($) {
    var widgets = {
        longPress: {
            _init: function(){
                var self = this;
                if (!this.options.extraActions) return;
                if (!this.options.touchduration){
                    this.options.touchduration = 500; //length of time we want the user to touch before we do something
                }
                this.element.addClass("long-press");//.addClass(this.options.type);
                if (!this.options.target){
                    this.options.target = this.element;
                }
                this.showExtraActions = this.showExtraActions.bind(this);
                this.options.touchStart = this.touchStart.bind(this);
                this.options.touchEnd = this.touchEnd.bind(this);
                this.options.touchMove = this.touchMove.bind(this);
                this.options.target[0].addEventListener("touchmove", this.options.touchMove);
                this.options.target[0].addEventListener("touchend", this.options.touchEnd);
                this.options.target.parent().on("touchstart", this.parentTouchStart);
                this.options.target[0].addEventListener("touchforcechange", this.touchForceChange);
                this.options.target[0].addEventListener("touchstart", this.options.touchStart);
            },
            parentTouchStart: function(e){
                Logger.debug("longPress: parent click ignoring");
                e.stopPropagation();
                e.preventDefault();
            },
            touchForceChange: function(e){
                Logger.debug("longPress: hard touch changed");
                e.stopPropagation();
                if (!e.touches || !e.touches.length) return;
                if (e.touches[0].force > 0.2){
                    e.preventDefault();
                }
                e.touches[0].force = 0;
            },
            touchStart: function(e){
                Logger.debug("longPress: touch start");
                e.stopPropagation();
                e.touches[0].force = 0;
                this.options.clientY = e.touches[0].clientY;
                this.options.longPressTimer && window.clearTimeout(this.options.longPressTimer);
                this.options.longPressTimer = window.setTimeout(this.showExtraActions, this.options.touchduration);
            },
            touchMove: function(e){
                e.touches[0].force = 0;
                var touchY =  e.touches[0].clientY;
                if (Math.abs(this.options.clientY - touchY) > 9){
                    this.options.longPressTimer && window.clearTimeout(this.options.longPressTimer);
                    this.options.longPressTimer = null;
                }
            },
            touchEnd: function(e){
                Logger.debug("longPress: touch end");
                e.stopImmediatePropagation();
                e.preventDefault();

                if (!this.options.longPressTimer) return;
                document.activeElement.blur();
                if (this.options.longPressTimer) {
                    window.clearTimeout(this.options.longPressTimer);
                    e.stopPropagation();
                }
                if (!$(".popup-opening").length){
                //} else {
                    e.target.click();
                }
                //This is very ugly, for IOS WS a click event is trigger on the shield (which cause the context menu to close)
                setTimeout(function(){
                    $(".popup-opening").removeClass("popup-opening");
                },61);
            },
            showExtraActions: function(){
                Logger.debug("longPress: showExtraActions called");
                this.options.target.addClass("popup-opening");
                this.options.longPressTimer && window.clearTimeout(this.options.longPressTimer);
                Utils.showContextMenu({items:this.options.extraActions, title: this.options.title});
            }
        },
        externalLink: {
            _init: function () {
                var self = this;
                if (!this.options.data) return;
                this.element.addClass("external-link");
                if (!this.options.target){
                    this.options.target = this.element;
                }
                this.element[0].action = this.options.data;
                this.options.target.on("click", function(e) {
                    self.openExternalLink(self.element[0].action);
                });
            },
            openExternalLink: function(url) {
                if (Capriza.cordova) {
                    var openInBrowser = this.options.openInBrowser;
                    if (openInBrowser) {
                        this.openExternalApp(url);
                    }
                    else {
                        var fileName = Utils.Links.extractFilename(url);
                        Utils.Links.openExternal(url, fileName);
                    }
                }
                else {
                    this.openExternalApp(url);
                }
            },
            openExternalApp: function(url) {
                Utils.Links.openExternalApp(url);
            },
            setData: function(options){
                if (!options || !options.data) return;
                this.options.data = options.data;
                this.element[0].action = this.options.data;
            }
        },
        zappLink:{
            _init: function() {
                var self = this;
                if (!this.options.data) return;

                var workSimpleVersion = Capriza.cordova ? parseInt(Capriza.cordova) : -1;
                this.openInWorkSimple = workSimpleVersion >= 16;
                this.element.addClass("zapp-link");

                if (!this.options.target){
                    this.options.target = this.element;
                }

                this.element[0].action = this.options.data;

                if (this.openInWorkSimple) {
                    this.element[0].extraActions = [
                        { name: "Open in Browser", action: function() { self.openZappInBrowser(true); } },
                        { name: "Open in Work-Simple", action: function() { self.openZappInWorkSimple(); } },
                    ];
                    if (document.queryCommandSupported("copy")){
                        this.element[0].extraActions.push({ name: "Copy Link", action: function () { Utils.copyToClipBoard(self.options.data); } });
                    }
                    this.options.target.longPress({title: this.options.data, extraActions:this.element[0].extraActions});
                }

                this.options.target.on("click", function(e) {
                    self.openZapp();
                });
            },
            openZapp: function () {
                if (this.openInWorkSimple) {
                    this.openZappInWorkSimple();
                }
                else {
                    var newTab = this.options.isZappInNewTab;
                    this.openZappInBrowser(newTab);
                }
            },
            openZappInBrowser: function (newTab) {
                if (newTab) {
                    Utils.Links.openExternalInBlank(this.element[0].action);
                }
                else {
                    window.open(this.element[0].action, "_self");
                }
            },
            openZappInWorkSimple: function () {
                if (Capriza.device.ios) {
                    Capriza.Capp.messenger.emit('runZapp', this.element[0].action);
                }
                else if (Capriza.device.android) {
                    top.Capriza.zappAPI["runZapp"](this.element[0].action)
                }
                else {
                    this.openZappInBrowser(true);
                }
            },
            setData: function(options){
                if (!options || !options.data) return;
                this.options.data = options.data;
                this.element[0].action = this.options.data;
            }
        },
        phone:{
            _init: function() {
                var self = this;
                if (!this.options.data) return;
                this.element.addClass("telephone");//.addClass(this.options.type);
                if (!this.options.target){
                    this.options.target = this.element;
                }
                if (Capriza.device.ios){
                    this.options.data = this.options.data.replace(/\s/g, "");
                }
                this.element[0].action = "tel:" + this.options.data;
                this.element[0].extraActions = [
                    {name: "Call", action: function(){window.open( self.element[0].action, Utils.openAppString())}},
                    {name: "Send SMS", action: function(){window.open("sms:"+ self.options.data, Utils.openAppString())}}
                ];
                if (document.queryCommandSupported("copy")){
                    this.element[0].extraActions.push({ name: "Copy Phone Number", action: function () { Utils.copyToClipBoard(self.options.data); } });
                }
                this.options.target.on("click", function(e) {
                    e.stopPropagation();
                    self.openPhone(self.element[0].action);
                });
                if(Capriza.device.isMobile) {
                    this.options.target.longPress({
                        title: this.options.data,
                        extraActions: this.element[0].extraActions
                    });
                }
            },
            openPhone: function(phone){
                window.open(phone, Utils.openAppString("_self"));
            },
            setData: function(options){
                if (!options || !options.data) return;
                this.options.data = options.data;
                if (Capriza.device.ios){
                    this.options.data = this.options.data.replace(/\s/g, "");
                }
                this.element[0].action = "tel:" + this.options.data;
            }
        },
        email:{
            _init: function() {
                var self = this;
                this.element.addClass("email");//.addClass(this.options.type);
                if (this.options.data) {
                    this.element[0].action = "mailto:" + this.options.data;
                }
                if (!this.options.target){
                    this.options.target = this.element;
                }
                this.element[0].extraActions = [
                    { name: "New Email", action: function(){ self.openEmail(self.element[0].action) } },

                ];
                if (document.queryCommandSupported("copy")){
                    this.element[0].extraActions.push({ name: "Copy Email Address", action: function () { Utils.copyToClipBoard(self.options.data); } });
                }
                this.options.target.on("click", function(e) {
                    e.stopPropagation();
                    self.openEmail(self.element[0].action);
                });
                if(Capriza.device.isMobile) {
                    this.options.target.longPress({
                        title: this.options.data,
                        extraActions: this.element[0].extraActions
                    });
                }
            },
            openEmail: function(email){
                window.open(email, Utils.openAppString("_self"));
            },
            setData: function(options){
                if (!options || !options.data) return;
                this.options.data = options.data;
                this.element[0].action = "mailto:" + options.data;
            }
        },
        address:{
            _init: function() {
                var self = this;
                if (!this.options.data) return;
                this.element.addClass("address");//.addClass(this.options.type);
                this.openInMiniBrowser = this.openInMiniBrowser.bind(this);
                this.element[0].htmlEncodedValue = encodeURIComponent(this.options.data.replace(/[ ]?<[\/]?br\s*[\/]?>[ ]?/gi, " "));
                this.element[0].action = 'https://maps.google.com/maps?q=' + this.element[0].htmlEncodedValue;
                this.element[0].extraActions = [
                    {name: "Open in Zapp", action: this.openInMiniBrowser}
                ];
                if (Capriza.device.ios){
                    this.element[0].extraActions.push({name: "Open in Maps", action: function(e){
                        self.openMapsUrl("maps://?q="+ self.options.data);
                    }});
                } else {
                    this.element[0].extraActions.push({name: "Open in Maps", action: function(e){
                        self.openMapsUrl('https://maps.google.com/maps?q=' + self.element[0].htmlEncodedValue);
                    }});
                }
                if (Capriza.device.isMobile && (!Capriza.cordova || parseInt(Capriza.cordova) >= 16)) {
                    if (Capriza.device.ios){
                        this.element[0].extraActions.push({name: "Open in Google Maps", action: function(e){
                            Utils.Links.openExternalApp('https://maps.google.com/maps?q=' + self.element[0].htmlEncodedValue);
                        }});
                    }
                    this.element[0].extraActions.push({
                        name: "Open in Waze", action: function (e) {
                            Utils.Links.openExternalApp("waze://?q=" + self.element[0].htmlEncodedValue + "&navigate=yes", null, "https://itunes.apple.com/us/app/waze-social-gps-traffic/id323229106?mt=8", "https://play.google.com/store/apps/details?id=com.waze&referrer=utm_source%3Dgmm%26utm_campaign%3Dgmm_android" );

                        }
                    });
                }
                if (document.queryCommandSupported("copy")) {
                    this.element[0].extraActions.push({ name: "Copy Address", action: function (e) { Utils.copyToClipBoard(self.options.data); }});
                }
                if (!this.options.target){
                    this.options.target = this.element;
                }
                this.options.target.on("click", this.openInMiniBrowser);
                this.options.target.longPress({title: this.options.data, extraActions:this.element[0].extraActions});
            },
            openInMiniBrowser: function(e){
                e.stopPropagation();
                Capriza.Views.Utils.buildMiniBrowser(this.element[0].action + '&output=embed', this.getMiniBrowserExtraActions() );
            },
            getMiniBrowserExtraActions: function(){
                return this.element[0].extraActions.slice(1);
            },
            openMapsUrl: function(href){
                window.open(href, Utils.openAppString());
            },
            setData: function(options){
                if (!options || !options.data) return;
                this.options.data = options.data;
                this.element[0].htmlEncodedValue = encodeURIComponent(this.options.data.replace(/[ ]?<[\/]?br\s*[\/]?>[ ]?/gi, " "));
                this.element[0].action = 'https://maps.google.com/maps?q=' + this.element[0].htmlEncodedValue;
            }
        }
    };
    _.each(widgets, function(widget, name) {
        var proto, name = "capriza." + name;
        proto = _.extend(_.extend({}, Capriza.widgetPrototype), widget);
        $.widget(name, proto);
    });
})(jQuery);

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/Page.js

try{
(function() {
    Capriza.Model.Page = Backbone.Model.extend({
        initialize: function() {
//            Logger.debug("Capriza.Model.Page");
        }
        // placeholder
    });

    Capriza.Model.ContextPage = Capriza.Model.Page.extend({
        initialize: function() {
            var self = this;

            if (this.get("presentationControl")) {
                var root = new Capriza.Model.Control(this.get("presentationControl"));
                this.set("root", [root.get("id")]);
                root.addPage(self);
            }
            else if(this.get("controls")){
                this.set(
                    "controls",
                    this.get("controls").map(function(ctrl){
                        var currModel = ctrl.id && Capriza.Model.Control.getById(ctrl.id);
                        if(currModel && self.tableDrill) return currModel; // <-- already initialized (drill)page
                        var model = new Capriza.Model.Control(ctrl);
                        model.addPage(self);
                        return model;
                    })
                );
                this.set("root", [this.get("controls")[0].get("id")]);
            }

            Capriza.Model.Page.prototype.initialize.apply(this, arguments);

            this.verifyFirstContext();

            Capriza.Model.PageDB[this.getDbKey()] = this;

            this.on("change:controls", function() {
                var prevControls = self.previous("controls");
                prevControls && _.each(prevControls, function(control) {
                    control && control.removePage(self);
                });

                var currControls = this.get("controls");
                currControls && _.each(currControls, function(control) {
                    control && control.addPage(self);
                });
            });
        },

        getControlsOrRoot:function(){
          return (this.get("controls") || this.get("root"));
        },

        verifyFirstContext: function(){
            if (!Capriza.Model.firstContext) {
                logger.log('dispatching first context');
                Dispatcher.trigger("application/firstContext", {timeFromAccessURL: this.get('timeFromAccessURL')});
                Capriza.Model.firstContext = this;
            }
            else {
                logger.log('not dispatching first context');
            }
        },

        getDbKey: function() {
            return this.get("contextId");
        },

        controlChanged: function(control, attributes) {
            this.trigger("page/controlChanged", control, attributes );
			Dispatcher.trigger("page/controlChanged", this, control, attributes);
        },

        removeControl: function(controlId) {
            var index = this.get("root").indexOf(controlId);
            if (index > -1) this.get("root").splice(index, 1);
            this.trigger("page/controlRemoved", controlId);
        },

        containsControl: function(controlId) {
            function searchControl(controlModel) {
                if (found) return false;

                if (controlModel.get("id") === controlId) {
                    found = true;
                    return false;
                }

                var children = controlModel.get("controls");
                children && children.forEach(searchControl);
            }

            var found = false;
            if (!this.get("root") || !this.get("root").length) return;
            this.get("root").map(function(control) { return Capriza.Model.Control.getById(control); }).forEach(searchControl);
            return found;
        }
    },{
        getByContextId: function(contextId) {
            return Capriza.Model.PageDB[contextId];
        },

        compare: function(p1, p2) {
            if (!p1 && !p2) return true;
            if (!p1 || !p2) return false;
            if (p1.get("contextId") !== p2.get("contextId")) return false;

            var rootControlId1 = p1.get("root")[0];
            var rootControlId2 = p2.get("root")[0];

            var rootControl1 = Capriza.Model.Control.getById(rootControlId1);
            var rootControl2 = Capriza.Model.Control.getById(rootControlId2);
            var controls1 = rootControl1 && rootControl1.get("controls");
            var controls2 = rootControl2 && rootControl2.get("controls");

            if (!controls1 || !controls2 || controls1.length !== controls2.length) return false;

            var cache = [];

            var circularReplacer = function(key, value) {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        // Circular reference found, discard key
                        return;
                    }
                    // Store value in our collection
                    cache.push(value);
                }
                return value;
            };

            var controls1Str = JSON.stringify(controls1, circularReplacer);
            cache = [];
            var controls2Str = JSON.stringify(controls2, circularReplacer);
            cache = null; // Enable garbage collection

            return controls1Str === controls2Str;
        }
    });

    Capriza.Model.LoginPage = Capriza.Model.ContextPage.extend({

        verifyFirstContext: function(){
            //prevent splash hiding by overriding default.
        },

        verifyLoginAsFirstContext: function(){
            Capriza.Model.ContextPage.prototype.verifyFirstContext.apply(this);
        },

        initialize: function() {
            this._identityKeysToModel = {};

            Capriza.Model.ContextPage.prototype.initialize.apply(this, arguments);

            var controls = this.get("root").map(function(controlId){
               return Capriza.Model.Control.getById(controlId);
            });
            this._storeIdentityKeys(controls);
        },

        _storeIdentityKeys: function(controls){
            var self = this;
            if (controls) {
                _.each(controls, function(control) {
                    if(control && control.get("identityKey")){
                        self._identityKeysToModel[control.get("identityKey")] = control.get("id");
                    }
                    control && self._storeIdentityKeys(control.get("controls"));
                });
            }
        },

        getModelForIK:function(ik){
            return ik && this._identityKeysToModel[ik] && Capriza.Model.Control.getById(this._identityKeysToModel[ik]);
        },

        getIdentityKeys:function(){
          return Object.keys(this._identityKeysToModel);
        }

    });

    Capriza.Model.MVPage = Capriza.Model.BlueprintPage = Capriza.Model.ContextPage.extend({

        verifyFirstContext: function(){
            //This is to prevent false reports on first visible page...
        }

    });

    Capriza.Model.PageDB = {};
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/HandlebarsUiControl.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 11/28/12
 * Time: 1:22 PM
 * To change this template use File | Settings | File Templates.
 */
;(function() {
    Capriza.Views.HandlebarsUiControl = Capriza.Views.UiControl.extend({
        _render: function() {
            return this._renderHendelbars();
        },

        _addMaxLengthValidation: function($elm){
            if ($elm && this.model.get("maxLength")) {
                $elm.attr("maxlength",this.model.get("maxLength"));
                if (Capriza.device.isMobile && Capriza.device.android){
                    $elm.on("change keyup", function(event){
                        var maxLength = $(this).attr("maxlength");
                        if (this.value.length > maxLength){
                            //remove extra text which is more then maxLength
                            $(this).val($(this).val().slice(0, maxLength));
                        }
                    });
                }
            }
        }
    });
})();


}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Content.js

try{
;
(function () {

    Capriza.Views.Content = Capriza.Views.UiControl.extend({

        initialize: function() {
            _.extend(
                this.model,
                {
                    getCurrentItemsForCache : function(){
                        return [{text:this.get("value")}];
                    }
                }
            );
        },

        _render: function () {
            this.$el.addClass("content").attr("id", this.getUniqueControlId());

            if (this.model.get('videoData')) {
                this.$el.addClass('content-video');
                this.setVideoData(this.model.get('videoData'));
            }
            else {
                this.$value = $('<div class="value styleable-text" />').appendTo(this.$el);
                var value = this.parseValue();
                this.setValue(value.replace(/&quot;/g, "'"));
            }
            //var self = this;
            //function increase(){
            //    //self.$el.height(self.$el.height() + 300);
            //    self.moveAllNextElementDown(self.$el, 300, "300ms", true);
            //    todo = decrease;
            //}
            //function decrease(){
            //    //self.$el.height(self.$el.height() - 300);
            //    self.moveAllNextElementUp(self.$el, 300 , "300ms", true);
            //    todo = increase;
            //}
            //var todo = increase;
            //this.$el.on("click", function(){
            //    //todo();
            //});
            return this.$el;
        },

        labelFor: Utils.noop,

        parseValue : function() {
            var value = this.model.get("value") || "";
            return value.replace("{APP-NAME}", Utils.getAppName);
        },

        setVideoData : function (videoData) {

            if(typeof this.model.get('videoData') !== "object"){
                return;
            }
//          normalize
          videoData.width="90%";
//          delete videoData.height;

           this.$el.html($("<iframe>",videoData));
        },

        setValue: function (value) {
            if((typeof value == "string") && (value.indexOf("{APP-NAME}") > -1 )) {
                value = value.replace("{APP-NAME}", Utils.getAppName);
            }

            this._insertHtml(value);

            if (this.model.get("shouldUseWebColor")) {
                var style = this.model.get("style");
                style && (this.$el.css(style) && this.$value.css(style));
            }

            //we need to make sure that mcStyle will override the value
            this.setMcStyle();

        },

        setCss: function (el, name, value) {
            if (name === "font-size") {
                el.css(name, value);
                el.css("line-height", "1em");
            } else {
                Capriza.Views.UiControl.prototype.setCss.apply(this, arguments);
            }
        },

        _insertHtml: function(html) {
            var contentAction= this.model.get('contentAction');
            this.$value.html(Capriza.Views.Utils.addTelephoneLinks(html || "", contentAction));

            if (contentAction === "openFeedback"){
                this.$el.addClass("open-feedback");
                this.$value.on("click", Utils.openFeedback);
                return;
            }
            // if outside of native iOS Capriza, use iframe to open external links
            Capriza.Views.Utils.createMiniBrowser(this.$el, this.model);
        }

    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Group.js

try{
;(function() {
    Capriza.Views.Group = Capriza.Views.UiControl.extend({
        initialize: function() {
            var self = this;
            this.options.getViewByModel = this.options.getViewByModel || this.getViewByModel;
            _.each(this.model.get("controls"), function(control) {
                self.createAndAddControl(control);
            });

            this.model.off("change:controls").on("change:controls",function(){
                self.options.page.getViews(self.model.previousAttributes()["controls"] || []).forEach(function(view){
                    view.destroy();
                });
            });
            this.$innerContainer = this.initInnerContainer();

            this.addClickAction();

        },

        addClickAction: function(){
            var clickAction = this.model.get("click");
            if (!clickAction) return;

            Logger.debug("[ClickAction] creating click action view ("+clickAction.get("id")+")" + "for control: " + this.model.get("id"));

            var clickActionView = this.getView(clickAction); //to handle updates (on the view) from the Engine
            clickActionView.parentView = this; //bind the clickActionView to this view.
            this.options.page.addView(clickAction.get("id"), clickActionView);
        },

        createAndAddControl: function(control){
            if(control.get("missing")) return;
            var view = this.getView(control);
            this.options.page.addView(control.get("id"), view);
            return view;
        },

        getView: function(model) {
            return Capriza.Views.createView(model, this.options.page, _.bind(this.options.getViewByModel, this), this.defaultView);
        },

        getViewByModel: function(model) {

            var type = model.get('type'), key = model.get('key');

            var typeClass = this.modelToView && this.modelToView[type];
            if (typeClass) return typeClass;

            if (Capriza.Views.modelToView[type]) return Capriza.Views.modelToView[type];

            if (model.get("controls")) {
                return Capriza.Views.GenericCollection;
            } else {
                return Capriza.Views.GenericView;
            }
        },

        initInnerContainer: function() {
            return this.$el;
        },

        modelToView: Capriza.Views.modelToView,

        _render: function() {
            _.each(this.model.get("controls"), this.addControl, this);
            this.renderedCount = this.model.get("controls") && this.model.get("controls").length;

            this.addPaginator();

            this.$el.addClass("group").attr("id", this.getUniqueControlId() || "");

            if (this.model.get('mcClass') === 'vertical-layout') {
                this.$el.removeClass('horizontal-layout');
            }

            if (Capriza.isRTL) {
                this.$el.addClass('right-align');
            }
            return this.$el;
        },

        _post: function(){
            if (this.model.get("click")){
                var clickActionView = this.options.page.getView(this.model.get("click").get("id"));
                clickActionView.render();
            }
        },

        addControl: function(control) {
//            Logger.debug('adding control of type '+control.get("type")+' and id '+control.get("id"));
            if(control.get("missing")) return;
            var view = this.options.page.getView(control.get("id"));
            this.$el.append(view.render());
        },

        processSelectableGroupItem: function(control, groupItemElement, groupItemUniqueControlId, parentId) {
            var self = this,
                $el = $(groupItemElement);

            var inputType = 'radio';
            if (control.get('supportsMulti') && control.get('supportsUnselect')) {
                inputType = 'checkbox';
            }

            var selectEl = $("<div id='" + groupItemUniqueControlId + "Checkbox' class='selectable-checkbox'> <i class='selected-icon icon-checkbox-selected'></i> <i class='unselected-icon icon-checkbox-unselected'></i> </div>").addClass(inputType + "-selection-mode").prependTo($el);

            if (control.get("actionControls") && control.get("actionControls").indexOf("selectDisabled") > -1) selectEl.addClass("disabled");
            if (control.get("isDisabled")) selectEl.addClass("disabled");
            if (!Capriza.device.stock) {
                $.capriza.fastClick($(selectEl)[0]);
            }

            selectEl.toggleClass('checked', !!(control.get('isSelected') || control.get('selected')));
            $el.toggleClass('selected', !!(control.get('isSelected') || control.get('selected')));

            selectEl.on("click", function() {
                if (selectEl.hasClass("disabled")) return;
                var isChecked = $(this).hasClass('checked');
                if(inputType === 'checkbox' || (inputType === "radio" && !isChecked)) {
                    Dispatcher.trigger("select/change", {checked: !isChecked, id: this.id, parent: self});

                    control.api.setIsSelected(!isChecked);
                    control.set("isSelected", !isChecked);
                }
                return false;
            });

            Dispatcher.on("select/change", function(data){
                if (selectEl[0].id === data.id) {
                    selectEl.toggleClass('checked', !!data.checked);
                    $el.toggleClass('selected', !!data.checked);
                } else if (inputType === 'radio' && data.parent === self) {
                    selectEl.removeClass('checked');
                    $el.removeClass('selected');
                }
            });
        },

        prependEl: function ($view) {
            this.$el.prepend($view);
        },
        addViewAtIndex: function(view, index) {
            function animateIn() {
                $view.addClass("animated fadeInLeft");
                $view.on("animationend webkitAnimationEnd", function() {
                    $view.removeClass("animated fadeInLeft");
                    Dispatcher.trigger("view/animateIn/after", view);
                });
            }

            var $view = view.render();
            // if there is no index, or if this view should be the last item append it
            if (index === undefined) {
                this.$el.append($view);
            } else if (index === 0) {
                this.prependEl($view)
            } else {
                //get prevControl from the DOM
                var indexOfModel = 0,
                    controls = this.model.get("controls");
                for (var i = 0; controls && (i < controls.length); i++){
                    if (controls[i].get("id") == view.model.get("id")) {
                        indexOfModel = i;
                    }
                }
                var found;
                while (indexOfModel > 0){
                    var beforeModel = this.model.get("controls")[--indexOfModel];
                    if (!beforeModel) return;
                    var beforeView = this.options.page.getView(beforeModel.get("id"));
                    if (beforeView && !beforeView.model.get("missing")) {
                        $view.insertAfter(beforeView.$el);
                        found = true;
                        break;
                    }
                }
                !found && this.prependEl($view);
            }
            Dispatcher.trigger("view/animateIn/before", view);

            if(window.isDesignerPreview || window.designerLoaded) {
                Capriza.Views.usePageUpdateAnimation && animateIn();
            }

        },

        addPaginator: function() {
            function createPaginator(type, options) {
                options || (options = {});
                var eventType, icon;
                if (type === "Next") {
                    eventType = "next";
                    icon = "fa-chevron-right";
                } else {
                    eventType = "previous";
                    icon = "fa-chevron-left";
                }
                return $("<button><i class='fa " + icon + "'></i></button>").paginatorButton({ type: eventType, disabled: options.disabled }).on("paginatorbutton_click", paginatorClicked(eventType)).appendTo(buttonsGroup);
            }

            function paginatorClicked(type) {
                return function() {
                    createGroupPaginator();
                    $.capriza.groupPaginator.lastClicked = type;
                    self.model.api[type]();
                };
            }

            function createPagesList(items) {
                if (!items || items.length == 0) return;
                var pages = $("<select><option>page</option></select>").css({width: "50%"}).appendTo(itemsCount);
                items.forEach(function(option) {
                    pages.append($("<option></option>").val(option).text(option));
                });

                pages.on("change", function() {
                    if (this.selectedIndex === 0) return;
                    self.model.api.setPage( self.model.get("pages")[this.selectedIndex - 1] ); // Since we added default page option as 1st element index decreased by 1
                });

                return pages;
            }

            function createGroupPaginator(){
                if (!$.capriza.groupPaginator){
                    $.capriza.groupPaginator = {};
                }
            }

            function createNumberOfItems(controls, isLast, isFirst){
                createGroupPaginator();
                var totalCount = $.capriza.groupPaginator.totalCount,
                    currentControls = controls.length > 1 ? (controls[1].get("type").indexOf("drill") > -1 ? controls.length/2 - 1 : controls.length - 1) : 1,
                    startIndex ,endIndex, sameAsBefore;
                if ($.capriza.groupPaginator.lastClicked == "previous"){
                    startIndex = $.capriza.groupPaginator.startIndex - currentControls;
                    startIndex--;
                    if (startIndex < 1 ){
                        startIndex = 1;
                    }
                } else if ($.capriza.groupPaginator.lastClicked == "next"){
                    if  ((window.isDesignerPreview || window.designerLoaded) && !Capriza.designerMode || isFirst){
                        startIndex = 1;
                    } else {
                        startIndex = $.capriza.groupPaginator.endIndex || 0;
                        startIndex++;
                    }
                } else {
                    sameAsBefore = true;
                }
                $.capriza.groupPaginator.lastClicked = "";
                if (sameAsBefore){
                    startIndex = $.capriza.groupPaginator.startIndex || 1;
                    endIndex = $.capriza.groupPaginator.endIndex || (startIndex + currentControls);
                } else {
                    endIndex = startIndex + currentControls;
                }
                $.capriza.groupPaginator.startIndex = startIndex;
                $.capriza.groupPaginator.endIndex = endIndex;
                if (isLast || ($.capriza.groupPaginator.totalCount && $.capriza.groupPaginator.totalCount < endIndex)) {
                    $.capriza.groupPaginator.totalCount = totalCount = endIndex;
                }

                $("<span>"+startIndex+"-"+endIndex+"</span>").addClass("paginator-items-numbers").appendTo(itemsCount);
                itemsCount.append(" of "+ (totalCount ? "" : "many"));
                $("<span>"+(totalCount ? totalCount : "")+"</span>").addClass("paginator-items-numbers total-items").appendTo(itemsCount);

            }

            this.paginator && this.paginator.remove();
            var controls = this.model.get("controls");
            if ((!this.model.get("hasPrevious") && !this.model.get("hasNext") && !this.model.get("pages")) || !controls  || !controls.length) return;

            var self = this, group = $("<div></div>").addClass("paginator " + self.getUniqueControlId()).appendTo(self.$el);
            if (!self.model.get("hasPrevious") && !self.model.get("hasNext")) {
                // only pages list
                createPagesList(self.model.get("pages"));
                group.prepend($("<span></span>").text("Page:"));
                group.addClass("only-pages");
                return;
            }

            var buttonsGroup = $("<div></div>").addClass("paginator-buttons").appendTo(group);

            createPaginator("Previous", { disabled: !self.model.get("hasPrevious") });
            createPaginator("Next", { disabled: !self.model.get("hasNext") || self.model.get("yesMore") });
            var itemsCount = $("<div></div>").addClass("paginator-items-count").appendTo(group),
                items = self.model.get("pages");
            if (items && items.length == 0) {
                createPagesList(items);
            } else {
                if (controls.length > 0 && controls[0].get("mcTemplId")) {
                    createNumberOfItems(controls, !self.model.get("hasNext"), !self.model.get("hasPrevious"));
                }
            }
            self.paginator = group;
        },

        setPresentedControlCount: function() {
            var self = this;
            if (this.model.get("presentedControlCount")) {
                var msg = 'Showing first ' + self.model.get("presentedControlCount") + ' items';
                if (self.$presentedControlCount) {
                    self.$presentedControlCount.text(msg);
                } else {
                    self.$presentedControlCount = $('<div class="' + self.getUniqueControlId() + '_showingMessage presented-count">' + msg + '</div>').appendTo(self.$el);
                }
            } else if (self.$presentedControlCount) {
                self.$presentedControlCount.remove();
                self.$presentedControlCount = null;
            }
        },

        setControls: function() {
            if (this.updating) return;
            var currScrollPosition = $.capriza.currentScrollPosition();
            this.$el.empty();
            this.$label = null;
            this.$presentedControlCount = this.$showMorebtn = this.$showMoreSpinner = null;
            this.updating = true;
//            Capriza.Model.Control.prototype.initialize.call(this.model, this.model.attributes, { parent: this.model.parent });
//            this.model.addPage(this.model.pages);
            this.initialize();
            this.updating = false;
            this.render();
            //this.setIsLast(this.isLast); // (AMIT) a hack :-( setIsLast has functionality that should be inside _render(), but I can't remember why it wasn't there in the first place
            $.capriza.activePage[0].scrollTop = currScrollPosition;
        },

        setPaginator: function() {
            $(".paginator", this.$el).remove();
            this.addPaginator();
        },

        setPages: function(pages) {
            this.setPaginator();
        },

        setHasNext: function(hasNext) {
            this.setPaginator();
        },

        setHasPrevious: function(hasPrevious) {
            this.setPaginator();
        },

        addShowMore: function() {
            if (!this.$showMoreSpinner || !this.$showMoreSpinner.length) {
                this.$showMoreSpinner = $("<div class='show-more-spinner'></div>").rotatingSpinner({
                    width: "35px",
                    height: "35px"
                }).appendTo(this.$el);
            }
        },

        renderChunk: function(startIndex) {
            var self = this;
            var newControls = self.model.get("controls").slice(startIndex);
            _.each(newControls, function(control, i) {
                self.options.page.addView(control.get("id"), self.getView(control));
                self.addControl(control, startIndex+i);
            });
            self.renderedCount += newControls.length;

            self.setMcStyle();
        },

        setMoreItems: function(response){
            Logger.debug('handling moreItems');
            var control = this.model;
            var controls = response.controls.map(function (c) {
                var model = new Capriza.Model.Control(c, { parent: control});
                model.addPage(control.pages);
                return model;
            });
            control.attributes.controls = control.attributes.controls.concat(controls);
            control.set("yesMore", response.yesMore);
            _.each(control.pages, function(page) {
                page.trigger("page/moreItems", control, response.startIndex);
            });
        },

        onMoreItemsArrived: function(startIndex) {
            if (!this.waitingForItems) return;
            if (!this.model.get("yesMore")){
                this.$showMoreSpinner && this.$showMoreSpinner.removeClass("active");
                this.$(".spinner").removeClass("active");
            }
            this.waitingForItems = false;
            if (this.model.get("yesMore")) {
                if (this.isLast) {
                    this.scrollDetector.start();
                } else {
                    this.$showMorebtn.addClass("active");
                    this.$showMoreSpinner && this.$showMoreSpinner.removeClass("active");
                    this.$(".spinner").removeClass("active");
                }
            } else {
                this.paginator && this.setHasNext(this.model.get("hasNext"));
            }
            this.renderChunk(startIndex);
        },

        setYesMore: function(isYesMore) {
            var self = this;
            if (isYesMore && !this.options.page.isMvp && Capriza.StateManager.isSynced) {
                if (this.isLast) {
                    self.scrollDetector = (self.scrollDetector || new Capriza.Views.ScrollDetector({ el : self.el }).on("change", function() {
                        if (self.options.page.$el.hasClass('active')){
                            self.scrollDetector.stop();
                            self.waitingForItems = true;
                            self.model.api.getMoreItems(self.renderedCount);
                        } else {
                            self.$showMoreSpinner && self.$showMoreSpinner.removeClass("active");
                        }
                    }));


                    self.$showMoreSpinner.addClass("active");

                    if (!self.waitingForItems) {
                        setTimeout(function() {
                            // verify before the call to the API that waitingForItems wasn't changed between the
                            // last check and the actual time that the callee method is run in the timeout
                            if(self.waitingForItems) return;
                            // if the last item is visible in the viewport, then need to ask for more items without scroll
                            Logger.debug('getting last control id is '+self.model.get("controls")[self.model.get("controls").length - 1].get("id")+' type is '+self.model.get("controls")[self.model.get("controls").length - 1].get("type"));
                            var topLevelControls = self.getTopLevelControls();

                            function activateScroll(){
                                if (topLevelControls.length > 0) {
                                    var controlsLen = topLevelControls.length;
                                    var lastControl = topLevelControls[controlsLen - 1].get('controls')[0];
                                    var pageBottom = self.options.page.$el[0].getBoundingClientRect().bottom;
                                    var lastControlView = self.options.page.getView(lastControl.get("id"));
                                    var lastControlTop = lastControlView ? lastControlView.$el[0].getBoundingClientRect().top : 0;

                                    Logger.debug("page bottom " + pageBottom + " <==> last item top " + lastControlTop);
                                    //IF control is not in DOM (as in first phase in tables) then lastControlTop is 0 and we don't want more items
                                    if (lastControlTop > 0 && pageBottom >= lastControlTop) {
                                        self.$showMoreSpinner.addClass("active");
                                        self.waitingForItems = true;
                                        self.model.api.getMoreItems(self.renderedCount);
                                    } else {
                                        self.scrollDetector.start();
                                    }
                                }
                            }
                            self.options.page.$el.one("page/disabled", function(){
                                self.$showMoreSpinner && self.$showMoreSpinner.removeClass("active");
                            });
                            if (self.options.page.$el.hasClass('active')){
                                activateScroll();
                            } else {
                                self.options.page.$el.one("page/active", function(){
                                    activateScroll();
                                });
                            }
                        }, 0);
                    }
                } else {
                    self.scrollDetector && self.scrollDetector.stop();
                    self.$showMorebtn = (self.$showMorebtn || $("<button class='show-more'>Show More</button>").on("click", function() {
                        self.waitingForItems = true;
                        self.$showMoreSpinner.addClass("active");
                        self.$showMorebtn.removeClass("active");
                        Logger.debug('getting more items with '+self.renderedCount);
                        self.model.api.getMoreItems(self.renderedCount);
                        return false;
                    }).appendTo(self.$el));

                    if (!self.waitingForItems) self.$showMorebtn.addClass("active");
                }
            } else {
                self.scrollDetector && self.scrollDetector.stop();
                self.$showMorebtn && self.$showMorebtn.removeClass("active");
                self.$showMoreSpinner && self.$showMoreSpinner.removeClass("active");
            }
        },

        getTopLevelControls: function() {
            return this.model.get('controls');
        },

        setIsLast: function(isLast) {
            var self = this;
            self.isLast = isLast;
            self.addShowMore();
            self.setYesMore(self.model.get("yesMore"));
        },

        _destroy: function() {

            this.model.get("controls") && this.options.page.getViews(this.model.get("controls")).forEach(function(view){
                view.destroy();
            });

            if (this.scrollDetector) {
                this.scrollDetector.stop();
            }
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Table.js

try{
;(function() {

    var testElement = document.createElement('div');

    var transformPrefix = "transform" in testElement.style ? "transform" : "webkitTransform";
    var transformProperty = transformPrefix === "webkitTransform" ? "-webkit-transform" : "transform";

    Capriza.Views.disableScroll = function(e) {
        if (event.touches.length === 1) {
            $(this).off('touchmove' ).on('touchmove', function(e) {

                event.preventDefault();
                event.stopPropagation();
            });
        }
    };

    Capriza.Views.registerDisableScroll = function() {

        $(window).on('touchstart', Capriza.Views.disableScroll);

    };

    Capriza.Views.unregisterDisableScroll = function() {
        $(window).off('touchstart', Capriza.Views.disableScroll);
        $(window).off('touchmove');
    };

    // Simulates click when user presses Space or Enter
    function onKeyPress(event) {
        if ((event.which == 13) || (event.which == 32)) {
            this.click();
        }
        return false;
    }

    Capriza.Views.TableRow2 = Capriza.Views.Group.extend({
        template: "tableRow",
        initialize: function() {
            Capriza.Views.Group.prototype.initialize.apply(this, arguments);
            this.table = this.options.table;
            this.page = this.options.page;

            var shouldUseWebColor = this.table.model.get("shouldUseWebColor");
            this.model.attributes["shouldUseWebColor"] = shouldUseWebColor;
            this.getMainControl().attributes["shouldUseWebColor"] = shouldUseWebColor;
            _.each(this.getMainControl().get("controls"), function(control) {
                control.attributes["shouldUseWebColor"] = shouldUseWebColor;
                var controls = control.get("controls");
                controls && controls.forEach(arguments.callee);
            });

        },

        //initInnerContainer: function() {
        //    return $(".row-box", this.$el);
        //},

        _render: function() {
            this._renderHendelbars();
            this.$innerContainer =$(".row-box", this.$el);



           // var shouldUseWebColor = this.table.model.get("shouldUseWebColor");
            //Main Control
            var mainControl = this.getMainControl();
            var mainView = this.page.getView(mainControl.get("id"));
            mainView.render().addClass("main-control").appendTo(this.$innerContainer);
            mainView.rowIndex = this.rowIndex;

            //Aligned column
            if (this.table.model.get("alignedColumn") !== undefined) {
                mainView.$el.find(">.grouping>.ui-control").eq(this.table.model.get("alignedColumn")).appendTo(this.$innerContainer).addClass("hide-labels aligned-column");
            }

            //Group Selector
            if(this.table.isTableHasSelectable(this.model)){
                this.table.processSelectableGroupItem(this.getSelectControl(), this.getRepEl(), this.getUniqueControlId());
            }

            //Drill
            if (this.table.isTableHasDrillPage()) {
                this.addDrill();
            }


            //Swipe
            var swipeActions = this.getSwipeActions();

            if (swipeActions) {
                this.addSwipe(swipeActions);
            } else if(this.table.isTableHasSwipeActions() && !this.table.model.get('hasDrillPage')) {
                this.getRepEl().append('<div class="swipe-icon-placeholder"></div>');
            }

            return this.$el;
        },

        getRepEl:function(){
            return $(".row-box",this.$el).first();
        },

        setShouldUseWebColor: function() {

            Capriza.Views.UiControl.prototype.setShouldUseWebColor.apply(this, arguments);
            var style = this.model.get("style");
            style && this.getRepEl().css(style);
        },

        getMainControl: function() {
            var mainControl = this.model.get('controls').filter(function(control) {
                return control.get('type') === 'main';
            });
            return mainControl[0];
        },

        getSelectControl: function() {
            var selectControl = this.model.get('controls').filter(function(control){
                return control.get('type') === 'groupSelector';
            });
            return selectControl[0];
        },

        getSwipeActions: function() {
            var swipeActionsSections =  this.model.get('controls').filter(function(control) {
                return control.get('type') === 'swipeActions' && control.get('controls') && control.get('controls').length > 0;
            });
            return swipeActionsSections && swipeActionsSections[0];
        },



        //TODO: Refactor this abit...
        addDrill:function(){
            var self = this, $item = this.getRepEl(), row = this.getMainControl(), rowId = row.get("id");
            $item.addClass("drill");
            var $drillIcon = $("<div class='drill-icon'></div>").appendTo(this.getRepEl());

            if(!this.table.isTableHasDrillPageControls()){ //table actually does not have the drill pages (we are in the middle of phases).
                $drillIcon.addClass("missing-drill");
                return;
            }

            if (Capriza.device.isDesktop) {
                $drillIcon.attr("tabindex", 0).keypress(onKeyPress);
            }
            this.fastclick = $.capriza.fastClick($item[0], { highlightDelay: 100 });

            // This just looks like a hack, but actually all the stop propagation in TableEx should be written in a more simple way here, just like it is in tabular.
            $(".onoffswitch", $item).on("click", function(e) { e.stopPropagation(); });
            $(".onoffswitch3", $item).on("click", function(e) { e.stopPropagation(); });

            $item.on("click", function(e) {
                if(self.$el.hasClass("clickable") && !e.target.classList.contains("drill-icon")) return;

                e.stopPropagation();
                if ($(this).hasClass('swiping') || $(this).hasClass('swipped')) return;
                if ($(this).hasClass('swipe-shown')) {
                    self.hideSwipeActions(self.getRepEl($(this)));
                    return;
                }
                if (!$(".viewport").hasClass("transitioning") && !self.table.$el.hasClass('phantom')) {
                    var $liItem = self.$el;
                    $liItem.addClass('clicked');
                    setTimeout(function(){
                        $liItem.removeClass('clicked');
                    }, 0);

                    var transition = Capriza.device.isTablet ? "none" : "slide";
                    self.closeAllOtherSwipes();
                    self.table.doDrill(rowId, {transition: transition});
                    try{
                        self.reportInteraction({
                            element: "Table",
                            interaction: "click",
                            controlPath: "#" + self.model.get("id") + " [data-mc='"+rowId+"'] + div",
                            rowId: rowId,
                            rowIndex: self.drillIndex
                        });
                    } catch(e){
                        Logger.info("[UserInteraction] Exception on report Table do drill interaction");
                    }
                }
            });

        },

        hideSwipeActions: function(swipeContainer) {
            var self = this;
            $(swipeContainer).addClass('swiping');
            var cssObj = {};
            cssObj[transformProperty] = "translate3d(0, 0, 0)";

            document.removeEventListener("click", self.closeAllForThis, {passive: true});
            $(swipeContainer).transition(cssObj, function(){
                $(this).css(transformProperty, '0, 0, 0');
                $(this).removeClass('swiping');
                $(this).removeClass('swipe-shown');
                var numOfOpenSwipes = $('.swipped', self.$el).length;//TODO: copied a bug...the this of this function is not the table
                if (Capriza.device.stock && numOfOpenSwipes === 0) {
                    Capriza.Views.unregisterDisableScroll();
                }
                if(!$(swipeContainer).hasClass('swipingOn')) {
                    var $row = $(swipeContainer).parent();

                    $(".swipe_cell", $row).removeClass("show-swipe-actions");
                }
                self.trigger("swipe/end");
            });
        },

        showSwipeActions: function(swipeContainer) {
            var self = this;
            $(swipeContainer).addClass('swiping').addClass('swipingOn');
            self.closeAllForThis = self.closeAllOtherSwipes.bind(self);
            document.addEventListener("click", self.closeAllForThis, {passive: true});

            self.closeAllForThis(self.$innerContainer);

            var $row = $(swipeContainer).parent();

            var $cell = $(".swipe_cell", $row);
            if ($cell.length > 0) Logger.debug("[Table][showSwipeActions] add class 'show-swipe-actions' to: " + $cell[0].outerHTML);
            else Logger.debug("[Table][showSwipeActions] didn't find the swipe_cell, $row: " + $row[0].outerHTML);

            $cell.addClass("show-swipe-actions");

            var cssObj = {};
            cssObj[transformProperty] = "translate3d(-72%, 0, 0)";
            $(swipeContainer).transition(cssObj, function(){
                $(this).removeClass('swiping').removeClass('swipingOn');
                $(this).addClass('swipe-shown');
                if (Capriza.device.stock) {
                    Capriza.Views.registerDisableScroll();
                }
                self.trigger("swipe/end");
            });
        },

        initSwipeForItem: function($item, $itemContent, $swipeIcon, isMobile, onStartCallback) {
            if (isMobile) {
                $item.swipe({swipeRight: _.bind(this.showSwipeActions, this), swipeRightArgs: [$itemContent],
                    swipeLeft: _.bind(this.hideSwipeActions, this), swipeLeftArgs: [$itemContent], onStart: onStartCallback });
            }
            else {
                $item.mouseSwipe({swipeRight: _.bind(this.showSwipeActions, this), swipeRightArgs: [$itemContent],
                    swipeLeft: _.bind(this.hideSwipeActions, this), swipeLeftArgs: [$itemContent], onStart: onStartCallback });
            }
        },

        closeAllOtherSwipes: function($itemContent) {
            var openSwipes = $('.swiping, .swipe-shown');
            if (!$itemContent && openSwipes.length > 0) {
                //basically, close all swipes
                this.hideSwipeActions(openSwipes);
            }
            else {
                var self = this;
                //close all other swipes
                openSwipes.each(function() {
                    if (this != $itemContent[0]) {
                        self.hideSwipeActions($(this));
                    }
                })
            }
        },

        onDragTableCancel: function(xMoved, $el, step) {
            $el.addClass('swiping');

            if (step.direction === 'left') {
                this.hideSwipeActions($el[0]);
            }
            else {
                this.showSwipeActions($el[0]);
            }

        },

        //TODO: Refactor this abit...
        addSwipe: function(swipeActions) {
            var $item = this.$el;
            var $swipeIcon;

            $item.addClass("swipe");


            if (!this.table.model.get('hasDrillPage')) {
                $swipeIcon = $("<div class='swipe-icon'/>");
                $swipeIcon.html("<i class='fa fa-ellipsis-v'/>");

                if (Capriza.device.isDesktop) {
                    $swipeIcon.attr("tabindex", -1);
                }
                this.getRepEl().append($swipeIcon);
            }

            var swipeContainerView = this.options.page.getView(swipeActions.get('id'));
            if (!swipeContainerView) {
                Logger.error('ERROR! swipeContainerView '+swipeActions.get('id')+' is undefined');
            }
            var $swipeContainer = swipeContainerView.render();

            $("button", $swipeContainer).attr("tabindex", -1);
            $swipeContainer.addClass('swipe_cell');
            var self = this;

            var $itemContent = this.getRepEl();

            $swipeIcon = $('.swipe-icon', $itemContent);

            $swipeIcon.off('click').on('click', function(e) {
                e.stopPropagation();
                setTimeout(function(){
                    $swipeIcon.removeClass('clicked');
                }, 0);

                if ($(this).parent(".swipe-shown").length > 0) {
                    self.hideSwipeActions($itemContent);
                }
                else {
                    self.closeAllOtherSwipes();
                    self.showSwipeActions($itemContent);
                }

            });

            if (Capriza.device.isMobile && (Capriza.device.chrome || Capriza.device.ios)) {
                //strange, but this line of code solves #9306
                if (Capriza.device.ios) this.options.page.$el.on('touchstart', function() {});

                var itemWidth, thirdItemWidth, itemLeft;

                var dragCallback = function(step, transformProperty) {
                    if ($itemContent.hasClass('swiping') || ($itemContent.hasClass('swipe-shown') && step.direction === 'left')) {
                        step.toSet = undefined;
                        return;
                    }
                    var toX = step.toSet;
                    if ($itemContent[0].getBoundingClientRect().right+toX <= itemWidth &&
                        $itemContent[0].getBoundingClientRect().right >= (thirdItemWidth-10)) {

                        $itemContent[0].style[transformProperty] = 'translate3d('+toX+'px, 0, 0)';

                        try{
                            var controlPath = "#" + self.model.get("id") + " [data-mc='"+rowControlId+"'] + .swipe-icon";
                            if ($(controlPath).length) {
                                self.reportInteraction({
                                    element: "Table",
                                    interaction: "click",
                                    controlPath: controlPath,
                                    rowId: rowControlId,
                                    rowIndex: self.drillIndex,
                                    additionalData: "swipe perform"
                                });
                            }
                        } catch(e){
                            Logger.info("[UserInteraction] Exception on report Table do drill interaction");
                        }
                    }
                };

                var onStart = function(step) {

                    if (step.direction === 'left') {
                        self.closeAllOtherSwipes($itemContent);
                    }

                    $swipeContainer.addClass("show-swipe-actions");
                    //$itemContent[0].style[transformProperty] = 'translate3d(0, 0, 0)';
                    thirdItemWidth = $item.width()*0.3;
                    itemWidth = $item.width();
                    itemLeft = $item[0].getBoundingClientRect().left;
                };

                $itemContent.drag({swipeRight : _.bind(this.showSwipeActions, this),
                    swipeLeft : _.bind(this.hideSwipeActions, this),
                    threshold: 0.25,
                    dragCallback: dragCallback,
                    onCancel: _.bind(this.onDragTableCancel, this),
                    onStart: onStart});

            }
            else {
                this.initSwipeForItem($item, $itemContent, $swipeIcon, Capriza.device.isMobile);
            }

            $('.swipe_btn', $swipeContainer).on('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                var $btnElement = $(this);
                var swipeControl = swipeActions.filter(function(swipeControl){
                    return $btnElement.attr('id') === swipeControl.get('id');
                });
                if (swipeControl.length > 0) {
                    swipeControl[0].api.click();
                }
            });
            $item.prepend($swipeContainer);
            return $swipeContainer;

        }

    });

    Capriza.Model.DrillPage = Capriza.Model.ContextPage.extend({
        initialize: function() {
            var self = this;
            this.tableDrill = true;
            Capriza.Model.ContextPage.prototype.initialize.apply(this, arguments);

            var drillPageChildControls = this.get('controls');

            drillPageChildControls.forEach(function(ctrl){
                ctrl.parent = self;
            });
            this.updatePages(drillPageChildControls[0]);


        },

        updatePages: function(control) {
            Capriza.Model.ControlDB[control.id].pages = [this];

            var self = this;

            var subcontrols = control.get("controls");
            if (subcontrols) {
                subcontrols.forEach(function(childControl){
                    self.updatePages(childControl);
                });
            }
        },

        getDbKey: function() {
            return this.get("dbKey");
        },

        setControls:function(){
            Capriza.Model.Control.prototype.setControls.apply(this, arguments);
        },
        getContextId:function(){
            return Capriza.Model.Control.prototype.getContextId.apply(this, arguments);
        },
        addPage:function(page){
            //ignore this, it is only for Capriza.Model.Control compatibility
        }
    });


    Capriza.Views.DrillPage = Capriza.Views.ContextPage.extend({
        initialize: function() {

            _.bindAll(this, "render");
            Capriza.Views.ContextPage.prototype.initialize.apply(this, arguments);
            this.$el.addClass("table-drill").attr("data-mc", this.model.get("id")).attr("data-mctemplid", this.model.get("mcTemplId"));
            if (Capriza.isRTL) {
                this.$el.addClass('right-align');
            }

            var self = this;
            Dispatcher.off("switcherPrev/show");
            Dispatcher.on("switcherPrev/show", function($switcherBtn){
                var eventTrigger = Capriza.device.stock || Capriza.device.ios ? "touchend" : "click";
                $switcherBtn.off(eventTrigger).on(eventTrigger, function() {

                    if (!$(this).hasClass('disabled')) {
                        Logger.debug('switch up clicked');
                        $(this).addClass("clicked");
                        self.$el.trigger('drillPrevClicked');
                        var _this = this;
                        setTimeout(function(){$(_this).removeClass('clicked')}, 50);
                    }

                });

                $switcherBtn.toggleClass('disabled', !self.hasPreviousDrill());
            });

            Dispatcher.off("switcherNext/show");
            Dispatcher.on("switcherNext/show", function($switcherBtn){
                var eventTrigger = Capriza.device.stock || Capriza.device.ios ? "touchend" : "click";
                $switcherBtn.off(eventTrigger).on(eventTrigger, function() {

                    if (!$(this).hasClass('disabled')) {
                        Logger.debug('switch down clicked');
                        $(this).addClass("clicked");
                        self.$el.trigger('drillNextClicked');
                        var _this = this;
                        setTimeout(function(){$(_this).removeClass('clicked')}, 50);
                    }

                });
                Dispatcher.on("table/renderedChunk", function() {
                    $switcherBtn.removeClass('disabled');
                });
                Dispatcher.on("table/waitingForItems", function(that) {
                    $switcherBtn.toggleClass('disabled', !self.hasNextDrill.call(self));
                });

                $switcherBtn.toggleClass('disabled', !self.hasNextDrill());
            });

            if (this.model.get("shouldUseWebColor")) {

                this.model.get("controls").forEach(function(control) {
                    self.propagateWebColorFlag(Capriza.Model.ControlDB[control.id], self.model.get("shouldUseWebColor"));
                })

            }
        },

        propagateWebColorFlag: function(control, shouldUseWebColorValue) {

            control.set('shouldUseWebColor', shouldUseWebColorValue);
            var self = this;
            if (!control.get('controls')) return;
            control.get('controls').forEach(function(childControl) {
                self.propagateWebColorFlag(Capriza.Model.ControlDB[childControl.id], control.get("shouldUseWebColor"));
            })
        },

        getRoot: function() {
            return Capriza.Model.Control.getById(this.model.get("controls")[0].id);
        },

        getControlsIds: function() {
            return this.model.get("controls").map(function(control){return control.id});
        },

        _post: function() {

            var tableId = Capriza.Model.ControlDB[this.model.get('id')].parent.get('id');

            this.$el.attr("id", this.getPageId()+'_backdrill_'+tableId);
        },

        hasNextDrill: function() {
            var rowControl = Capriza.Model.Control.getById(this.model.get('rowControlId'));
            if (!this.model.get('id') || !Capriza.Model.ControlDB[this.model.get('id')] || !rowControl){
                return;
            }
            var tableModel = Capriza.Model.ControlDB[this.model.get('id')].parent;

            var controlIndex = tableModel.get('controls').indexOf(rowControl.parent);

            return (controlIndex > -1 && controlIndex < tableModel.get('controls').length-2) || (tableModel && tableModel.get("yesMore") && !tableModel.waitingForItems);
        },

        hasPreviousDrill: function() {

            var rowControl = Capriza.Model.Control.getById(this.model.get('rowControlId'));
            var tableModel = Capriza.Model.ControlDB[this.model.get('id')].parent;

            var controlIndex = tableModel.get('controls').indexOf(rowControl.parent);

            return controlIndex > 0;

        },

        beforeBack: function(toPage) {
            Dispatcher.off("table/renderedChunk").off("table/waitingForItems");
            if (!toPage.hasClass('table-drill') && !toPage.hasClass('cdialog')) {
                this._clearHeader();
            }

        },

        destroy: function() {
            this._clearHeader();
            Dispatcher.off("table/renderedChunk").off("table/waitingForItems");
            Capriza.Views.PageView.prototype.destroy.call(this);
        },

        _clearHeader: function() {
            setTimeout(function(){
                $('.next-switcher').transition({"x": "0px"});
                $('.prev-switcher').transition({"x": "0px"});
                Dispatcher.trigger("header/remove");
            }, 0);
        },

        getViews: function(controls) {
            var self = this;
            controls = controls || this.model.get("controls")[0].get("controls").map(function(control) { return Capriza.Model.Control.getById(control.id); });
            return controls.map(function(control) { return self.getView(control.get("id")); }).filter(function(view) { return !!view; });
        }
    });

    Capriza.Views.Table = Capriza.Views.Group.extend({
        className: "table",
        drillPage: undefined,


        createAndAddControl: function(control){
            if(control.get("type") === 'drillPage') return;
            Capriza.Views.Group.prototype.createAndAddControl.apply(this, arguments);
        },

        getView: function(model) {
            if (model.get("type") === 'topLevel'){
                return new Capriza.Views.TableRow2({ model: model, page: this.options.page, table: this});
            }
            else {
                Logger.warn("getView of table should not be called with control other than topLevel");
            }
        },

        getFirstTopLevelControl: function() {
            var topLevelControls = this.getTopLevelControls();
            return topLevelControls.length > 0 && topLevelControls[0];
        },


        initInnerContainer: function() {
            return $("<ul class='rows'></ul>").appendTo(this.$el);
        },

        getTopLevelControls: function() {
            var controls = this.model.get('controls');
            var topLevelControls = controls.filter(function(control) {
                return (control.get && control.get('type') === 'topLevel') || control.type === 'topLevel';
            });
            return topLevelControls;
        },

        getMainControl: function(topLevelControl) {
            var mainControl = topLevelControl.get('controls').filter(function(control) {
                return control.get('type') === 'main';
            });
            return mainControl[0];
        },

        getSwipeActionsControl: function(topLevelControl) {
            var swipeActionsControl = topLevelControl.get('controls').filter(function(control) {
                return control.get('type') === 'swipeActions';
            });
            return swipeActionsControl[0];
        },

        addPhaseUI: function() {
			if (this.model.get("noDataEnabled") === false) return;

			var noDataText = this.model.get("noDataText") || Capriza.translator.getText(Capriza.translator.ids.noDataAvailable);

            var $partialSpinner = $("<li class='partial-phase-0-spinner empty-table-spinner'></li>").rotatingSpinner({
                width: "35px",
                height: "35px",
            });
            this.$innerContainer.prepend($partialSpinner).prepend("<li class='empty-table'>"+noDataText+"</li>");
            this.model.get("emptySpinnerOn") !== false && this.model.set("emptySpinnerOn", true);
        },

        closeAllSwipes: function() {
            var firstTopLevelControl = this.getFirstTopLevelControl();
            if(firstTopLevelControl) {
                var tableRowView = this.options.page.getView(firstTopLevelControl.id);
                tableRowView && tableRowView.closeAllOtherSwipes();
            }
        },

        _render: function() {
            Logger.debug('render of table has started');
            var self = this, controls = this.model.get("controls");
            this.$el.attr("id", this.getUniqueControlId() || "");

            this.addPhaseUI();

            if (this.isTableHasSwipeActions()) {
                this.$el.addClass('swipe');
                Dispatcher.on('control/action/end pageView/tabChange', function(control) {
                    var controlId = (control && control.model && control.model.get("id")) || control;
                    Logger.debug('Closing all swipes due to clicking on ' + controlId);
                    self.closeAllSwipes();
                }, this);
            }

            if (this.isTableHasDrillPage()) {
                this.$el.addClass('drill');
            }

            if(this.model.get("phase") === undefined)
                _.each(this.model.get('controls'), this.addTopLevelControl, this);

            var firstLine = this.$('li.row')[0];
            firstLine && $("*", $(firstLine)).removeClass('highlighted');

            self.refreshEmpty();

            this.addPaginator();
            this.setPresentedControlCount();

            var topLevelControls = this.getTopLevelControls();
            this.renderedCount = topLevelControls && topLevelControls.length;

            this.options.page.listeningToPageChange = (this.options.page.listeningToPageChange || []);
            if (this.options.page.listeningToPageChange.indexOf(self.model.get("id")) === -1) {
                this.options.page.listeningToPageChange.push(self.model.get("id"));

                Dispatcher.on("page/back/before", function(data) {
                    Logger.debug("[Table] received 'page/back/before' to: " + data.toPage.data("pageView"));
                    if (data.toPage.data("pageView") === self.options.page) {
                        var tableView = self.options.page.getView(self.model.get("id"));
                        if (tableView) { // if the view was already deleted from the page. TODO: WARNING SIGN!!! too many bugs with this piece of code. should be transferred to the page view.
                            Logger.debug(self.model.get("id") + ": setting inDrill to false (cid=" + tableView.cid + ")");
                            self.options.page.inDrill = false;
                            delete self.options.page.model.drillIndex;

                            //notify the page the drill is not "blocking" anymore..
                            Capriza.Views.UiControl.prototype.unblockPage.apply(self);
                        }
                    }
                });
            }

            if (this.model.get("partialPhase") !== undefined) {
                this.$el.addClass("partial-phase-" + this.model.get("partialPhase"));
            }
            if (this.model.get("phase") > 0) {
                this.$el.addClass("partial-phase-" + 2);
            }

            if (this.options.page.inDrill === this.model.get('id')) {
                this.keepDrillUiState();
            }

            this.initHint(this.getSwippableItem());

            return this.$el;
        },

        initHint: function($hintedElement) {

            if (!this.options.page.hinted && this.isTableHasDrillPage() && this.isTableHasSwipeActions()) {

                //There is something wrong with chrome 36 for android that this hint screws up the swipe. ran out of
                //time for investigating...disabling for now
                if (!Capriza.device.isMobile || (Capriza.device.isMobile && !Capriza.device.chrome)) {
                    Logger.debug('going to show hint');
                    setTimeout(this.hintSwipe.bind(this, $hintedElement), 300);
                    this.options.page.hinted = true;
                }

            }
        },

        //TODO:fix rendering
        renderChunk: function(startIndex) {
            Logger.debug('render chunk started with '+startIndex);
            var self = this;
            var newControls = self.getTopLevelControls().slice(startIndex);
            _.each(newControls, function(control, i) {
                self.createAndAddControl(control);

                self.addTopLevelControl(control, (startIndex+i)*2);
            });

            Dispatcher.trigger("table/renderedChunk");

            Logger.debug('render chunk ended with '+startIndex);

            self.setMcStyle();
        },

        hintSwipe: function($hintedElement) {
            $(".swipe_cell",$($hintedElement).parent()).addClass("show-swipe-actions");
            $hintedElement.transition({ 'x': '-15%' }, function(){
                $(this).transition({ 'x': '0%'},function(){
                    if (!$($hintedElement).hasClass('swipe-shown')) //#20934
                        $(".swipe_cell",$($hintedElement).parent()).removeClass("show-swipe-actions");
                }).removeClass('hinting');
            }).addClass('hinting');
        },

        initDrillPage: function(data) {

            data.parentPage = this.options.page.model;
            data.contextId = this.options.page.model.get('contextId');
            data.tableId = this.model.get('id');
            data.shouldUseWebColor = this.model.get('shouldUseWebColor');

            var drillPage = new Capriza.Model.DrillPage(data);
            drillPage.parent = Capriza.Model.ControlDB[drillPage.get("id")].parent;
            Capriza.Model.ControlDB[drillPage.get("id")] = drillPage;
            return drillPage;
        },

        onDrillPrevClicked: function() {


            var prevRowId = this.getNextRowId(-2);

            if (prevRowId) {
                this.doDrill(prevRowId, { transition: "none", headerTransition: "flip", reverse: true, notInStack: true, replaceInStack: true});
                $(".prev-switcher>.value").focus();

                var toPage = this.drillPage ? this.drillPage.$el : undefined;
                $(document).trigger("pagechange", { toPage:toPage });
            }


        },

        onDrillNextClicked: function() {
            var nextRowId = this.getNextRowId(2);
            this.getNextRowsFromDrill();
            if (nextRowId) {

                this.doDrill(nextRowId, { transition: "none", headerTransition: "flip", notInStack: true, replaceInStack: true});
                $(".next-switcher>.value").focus();

                var toPage = this.drillPage ? this.drillPage.$el : undefined;
                $(document).trigger("pagechange", { toPage:toPage });
            }
        },

        getNextRowsFromDrill: function(){
            if (this.model.get("yesMore") && !this.waitingForItems && this.drillIndex/2 > this.renderedCount - 4) {
                this.waitingForItems = true;
                this.model.waitingForItems = true;
                this.model.api.getMoreItems(this.renderedCount);
                Dispatcher.trigger("table/waitingForItems", this);
            }
        },

        getNextRowId: function(step) {
            var currIndex = this.drillIndex, nextViews, result = undefined;


            if (!this.$el.hasClass('tabular')) {
                nextViews = _.values(this.options.page._views).filter(_.bind(function(view) {
                    var tableId = this.model.get('id');

                    if (view.rowIndex || view.rowIndex === 0) {
                        var viewParentId = view.model.parent.parent.id;
                    }

                    return view.rowIndex === currIndex + step && tableId === viewParentId;
                }, this));

                nextViews.forEach(function(nextView) {
                    if (nextView.$el.css('display')) {
                        result = nextView;
                    }
                });

                return result && result.model.get('id');
            }
            else {
                this.$("tr").each(function() {
                    if ($(this).data('rowIndex') === currIndex + step) {
                        result = $(this).data('model').id;
                    }
                });
                return result;
            }



        },

        addTopLevelControl: function(control, i) {
            if (control.get('type') !== 'topLevel') return;
            this.renderedCount++;

            var view = this.options.page.getView(control.get("id"));

            view.rowIndex = i;
            view.render().appendTo(this.$innerContainer);

        },

        isTableHasDrillPage: function() {
            return this.model.get("hasDrillPage");
        },

        isTableHasDrillPageControls: function() {
            var controls = this.model.get("controls");
            var hasAnyDrillPage =  controls.some(function(control) {
                return control.get('type') === 'drillPage';
            });
            return hasAnyDrillPage;
        },

        isTableHasSwipeActions: function() {

            var topLevelControls = this.getTopLevelControls();
            if (topLevelControls.length === 0) return false;
            var controls = topLevelControls[0].get("controls");
            var swipeActionsSections =  controls.filter(function(control) {
                return control.get('type') === 'swipeActions' && control.get('controls') && control.get('controls').length > 0;
            });
            return swipeActionsSections.length > 0;
        },

        isTableHasSelectable: function(topLevelControl) {
            var mainControl = this.getMainControl(topLevelControl);
            var selectControl = mainControl.parent.get('controls').filter(function(control){return control.get('type') === 'groupSelector';});

            return selectControl.length > 0 && !this.isTableHasSwipeActions();
        },

        getSwipeActions: function(topLevelControl) {//used in ILEBars
            var swipeActionsSections =  topLevelControl.get('controls').filter(function(control) {
                return control.get('type') === 'swipeActions';
            });
            return swipeActionsSections.length > 0 && swipeActionsSections[0];
        },

        getSwippableItem: function($item) {
            $item = $item || this.$('.row-wrap').first();
            return this.getRowSubElement($item);

        },

        getRowSubElement: function($item) {
            return $item.children(".row-box");
        },

        doDrill: function(rowControlId, options) {
            var self = this;
            self.drillItemId = rowControlId;

            if (Capriza.compatMode) {
                delete self.drillPage.scrollPosition;
            }

            self.drillPage = self.buildDrillPage(rowControlId);


            if (self.scrollDetector) {
                self.scrollDetector.stop();
                Dispatcher.once("page/back/after", function() {
                    self.scrollDetector.start();
                });
            }

            this.options.page.inDrill = this.model.get('id');

            if (this.$el.hasClass('tabular')) {
                var trEl = this.$("tr").filter(function(){
                    return $(this).data('model') && $(this).data('model').id === rowControlId;
                });

                self.drillIndex = trEl.data('rowIndex');
            }
            else {

                self.drillIndex = this.options.page.getView(rowControlId).rowIndex;

            }
            self.options.page.model.drillIndex = self.drillIndex;
            self.drillPage.model.set("rowControlId", rowControlId);
            self.drillPage.render();
            options.fromPage = this.options.page;
            self.drillPage.show(options);

            //inherited from uiControl, notifies the page that this control now blocks the entire page,
            //until "unblockPage" or "back" are called
            this.notifyBlockPage();

            self.trigger("table/drill", self.drillPage);
        },

        getDrillPageDBID: function() {
            return "page_"+this.options.page.model.get("id")+"_table_"+this.model.get('id')+"_drillPage";
        },


        buildDrillPage: function(rowControlId) {


            var rowControl = Capriza.Model.ControlDB[rowControlId];
            var drillPageData = this.getDrillPageData(rowControl.parent.get('refId'));
            var contentToRemove = $(".table-drill[id*=backdrill_"+this.model.get('id')+"]");
            if (contentToRemove.length > 0) {
                contentToRemove.remove();
            }

            var drillPageModel = this.initDrillPage(drillPageData.toJSON());
            var pageView = new Capriza.Views.DrillPage({ model: drillPageModel });

            if (this.model.get("partialPhase") === 1 || this.model.get("phase") > 0) {
                pageView.$el.addClass("loading-page").append('<div class="spinner"></div>');
            }

            if (this.model.get("shouldUseWebColor") && drillPageData.get('style')) {
                pageView.$el.css(drillPageData.get('style'));
            }

            pageView.$el.on("drillPrevClicked", _.bind(this.onDrillPrevClicked, this));
            pageView.$el.on("drillNextClicked", _.bind(this.onDrillNextClicked, this));
            return pageView;
        },

        getDrillPageData: function(refId) {
            var controls = this.model.get('controls');
            var filteredResults = controls.filter(function(control) {
                return control.get('refId') === refId && control.get('type') === 'drillPage';
            });

            return filteredResults[0];

        },

        setControls: function() {

            Capriza.Views.Group.prototype.setControls.apply(this, arguments);
            this.refreshEmpty();

            if (this.options.page.inDrill) {
                this.keepDrillUiState();
            }

        },

        keepDrillUiState: function(){

            Logger.debug('keepDrillUiState started');

            var self = this;

            function handleInDrill() {
                var succeededDrill = self.keepInDrill(self.drillItemId, self.options.page.model.drillIndex);
                if (!succeededDrill) self.options.page.show({ transition: "none" }).$el.css({ x: 0 });
            }

            // If table gets controlUpdates and the view is inside the drill page - try to find the same row ID.
            // If the row IDs have changed - try to go to the row in the same index (fair assumption? TiVo thinks so ...)
            // If there isn't a row at that index - go back to the table page

            if ($(".viewport").hasClass("transitioning")) { // fix to #7272
                Dispatcher.once("page/change/after", function() {
                    handleInDrill();
                });
            } else {
                handleInDrill()
            }

        },

        keepInDrill: function(drillItemId, drillIndex) {

            Logger.debug('keepInDrill started with '+drillItemId+' drill index is '+drillIndex);

            if(!this.isTableHasDrillPage()){
                Logger.debug('cannot keepInDrill as there are no drill pages');
                this.options.page.inDrill = false;
                delete this.options.page.model.drillIndex;
                return;
            }

            var rows = this.model.get("controls");
            if (rows.some(function(x) { return drillItemId == x.get("id"); })) {
                Logger.debug("keeping drill in the same row");
            } else if (rows.length > drillIndex) {

                var topLevelControl = rows[drillIndex];
                Logger.debug('looking for '+topLevelControl.get('type')+' '+topLevelControl.get('id')+' main control')
                var mainControlArray = topLevelControl.get('controls').filter(function(control){return control.get('type') === 'main';});
                drillItemId = mainControlArray[0].get("id");
                Logger.debug("simulating drill on the same index row");
            } else {
                Logger.debug("can't keep drill on row");
                drillItemId = null;
            }

            var lastPage = $.capriza.pages[$.capriza.pages.length-1];
            if ($(lastPage).hasClass('table-drill')) {
                $.capriza.pages.pop();
            }

            if (drillItemId) {
                this.doDrill(drillItemId, {transition: "none"});
                try{
                    this.reportInteraction({
                        element: "Table",
                        interaction: "click",
                        controlPath: "#" + this.model.get("id") + " [data-mc='"+drillItemId+"'] + div",
                        rowId: drillItemId,
                        rowIndex: this.drillIndex
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Table do drill interaction");
                }
            }
            return drillItemId;
        },

        _refreshEmpty: function() {
            var controls = this.model.get("controls"), isEmpty = (this.model.get("partialPhase") !== 0 && (!controls || !controls.length)) || (this.model.get("phase") > 0);
            this.$(".empty-table").toggleClass("active", isEmpty);
        },

        refreshEmpty: function() {
            var self = this, controls = this.model.get("controls"), isEmpty = (this.model.get("partialPhase") !== 0 && (!controls || !controls.length)) || (this.model.get("phase") > 0);

            clearTimeout(this.showEmptyTableMsg);

            if(!isEmpty) {
                this.$(".empty-table, .empty-table-spinner").removeClass("active");
				this.model.set("emptySpinnerOn", false);
                return;
            }
            if (this.model.get("partialPhase") !== 0 && this.model.get("emptySpinnerOn") === false){
                self.$(".empty-table").addClass("active");
                return;
            }
            this.$(".empty-table-spinner").addClass("active");
            this.showEmptyTableMsg = setTimeout(function(){
                self.$(".empty-table").addClass("active");
                self.$(".empty-table-spinner").removeClass("active");
				self.model.set("emptySpinnerOn", false);
            }, self.model.get("noDataTimeout") || 4000);
        },

        //This method is called from the page, when the page wants to close/clear "blocking" controls
        unblockPage: function(){
            if (!this.destroyed) $.capriza.backPage();
        },

//        update: function() {
//            Capriza.Views.Group.prototype.update.apply(this, arguments);
//            if (this.model.get("hasNext") || this.model.get("hasPrevious")) {
//                $.capriza.activePage.data('pageView') && $.capriza.activePage.data('pageView').scrollTo(0, this.el.offsetTop);
//            }
//        }

        update: function(attributes) {
            Capriza.Views.Group.prototype.update.apply(this, arguments);
			var parent = this.$el.parent()[0];
            if (!attributes.hasOwnProperty('yesMore') && this.model.get("hasPrevious") && parent) {
                parent.scrollTop = this.el.offsetTop;
            }
            Dispatcher.trigger('table/updated', this.$el);
        },
        _destroy: function() {
            Capriza.Views.Group.prototype._destroy.apply(this, arguments);
            if (this.drillPage) {
                this.drillPage.getViews().forEach(function(view){
                    view.destroy();
                });
                Capriza.Views.UiControl.prototype.unblockPage.apply(this);
            }
        },

        //meant to allow click on a table row (drill) when mvp is displayed
        shouldAllowClickWhenDisabled: function(data){
            if (!data) return false;

            var row = $(data.event.target).closest(".ui-control.row-wrap").data("uicontrol");
            return row && row.model && row.model.get('type') == 'topLevel';
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/TabularView.js

try{
;(function() {

    var testElement = document.createElement('div');

    var flexPrefix = "flex" in testElement.style ? "flex" : "-webkit-flex";

    Capriza.Views.Tabular = Capriza.Views.Table.extend({
        _render: function() {
            
            this.$el.addClass('tabular-view');

            Capriza.Views.Table.prototype._render.apply(this, arguments);

            if (!this.model.get("hideHeaders")) this.setHeaders();
            return this.$el;

        },

        setHeaders: function() {
            this.$('.rows').prepend($('<li class="tabular-headers" ></li><li style="display:none"></li>'));
            
            var headers = this.getHeaders(), $headersContainer = this.$('.tabular-headers'), self = this;

            if (this.getFirstTopLevelControl() && this.isTableHasSelectable(this.getFirstTopLevelControl())) {
                $headersContainer.addClass('has-selectable').prepend('<div class="table-header-selectable"></div>');
            }

            headers.forEach(function(header) {
                var flexValue = header.columnData && header.columnData.flex || "";
                $('<div class="tabular-header">'+header.key+'</div>').css(flexPrefix, flexValue).appendTo($headersContainer);
            });
        },

        getHeaders: function() {
            var firstTopLevelControl = this.getTopLevelControls()[0];
            if (!firstTopLevelControl) return [];
            var mainControl = this.getMainControl(firstTopLevelControl), columnData = this.model.get("columnData") || [];
            return mainControl.get('controls').map(function(control, index) {
                var columnDataAtIndex = columnData[index],
                    key = (columnDataAtIndex && columnDataAtIndex.key) || control.get('key') || "";
                
                return {
                    key: key,
                    columnData: columnDataAtIndex
                };
            });
        }
    });

})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Link.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 11/15/12
 * Time: 5:30 PM
 * To change this template use File | Settings | File Templates.
 */
;(function() {
    Capriza.Views.Link = Capriza.Views.UiControl.extend({
        action: "click",
        widget: "link",

        getWidget: function(){
            return this.model.get("widget") || this.widget;
        },

        _render: function() {
            var self = this;
            var model = _.extend(this.model.toJSON(), { uniqueControlId: this.getUniqueControlId() });

//          recognized as file url
            var href = this.model.get("href");
            if (href) {
                Utils.Links.createExternalLink(this);
            } else {
                var widgetName = this.getWidget();
                this.$el[widgetName](model).on(widgetName.toLowerCase() + "_click", function() {
                    self.model.api[self.action]();
                    return false;
                });
            }

            this.$(".value").on("click", function(e) {
                try{
                    this.reportInteraction({
                    element: "Engine Link",
                    interaction: "click"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Engine link click interaction");
                }
                e.stopPropagation();
                Dispatcher.trigger("control/action/end",self);
            });

            return this.$el;
        },

        setName: function(name) {
            this.$el[this.widget]("setText", name);
        },

        setIsDisabled: function(){
            Capriza.Views.UiControl.prototype.setIsDisabled.apply(this, arguments);
            //update the widget as well
            this.$el[this.getWidget()]("setIsDisabled", this.model.get("isDisabled"));

        }
    });

    Capriza.Views.ClientLink = Capriza.Views.Link.extend({
        _render: function(){
            var model = _.extend(this.model.toJSON(), { uniqueControlId: this.getUniqueControlId() });
            if (!model.data) model.icon = null;
            this.$el["link"](model);

            return this.$el;
        },
        _post: function() {
            var linkType = this.model.get('clientLinkType');
            switch (linkType) {
                case "externalLink":
                case "zappLink":
                case "phone":
                case "email":
                case "address":
                {
                    var options = this.model.attributes;
                    if (options) {
                        options.target = this.$(".value");
                        this.$el[linkType](options);
                        this.$(".value")[0].href = this.$el[0].action;
                    }
                    break;
                }
            }
            this.$el.addClass(linkType).addClass("user-action");
        },
        setData: function(){
            var linkType = this.model.get('clientLinkType');
            switch(linkType){
                case "externalLink":
                case "zappLink":
                case "phone":
                case "email":
                case "address":{
                    var options = this.model.attributes;
                    if (options) {
                        this.$el[linkType]("setData", options);
                        this.$(".value")[0].href = this.$el[0].action;

                        //if there is data, set the icon, else remove the icon
                        if (options.data)
                            this.$el["link"]("setIcon", options.icon);
                        else
                            this.$el["link"]("setIcon", null);
                    }
                    break;
                }
            }
        },
        onClick: function() {
            try {
                this.reportInteraction({
                    element: (this.model.get('clientLinkType') || "").capitalize() + " Link (Client)",
                    interaction: "click",
                    data: this.model.get("data")
                });
            } catch(e){
                Logger.info("[UserInteraction] Fail to report Client Link interaction");
            }
            //ToDo: should enable send stats to engine
        }
    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Image.js

try{
;(function() {
    Capriza.Views.Image = Capriza.Views.UiControl.extend({
        tagName: "div",

        _render: function() {
            var model = _.extend(this.model.toJSON(), { uniqueControlId: this.getUniqueControlId() }), self = this;

            this.$el.image(model);
            this.$el.image('addClassToImage', 'hidden');

            this.$el.image('onLoad', function() {
                self.$el.image('removeClassToImage', 'hidden');
                setTimeout(self.trigger.bind(self, "image/loaded"), 300);
            });

            this.setSrc();
            return this.$el;
        },


        setSrc: function() {

            if (this.model.get("isBackgroundImage")) {

                this.$el.image("setBackgroundImage", this.model.get("src") || "", this.model.get("backgroundPosition") || "center", this.model.get("backgroundSize") || "cover");
            }
            else {
                this.$el.image("setSrc", this.model.get("src") || "");
            }

        },

        applyMcSize: function(){

            if (this.model.get("mcSize")) {
                $('img', this.$el).css(this.model.get("mcSize"));
            }
        }

    });

    Capriza.Views.ImageLink = Capriza.Views.Image.extend({
        _render: function() {
            Capriza.Views.Image.prototype._render.apply(this, arguments);
            var self = this;
            this.$el.on("image_click", function() {
                self.model.api.click();
                return false;
            });

            return this.$el;
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Textbox.js

try{
;(function() {

    function textBoxOnWidowResize(){
        if(document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA"){
            window.setTimeout(function(){
                document.activeElement.scrollIntoViewIfNeeded();
            },0);
        }
    }
    // fix ##13545 - Input on the page's bottom gets hidden by the keyboard on focus for Android.
    // FIX for iOS is in done below by listening to each click inside the input field
    if (Capriza.device.android) {
        window.addEventListener("resize", textBoxOnWidowResize);
    }

    Handlebars.registerHelper('textboxClass', function() {
        var klass = this._textboxClass;
        if (this.isSubmittable) klass += " submittable";
        if (this.multiline) klass += " multiline";
        return klass;
    });

    // Repositions popover on window resize
    function windowResized(event) {
        var control = event.data.control;

        // avoid blocking UI by high-rate repositionings
        if (!control.isPositioningPopover) {
            control.isPositioningPopover = true;

            requestAnimationFrame(function () {
                control.positionPopOver();
                control.isPositioningPopover = false;
            });
        }
    }

    Capriza.Views.TextboxBase = Capriza.Views.HandlebarsUiControl.extend({
        template: "textbox",
        inputType: "text",
        textboxIcon: "fa fa-times-circle",
        textboxClass: "textbox",
        isPositioningPopover: false,

        ////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////

        isDropdownEnabled: function(){
            return !!this.model.get("cacheKey") || !!this.model.get("cacheData");
        },

        options : {
            hasInput    : true,
            opener      : true,
            openerIcon  : "fa fa-caret-down",
            button      : false,
            multi       : false,
            filterable  : false,
            hideOnEmpty : false,
            showWhenReadOnly:false,

            sortByHist  : true,
            allowUnselect: false
        },

        initialize: function() {
            if(this.isDropdownEnabled()) {
                var self = this;
                var typeAdapter = this._types[this.model.get("type")];
                _.extend(this, typeAdapter);

                _.extend(this.options, this.opts);
                this.options.multi = this.model.get("multiple") != undefined ? this.model.get("multiple") : this.options.multi;
                ["modal", "openerIcon", "sortByHist", "filterable"].forEach(function (prop) {
                    if (self.model.get(prop) !== undefined) {
                        self.options[prop] = self.model.get(prop);
                    }
                });

                if(this.options.modal && (this.options.hasInput || this.options.filterable)){
                    this.options.modalInput = true;
                }

                Capriza.Model.Caching.initCaching(this.model);

                this.model.set("rows", []);
                this.model.set("filteredSortedRows", []);
				this.model.on("change:textValue", this.model.onTextValueChanged);
            }
            this._initialize && this._initialize();

        },

        removeDropdown: function () {
            if (this.$modalOver) this.$modalOver.remove();

            if (this.$popOver) {
                this.$popOver.remove();
                $(window).off("resize", windowResized);
            }
            this.$rows = undefined;
        },

        _destroy:function(){
            this.trigger("dropdown:destroy");
            textBoxOnWidowResize && window.removeEventListener("resize",textBoxOnWidowResize);
            this.removeDropdown();
            Utils.shieldDown("dd"+this.model.get("id"));
        },



        _post: function() {

            var self = this;
            setTimeout(function(){
                self.on("selectItems", function(){
                   self.trigger("itemsSelected");
                })
            }, 10);
            if(this.isDropdownEnabled()) this.renderDropdown();

            if(this.options.hasInput) {
                this._addMaxLengthValidation(this.getInput(true));
            }

            if (this.isBarcode()){
                this.$el.addClass("barcode");
            }

        },

        renderDropdown: function () {
            var self = this;
            this.$el.addClass("dropdown");


            this.setIsReadOnly(); //TODO: enable this ? yes, please. it's not executed generically by UiControl even though it's defined there. why? because.
            this.model.on("change:rows", this.filterAndSortRows, this);
            this.model.on("change:filteredSortedRows", this.populateItems, this);
            this.model.on("change:textValue", this.fillValue, this);
            this.fillValue();
            this.filterAndSortRows();

            this.addUiEventListeners();
            if (this.options.hasInput) {
                this.checkEmpty();
            }

            this.onScroll = function(){
                self.hideDropdown(true);
            };
        },

        addDropdownEventListeners:function(){
            var self = this;
            var onclick = function (e) {
                if(self.$items[0] == e.target || self.$rows[0] == e.target) {return;/* in modal when clicked outside an item we should ignore the click*/}
                var items = self.model.get("rows").filter(function (itm) {
                    if(itm.shouldSelect){itm.selected = true;}
                    else{delete itm.selected;}
                    delete itm.shouldSelect;
                    return itm.selected;
                });
                self.trigger("selectItems", items);
                self.hideDropdown();

                try{
                    self.reportInteraction({
                        element: "TextBox",
                        interaction: "click",
                        controlPath: "[data-modal-mc="+self.model.get("id")+"] .dd-save"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Text box save dd interaction");
                }
            };

            var eventsMap = Capriza.device.isMobile ? {click: onclick}
                : {click: onclick,
                mousedown: function () {self.keepDropdown = true}};

            (this.options.multi ? this.$save : this.$items).off(eventsMap).on(eventsMap);

            if(this.options.modalInput){
                var modalKeyUp = function(e){
                    self.checkEmpty();
                    self.trigger("modalInputKeyUp", e);
                };
                this.getInput().on("keyup",modalKeyUp);
                if(Capriza.device.ios){
                    this.getInput().on("focus",function(e){
                        var vh = Capriza.cordova && window.top.innerHeight > 0  ? window.top.innerHeight : "45%";
                        self.$modalOver.css("height" , vh);
                        self.$modalInput && self.$modalInput.length && setTimeout(function() {
                            self.$modalInput[0].scrollIntoViewIfNeeded();
                        }, 300);
                    }).on("blur",function(){
                        self.$modalOver.css("height" , "");
                    });
                }
            }
        },

        // Overrides to make a field marked by CSS class "focusable" get focus
        // or prevent focus according to its "isDisabled" state
        setIsDisabled: function () {
            Capriza.Views.HandlebarsUiControl.prototype.setIsDisabled.call(this);

            if (this.model.get("isDisabled")) {
                this.$(".focusable").attr("tabindex", -1);
            } else if (!this.model.get("isReadOnly")) {
                this.$(".focusable").attr("tabindex", 0);
            }
        },

        // Calls a handler for keyboard events
        _onKeyDown: function (event) {
            var s = {9: "_onTab", 13: "_onEnter", 27: "_onEscape",
                32: "_onSpace", 35: "_onEndOrHome", 36: "_onEndOrHome",
                38: "_onArrowUp", 40: "_onArrowDown"}[event.which];

            s && this[s](event);
        },

        // Hides dropdown
        _onTab: function () {
            this.hideDropdown(true);
        },

        // Hides dropdown
        _onEscape: function (event) {
            this.shown && event.stopPropagation();
            this.hideDropdown(true);
        },

        // Simulates a click to select an item if popup is open
        _onEnter: function (event) {
            var $rows = this.$rows;
            var item = ($rows ? $rows.children(".focused")[0] : null);

            if (item) {
                // simulate click to select item and put the focus back
                this.getInput(true).blur();
                item.click();
            } else if (event.which == 13) {
                // no item to select, close dropdown if shown

                try{
                    var controlPath = "[data-modal-mc="+this.model.get("id")+"]";
                    if ($(controlPath + " .dd-close").length){
                        controlPath += " .dd-close";
                    } else {
                        controlPath += " .dd-save";
                    }
                    this.reportInteraction({
                        element: "DropDown",
                        interaction: "click",
                        controlPath: controlPath
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Text box enter dd interaction");
                }
                this.hideDropdown(true);
            }

            var $v = this.$(".focusable");

            setTimeout(function () {$v.focus()}, 0);
        },

        // Space works like Enter on textboxes without input
        _onSpace: function (event) {
            if (!this.opts.hasInput) {
                event.preventDefault();
                Capriza.Views.Textbox.prototype._onEnter.call(this, event);
            }
        },

        // Moves selection to last/first item in popup
        _onEndOrHome: function (event) {
            if (this.shown) {
                var $items = this.$rows.children();
                var i = $items.filter(".focused").index();

                (event.which == 36) ? this._moveItemFocus(-i)
                    : this._moveItemFocus($items.length - 1 - i);

                event.preventDefault();
            }
        },

        // Arrow up - moves selection inside a popup (if shown).
        // Alt + Arrow up - cancels items popup
        _onArrowUp: function (event) {
            if (event.altKey) {
                this.hideDropdown(true);
            } else if (this.shown) {
                this._moveItemFocus(-1);
            }
            event.preventDefault();
        },

        // Opens popup or moves selection inside it (if already open)
        _onArrowDown: function (event) {
            if (this.shown) {
                // popup is shown, move selection inside it
                this._moveItemFocus(1);
            } else if (this.model.get("isReadOnly")
                && !this.options.showWhenReadOnly) {

                // popup is not shown and it's a readonly field
                // simulate a click on action button to open popup
                this.$actionButton.click();
            } else {
                // popup is not shown, open it
                this.showDropdown();
            }

            event.preventDefault();
        },

        // Moves a selection inside items popup
        _moveItemFocus: function (delta) {
            var $items = this.$rows.children();
            var $focusedItem = $items.filter(".focused").removeClass("focused");
            var index = ($focusedItem.index() + delta);
            var i = (index < 0) ? ($items.length - 1) : (index % $items.length);
            var $v = $items.eq(i).addClass("focused");

            $v[0] && $v[0].scrollIntoView(false);
        },

        addUiEventListeners: function () {
            var self = this;

            this.$openerButton = this.$("button.opener");
            this.$openerButton.on("click", _.bind(this.toggleDropdown, this));

            //this (re #13688) was commented due to several regressions of opening dropdowns in ios.
            //if(this.options.hasInput && Capriza.device.ios) {
            //    this.$(".value").find("input, textarea").on("focus", _.bind(this.toggleDropdown, this));
            //}

            //"focus" "click"
            this.$(".focusable").on("click", _.bind(this.toggleDropdown, this));

            if (Capriza.device.isDesktop) {
                this.$(".focusable").on(
                    "keydown", _.bind(this._onKeyDown, this));
            }
            this.$actionButton = this.$("button.action-button");
            this.$actionButton.on("click", function(e){
                self.trigger("actionClicked", e);
                e.stopPropagation();
            });

            this.$clearIcon = this.$("button.clear");
            this.$clearIcon.mousedown(function () {self.keepDropdown = true});
            this.$clearIcon.on("click", function() {
                if (self.model.get("isReadOnly")) return false;
                try{
                    self.reportInteraction({
                        element: "TextBox",
                        interaction: "click",
                        controlPath: "#"+self.$el.prop("id") + ".icon.clear",
                        additionalData: "Clear Text",
                        "old-value": self.model.get("encrypt") ? "$$Encrypted$$" : self.getInput(true).val()
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Text box clear text interaction");
                }
                self.getInput(true).val("");
                self.model.set("textValue", "");
                self.model.api.setText("");
                if(self.options.filterable) {self.filterAndSortRows()}
                // TODO (amit): crappy solution for #6791 - did it quickly for BMC
                if (self.$el.closest(".list,.table").length === 0) {
                    self.getInput(true).focus();
                }
                self.trigger("clear:input");
                return false;
            });

            if(self.options.hasInput) {
                this.getInput(true).on("keyup", function (e) {
                    self.checkEmpty();
                    self.trigger("controlInputKeyUp", e);
                    // If entered from next (tab) command the Click event wasn't dispatched
                    if(e.keyCode == 9){
                        self.toggleDropdown(e);
                    }
                }).on("keydown", function(e){
                    // If leaving with next (tab) command the Blur event wasn't dispatched
                    if(e.keyCode == 9){
                        self.changeListener();
                    }
                });
            }

            this.listenToChange();

            var $input = this.getInput(true).on("focus", function(e){
                Dispatcher.trigger("textBox/inputFocused", self);
                self.trigger("inputFocused", e);
            }).on("click", function(e){
                // fix ##13545 - Input on the page's bottom gets hidden by the keyboard on focus for iOS.
                // FIX for Android is in done above by listening to window resize
                if(Capriza.device.ios) {
                    setTimeout(function(){
                        self.getClosestScrollingContainer().off("scroll",self.onScroll);
                        //self.getScrollingContainer().off("scroll",self.onScroll);
                        if($input[0].scrollIntoViewIfNeeded) $input[0].scrollIntoViewIfNeeded();
                        self.getClosestScrollingContainer().on("scroll",self.onScroll);
                        //self.getScrollingContainer().on("scroll",self.onScroll);
                    },100);
                }
                self.trigger("inputClicked", e);
            });

            this.trigger("uiEventListenersAdded");

        },

        listenToChange:function(){
            var self = this;

            if(!self.touchingRegistered){
                self.touchingRegistered = true;
                this.$clearIcon = this.$("button.clear");
                this.$clearIcon
                    .on("touchstart mousedown",function(){
                        self.$clearIcon.toggleClass("touching",true);
                    }).on("touchend mouseup",function(){
                        setTimeout(function(){
                            self.$clearIcon.toggleClass("touching",false);
                        },10);
                    });
            }

            this.changeListener = this.changeListener || function(e){
                var $inputElement = self.getInput(true);
                var touchedClear = !!self.$(".clear.touching")[0];
                var eventClear = false;
                if (Capriza.device.firefox){
                    var origClear = e && e.originalEvent && $(e.originalEvent.explicitOriginalTarget);//For Firefox
                    eventClear = origClear && origClear.classList && origClear.classList.contains("clear") && origClear.parentElement == $inputElement[0].parentElement ;//For Firefox
                } else {
                    var relatedClear = e && e.relatedTarget;
                    eventClear = relatedClear && relatedClear.classList && relatedClear.classList.contains("clear") && relatedClear.parentElement == $inputElement[0].parentElement;//For Chrome
                }
                var activeIsClear = $(document.activeElement).hasClass("clear") && document.activeElement.parentElement == $inputElement[0].parentElement;

                self.hideDropdown(true, e);

                if(eventClear || activeIsClear || touchedClear ) return;
                var val = self.model.get("textValue") === undefined ? self.model.get("text") : self.model.get("textValue");
                if($inputElement.val() != val) {
                    self.trigger("change", e);
                }
            };
            this.getInput(true).on("blur",this.changeListener);
        },

        stopListenToChange:function(){
            this.getInput(true).off("blur",this.changeListener);
        },

        filterAndSortRows:function(e){

            var self= this;
            var isOpener = self.isOpener || e && e.target && ($(e.target).hasClass("opener") || $(e.target).closest("button").hasClass("opener"));

            var rows = this.model.get("rows") || [];
            if(this.options.filterable && !isOpener){
                var $input = this.getInput();
                var filter = $input && $input.val();
                if(filter) {
                    var regExp = new RegExp(".*" + filter.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ".*", 'i');
                    rows = rows.filter(function (itm) {
                        return regExp.test(itm.text) || (itm.additional && itm.additional.length > 0 && itm.additional.some(function(a){
                            return regExp.test(a.text);
                        }));
                    });
                }
            }

            if(self.options.sortByHist){
                rows.sort(function(a, b){
                    if(a.hist == undefined && b.hist == undefined) return a.idx - b.idx; //No hist sort by index
                    if(a.hist > -1 && b.hist == undefined) return -1; //hist always first
                    if(b.hist > -1 && a.hist == undefined) return 1; //hist always first
                    return a.histIdx - b.histIdx; //sort by hist index
                });
            }
            this.model.set("filteredSortedRows", rows);

            return rows.length > 0;
        },

        populateItems: function () {
            var self= this;
            if(!self.$rows) return;
            self.$rows.empty();
            var rows = this.model.get("filteredSortedRows") || [];

            if(!this.options.modal && rows.length == 0 && this.options.hideOnEmpty) {
                this.hideDropdown();//TODO: consider temp hiding; or showing current textbox value if applicable
                return;
            }

            rows.forEach(function(item, idx){
                if(item.selected) item.shouldSelect = true;
                else delete item.shouldSelect;
                var itemText = (item.text || "").replace(/\xA0/g/* removing "real" nbsp char that causes lines not to wrap*/, " ");
                var $itemEl = $('<li data-idx="'+item.idx+'"><div class="text-wrap"><span class="item-text"></span><span class="additional-text"></span></div><i class="fa fa-check checked single-checked"></i><i class="icon-checkbox-selected multiple-checked"></i><i class="icon-checkbox-unselected multiple-unchecked"></li>')
                    .toggleClass("selected",!!item.selected)
                    .toggleClass("disabled",!!item.disabled)
                    .on("click", function(e){
                        if(item.disabled) {
                            self.trigger("dropdown:disable");
                            e.stopPropagation();
                            return;
                        }
                        var selected = (item.shouldSelect === undefined) ? item.selected : item.shouldSelect;
                        if(selected && !self.options.multi && !self.options.allowUnselect) return;//Prevent unselect when it is not supported
                        if(!self.options.multi) self.model.get("rows").forEach(function(other){other.setSelected && other.setSelected(false);});
                        item.setSelected(!selected);
                    });
                $(".item-text",$itemEl).text(itemText);
                if(item.additional && item.additional.length > 0){
                    var additionalText = item.additional.map(function(a){
                        return a.text.replace(/<.*?>/g,"");
                    }).join(", ");
                    $(".additional-text",$itemEl).text(additionalText);
                }

                if(item.hist){
                    $('<i class="fa fa-clock-o history"></i>').appendTo($itemEl);

                    /////////////////////////////////////////////
                    var swipeAnySide = function() {
                        self.model.removeItemFromHist(item);
                        delete item.hist;
                        delete item.histIdx;
                        self.trigger("cache:updated");
                        self.filterAndSortRows();
                    };

                    var dragCallback = function(step, transformProperty) {
                        if ($itemEl.hasClass('swiping')) return;
                        $itemEl[0].style[transformProperty] = 'translate3d('+step.curX+'px, 0, 0)';
                        var dist = Math.abs(step.curX);
                        dist = dist > 150 ? 150 : dist;
                        var opacity = (dist / 500);
                        opacity = opacity < 0.1 ? 0.1 : opacity;
                        $itemEl[0].style["background"] = 'rgba(0,0,0,' + opacity + ')';
                    };

                    var onCancel = function(){
                        $itemEl.transition({ x: '0px', background:'transparent' });
                        $itemEl.removeClass("deleting-cache");
                    };

                    var onStart = function(){
                        $itemEl.addClass("deleting-cache");
                    };

                    $itemEl.drag({swipeRight : swipeAnySide,
                        swipeLeft : swipeAnySide,
                        threshold: 0.5,
                        dragCallback: dragCallback,
                        onCancel: onCancel,
                        onStart: onStart});
                    /////////////////////////////////////////////
                }
                item.setSelected = function(state){//TODO: fix when in single select mode and selecting the selected item
                    item.shouldSelect = state;
                    $itemEl.toggleClass("selected", state);
                };

                self.$rows.append($itemEl);
            });
            if(this.shown) this.positionPopOver();
        },

        fillValue: function(){
            var value = this.model.get("textValue");
            if(this.options.hasInput) {
                if (value === undefined) return; // copied (in a way) from Textbox.js::setText
                var $input = this.getInput(true);
                if (!$input.is(":focus") && $input.val() !== value) $input.val(value); // also copied from Textbox.js::setText
                this.checkEmpty();
            }
            else {
                this.$(".selected-content").text(value);
                this.fillPlaceholderIfNeeded();
            }
        },

        fillPlaceholderIfNeeded:function(){
            if(this.options.hasInput) return;//placeholder handled by the input...
            if(!this.model.get("textValue") && this.model.get("placeholder")) {
                this.$(".selected-content").text(this.model.get("placeholder")).addClass("placeholder-text");
            }
            else{
                this.$(".selected-content").removeClass("placeholder-text");
            }
        },

        //////////////////////////////////////// Visual Rendering


        createItemsEl:function(){
            this.$items = $('<div class="items"><ul class="rows"></ul><div class="loading-data hidden">Loading more choices...</div><button class="dd-save"><i class="fa fa-check"></i></button></div>').toggleClass("multi",this.options.multi);//TODO: dont call options as it is not cached
            this.$rows = this.$items.find(".rows");
            this.$save = this.$items.find(".dd-save");
            this.$loading = this.$items.find(".loading-data");

            this.$items.on("click",function(e){
                e.stopPropagation();
                e.preventDefault();
            });

            return this.$items;
        },

        createPopover:function(){
            this.$popOver = this.renderOutsideEl("popover").addClass("popover-dropdown closed hidden").toggleClass("multi",this.options.multi);

            this.$tipFG = $('<div class="dd-tip-fg"></div>').appendTo(this.$popOver);
            this.createItemsEl().appendTo(this.$popOver);
            this.$tipBG = $('<div class="dd-tip-bg"></div>').appendTo(this.$popOver);

            var self = this;

            this.$popOver.bind('animationend webkitAnimationEnd MSAnimationEnd oAnimationEnd', function(e) {
                self.$rows.addClass('active');
                if (e.originalEvent.animationName === 'close') {
                    self.$popOver.removeClass("close-bubble");
                    self.$popOver.addClass("closed hidden");
                    self.$rows.removeClass('active');
                }

            });

            if(this.options.filterable){
                this.getInput(true).on("input",function(){
                    clearTimeout(self.filterTimeout);
                    self.filterTimeout = setTimeout(function(){
                        self.filterAndSortRows();
                    },300)
                });
            }

            $(window).on("resize", {control: this}, windowResized);
        },

        createModal:function(){
            var self = this;
            this.$modalOver = this.renderOutsideEl("modal").addClass("modal-dropdown closed hidden").toggleClass("multi",this.options.multi);
            $('<div class="dd-header"><button class="dd-close"><i class="fa fa-times"></i></button></div>').appendTo(this.$modalOver);
            var $header = this.$modalOver.find(".dd-header");

            if(this.options.modalInput){
                this.$modalInput = $('<input>').addClass("dd-input").appendTo($header);
                this.$modalInput.on("keydown", self._onKeyDown.bind(self));
                $('<button class="icon clear"><i class="fa fa-times-circle"></i></button>').appendTo($header).on("click", function() {
                    self.$modalInput.val("").focus();
                    if(!self.options.model.get("isReadOnly") && !self.options.preventClearTextValueFromModal) {self.model.set("textValue", "");}
                    self.trigger("clear:modalinput");
                    if(self.options.filterable) {self.filterAndSortRows()}
                    return false;
                });
                $header.find(".fa-times").removeClass("fa-times").addClass("fa-chevron-left");
                this.$modalOver.addClass("has-input");

                this._addMaxLengthValidation(this.$modalInput);
            }
            else{
                $('<div>Choose options</div>').addClass("dd-text").appendTo($header);
            }

            if(this.options.filterable){
                this.$modalInput.on("keyup",function(){
                    clearTimeout(self.filterTimeout);
                    self.filterTimeout = setTimeout(function(){
                        self.filterAndSortRows();
                    },300)
                });
            }

            this.createItemsEl().appendTo(this.$modalOver);
            this.$save.remove().appendTo($header);

            $header.find(".dd-close").on("click",function(e){
                self.hideDropdown(true);
                self.trigger("modal:close");

                try{
                    self.reportInteraction({
                        element: "TextBox",
                        interaction: "click",
                        controlPath: "[data-modal-mc="+self.model.get("id")+"] .dd-close"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Text box close dd interaction");
                }
            })
        },


        //////////////////////////////////////// Show/Hide

        showLoading:function(){
            this.isLoading = true;
            this.$loading && this.$loading.toggleClass("hidden", false);
            this.$el.toggleClass("loading", true);
            this.trigger("loading/show");
        },

        hideLoading:function(){
            this.isLoading = false;
            this.$loading && this.$loading.toggleClass("hidden", true);
            this.$el.toggleClass("loading", false);
            this.trigger("loading/hide");
        },


        showDropdown:function(e1){
            e1 = e1 && e1.originalEvent || e1 || {};
            if(this.shown || this.hiding || e1.justHidden || this.model.get("isDisabled") || (!this.options.showWhenReadOnly && this.model.get("isReadOnly"))) return;

            var self = this;
            var beforeShowArg = {};
            this.trigger("beforeShow", beforeShowArg);
            if(beforeShowArg.cancel) return;

            var hasItems = this.filterAndSortRows(e1);
            if(this.options.hideOnEmpty && !hasItems) return;

            if (this.options.modal || this.options.multi) {
                this.createModal();
            }
            else {
                this.createPopover();
            }
            this.addDropdownEventListeners();
            this.populateItems();
            this.isLoading && this.$loading.toggleClass("hidden", false);

            if(this.$popOver){
                this.$shield = Utils.shieldUp("dd"+this.model.get("id"), true);
                if(Capriza.device.ios){
                    //this.getScrollingContainer().on("scroll",this.onScroll);
                    this.getClosestScrollingContainer().on("scroll",this.onScroll);
                }
                else if (Capriza.device.android){
                    this.getClosestScrollingContainer().css({"overflow-y":"hidden"});
                    //this.getScrollingContainer().css({"overflow-y":"hidden"});
                }
                this.$popOver.removeClass("hidden")[0].offsetWidth;
                this.positionPopOver();

                var animationClasses = this.options.hasInput ? '' : ' open-bubble-bounce-start';
                this.$popOver.addClass('active'+animationClasses).removeClass("closed");

                if (!animationClasses /*|| Capriza.device.ie11*/) {
                    this.$rows.addClass('active');
                }

                this.$shield.on("click",function(e){
                    self.trigger("shield:click", e);
                    if(e.dontHide) return;

                    try{
                        self.reportInteraction({
                            element: "TextBox",
                            interaction: "click",
                            controlPath: ".global-shield.dd"+self.model.get("id")
                        });
                    } catch(e){
                        Logger.info("[UserInteraction] Exception on report Text box close popup interaction");
                    }
                    self.hideDropdown(true, e);
                });
            }

            if(this.$modalOver){
                function changeClasses(){
                    self.$modalOver.removeClass("hidden");
                    if(Capriza.device.ios){
                        self.getClosestScrollingContainer().on("scroll",self.onScroll);
                        //self.getScrollingContainer().on("scroll",self.onScroll);
                    }
                    else if (Capriza.device.android){
                        self.getClosestScrollingContainer().css({"overflow-y":"hidden"});
                        //self.getScrollingContainer().css({"overflow-y":"hidden"});
                    }
                    self.$shield.css({"background":"rgba(0,0,0,0.2)"});
                    self.$modalOver.addClass('active').removeClass("closed");
                }
                this.$shield = Utils.shieldUp("dd" + this.model.get("id"), true).css({"background":"rgba(0,0,0,0)","transition":"background-color 0.2s"});
                this.$shield.on("click",function(e){
                    self.hideDropdown(true, e);
                });

                if(Capriza.device.isTablet) {
                    if(!this.options.modalInput) {
                        this.$modalOver.bind('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd', function(e) {
                            self.$modalOver.removeClass("sliding");
                        });
                    }
                    changeClasses();
                }else{
                    changeClasses();
                }

                if(this.$modalInput){
                    this.$modalInput.val(this.getInput(true).val());
                    this.$modalInput.focus();
                }
            }

            this.shown = true;
            e1.justShown = true;

            //inherited from uiControl, notifies the page that this control now blocks the entire page,
            //until "unblockPage" or "hideBubble" are called
            this.notifyBlockPage();

            this.trigger("dropdown:shown");
        },

        hideDropdown:function(cancel, e1){
            e1 = e1 && e1.originalEvent || e1 || {};
            if(!this.shown || e1.justShown) return;
            this.hiding = true;

            var self = this;

            cancel ? this.trigger("canceling") : this.$(".focusable").focus();
            this.trigger("beforeHide");

            function finishHiding(){
                self.shown = false;
                e1.justHidden = true;
                //notify the page that this dropdown doesn't block it anymore.
                Capriza.Views.UiControl.prototype.unblockPage.apply(self);
                self.trigger("dropdown:hidden");
                self.hiding = false;
            }
            if(this.$popOver){
                Utils.shieldDown("dd"+this.model.get("id"));
                if(Capriza.device.ios){
                    this.getClosestScrollingContainer().off("scroll",this.onScroll);
                    //this.getScrollingContainer().off("scroll",this.onScroll);
                }
                else if (Capriza.device.android){
                    //this.getScrollingContainer().css({"overflow-y":"auto"});
                    this.getClosestScrollingContainer().css({"overflow-y":"auto"});
                }

                var animationClasses = this.options.hasInput ? '' : "close-bubble";
                this.$popOver.addClass(animationClasses);
                this.$popOver.removeClass('active');
                this.$popOver.removeClass('open-bubble-bounce-start');

                this.$popOver.bind('animationend webkitAnimationEnd MSAnimationEnd oAnimationEnd', function(e) {
                    self.removeDropdown();
                    finishHiding();
                });

                if (!animationClasses /*|| Capriza.device.ie11*/) {
                    self.removeDropdown();
                    finishHiding();
                }
            }
            if(this.$modalOver){
                function changeClassesAndRemove(){
                    self.$modalOver.addClass("hidden closed");
                    self.$modalOver.removeClass('active');
                    Utils.shieldDown("dd"+self.model.get("id"));
                    if(Capriza.device.ios){
                        self.getClosestScrollingContainer().off("scroll",self.onScroll);
                        //self.getScrollingContainer().off("scroll",self.onScroll);
                    }
                    else if (Capriza.device.android){
                        self.getClosestScrollingContainer().css({"overflow-y":"auto"});
                        //self.getScrollingContainer().css({"overflow-y":"auto"});
                    }
                    self.removeDropdown();
                    finishHiding();
                }
                this.$shield.css({"background":"rgba(0,0,0,0)"});
                if(Capriza.device.isTablet) {
                    self.$modalOver.addClass("sliding");
                    if(!this.options.modalInput) {
                        self.$modalOver.bind('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd', function(e) {
                            self.$modalOver.removeClass("sliding");
                            changeClassesAndRemove();
                        });
                        self.$modalOver.removeClass('active');
                    }
                    else{
                        changeClassesAndRemove();
                    }
                }
                else {
                    changeClassesAndRemove();
                }
            }
        },

        toggleDropdown: function(e){
            try{
                this.reportInteraction({
                    element: "TextBox",
                    interaction: "click"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Text box toggle dropdown interaction");
            }
            if(this.shown) {
                this.hideDropdown(true,e)
            } else {
                this.showDropdown(e);
            }
            e.stopPropagation();
        },

        //This method is called from the page, when the page wants to close/clear "blocking" controls
        unblockPage: function(){
            this.hideDropdown(true);
        },

        positionPopOver:function(){
            if(!this.$popOver) return;
            var tipHalfHeight = this.$tipFG.css("border-left-width").replace("px","");
            var tipVisualHeight = tipHalfHeight / 0.71 /* ~sin(45)*/;
            var elRect = (this.$el.find(".opener").length > 0 ? this.$el.find(".opener") : this.$el)[0].getBoundingClientRect();
            var btnRect = (this.$openerButton && this.$openerButton[0] ? this.$openerButton[0].getBoundingClientRect(): elRect);
            var vpRect = $('.viewport')[0].getBoundingClientRect();

            var tipLeftAdjust = 0;
            if(Capriza.device.isTablet){
                var elValueRect = (this.$el.find(".value").length > 0 ? this.$el.find(".value") : this.$el)[0].getBoundingClientRect();
                this.$popOver.css({left: elValueRect.left, right: (vpRect.width - elValueRect.right)});
                tipLeftAdjust = elValueRect.left;
            }

            var tipLeft = btnRect.left - vpRect.left + (btnRect.width/2) - tipLeftAdjust - tipHalfHeight /*height and width are the same*/;
            var bgBorderWidth = 1 * this.$tipBG.css("border-left-width").replace("px","");

            var itemsOverHeight= this.$popOver.find(".items").height();
            //this.$popOver.find(".rows").css({"height":itemsOverHeight});
            var withKeyBoard = document.activeElement && (document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA"); // #19310 in IE11 activeElement can be null
            var threshold = withKeyBoard ? 0.6 : 1.2;

            if(elRect.top - vpRect.top > (vpRect.bottom - elRect.bottom) * threshold) { //Should open upwards

                // Popover
                var elTop = elRect.top - vpRect.top - itemsOverHeight;// - tipVisualHeight;
                this.$popOver.css('top', elTop);
                this.$popOver.css('transform-origin', (tipLeft +(tipVisualHeight/2)) + "px bottom");
                //this.$popOver.attr('placement', 'bottom-'+animateOrigin);
                // Tip
                var tipTop = itemsOverHeight - tipVisualHeight +1;
                this.$tipFG.css({"left" : tipLeft,"top" : tipTop,"transform":"transform: rotateZ(225deg)"});
                this.$tipBG.css({"left" : tipLeft - bgBorderWidth,"top" : tipTop,"transform":"transform: rotateZ(225deg)"});
            } else {
                // Popover
                //TODO: consider removing the border size itself instead of -1 in case we have a thicker border (should also consider the input border if needed)
                var elBottom = elRect.bottom - vpRect.top -1;// + tipVisualHeight;
                this.$popOver.css('top', elBottom);
                this.$popOver.css('transform-origin', (tipLeft +(tipVisualHeight/2)) + "px top");
                //this.$popOver.attr('placement', 'top-'+animateOrigin);
                // Tip
                this.$tipFG.css({"left" : tipLeft,"top" : -tipHalfHeight,"transform":"transform: rotateZ(45deg)"});
                this.$tipBG.css({"left" : tipLeft - bgBorderWidth,"top" : -tipHalfHeight,"transform":"transform: rotateZ(45deg)"});
            }
        },

        ////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////

        getPresentationModel: function () {
            var model = this.model.toJSON(),
                buttonObj = this.getTextboxButtonObj();

            _.extend(model, {
                uniqueControlId: this.getUniqueControlId(),
                labelId: this.labelId(),
                inputId: this.labelFor(),
                inputType: model.inputType || this.inputType,
                hasIconLabel: !!model.iconLabel,
                textboxIcon: buttonObj.icon,
                ariaLabel: buttonObj.ariaLabel,
                actionClass: buttonObj.actionName,
                buttonDisabled: buttonObj.disable,
                _textboxClass: this.textboxClass,
                isClearButton: this.isClearButton()
            });

            if(this.isDropdownEnabled()) {
                _.extend(model, this.options);

                model.button = model.button || this.isLocation() || this.isBarcode();
                model.hasIconButton = model.opener || model.button;
                model.textValue = model.text || model.valueText || model.placeholder;
            }

            return model;
        },

        getTextboxButtonObj: function() {
            var textboxIcon = this.textboxIcon, ariaLabel = "Clear Text", disable = false, actionName = "";
            if (this.isBarcode()) {
                textboxIcon = "fa fa-qrcode";
                ariaLabel = "Scan with camera";
                disable = !this.enableBarcode();
                actionName = "barcode";
            }
            if (this.isLocation()) {
                textboxIcon = "fa fa-location-arrow";
                ariaLabel = "Locate on Map";
                disable = !this.enableLocation();
                actionName = "location";
            }
            if (this.isSubmittable()) {
                textboxIcon = 'fa fa-chevron-right';
                ariaLabel = "Submit";
            }

            return {
                icon: textboxIcon,
                ariaLabel: ariaLabel,
                disable: disable,
                actionName: actionName
            };
        },

        isBarcode: function() {
            return this.hasExtraData("barcode");
        },

        isLocation: function() {
            return this.hasExtraData("location");
        },

        isSubmittable: function() {
            return this.model.get("isSubmittable");
        },

        isClearButton: function() {
            return this.getTextboxButtonObj().icon === "fa fa-times-circle";
        },

        enableBarcode: function() {
            return this.isBarcode() && Capriza.Capp && Capriza.Capp.barcodeScanner;
        },

        enableLocation: function() {
            return this.isLocation() && !window.isDesignerPreview && !window.designerLoaded;
        },

        getInput:function(real){
            if(!real && this.options.modal && this.options.modalInput){
                return this.$modalInput;
            }

            if (this.model.get("multiline")) {
                return this.$("textarea");
            } else {
                return this.$("input");
            }
        },

        setText: function(text) {
            var $input = this.getInput();

            if (text !== undefined && !$input.is(':focus') && $input.val() !== text) {
                $input.val(text);

                if(this.model.get("multiline")){
                    $input.trigger("autosize");
                }
            }

            this.checkEmpty && this.checkEmpty($input);
        },

        getText: function(){
            var $input = this.getInput();
            return $input.val();
        },

        disablePropagation: function() {
            this.$(".value, label").on('click', function(e) {
                e.stopPropagation();
                e.preventDefault();
            })
        },
        checkEmpty: function($input) {
            $input = $input || this.getInput(true);
            if(!$input || $input.val()===undefined) return;//TODO: <<-- fix this hack (to prevent exception when having a filter on a non input DD)
            this.$el.toggleClass("empty", $input.val().length==0);
        },

        setTooltip: function() {
            Capriza.Views.UiControl.prototype.setTooltip.apply(this, arguments);
            if (this.model.get('tooltip')) {
                this.getInput(true).attr('title', this.model.get('tooltip'));
            }

        },

        locationInput:function() {
            function locationSuccess(position) {

                function geocodingSuccess(geocode) {
                    logger.log(geocode);
                    window.baba = geocode;
                    if(geocode.status != "OK"){
                        return error();
                    }
                    var locationType = self.model.get("locationType");
                    if (!locationType) {
                        locationType = "full_address";
                    }
                    var address = window.Utils.LocationParser.getLocation(geocode.results, locationType);
                    if (!address) {
                        if (locationType === "full_address" || locationType === "gps_coordinates") {
                            address = lat + "," + lng;
                        }
                        else {
                            address = "";
                        }
                    }

                    try{
                        self.reportInteraction({
                            element: "TextBox",
                            interaction: "click",
                            additionalData: "Geo Location",
                            value: self.model.get("encrypt") ? "$$Encrypted$$" : address
                        });
                    } catch(e){
                        Logger.info("[UserInteraction] Exception on report Text box geolocation interaction");
                    }
                    self.model.set("textValue", address);
                    self.model.api.setText(address);
                    self.fillValue();
                    $input.blur();
                    Utils.hideLoading();
                }

                var lat=position.coords.latitude;
                var lng=position.coords.longitude;

                var apiRequest=googleReverseGeocodingApi.replace('{lat}',lat);
                apiRequest=apiRequest.replace('{lng}', lng);


                $.ajax({
                    url: apiRequest,
                    success: geocodingSuccess,
                    error:error,
                    xhrFields:{
                        withCredentials:false
                    }
                });
            }

            function error() {
                alert("Couldn't get location, make sure location services are enabled in settings", null, "location disabled");
                logger.error("Getting location error",arguments);
                Utils.hideLoading();
            }

            function getLocation(e){
                Utils.showLoading('Getting your location...');
                try {
                    top.navigator.geolocation.getCurrentPosition(locationSuccess, error, {enableHighAccuracy: true, timeout: 5000});
                }
                catch (err) {
                    error();
                }
                $input.blur();
            }

            var self = this;
            var googleReverseGeocodingApi="https://maps.google.com/maps/api/geocode/json?latlng={lat},{lng}";
            var $input =this.getInput(true);
            this.$(".location").off("click").on("click", getLocation);
        },
    });


    //////////////////////////////////////// Model Extension
    Capriza.Model.Caching = {};

    Capriza.Model.Caching.initCaching = function(model){
        var cacheKey = model.get("cacheData") && model.get("cacheData").key;
        _.extend(model, Capriza.Model.Caching.Prosthesis);
        Capriza.Model.Caching._cachedControls[model.get("id")] = model;
        if(!cacheKey) return;
        if(!Capriza.Model.Caching._cacheKeys[cacheKey]) {
            Capriza.Model.Caching._cacheKeys[cacheKey] = _.extend({}, Backbone.Events);
            if(!window.appData){
                Dispatcher.once("appData", function() {
                    model.triggerHistoryChanged(cacheKey);
                });
            }
        }
        Capriza.Model.Caching._cacheKeys[cacheKey].on("history:change",function(mcId){
            if(model.get("id") == mcId) {
                setTimeout(function(){
                    model.refreshRows();
                },251);
            }
            else{
                model.refreshRows();
            }
        });

    };

    Capriza.Model.Caching.refreshAllCachedControls=function(){
            Object.keys(Capriza.Model.Caching._cachedControls).forEach(function(key){
                Capriza.Model.Caching._cachedControls[key].refreshRows();
            })
    };

    Capriza.Model.Caching.Prosthesis = {

        _mergeCache: function(items, cache, union){
            if(!cache) return items;
            var merged = items.map(function(item, idx){
                var cacheItem = _.find(cache,function(ci){
                    var found = ci.text == item.text;
                    if(found) ci.idx = idx;
                    return found;
                });
                return _.extend(item,cacheItem);
            });
            if(union){
                var notMerged = cache.filter(function(ci){
                   return !(ci.idx > -1);
                });
                merged = merged.concat(notMerged);
            }
            return merged;
        },

        getItems:function(){
            return [];
        },

        refreshRows:function(){
            var items = this.getItems();
            var cache = Capriza.CacheManager.getHistory(this);
            items = this._mergeCache(items, cache);
            this.set("rows", items);
        },

        saveToCache: function(reason){
            if(!this.get("cacheKey") && !this.get("cacheData")) return;
            var self = this;
            var items = this.getCurrentItemsForCache(reason);
            var additional;

            if(items.length == 1){
                additional = this.getAdditionalValues(reason);
            }

            items.forEach(function(item){
                if(item.text && item.text.trim()){
                    if(additional){
                        item.additional = additional;
                    }
                    Capriza.CacheManager.setHistory(self,item);
                }
            });

			if (items.length > 0) {
				Capriza.CacheManager.setPersonalizedRTParam(self, items[items.length - 1].text);
			}

            this.triggerHistoryChanged(this.get("cacheData").key);
        },

		onTextValueChanged: function() {
			Capriza.CacheManager.verifyPersonalizedRTParam(this, this.get("textValue"));
		},

        triggerHistoryChanged: function (key) {
            Capriza.Model.Caching._cacheKeys[key] && Capriza.Model.Caching._cacheKeys[key].trigger("history:change",this.get("id"));
        },

        removeItemFromHist:function(item){
            if(!this.get("cacheKey") && !this.get("cacheData")) return;
            Capriza.CacheManager.removeItemFromHist(this, item.histIdx);
            this.triggerHistoryChanged(this.get("cacheData").key);
        },

        getCurrentItemsForCache:function(){
            return this.get("rows").filter(function(item){
                return item.selected;
            }).map(function(item){
                return {text: item.text}; //No need for selected or index or nothing
            });
        },

        getAdditionalValues: function(){
            var additional;
            if(this.get("cacheSecondaryControls")){
                additional = [];
                this.get("cacheSecondaryControls").forEach(function(mcId){
                    var additionalModel = Capriza.Model.Control.getById(mcId);
                    var item = additionalModel.getCurrentItemsForCache && additionalModel.getCurrentItemsForCache();
                    if(item && item.length > 0 && item[0].text.length > 0) additional.push(_.extend({mcId:mcId},item[0]));
                });
            }
            return additional;
        }
    };

    Capriza.Model.Caching._cachedControls = {};
    Capriza.Model.Caching._cacheKeys = {};

    Capriza.Views.Textbox = Capriza.Views.TextboxBase.extend({

        _post: function() {

            var self = this;
            _.bindAll(this, "onChange", "submit", "onKeyUp", "enableBarcodeWhenReady");
            var $input = this.getInput(true);

            $input.on("keyup", this.onKeyUp);

            // TODO: this should be cleaned up: in TextboxBase._post the addUiEventListeners method is called only if !isDropDownEnabled
            if (!this.isDropdownEnabled()) {
                //$input.on("change", this.onChange);
                this.listenToChange();
                this.on("change",this.onChange);
                this.$(".icon").on("click", _.bind(this.onClearClick, this));
            }

            if (this.enableLocation()) {
                this.locationInput();
            }

            if (this.isSubmittable()) {
                this.setIsSubmittable();
            }

            if (this.isBarcode()) {
                if (this.enableBarcode()){
                    this.barcodeScannerInput();
                }
                else {
                    Dispatcher.on("capp/pluginready", self.enableBarcodeWhenReady);
                    Logger.debug("barcode scanner not ready - waiting for event");
                }
            }

            if (this.model.get("multiline")) {
                $input.css("min-height",50);
                setTimeout(function(){
                    $input.autosize();
                },10);

            }

            if (this.model.get("incrementalType")) {
                $input.on("input", function(){
                    self.model.api.setText(self.getEventData());
                });
            }

            // This is a fix for bug #21592 - the problem is "-webkit-overflow-scrolling: touch" on the page but we can't remove it.
            // Need to force reflow so that the input will draw the new value.
            // Don't use Capriza.reflow because when typing fast it's change the size of the window.
            if (Capriza.device.ios) {
                $input.on("input", function(){
                    var scrollingArea = self.getClosestScrollingContainer();
                    if (scrollingArea && scrollingArea.length) {
                        var scrollTop = scrollingArea[0].scrollTop;
                        scrollingArea[0].scrollTop = 0;
                        scrollingArea[0].scrollTop = scrollTop;
                    }
                });
            }

            this.checkEmpty( $input ) ;

            this.setIsReadOnly();

            Capriza.Views.TextboxBase.prototype._post.apply(this, arguments);

        },

        enableBarcodeWhenReady: function () {
            if (this.enableBarcode()) {
                Dispatcher.off("capp/pluginready", self.enableBarcodeWhenReady);

                Logger.debug("barcode scanner is ready - capp/pluginready event received");

                this.$el.removeClass("buttonDisabled");
                this.barcodeScannerInput();
            }
        },

        onClearClick: function() {
            var $input = this.getInput(true);
            if (this.model.get("isReadOnly")) return false;
            var orig = $input.val();
            $input.val("");
            if (orig) this.onChange(orig);

            if(this.model.get("multiline")){
                $input.trigger("autosize")
            }

            // TODO (amit): crappy solution for #6791 - did it quickly for BMC
            if ($input.closest(".list,.table").length === 0) {
                $input.focus();
            }

            return false;
        },


        //checkEmpty: function($input) {
        //    this.$el.toggleClass("empty", $input.val().length==0);
        //},

        onChange: function(orig) {
            try{
                var controlPath = "#"+ this.$el.prop("id") + " ." + this.getInput()[0].classList.toString().replace(/\s/g, ".");
                this.reportInteraction({
                    element: "TextBox",
                    controlPath: controlPath,
                    interaction: "val",
                    additionalData: "Text Change",
                    value: this.model.get("encrypt") ? "$$Encrypted$$" : this.getInput().val()
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Text box on change interaction");
            }
            if(!this.model.get("incrementalType") || (typeof orig == "string" && orig != this.getInput().val())){
                this.model.api.setText(this.getEventData());
            }
            this.model.set("text", this.getInput().val());
        },
        onKeyUp: function(e) {
            this.checkEmpty(this.getInput()) ;
        },
	    getEventData: function() {
		    return {
			    value: this.getInput().val(),
			    encrypt: this.model.get("encrypt")
		    };
		},

        setIsSubmittable: function() {
            var self = this, $input = self.getInput();
            this.$("button").off('click').on("click", function(e) {
                e.preventDefault();
                self.submit();
            });
            $input.on("keypress", function(e) {
                if (e.keyCode === 13) {
                    e.stopPropagation(); //#21091 call the onChange() manually if value changed, to prevent race condition with 'submit'
                    if (self.isTextChanged()) self.trigger('change');
                    self.submit();
                    self.trigger('enterKeyPressed');
                }
            });
        },

        setIsInForm: function(){
            if (this.isSubmittable()) return;
            var self = this;
            this.getInput().on("keypress", function(e) {
                if (e.keyCode === 13) {
                    Logger.debug("[Textbox][setIsInForm] Enter key pressed. triggering change to set the text. triggering 'enterKeyPressed'");
                    e.stopPropagation();
                    e.preventDefault();
                    $(this).blur();
                    if (self.isTextChanged()) self.trigger('change');
                    self.trigger('enterKeyPressed');
                    self.hideDropdown(true, e);
                }
            });
        },

        isTextChanged: function() {
            return this.getInput().val() != this.getText();
        },

        getText: function(){
            return this.model.get("textValue") === undefined ? this.model.get("text") : this.model.get("textValue");
        },

        submit: function() {
            this.model.api.submit();
        },

        barcodeScannerInput: function () {
            var _this=this;
            this.$("button").off('click').on("click", function(e) {
                if(!_this.model.get('isDisabled')) {
                    e.preventDefault();
                    e.stopPropagation();
                    Capriza.Capp.barcodeScanner.scan(function success(result) {
                        if (!result.cancelled) {
                            _this.setText(result.text);
                            _this.model.api.setText(result.text);
                        }

                    }, function error() {
                        navigator.notification.alert("Please try again.", debugCallback, "Scan Failed");
                    });
                }
            })

        },

        _types : {
			textbox:{
				opts: {
					hasInput: true,
					modal:false,
					opener:false,
					filterable:true,
					hideOnEmpty:true
				},

				_post:function(){
					Capriza.Views.Textbox.prototype._post.apply(this,arguments);
					var self = this;


					this.model.refreshRows = function(){
						var cache = Capriza.CacheManager.getHistory(this);
						this.set("rows", cache);
						if(!cache || cache.length == 0) self.hideDropdown();
					};

					self.model.refreshRows();

					this.model.on("change:text", function() {
						self.model.set("textValue", self.model.get("text"));
					});
					self.model.set("textValue", self.model.get("text"));

					this.model.getCurrentItemsForCache = function(){
						return [{text:this.get("text")}];
					};

					this.on("selectItems", function(items){
						var val = items.map(function(itm){
							delete itm.selected; //in textbox we don't need selected state.
							return itm.text;
						})[0];
						this.model.api.setText(val);
						this.model.set("text", val);
						if(self.model.get("multiline")){
							this.getInput(true).trigger("autosize");
						}
						this.model.saveToCache();
					});

					this.getInput(true).on("input", function(){
						if(!self.shown && self.filterAndSortRows())
						{
							self.showDropdown();
						}
					});

					this.on("change", function(){
						self.onChange();
						this.model.saveToCache();
					});

					this.on("clear:modalinput", function(){
						this.model.api.setText("");
					});

					this.on("clear:input", function(){
						this.model.set("text", "");
						self.showDropdown();
					});

					this.on("cache:updated",function(){
						self.model.refreshRows();
					});

					this.on("beforeShow", function (e) {
						if (self.model.get("rows").length == 0) {
							e.cancel = true;
						}
					});

					this.on("dropdown:shown",function(){
						self.stopListenToChange();
					});

					this.on("dropdown:hidden",function(){
						self.listenToChange();
					});

					this.on("shield:click", function(e){
                        var $btn = self.$("button");
						if($btn[0]) {
							var btnRect = $btn[0].getBoundingClientRect();
							if (btnRect.left < e.clientX && btnRect.right > e.clientX && btnRect.top < e.clientY && btnRect.bottom > e.clientY) {

                                if($btn.hasClass("clear")) {
                                    $btn.click();
                                    e.dontHide = true;
                                }
                                else{
                                    self.changeListener();
                                    $btn.click();
                                }
							return;
                            }
						}

                        try{
                            self.reportInteraction({
                                element: "TextBox",
                                interaction: "click",
                                controlPath: "[data-popover-mc='"+self.model.get("id")+"' .global-shield.active"
                            });
                        } catch(e){
                            Logger.info("[UserInteraction] Exception on report Text box shield click interaction");
                        }
                        self.changeListener();
					});

                    if(this.$clearIcon && !this.$clearIcon[0]){//submittable or location or barcode (should not open dropdown)
                        this.$("button").on("click",function(e){
                            e.stopPropagation();
                        });
                    }

				}

			}
		}
    });

    Capriza.Views.Passwordbox = Capriza.Views.Textbox.extend({
        inputType: "password",
        textboxClass: "textbox passwordbox",

        isDropdownEnabled: function(){
            return false;
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Checkbox.js

try{
;(function() {
    Capriza.Views.Checkbox = Capriza.Views.UiControl.extend({

        initialize: function(){
            this.changedCallbacks = [];
        },

        _render: function() {
            var self = this,
                uniqueControlId = this.getUniqueControlId();

            this.$el = $(Handlebars.templates['checkbox']({ uniqueControlId: uniqueControlId }));
            this.$el.on("click", function(e) { e.stopPropagation(); });

            this.setChecked(this.getChecked());
            
            this.$el.on('click', function (e) {
                if (self.model.get("isDisabled")) return;
                self.onChange(!self.getChecked());
            });

            if (Capriza.device.isDesktop) {
                this.$el.on("keypress", function (event) {
                    (event.which == 32) && this.click();
                    return false;
                });
            }

            return this.$el;
        },
        
        onChange:  function(checked){
            var self = this, selfArgs = arguments;
            
            this.$el.toggleClass('checked', checked);
            this.$(".value").focus();
            this.model.set("checked", checked);
            this._onChange(checked);
            
            this.changedCallbacks.forEach(function(callback){
                callback.apply(self,selfArgs);
            });
        },
        
        _onChange:  function(checked){
            this.model.api.setChecked(checked);
        },

        regOnChange:function(callback){
            this.changedCallbacks.push(callback);
        },

        setChecked: function(checked) {
            this.$el.toggleClass('checked', !!checked);
        },

        getChecked: function() {
            return this.model.get('checked');
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/LoginCheckbox.js

try{
;(function() {
    Capriza.Views.LoginCheckbox = Capriza.Views.Checkbox.extend({

        _onChange:function(checked){
            //do nothing (don't send the Engine)
        },

        getReplacedAdditionalValues: function () {
            return {checked: this.getChecked()};
        },

        setReplacedAdditionalValues: function (values) {
            this.onChange(values.checked);
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Datepicker.js

try{
;(function() {
    // On arrow down, simulates click to open datepicker dialog and sets focus
    // to its first element
    function onKeyDown(event) {
        if (event.which == 40) {
            this.click();

            function focusDialog() {
                var el = $("[role=dialog] [tabindex=0]")[0];

                el.focus();
            }

            setTimeout(focusDialog, 500);
        }
    }

    Capriza.Views.Datepicker = Capriza.Views.HandlebarsUiControl.extend({
        template: "datepicker",

        getPresentationModel: function() {
            var preset=this.model.get("supports");
            var type=preset + "picker";
            var inputType;

            //there is a bug on android 4 devices with the native date picker
            if ( Capriza.device.android  || !Modernizr.inputtypes[preset] || (!Capriza.device.isMobile && Utils.caprizaMode != "ShellMode") || (Capriza.device.ios6 && preset == "datetime")) {
                inputType = "text";
            } else if (Capriza.device.ios) {
                inputType = '';
            } else {
                inputType = preset;
            }

            var icon = this.model.get("iconLabel");
            //icon = icon || (preset === "time" ? "fa fa-clock-o" : "fa fa-calendar");

            var ariaDescription = (preset == "datetime"? "date and time" : preset) + " picker";

            return {
                uniqueControlId: this.getUniqueControlId(),
                inputId: this.labelFor(),
                name: this.model.get("name"),
                inputType:inputType,
                presetType:preset,
                iconLabel: icon,
                ariaDescription: ariaDescription,
                placeholder: this.model.get("placeholder"),
                cssClass:type
            };
        },

        disablePropagation: function() {

            this.$(".value").on('click', function(e) {
                e.stopPropagation();
            })

        },

        _post: function() {
            var self = this,
                $input = this.$("input"),
                symbolIcon = this.$("span.icon"),
                deleteIcon = this.$("button.icon");

            // when finished initialization check which icon will be displayed.
            this.alterIconsVisibility();
            deleteIcon.on("click", function() {
                $input.val("");
                self.saveDateToModel("");
            });

            symbolIcon.on("click", function() {
                $input.focus();
                $input.click();
            });

            self._initWithMobiscroll();
        },

        _destroy: function() {
            this.mobiscrollInst && this.mobiscrollInst.destroy();
        },

        supportedLangs:{
            "de":"de",
            "fr":"fr",
            "sv":"sv"
        },

        _createMobiscrollTimeFormat: function(timeFormat) {
            return timeFormat === "ampm" ? "h:ii A" : "HH:ii";
        },

        _initWithMobiscroll: function() {
            var modelTimeFormat = this.model.get("timeFormat");
            var self = this,
                $input = this.$("input"),
                localDate = this.model.get("date") ? this.fromEngineFormatToDate(this.model.get("date")) : undefined,
                preset = self.getPresentationModel().presetType,
                zeroMinutes = new Date(),
                config = window.appData && window.appData.config,
                dateOrder = (config && config.dateOrder) || undefined,
                dateFormat = (config && config.dateFormat) || undefined,
                timeFormat = (preset.indexOf("time") > -1) ? this._createMobiscrollTimeFormat(modelTimeFormat) : undefined,
                lang = this.supportedLangs[this.model.get("lang")] || (config && config.locale) || undefined;

            if (!dateFormat || !dateOrder) {
                var dateFormatByLocale = window.Utils.DateHelper && window.Utils.DateHelper.getDateFormat();

                if (!dateFormat) {
                    dateFormat = dateFormatByLocale ? dateFormatByLocale.toLowerCase() : undefined;
                }

                if (!dateOrder) {
                    dateOrder = dateFormatByLocale ? dateFormatByLocale.replace(/[^Mdy]/g, '') : "MMddyy";
                }
            }

            zeroMinutes.setMinutes(0);
            var options={
                theme: Capriza.device.android ? 'android-ics light': 'ios7',
                display: this.isInBubble(this.model.parent) ? 'bottom' : (Capriza.device.isTablet ? "bubble" : Capriza.device.android ? 'modal': 'bottom'),
                mode:'scroller',
                dateOrder: dateOrder,
                dateFormat: dateFormat,
                lang:lang,
                defaultValue: zeroMinutes,
                timeFormat: timeFormat,
                timeWheels: modelTimeFormat === '24hr' ? 'HHii' : undefined,
                context:  Capriza.device.isTablet ? $('.viewport') : (!Capriza.device.isMobile ? $('.viewport') : undefined),
                maxDate: preset != "time" ? new Date((new Date().getFullYear() + 10),12,31) : undefined,
                showOnFocus: false,
                buttons: ['set', 'cancel', 'clear']
            };

            if(Capriza.device.stock){
                options.tap=false; // fixes the problem that the background items are clicked while interacting with the dilog

                /**
                 * adding a dummy function on touchstart fixes the scrolling issue.
                 * ticket #8382.
                 * Happens in stock browsers with Android version < 4.3
                 */
                function stockDateScrollFix(){}

                options.onShow = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).on('mousedown', stockDateScrollFix);
                    });
                };

                options.onClose = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).off('mousedown', stockDateScrollFix);
                    });
                }
            }

            options.onClear = function () {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDateToModel("");
                }
                self.alterIconsVisibility();
            }

            $input.mobiscroll()[preset](options);

            if (Capriza.device.isDesktop) {
                $input.removeAttr("readonly").keydown(onKeyDown);
            }

            self.mobiscrollInst = $input.mobiscroll('getInst');

            if (localDate) {
                $input.scroller('setDate', self.fromUtc(localDate), true);
            }

            this.alterIconsVisibility(); // needed for the drill down

            $input.on("change", function() {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDateToModel(self.toUtc(new Date($input.scroller('getDate'))));
                }
                self.alterIconsVisibility();
            });
        },

        // removed the native timepicker because it caused crashes of the Safari, and stucked the Android.
        /*_initNative: function() {
         var self = this,
         $input = this.$("input");

         if (this.model.get("date")) {
         var value = this.fromEngineFormatToValue(this.model.get("date"));
         $input[0].value = value;
         $input.data("_date", value);
         }

         self.alterIconsVisibility(); // needed for the drill down

         $input.on("blur", function() {
         var orig = $input.data("_date");
         var curr = $input[0].value;

         console.log("input.value:" + $input[0].value);
         console.log("input.value(date): " + new Date($input[0].value));
         console.log("curr: " + curr);
         console.log("curr(json): " + JSON.stringify(curr));
         console.log("orig: " + orig);
         console.log("curr is null? " + (curr === null));
         console.log("curr is undefined? " + (curr === undefined));
         console.log("curr is empty string? " + (curr === ""));
         console.log("typeof curr " + (typeof curr));

         if ( !orig || curr !== orig ) {
         $input.data("_date", curr);
         self.saveDateToModel(self.fromValueToEngineFormat(curr));
         }
         self.alterIconsVisibility();
         });
         },*/

        alterIconsVisibility: function() {
            Logger.trace('this.$("input").val() !== ""' + (this.$("input").val() !== ""));
            Logger.trace('this.$("input") id = ' + this.$("input").attr('id'));
            if (this.$("input").val() !== ""){
                this.$el.addClass('has-content');
            } else {
                this.$el.removeClass('has-content');
            }
        },

        setDate: function(date) {
            this._setDateForMobiscroll(date);
        },

        saveDateToModel: function(date){
            this.model.api.setDate(date);
            this.model.set("date", date);
            Dispatcher.trigger("control/action/end",this);
        },

        _setDateForMobiscroll: function(date) {
            var $input = this.$("input");
            if (date !== "" && date !== null){
                var currValue = $input.scroller('getDate'), newValue = this.fromEngineFormatToDate(date);
                if (!currValue || !this.compareDates(newValue, new Date(currValue))) {
                    console.log("updating date on mobiscroll");
                    Capriza.Views.Datepicker.ignoreEvent = true;
                    $input.scroller('setDate', this.fromUtc(newValue), true);
                    Capriza.Views.Datepicker.ignoreEvent = false;
                }
            } else {
                $input.val(""); // this line is necessary for the drill pages
                this.alterIconsVisibility();
            }
        },

        // removed native datepickers. see previous comment
        /*        _setDateNative: function(date) {
         var $input = this.$("input");
         if (date !== "" && date !== null){
         var currValue = $input[0].value;
         if (!currValue || currValue !== this.fromEngineFormatToValue(date)) {
         console.log("updating date on native input");
         $input[0].value = this.fromEngineFormatToValue(date);
         }
         } else {
         $input.val(""); // this line is necessary for the drill pages
         this.alterIconsVisibility();
         }
         },*/

        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param str
         * @returns {Date}
         */
        fromEngineFormatToDate: function(str) {
            var localDate = new Date(str);
            if (localDate && isNaN(localDate.getTime())) {
                var match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(this.model.get("date"));
                localDate = new Date(Date.UTC(Number(match[1]), Number(match[2]) - 1, Number(match[3]), Number(match[4]), Number(match[5]), Number(match[6]), Number(match[7])));
            }
            return localDate;
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param d1
         * @param d2
         * @returns {boolean}
         */
        compareDates: function(d1, d2) {
            return d1.getUTCMonth() == d2.getUTCMonth() && d1.getUTCDate() == d2.getUTCDate() && d1.getUTCFullYear() == d2.getUTCFullYear()&& d1.getUTCHours() == d2.getUTCHours()&& d1.getUTCMinutes() == d2.getUTCMinutes();
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * The engine sends 27/12/2012 10:46am UTC
         * We need to populate the datepicker with 27/12/2012 10:46am in the user's timezone.
         * So we interpret the engine's date in UTC, and create a new date in the user's timezone with those values.
         * @param d
         * @return {Date}
         */
        fromUtc: function(d) {
            return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(),d.getUTCMinutes());

        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * User picked 27/12/2012 7:00am GMT +0200
         * We need to send the engine a UTC(GMT) of 27/12/2012 7:00am, which is 27/12/2012 9:00am GMT +0200
         * So we will always send the engine a date with the offset of the user's timezone
         * Alternatively, we can just add the timezone offset in minutes
         *
         * @param d - user selected date (in the user's timezone)
         * @return {Date} - offset corrected date (the same values as |d| only in UTC)
         */
        toUtc: function(d) {
            return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(),d.getMinutes()));

        },

        /**
         * ##### For Native Implemenetation ####
         * Recieves value with format of 2013-11-14T08:24:15.318Z and extracts the values from it. No translation is needed here - only string manipulation.
         * @param engineFormat
         * @returns {string}
         */
        fromEngineFormatToValue: function(engineFormat) {
            if (engineFormat === null) return "";

            var preset = this.model.get("supports"),
                match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(engineFormat),
                year = match[1],
                month = match[2],
                day = match[3],
                hours = match[4],
                minutes = match[5];
            if (preset === "date") {
                return year + '-' + month + '-' + day;
            } else if (preset === "datetime") {
                return engineFormat;
            } else if (preset === "time") {
                return hours + ':' + minutes;
            }
        },

        /**
         * ##### For Native Implemenetation ####
         *
         * Each picker type returns a different format from input.value
         * We want to normalize this to the engine's format, for example:
             * 1) datepicker: 2013-11-13 ==> 2013-11-13T00:00:00.000Z
         * 2) datetimepicker: the same value
         * 3) timepicker: 10:26 ==> 1970-01-01T10:26:00.000Z
         * @param value
         * @returns {*}
         */
        fromValueToEngineFormat: function(value) {
            if (!value) return "";
            var preset = this.model.get("supports");
            if (preset === "date") {
                return value + "T00:00:00.000Z";
            } else if (preset == "datetime") {
                return value;
            } else if (preset === "time") {
                return "1970-01-01T" + value + ":00.000Z";
            }
        }
    });

    function pad(value) {
        return value > 9 ? value : '0' + value;
    }
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Calendar.js

try{
;(function() {
    Capriza.Views.Calendar = Capriza.Views.HandlebarsUiControl.extend({
        template: "datepicker",

        attributesUpdateOrder: ["minDisplayDate", "maxDisplayDate", "selectedDays", "markedDays", "minDate", "maxDate"],

        mobiOptions: {},
        minDisplayDate: false,
        maxDisplayDate: false,
        $calArea: undefined,
        calInst: undefined,
        selectedDays: [],
        lastLoadedMonth: undefined,

        getPresentationModel: function() {
            var icon = this.model.get("iconLabel");

            return {
                uniqueControlId: this.getUniqueControlId(),
                inputId: this.labelFor(),
                name: this.model.get("name"),
                inputType:"text",
                placeholder:this.model.get("placeholder"),
                iconLabel: icon,
                cssClass: "calendar"
            };
        },

        //TODO: should distroy on CNF
        _destroy: function(){
            //this.$("input").mobiscroll('destroy');
            if(this.calInst) {
                this.calInst.destroy();
            }
        },

        disablePropagation: function() {

            this.$(".value").on('click', function(e) {
                e.stopPropagation();
            })

        },

        _post: function() {
            var self = this,
                $input = this.$("input"),
                symbolIcon = this.$("span.icon"),
                deleteIcon = this.$("button.icon"),
                preset = "date";

            symbolIcon.addClass(preset);

            // when finished initialization check which icon will be displayed.
            this.alterIconsVisibility();
            deleteIcon.on("click", function() {
                $input.val("");
                self.saveDatesToModel([]);
                self.alterIconsVisibility();
            });

            symbolIcon.on("click", function() {
                $input.focus();
                $input.click();

            });

            self._initMobiscroll();
            if (this.model.get('displayMode') === 'inline') {
                this.$("input").click();
            }

        },

        supportedLangs:{
            "de":"de",
            "fr":"fr",
            "sv":"sv"
        },
        translations:{
            "de":{
                "Legend":"Legende",
                "Calendar":"Kalender"
            }
        },

        _initMobiscroll: function() {
            var defaultMaxDate = new Date();
            defaultMaxDate.setFullYear(defaultMaxDate.getFullYear()+10);
            var self = this,
                $input = this.$("input"),

                selectedDays = this.model.get("selectedDays") ? this.model.get("selectedDays") : undefined,
                selectionMode = this.model.get("selectionMode") ? this.model.get("selectionMode") : {},
                navigation = this.model.get("displayYear") === false ? 'month':'yearMonth',
                firstDay = this.model.get("firstWeekDay") > -1 ? this.model.get("firstWeekDay") : 1,
                minDate  = this.model.get("minDate") ? this.fromEngineFormatToDate(this.model.get("minDate")) : undefined,
                maxDate  = this.model.get("maxDate") ? this.fromEngineFormatToDate(this.model.get("maxDate")) : defaultMaxDate,
                weekCounter   = this.model.get("showWeekCounter") ? 'year' : undefined,


                markTypes = this.model.get("markTypes"),

                preset = "calendar",
                config = window.appData && window.appData.config,
                dateFormat = (config && config.dateFormat) || undefined,
                lang = this.supportedLangs[this.model.get("lang")] || (config && config.locale) || undefined,
                $legend,
                $legendPanel,
                isLegendVisible = false,
                $legendButton,
                onShowEvents = [],
                onMonthChangeEvents = [],
                onCloseEvents = [];

            if (!dateFormat) {
                var dateFormatByLocale = window.Utils.DateHelper && window.Utils.DateHelper.getDateFormat();
                dateFormat = dateFormatByLocale ? dateFormatByLocale.toLowerCase() : undefined;
            }

            self.minDisplayDate  = this.model.get("minDisplayDate") ? this.fromUtc(this.fromEngineFormatToDate(this.model.get("minDisplayDate"))) : undefined;
            self.maxDisplayDate  = this.model.get("maxDisplayDate") ? this.fromUtc(this.fromEngineFormatToDate(this.model.get("maxDisplayDate"))) : undefined;
            self.minDate = minDate;
            self.maxDate = maxDate;


            this.mobiOptions={
                theme: Capriza.device.android ? 'android-ics light': 'ios7',
                display: this.isInBubble(this.model.parent) ? 'bottom' : (Capriza.device.isTablet ? "bubble" : Capriza.device.android ? 'modal': 'bottom'),

                navigation: navigation,
                firstDay: firstDay,

                minDate: minDate,
                maxDate: maxDate,

                weekCounter: weekCounter,

                invalid: self._getInitInvalidDays(),
                marked: self._getInitMarkedDays(),
                markedText: false,
                markedDisplay: "bottom",
                dateFormat: dateFormat,
                lang: lang,
                context: !Capriza.device.isMobile ? $('.viewport') : undefined,

                selectType: selectionMode.type ? selectionMode.type :'day',
                multiSelect: selectionMode.type == "multi",
                closeOnSelect: (selectionMode.type != "multi") && selectionMode.closeOnSelect,
                firstSelectDay: selectionMode.selectFromDay,
                showOnFocus: false,

                liveSwipe:!window.isDesignerPreview,//TODO: should disable in desktop ?
                //,showDivergentDays: false
                buttons: ['set', 'cancel', 'clear']
            };

            this.mobiOptions.onClear = function () {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDatesToModel("");
                }
                self.alterIconsVisibility();
            }


            //////////////////////////////////
            //Handle Lazy loading of data "server side month scroll"
            if(self.minDisplayDate || self.maxDisplayDate){

                function loadMonthIfNeeded(year, month, instance){
                    var thisMonth = new Date(year, month, 3); // dont use 1st in month to prevent utc time issues
                    self.lastLoadedMonth = thisMonth;
                    self.saveToPageState("lastLoadedMonth",thisMonth);
                    if(self.maxDisplayDate && thisMonth > self.maxDisplayDate){
                        self.showCalLoading();
                        self.model.api.nextMonth();
                    }
                    if(self.minDisplayDate && thisMonth < self.minDisplayDate){
                        self.showCalLoading();
                        self.model.api.prevMonth();
                    }
                };
                onMonthChangeEvents.push(loadMonthIfNeeded);

                onMonthChangeEvents.push(self._setOutOfRangeDaysAsInvalid);

                ///////////////////////////////////
                // Verify displayed date is in the min/max range
                function onBeforeShow(inst){
                    var dateToShow = self._getDateToShow(inst.getDate());
                    if(dateToShow){
                        inst.navigate(dateToShow);
                    }
                    self._setOutOfRangeDaysAsInvalid(false, false, inst);
                };
                this.mobiOptions.onBeforeShow = onBeforeShow;

            }

            function _onShow($el, valText, inst) {
                self.saveToPageState("isShown",true);
	            self._onDisplayChange();
                self.$calArea= $('div.dwc.dw-cal-c', $el);
                _.each(onShowEvents,function(func){func($el, valText, inst);});
            }
            this.mobiOptions.onShow = _onShow;


            function _onMonthChange(year, month, inst) {
                $(".dw-cal-btn").keyup();//prevent multiple events
                _.each(onMonthChangeEvents,function(func){

                    func.apply(self, [year, month, inst]);
                });
	            setTimeout(self._onDisplayChange, 1000);
            }
            this.mobiOptions.onMonthChange = _onMonthChange;

            ///////////////////////////////////////////////////////////////
            // Init legend if needed.
            if(markTypes && Object.keys(markTypes).length > 0) {

                var types = Object.keys(markTypes);

                $legend = $('<div class="calendar-legend"><div class="calendar-panel"><ul></ul></div></div>');

                var $ul = $('ul',$legend);

                _.each(types, function(key){
                    var item = markTypes[key],
                        $li = $('<li><span class="mark-color">&nbsp;</span><span class="mark-text"></span></li>');
                    if(item.color){
                        $('.mark-color',$li).css({background:item.color});
                    }
                    if(item.text){
                        $('.mark-text',$li).text(item.text);
                    }
                    $li.appendTo($ul);
                });

                onShowEvents.push(function addLegend($calEl, valText, inst) {
                    $('div.dwc.dw-cal-c', $calEl).prepend($legend);
                    $legendPanel = $(".calendar-panel", $legend);
                    $legendPanel.click(function () {
                        _toggleLegend();
                    });
                });


                //Only load translation if the mobiscrollLangPack extensions was enabled and a translation to the current lang is available
                var translation = self.mobiOptions.lang && $.mobiscroll.i18n[self.mobiOptions.lang] && self.translations[self.mobiOptions.lang] && self.translations[self.mobiOptions.lang];
                var calendarText = translation && translation["Calendar"] || "Calendar";
                var legendText = translation && translation["Legend"] || "Legend";

                function _toggleLegend() {
                    isLegendVisible = !isLegendVisible;

                    if(!$legendButton && $(this).hasClass('dwb')){
                        $legendButton = $(this);
                    }
                    if(isLegendVisible){
                        $legendButton.text(calendarText);
                    } else {
                        $legendButton.text(legendText);
                    }
                    //$legendButton.toggleClass("legend-is-open", isLegendVisible);
                    $legend.toggleClass("calendar-legend-visible", isLegendVisible);
                };

                this.mobiOptions.buttons = [
                    'set',
                    { text: legendText, handler: _toggleLegend },
                    'cancel',
                    'clear'
                ];

                onCloseEvents.push(function hideLegend(){
                    isLegendVisible && _toggleLegend();
                    $legendButton = undefined;

                })
            }


            function _onClose() {
                self.saveToPageState("isShown",false);
                _.each(onCloseEvents,function(func){
                    func.apply(self);
                });
            };

            this.mobiOptions.onClose = _onClose;


            if(Capriza.device.stock){
                this.mobiOptions.tap=false; // fixes the problem that the background items are clicked while interacting with the dilog

                /**
                 * adding a dummy function on touchstart fixes the scrolling issue.
                 * ticket #8382.
                 * Happens in stock browsers with Android version < 4.3
                 */
                function stockDateScrollFix(){}

                onShowEvents.push(function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).on('mousedown', stockDateScrollFix);
                    });
                });

                this.mobiOptions.onClose = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).off('mousedown', stockDateScrollFix);
                    });
                }
            }


            ///////////////////////////////////////////////////////////////
            // Init the mobiscroll itself
            $input.mobiscroll().calendar(this.mobiOptions);
            self.calInst = $input.mobiscroll('getInst');
            //////////////////////////////////////////////////////////////
            // Set preselected day(s) or clear if none
            if (selectedDays && selectedDays.length > 0) {
                self._setDatesForMobiscroll(selectedDays);
                if($input.val() == ""){ //this is due to mobiscroll bug where the input is not populated in some cases  (like today) when initialized
                    $input.val(this.calInst.val)
                }
            }

            //self.saveToPageState("lastLoadedMonth",thisMonth);
            if(self.loadFromPageState("lastLoadedMonth")){
                self.lastLoadedMonth = self.loadFromPageState("lastLoadedMonth");
            }

            this.alterIconsVisibility(); // needed for the drill down

            $input.on("change", function() {
                if (!Capriza.Views.Calendar.ignoreEvent) {
                    var calValues = self._getMobiscrollValues(),
                        values = _.map(calValues,function(value, key){
                            return self.toUtc(new Date(value));
                        });

                    self.saveDatesToModel(values);
                }
                self.alterIconsVisibility();
            }).on("click",function(e){
                e.stopPropagation();
                e.preventDefault();
            });

            if(self.loadFromPageState("isShown")){
                self.calInst.show(true);
            }

        },

	    showCalLoading: function(){
			var $loading = $('<div class="calendar-screen-block"></div>'), self = this;
			$loading.css(
				{
					width: "100%",
					height: "100%",
					position: "absolute",
					top: 0,
					left: 0,
					background: "rgba(0,0,0,0.5)",
					"z-index":900
				}
			).click(function(){
					//this.remove()
				});
			if(self.$calArea) self.$calArea.prepend($loading);
		},

	    _onDisplayChange: function(){
			return false;
	    },

        _getDateToShow: function(date){
            if(this.maxDisplayDate && this.lastLoadedMonth < this.maxDisplayDate && this.minDisplayDate && this.lastLoadedMonth > this.minDisplayDate) return this.lastLoadedMonth;//Already was between range limits
            var thisMonth = date || new Date();
            if(this.maxDisplayDate && thisMonth > this.maxDisplayDate){
                return this.maxDisplayDate;
            }
            if(this.minDisplayDate && thisMonth < this.minDisplayDate){
                return this.minDisplayDate;
            }
            return false;
        },

        _removeAllSelectedValues: function(){
            var currSelected = this._getMobiscrollValues(),
                self = this;

            if(self.calInst) {
                _.each(currSelected, function (val) {
                    self.calInst.removeValue(val);
                });
            }
        },

        _getInitInvalidDays: function () {
            var self = this,
                invalidDays = this.model.get("invalidDays"),
                ret = undefined;

            if(invalidDays){
                ret = [];
                _.each(invalidDays,function(item){
                    if(item.length == 2){
                        ret.push(item);
                    }
                    if(item.length == 24){
                        ret.push(self.fromUtc(self.fromEngineFormatToDate(item)));
                    }
                });
            }

            return ret;
        },

        _getInitMarkedDays : function(mkdDays){
            var self = this,
                markedDays = mkdDays || this.model.get("markedDays"),
                markTypes = this.model.get("markTypes"),
                ret = undefined,
                defaultColor = "#ccc";

            if(markedDays){
                ret = [];
                _.each(markedDays,function(item){
                    var type = markTypes[item.type];
                    if(!item.data) item.data = {};

                    var mark = {
                        d: self.fromUtc(self.fromEngineFormatToDate(item.day)),
                        color: item.data.color ? item.data.color : (type && type.color ? type.color : defaultColor),
                        text : item.data.text ? item.data.text : (type && type.text ? type.text : undefined),
                        icon : item.data.icon ? item.data.icon : (type && type.icon ? type.icon : undefined)//TODO: CHeck if it works with our already used fontawesome
                    };
                    ret.push(mark);
                });

            }
            return ret;
        },
        alterIconsVisibility: function() {
            Logger.trace('this.$("input").val() !== ""' + (this.$("input").val() !== ""));
            Logger.trace('this.$("input") id = ' + this.$("input").attr('id'));
            if (this.$("input").val() !== ""){
                this.$el.addClass('has-content');
            } else {
                this.$el.removeClass('has-content');
            }
        },

        saveDatesToModel: function(dates){
            var self = this;
            if(this.maxDisplayDate || this.minDisplayDate) {
                dates = _.filter(dates, function (d) {
                    //check if the date is in the range (if a range side is specified)
                    return (self.minDisplayDate ? d >= self.minDisplayDate : true ) && (self.maxDisplayDate ? d <= self.maxDisplayDate : true);
                });
            }
            if(dates[0]) {this.lastLoadedMonth = dates[0]; self.saveToPageState("lastLoadedMonth",dates[0]);}
            this.model.api.setDates(dates);
        },


        _getMobiscrollValues: function () {
            //TODO find why  $input.mobiscroll('getValues') does not work sometimes...
            return this._shouldUseMultiAPI() ? this.calInst.getValues() : [this.calInst.getDate()];
        },

        _setDatesForMobiscroll: function(dates) {
            var self = this, $input = this.$("input");
            if (dates && dates.length > 0){
                var currValues = this._getMobiscrollValues($input), newValues = this.arrayFromUtc(this.fromEngineFormatToDateArray(dates));
                if (!currValues || !this.compareDatesArrays(newValues,currValues)) {
                    self.selectedDays = newValues;
                    console.log("updating date on mobiscroll");
                    Capriza.Views.Calendar.ignoreEvent = true;
                    if(this._shouldUseMultiAPI()){
                        $input.mobiscroll('setValues', newValues, true);
                    } else{
                        $input.mobiscroll('setDate', newValues[0], true);
                    }

                    Capriza.Views.Calendar.ignoreEvent = false;
                }
            } else {
                this._removeAllSelectedValues();
                $input.val(""); // this line is necessary for the drill pages
                this.alterIconsVisibility();
            }
        },


        _shouldUseMultiAPI: function(){
            //TODO: open defect to mobi why getValues is not working in 'day' mode
            return this.mobiOptions.multi || this.mobiOptions.selectType == 'week';
        },



        _verifyMinMax: function(){
            var lastLoadedMonth = this.loadFromPageState("lastLoadedMonth");
            if(lastLoadedMonth
                && this.minDisplayDate && this.minDisplayDate < lastLoadedMonth
                && this.maxDisplayDate && this.maxDisplayDate > lastLoadedMonth){
                this.lastLoadedMonth = lastLoadedMonth;
                this.calInst.navigate(this.lastLoadedMonth);
                this.saveToPageState("lastLoadedMonth",undefined);
            }
        },

        _setOutOfRangeDaysAsInvalid: function(year, month, instance){
            var invalidDays = this._getInitInvalidDays() || [];
            for(var i = 1;i < 16;i++){
                if(this.maxDisplayDate){
                    var maxInc = new Date(this.maxDisplayDate.toISOString());
                    maxInc.setDate(maxInc.getDate() + i);
                    invalidDays.push(maxInc);
                }
                if(this.minDisplayDate) {
                    var minDec = new Date(this.minDisplayDate.toISOString());
                    minDec.setDate(minDec.getDate() - i);
                    invalidDays.push(minDec);
                }
            }
            instance.settings.invalid = invalidDays;
            instance.refresh();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Setters

        setMinDisplayDate:function(minDisplayDate){
            var mdd = this.fromUtc(this.fromEngineFormatToDate(minDisplayDate));
            if(mdd == this.minDisplayDate) return;
            this.minDisplayDate = mdd;
            if(this.$calArea) $(".calendar-screen-block",this.$calArea).remove();
            this._verifyMinMax();
            this._setOutOfRangeDaysAsInvalid(false,false,this.calInst);
        },
        setMaxDisplayDate:function(maxDisplayDate){
            var mdd = this.fromUtc(this.fromEngineFormatToDate(maxDisplayDate));
            if(mdd == this.maxDisplayDate) return;
            this.maxDisplayDate = mdd;
            if(this.$calArea) $(".calendar-screen-block",this.$calArea).remove();
            this._verifyMinMax();
            this._setOutOfRangeDaysAsInvalid(false,false,this.calInst);
        },

        setMarkedDays:function(markedDays){
            if (this.calInst && this.calInst.settings) {
                this.calInst.settings.marked = this._getInitMarkedDays(markedDays);
                this.calInst.refresh();
            }
        },
        setSelectedDays: function(selDays){
            this.selectedDays = selDays;
            this._setDatesForMobiscroll(selDays);
            return;
//
//            var $input = this.$("input"),
//                selectedDays=this.fromEngineFormatToDateArray(selDays);
//            if (selectedDays && selectedDays.length > 0) {
//                this.calInst.setDate(this.fromUtc(selectedDays[0]), true);
//                if(this._shouldUseMultiAPI()) {
//                    this.calInst.setValues(this.arrayFromUtc(selectedDays), true);
//                }
//            }
//            else{
//                this._removeAllSelectedValues();
//            }
        },

        setMinDate:function(minDateStr){
            var minDate = this.fromUtc(this.fromEngineFormatToDate(minDateStr));
            var isVis = this.calInst.isVisible();
            this.mobiOptions.minDate = minDate;
            this.calInst.option('minDate', minDate);
//            this.calInst.refresh();
            isVis && this.calInst.show(true);
        },

        setMaxDate:function(maxDateStr){
            var maxDate = this.fromUtc(this.fromEngineFormatToDate(maxDateStr));
            var isVis = this.calInst.isVisible();
            this.mobiOptions.maxDate = maxDate;
            this.calInst.option('maxDate', maxDate);
//            this.calInst.refresh();
            isVis && this.calInst.show(true);
        },




        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Helpers



        sortDates: function(dates){
            return dates.sort(function(a,b){
                return a > b ? 1 : b > a ? -1 : 0;
            })
        },

        fromEngineFormatToDateArray : function(dates){
            var self = this;
            return _.map(dates,function(value){
                return self.fromEngineFormatToDate(value);
            });
        },


        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param str
         * @returns {Date}
         */
        fromEngineFormatToDate: function(str) {
            var localDate = new Date(str);
            if (localDate && isNaN(localDate.getTime())) {
                var match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(this.model.get("date"));
                localDate = new Date(Date.UTC(Number(match[1]), Number(match[2]) - 1, Number(match[3]), Number(match[4]), Number(match[5]), Number(match[6]), Number(match[7])));
            }
            return localDate;
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param d1
         * @param d2
         * @returns {boolean}
         */
        compareDates: function(d1, d2) {
            return d1.getUTCMonth() == d2.getUTCMonth() && d1.getUTCDate() == d2.getUTCDate() && d1.getUTCFullYear() == d2.getUTCFullYear()&& d1.getUTCHours() == d2.getUTCHours()&& d1.getUTCMinutes() == d2.getUTCMinutes();
        },

        compareDatesArrays: function(ds1, ds2){
            if(ds1.length != ds2.length){
                return false
            }
            ds1 = this.sortDates(ds1);
            ds2 = this.sortDates(ds2);

            for(var i=0 , l=ds1.length ; i<l ; i++){
                if(!ds1[i] || !ds2[i] || !this.compareDates(ds1[i],ds2[i])){
                    return false
                }
            }
            return true;
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * The engine sends 27/12/2012 10:46am UTC
         * We need to populate the datepicker with 27/12/2012 10:46am in the user's timezone.
         * So we interpret the engine's date in UTC, and create a new date in the user's timezone with those values.
         * @param d
         * @return {Date}
         */
        fromUtc: function(d) {
            return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(),d.getUTCMinutes());

        },

        arrayFromUtc:function(dates){
            var self = this;
            return _.map(dates,function(d){return self.fromUtc(d)});
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * User picked 27/12/2012 7:00am GMT +0200
         * We need to send the engine a UTC(GMT) of 27/12/2012 7:00am, which is 27/12/2012 9:00am GMT +0200
         * So we will always send the engine a date with the offset of the user's timezone
         * Alternatively, we can just add the timezone offset in minutes
         *
         * @param d - user selected date (in the user's timezone)
         * @return {Date} - offset corrected date (the same values as |d| only in UTC)
         */
        toUtc: function(d) {
            return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(),d.getMinutes()));

        },

        arrayToUtc:function(dates){
            var self = this;
            return _.map(dates,function(d){return self.toUtc(d)});
        },

        /**
         * ##### For Native Implemenetation ####
         * Recieves value with format of 2013-11-14T08:24:15.318Z and extracts the values from it. No translation is needed here - only string manipulation.
         * @param engineFormat
         * @returns {string}
         */
        fromEngineFormatToValue: function(engineFormat) {
            if (engineFormat === null) return "";

            var type = this.model.get("type").replace("picker", ""),
                match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(engineFormat),
                year = match[1],
                month = match[2],
                day = match[3],
                hours = match[4],
                minutes = match[5];
            if (type === "date") {
                return year + '-' + month + '-' + day;
            } else if (type === "datetime") {
                return engineFormat;
            } else if (type === "time") {
                return hours + ':' + minutes;
            }
        },

        /**
         * ##### For Native Implemenetation ####
         *
         * Each picker type returns a different format from input.value
         * We want to normalize this to the engine's format, for example:
         * 1) datepicker: 2013-11-13 ==> 2013-11-13T00:00:00.000Z
         * 2) datetimepicker: the same value
         * 3) timepicker: 10:26 ==> 1970-01-01T10:26:00.000Z
         * @param value
         * @returns {*}
         */
        fromValueToEngineFormat: function(value) {
            if (!value) return "";
            var type = this.model.get("type").replace("picker", "");
            if (type === "date") {
                return value + "T00:00:00.000Z";
            } else if (type == "datetime") {
                return value;
            } else if (type === "time") {
                return "1970-01-01T" + value + ":00.000Z";
            }
        }
    });

    function pad(value) {
        return value > 9 ? value : '0' + value;
    }
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/BaseDateCalendarView.js

try{
(function() {
    Capriza.Views.BaseDateCalendarView = Capriza.Views.HandlebarsUiControl.extend({
        supportedLangs:{
            "de":"de",
            "fr":"fr",
            "sv":"sv"
        },

        _destroy: function(){
            throw new Error("baseDateCalendarView is abstract, extending views must implement _destroy");
        },

        _post: function() {
            throw new Error("baseDateCalendarView is abstract, extending views must implement _post");
        },

        _initWithMobiscroll: function() {
            throw new Error("baseDateCalendarView is abstract, extending views must implement _initWithMobiscroll");
        },

        disablePropagation: function() {
            this.$(".value").on('click', function(e) {
                e.stopPropagation();
            })
        },

        alterIconsVisibility: function() {
            Logger.trace('this.$("input").val() !== ""' + (this.$("input").val() !== ""));
            Logger.trace('this.$("input") id = ' + this.$("input").attr('id'));
            if (this.$("input").val() !== ""){
                this.$el.addClass('has-content');
            } else {
                this.$el.removeClass('has-content');
            }
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param d1
         * @param d2
         * @returns {boolean}
         */
        compareDates: function(d1, d2) {
            return d1.getUTCMonth() == d2.getUTCMonth() && d1.getUTCDate() == d2.getUTCDate() && d1.getUTCFullYear() == d2.getUTCFullYear()&& d1.getUTCHours() == d2.getUTCHours()&& d1.getUTCMinutes() == d2.getUTCMinutes();
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * The engine sends 27/12/2012 10:46am UTC
         * We need to populate the datepicker with 27/12/2012 10:46am in the user's timezone.
         * So we interpret the engine's date in UTC, and create a new date in the user's timezone with those values.
         * @param d
         * @return {Date}
         */
        fromUtc: function(d) {
            return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(),d.getUTCMinutes());

        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         *
         * User picked 27/12/2012 7:00am GMT +0200
         * We need to send the engine a UTC(GMT) of 27/12/2012 7:00am, which is 27/12/2012 9:00am GMT +0200
         * So we will always send the engine a date with the offset of the user's timezone
         * Alternatively, we can just add the timezone offset in minutes
         *
         * @param d - user selected date (in the user's timezone)
         * @return {Date} - offset corrected date (the same values as |d| only in UTC)
         */
        toUtc: function(d) {
            return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(),d.getMinutes()));

        },

        /**
         * ##### For Native Implemenetation ####
         *
         * Each picker type returns a different format from input.value
         * We want to normalize this to the engine's format, for example:
         * 1) datepicker: 2013-11-13 ==> 2013-11-13T00:00:00.000Z
         * 2) datetimepicker: the same value
         * 3) timepicker: 10:26 ==> 1970-01-01T10:26:00.000Z
         * @param value
         * @returns {*}
         */
        fromValueToEngineFormat: function(value) {
            if (!value) return "";
            var type = this.model.get("type").replace("picker", "");
            if (type === "date") {
                return value + "T00:00:00.000Z";
            } else if (type == "datetime") {
                return value;
            } else if (type === "time") {
                return "1970-01-01T" + value + ":00.000Z";
            }
        },

        /**
         * ##### For Native Implemenetation ####
         * Recieves value with format of 2013-11-14T08:24:15.318Z and extracts the values from it. No translation is needed here - only string manipulation.
         * @param engineFormat
         * @returns {string}
         */
        fromEngineFormatToValue: function(engineFormat) {
            if (engineFormat === null) return "";

            var type = this.model.get("type").replace("picker", ""),
                match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(engineFormat),
                year = match[1],
                month = match[2],
                day = match[3],
                hours = match[4],
                minutes = match[5];
            if (type === "date") {
                return year + '-' + month + '-' + day;
            } else if (type === "datetime") {
                return engineFormat;
            } else if (type === "time") {
                return hours + ':' + minutes;
            }
        },

        /**
         * ##### For Mobiscroll Implemenetation ####
         * @param str
         * @returns {Date}
         */
        fromEngineFormatToDate: function(str) {
            var localDate = new Date(str);
            if (localDate && isNaN(localDate.getTime())) {
                var match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z$/.exec(this.model.get("date"));
                localDate = new Date(Date.UTC(Number(match[1]), Number(match[2]) - 1, Number(match[3]), Number(match[4]), Number(match[5]), Number(match[6]), Number(match[7])));
            }
            return localDate;
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/AbstractDatePicker.js

try{
(function() {
    // On arrow down, simulates click to open datepicker dialog and sets focus
    // to its first element
    function onKeyDown(event) {
        if (event.which == 40) {
            this.click();

            function focusDialog() {
                var el = $("[role=dialog] [tabindex=0]")[0];

                el.focus();
            }

            setTimeout(focusDialog, 500);
        }
    }

    Capriza.Views.AbstractDatePicker = Capriza.Views.BaseDateCalendarView.extend({

        getPresentationModel: function() {
            var preset=this.model.get("supports");
            var type=preset + "picker";
            var inputType;

            //there is a bug on android 4 devices with the native date picker
            if ( Capriza.device.android  || !Modernizr.inputtypes[preset] || (!Capriza.device.isMobile && Utils.caprizaMode != "ShellMode") || (Capriza.device.ios6 && preset == "datetime")) {
                inputType = "text";
            } else if (Capriza.device.ios) {
                inputType = '';
            } else {
                inputType = preset;
            }

            var icon = this.model.get("iconLabel");
            //icon = icon || (preset === "time" ? "fa fa-clock-o" : "fa fa-calendar");

            var ariaDescription = (preset == "datetime"? "date and time" : preset) + " picker";

            return {
                uniqueControlId: this.getUniqueControlId(),
                inputId: this.labelFor(),
                name: this.model.get("name"),
                inputType:inputType,
                presetType:preset,
                iconLabel: icon,
                ariaDescription: ariaDescription,
                placeholder: this.model.get("placeholder"),
                cssClass:type
            };
        },

        _post: function() {
            error("trying to render abstract DatePicker");
        },

        _destroy: function() {
            this.mobiscrollInst && this.mobiscrollInst.destroy();
        },

        _createMobiscrollTimeFormat: function(timeFormat) {
            return timeFormat === "ampm" ? "h:ii A" : "HH:ii";
        },

        _initWithMobiscroll: function() {
            var modelTimeFormat = this.model.get("timeFormat");
            var self = this,
                $input = this.$("input"),
                localDate = this.model.get("date") ? this.fromEngineFormatToDate(this.model.get("date")) : undefined,
                preset = self.getPresentationModel().presetType,
                zeroMinutes = new Date(),
                config = window.appData && window.appData.config,
                dateOrder = (config && config.dateOrder) || undefined,
                dateFormat = (config && config.dateFormat) || undefined,
                timeFormat = (preset.indexOf("time") > -1) ? this._createMobiscrollTimeFormat(modelTimeFormat) : undefined,
                lang = this.supportedLangs[this.model.get("lang")] || (config && config.locale) || undefined;

            if (!dateFormat || !dateOrder) {
                var dateFormatByLocale = window.Utils.DateHelper && window.Utils.DateHelper.getDateFormat();

                if (!dateFormat) {
                    dateFormat = dateFormatByLocale ? dateFormatByLocale.toLowerCase() : undefined;
                }

                if (!dateOrder) {
                    dateOrder = dateFormatByLocale ? dateFormatByLocale.replace(/[^Mdy]/g, '') : "MMddyy";
                }
            }

            zeroMinutes.setMinutes(0);
            var options={
                theme: Capriza.device.android ? 'android-ics light': 'ios7',
                display: this.isInBubble(this.model.parent) ? 'bottom' : (Capriza.device.isTablet ? "bubble" : Capriza.device.android ? 'modal': 'bottom'),
                mode:'scroller',
                dateOrder: dateOrder,
                dateFormat: dateFormat,
                lang:lang,
                defaultValue: zeroMinutes,
                timeFormat: timeFormat,
                timeWheels: modelTimeFormat === '24hr' ? 'HHii' : undefined,
                context:  Capriza.device.isTablet ? $('.viewport') : (!Capriza.device.isMobile ? $('.viewport') : undefined),
                maxDate: preset != "time" ? new Date((new Date().getFullYear() + 10),12,31) : undefined,
                showOnFocus: false,
                buttons: ['set', 'cancel', 'clear']
            };

            if(Capriza.device.stock){
                options.tap=false; // fixes the problem that the background items are clicked while interacting with the dilog

                /**
                 * adding a dummy function on touchstart fixes the scrolling issue.
                 * ticket #8382.
                 * Happens in stock browsers with Android version < 4.3
                 */
                function stockDateScrollFix(){}

                options.onShow = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).on('mousedown', stockDateScrollFix);
                    });
                };

                options.onClose = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).off('mousedown', stockDateScrollFix);
                    });
                }
            }

            options.onClear = function () {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDateToModel("");
                }
                self.alterIconsVisibility();
            }

            $input.mobiscroll()[preset](options);

            if (Capriza.device.isDesktop) {
                $input.removeAttr("readonly").keydown(onKeyDown);
            }

            self.mobiscrollInst = $input.mobiscroll('getInst');

            if (localDate) {
                $input.scroller('setDate', self.fromUtc(localDate), true);
            }

            this.alterIconsVisibility(); // needed for the drill down

            $input.on("change", function() {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDateToModel(self.toUtc(new Date($input.scroller('getDate'))));
                }
                self.alterIconsVisibility();
            });
        },

        setDate: function(date) {
            this._setDateForMobiscroll(date);
        },

        saveDateToModel: function(date){
            this.model.api.setDate(date);
            this.model.set("date", date);
            Dispatcher.trigger("control/action/end",this);
        },

        _setDateForMobiscroll: function(date) {
            var $input = this.$("input");
            if (date !== "" && date !== null){
                var currValue = $input.scroller('getDate'), newValue = this.fromEngineFormatToDate(date);
                if (!currValue || !this.compareDates(newValue, new Date(currValue))) {
                    console.log("updating date on mobiscroll");
                    Capriza.Views.Datepicker.ignoreEvent = true;
                    $input.scroller('setDate', this.fromUtc(newValue), true);
                    Capriza.Views.Datepicker.ignoreEvent = false;
                }
            } else {
                $input.val(""); // this line is necessary for the drill pages
                this.alterIconsVisibility();
            }
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/AbstractCalendar.js

try{
;(function() {
    Capriza.Views.AbstractCalendar = Capriza.Views.BaseDateCalendarView.extend({
        attributesUpdateOrder: ["minDisplayDate", "maxDisplayDate", "selectedDays", "markedDays", "minDate", "maxDate"],

        mobiOptions: {},
        minDisplayDate: false,
        maxDisplayDate: false,
        $calArea: undefined,
        calInst: undefined,
        selectedDays: [],
        lastLoadedMonth: undefined,

        getPresentationModel: function() {
            var icon = this.model.get("iconLabel");

            return {
                uniqueControlId: this.getUniqueControlId(),
                inputId: this.labelFor(),
                name: this.model.get("name"),
                inputType:"text",
                placeholder:this.model.get("placeholder"),
                iconLabel: icon,
                cssClass: "calendar"
            };
        },

        //TODO: should distroy on CNF
        _destroy: function(){
            //this.$("input").mobiscroll('destroy');
            if(this.calInst) {
                this.calInst.destroy();
            }
        },

        _post: function() {
            symbolIcon.addClass("date");

            // when finished initialization check which icon will be displayed.
            this.alterIconsVisibility();
            deleteIcon.on("click", function() {
                $input.val("");
                self.saveDatesToModel([]);
                self.alterIconsVisibility();
            });

            symbolIcon.on("click", function() {
                $input.focus();
                $input.click();

            });

            self._initWithMobiscroll();
            if (this.model.get('displayMode') === 'inline') {
                this.$("input").click();
            }

        },

        translations:{
            "de":{
                "Legend":"Legende",
                "Calendar":"Kalender"
            }
        },

        _initWithMobiscroll: function() {
            var defaultMaxDate = new Date();
            defaultMaxDate.setFullYear(defaultMaxDate.getFullYear()+10);
            var self = this,
                $input = this.$("input"),

                selectedDays = this.model.get("selectedDays") ? this.model.get("selectedDays") : undefined,
                selectionMode = this.model.get("selectionMode") ? this.model.get("selectionMode") : {},
                navigation = this.model.get("displayYear") === false ? 'month':'yearMonth',
                firstDay = this.model.get("firstWeekDay") > -1 ? this.model.get("firstWeekDay") : 1,
                minDate  = this.model.get("minDate") ? this.fromEngineFormatToDate(this.model.get("minDate")) : undefined,
                maxDate  = this.model.get("maxDate") ? this.fromEngineFormatToDate(this.model.get("maxDate")) : defaultMaxDate,
                weekCounter   = this.model.get("showWeekCounter") ? 'year' : undefined,


                markTypes = this.model.get("markTypes"),

                preset = "calendar",
                config = window.appData && window.appData.config,
                dateFormat = (config && config.dateFormat) || undefined,
                lang = this.supportedLangs[this.model.get("lang")] || (config && config.locale) || undefined,
                $legend,
                $legendPanel,
                isLegendVisible = false,
                $legendButton,
                onShowEvents = [],
                onMonthChangeEvents = [],
                onCloseEvents = [];

            if (!dateFormat) {
                var dateFormatByLocale = window.Utils.DateHelper && window.Utils.DateHelper.getDateFormat();
                dateFormat = dateFormatByLocale ? dateFormatByLocale.toLowerCase() : undefined;
            }

            self.minDisplayDate  = this.model.get("minDisplayDate") ? this.fromUtc(this.fromEngineFormatToDate(this.model.get("minDisplayDate"))) : undefined;
            self.maxDisplayDate  = this.model.get("maxDisplayDate") ? this.fromUtc(this.fromEngineFormatToDate(this.model.get("maxDisplayDate"))) : undefined;
            self.minDate = minDate;
            self.maxDate = maxDate;


            this.mobiOptions={
                theme: Capriza.device.android ? 'android-ics light': 'ios7',
                display: this.isInBubble(this.model.parent) ? 'bottom' : (Capriza.device.isTablet ? "bubble" : Capriza.device.android ? 'modal': 'bottom'),

                navigation: navigation,
                firstDay: firstDay,

                minDate: minDate,
                maxDate: maxDate,

                weekCounter: weekCounter,

                invalid: self._getInitInvalidDays(),
                marked: self._getInitMarkedDays(),
                markedText: false,
                markedDisplay: "bottom",
                dateFormat: dateFormat,
                lang: lang,
                context: !Capriza.device.isMobile ? $('.viewport') : undefined,

                selectType: selectionMode.type ? selectionMode.type :'day',
                multiSelect: selectionMode.type == "multi",
                closeOnSelect: (selectionMode.type != "multi") && selectionMode.closeOnSelect,
                firstSelectDay: selectionMode.selectFromDay,
                showOnFocus: false,

                liveSwipe:!window.isDesignerPreview,//TODO: should disable in desktop ?
                //,showDivergentDays: false
                buttons: ['set', 'cancel', 'clear']
            };

            this.mobiOptions.onClear = function () {
                if (!Capriza.Views.Datepicker.ignoreEvent) {
                    self.saveDatesToModel("");
                }
                self.alterIconsVisibility();
            }


            //////////////////////////////////
            //Handle Lazy loading of data "server side month scroll"
            if(self.minDisplayDate || self.maxDisplayDate){

                function loadMonthIfNeeded(year, month, instance){
                    var thisMonth = new Date(year, month, 3); // dont use 1st in month to prevent utc time issues
                    self.lastLoadedMonth = thisMonth;
                    self.saveToPageState("lastLoadedMonth",thisMonth);
                    if(self.maxDisplayDate && thisMonth > self.maxDisplayDate){
                        self.showCalLoading();
                        self.model.api.nextMonth();
                    }
                    if(self.minDisplayDate && thisMonth < self.minDisplayDate){
                        self.showCalLoading();
                        self.model.api.prevMonth();
                    }
                };
                onMonthChangeEvents.push(loadMonthIfNeeded);

                onMonthChangeEvents.push(self._setOutOfRangeDaysAsInvalid);

                ///////////////////////////////////
                // Verify displayed date is in the min/max range
                function onBeforeShow(inst){
                    var dateToShow = self._getDateToShow(inst.getDate());
                    if(dateToShow){
                        inst.navigate(dateToShow);
                    }
                    self._setOutOfRangeDaysAsInvalid(false, false, inst);
                };
                this.mobiOptions.onBeforeShow = onBeforeShow;

            }

            function _onShow($el, valText, inst) {
                self.saveToPageState("isShown",true);
	            self._onDisplayChange();
                self.$calArea= $('div.dwc.dw-cal-c', $el);
                _.each(onShowEvents,function(func){func($el, valText, inst);});
            }
            this.mobiOptions.onShow = _onShow;


            function _onMonthChange(year, month, inst) {
                $(".dw-cal-btn").keyup();//prevent multiple events
                _.each(onMonthChangeEvents,function(func){

                    func.apply(self, [year, month, inst]);
                });
	            setTimeout(self._onDisplayChange, 1000);
            }
            this.mobiOptions.onMonthChange = _onMonthChange;

            ///////////////////////////////////////////////////////////////
            // Init legend if needed.
            if(markTypes && Object.keys(markTypes).length > 0) {

                var types = Object.keys(markTypes);

                $legend = $('<div class="calendar-legend"><div class="calendar-panel"><ul></ul></div></div>');

                var $ul = $('ul',$legend);

                _.each(types, function(key){
                    var item = markTypes[key],
                        $li = $('<li><span class="mark-color">&nbsp;</span><span class="mark-text"></span></li>');
                    if(item.color){
                        $('.mark-color',$li).css({background:item.color});
                    }
                    if(item.text){
                        $('.mark-text',$li).text(item.text);
                    }
                    $li.appendTo($ul);
                });

                onShowEvents.push(function addLegend($calEl, valText, inst) {
                    $('div.dwc.dw-cal-c', $calEl).prepend($legend);
                    $legendPanel = $(".calendar-panel", $legend);
                    $legendPanel.click(function () {
                        _toggleLegend();
                    });
                });


                //Only load translation if the mobiscrollLangPack extensions was enabled and a translation to the current lang is available
                var translation = self.mobiOptions.lang && $.mobiscroll.i18n[self.mobiOptions.lang] && self.translations[self.mobiOptions.lang] && self.translations[self.mobiOptions.lang];
                var calendarText = translation && translation["Calendar"] || "Calendar";
                var legendText = translation && translation["Legend"] || "Legend";

                function _toggleLegend() {
                    isLegendVisible = !isLegendVisible;

                    if(!$legendButton && $(this).hasClass('dwb')){
                        $legendButton = $(this);
                    }
                    if(isLegendVisible){
                        $legendButton.text(calendarText);
                    } else {
                        $legendButton.text(legendText);
                    }
                    //$legendButton.toggleClass("legend-is-open", isLegendVisible);
                    $legend.toggleClass("calendar-legend-visible", isLegendVisible);
                };

                this.mobiOptions.buttons = [
                    'set',
                    { text: legendText, handler: _toggleLegend },
                    'cancel',
                    'clear'
                ];

                onCloseEvents.push(function hideLegend(){
                    isLegendVisible && _toggleLegend();
                    $legendButton = undefined;

                })
            }


            function _onClose() {
                self.saveToPageState("isShown",false);
                _.each(onCloseEvents,function(func){
                    func.apply(self);
                });
            };

            this.mobiOptions.onClose = _onClose;


            if(Capriza.device.stock){
                this.mobiOptions.tap=false; // fixes the problem that the background items are clicked while interacting with the dilog

                /**
                 * adding a dummy function on touchstart fixes the scrolling issue.
                 * ticket #8382.
                 * Happens in stock browsers with Android version < 4.3
                 */
                function stockDateScrollFix(){}

                onShowEvents.push(function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).on('mousedown', stockDateScrollFix);
                    });
                });

                this.mobiOptions.onClose = function(){
                    $('[role="dialog"].dw-webkit').find('*').each(function(){
                        $(this).off('mousedown', stockDateScrollFix);
                    });
                }
            }


            ///////////////////////////////////////////////////////////////
            // Init the mobiscroll itself
            $input.mobiscroll().calendar(this.mobiOptions);
            self.calInst = $input.mobiscroll('getInst');
            //////////////////////////////////////////////////////////////
            // Set preselected day(s) or clear if none
            if (selectedDays && selectedDays.length > 0) {
                self._setDatesForMobiscroll(selectedDays);
                if($input.val() == ""){ //this is due to mobiscroll bug where the input is not populated in some cases  (like today) when initialized
                    $input.val(this.calInst.val)
                }
            }

            //self.saveToPageState("lastLoadedMonth",thisMonth);
            if(self.loadFromPageState("lastLoadedMonth")){
                self.lastLoadedMonth = self.loadFromPageState("lastLoadedMonth");
            }

            this.alterIconsVisibility(); // needed for the drill down

            $input.on("change", function() {
                if (!Capriza.Views.Calendar.ignoreEvent) {
                    var calValues = self._getMobiscrollValues(),
                        values = _.map(calValues,function(value, key){
                            return self.toUtc(new Date(value));
                        });

                    self.saveDatesToModel(values);
                }
                self.alterIconsVisibility();
            }).on("click",function(e){
                e.stopPropagation();
                e.preventDefault();
            });

            if(self.loadFromPageState("isShown")){
                self.calInst.show(true);
            }

        },

	    showCalLoading: function(){
			var $loading = $('<div class="calendar-screen-block"></div>'), self = this;
			$loading.css(
				{
					width: "100%",
					height: "100%",
					position: "absolute",
					top: 0,
					left: 0,
					background: "rgba(0,0,0,0.5)",
					"z-index":900
				}
			).click(function(){
					//this.remove()
				});
			if(self.$calArea) self.$calArea.prepend($loading);
		},

	    _onDisplayChange: function(){
			return false;
	    },

        _getDateToShow: function(date){
            if(this.maxDisplayDate && this.lastLoadedMonth < this.maxDisplayDate && this.minDisplayDate && this.lastLoadedMonth > this.minDisplayDate) return this.lastLoadedMonth;//Already was between range limits
            var thisMonth = date || new Date();
            if(this.maxDisplayDate && thisMonth > this.maxDisplayDate){
                return this.maxDisplayDate;
            }
            if(this.minDisplayDate && thisMonth < this.minDisplayDate){
                return this.minDisplayDate;
            }
            return false;
        },

        _removeAllSelectedValues: function(){
            var currSelected = this._getMobiscrollValues(),
                self = this;

            if(self.calInst) {
                _.each(currSelected, function (val) {
                    self.calInst.removeValue(val);
                });
            }
        },

        _getInitInvalidDays: function () {
            var self = this,
                invalidDays = this.model.get("invalidDays"),
                ret = undefined;

            if(invalidDays){
                ret = [];
                _.each(invalidDays,function(item){
                    if(item.length == 2){
                        ret.push(item);
                    }
                    if(item.length == 24){
                        ret.push(self.fromUtc(self.fromEngineFormatToDate(item)));
                    }
                });
            }

            return ret;
        },

        _getInitMarkedDays : function(mkdDays){
            var self = this,
                markedDays = mkdDays || this.model.get("markedDays"),
                markTypes = this.model.get("markTypes"),
                ret = undefined,
                defaultColor = "#ccc";

            if(markedDays){
                ret = [];
                _.each(markedDays,function(item){
                    var type = markTypes[item.type];
                    if(!item.data) item.data = {};

                    var mark = {
                        d: self.fromUtc(self.fromEngineFormatToDate(item.day)),
                        color: item.data.color ? item.data.color : (type && type.color ? type.color : defaultColor),
                        text : item.data.text ? item.data.text : (type && type.text ? type.text : undefined),
                        icon : item.data.icon ? item.data.icon : (type && type.icon ? type.icon : undefined)//TODO: CHeck if it works with our already used fontawesome
                    };
                    ret.push(mark);
                });

            }
            return ret;
        },

        saveDatesToModel: function(dates){
            var self = this;
            if(this.maxDisplayDate || this.minDisplayDate) {
                dates = _.filter(dates, function (d) {
                    //check if the date is in the range (if a range side is specified)
                    return (self.minDisplayDate ? d >= self.minDisplayDate : true ) && (self.maxDisplayDate ? d <= self.maxDisplayDate : true);
                });
            }
            if(dates[0]) {this.lastLoadedMonth = dates[0]; self.saveToPageState("lastLoadedMonth",dates[0]);}
            this.model.api.setDates(dates);
        },

        _getMobiscrollValues: function () {
            //TODO find why  $input.mobiscroll('getValues') does not work sometimes...
            return this._shouldUseMultiAPI() ? this.calInst.getValues() : [this.calInst.getDate()];
        },

        _setDatesForMobiscroll: function(dates) {
            var self = this, $input = this.$("input");
            if (dates && dates.length > 0){
                var currValues = this._getMobiscrollValues($input), newValues = this.arrayFromUtc(this.fromEngineFormatToDateArray(dates));
                if (!currValues || !this.compareDatesArrays(newValues,currValues)) {
                    self.selectedDays = newValues;
                    console.log("updating date on mobiscroll");
                    Capriza.Views.Calendar.ignoreEvent = true;
                    if(this._shouldUseMultiAPI()){
                        $input.mobiscroll('setValues', newValues, true);
                    } else{
                        $input.mobiscroll('setDate', newValues[0], true);
                    }

                    Capriza.Views.Calendar.ignoreEvent = false;
                }
            } else {
                this._removeAllSelectedValues();
                $input.val(""); // this line is necessary for the drill pages
                this.alterIconsVisibility();
            }
        },

        _shouldUseMultiAPI: function(){
            //TODO: open defect to mobi why getValues is not working in 'day' mode
            return this.mobiOptions.multi || this.mobiOptions.selectType == 'week';
        },

        _verifyMinMax: function(){
            var lastLoadedMonth = this.loadFromPageState("lastLoadedMonth");
            if(lastLoadedMonth
                && this.minDisplayDate && this.minDisplayDate < lastLoadedMonth
                && this.maxDisplayDate && this.maxDisplayDate > lastLoadedMonth){
                this.lastLoadedMonth = lastLoadedMonth;
                this.calInst.navigate(this.lastLoadedMonth);
                this.saveToPageState("lastLoadedMonth",undefined);
            }
        },

        _setOutOfRangeDaysAsInvalid: function(year, month, instance){
            var invalidDays = this._getInitInvalidDays() || [];
            for(var i = 1;i < 16;i++){
                if(this.maxDisplayDate){
                    var maxInc = new Date(this.maxDisplayDate.toISOString());
                    maxInc.setDate(maxInc.getDate() + i);
                    invalidDays.push(maxInc);
                }
                if(this.minDisplayDate) {
                    var minDec = new Date(this.minDisplayDate.toISOString());
                    minDec.setDate(minDec.getDate() - i);
                    invalidDays.push(minDec);
                }
            }
            instance.settings.invalid = invalidDays;
            instance.refresh();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Setters

        setMinDisplayDate:function(minDisplayDate){
            var mdd = this.fromUtc(this.fromEngineFormatToDate(minDisplayDate));
            if(mdd == this.minDisplayDate) return;
            this.minDisplayDate = mdd;
            if(this.$calArea) $(".calendar-screen-block",this.$calArea).remove();
            this._verifyMinMax();
            this._setOutOfRangeDaysAsInvalid(false,false,this.calInst);
        },
        setMaxDisplayDate:function(maxDisplayDate){
            var mdd = this.fromUtc(this.fromEngineFormatToDate(maxDisplayDate));
            if(mdd == this.maxDisplayDate) return;
            this.maxDisplayDate = mdd;
            if(this.$calArea) $(".calendar-screen-block",this.$calArea).remove();
            this._verifyMinMax();
            this._setOutOfRangeDaysAsInvalid(false,false,this.calInst);
        },

        setMarkedDays:function(markedDays){
            if (this.calInst && this.calInst.settings) {
                this.calInst.settings.marked = this._getInitMarkedDays(markedDays);
                this.calInst.refresh();
            }
        },
        setSelectedDays: function(selDays){
            this.selectedDays = selDays;
            this._setDatesForMobiscroll(selDays);
            return;
        },

        setMinDate:function(minDateStr){
            var minDate = this.fromUtc(this.fromEngineFormatToDate(minDateStr));
            var isVis = this.calInst.isVisible();
            this.mobiOptions.minDate = minDate;
            this.calInst.option('minDate', minDate);
//            this.calInst.refresh();
            isVis && this.calInst.show(true);
        },

        setMaxDate:function(maxDateStr){
            var maxDate = this.fromUtc(this.fromEngineFormatToDate(maxDateStr));
            var isVis = this.calInst.isVisible();
            this.mobiOptions.maxDate = maxDate;
            this.calInst.option('maxDate', maxDate);
//            this.calInst.refresh();
            isVis && this.calInst.show(true);
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Helpers

        sortDates: function(dates){
            return dates.sort(function(a,b){
                return a > b ? 1 : b > a ? -1 : 0;
            })
        },

        fromEngineFormatToDateArray : function(dates){
            var self = this;
            return _.map(dates,function(value){
                return self.fromEngineFormatToDate(value);
            });
        },

        compareDatesArrays: function(ds1, ds2){
            if(ds1.length != ds2.length){
                return false
            }
            ds1 = this.sortDates(ds1);
            ds2 = this.sortDates(ds2);

            for(var i=0 , l=ds1.length ; i<l ; i++){
                if(!ds1[i] || !ds2[i] || !this.compareDates(ds1[i],ds2[i])){
                    return false
                }
            }
            return true;
        },

        arrayFromUtc:function(dates){
            var self = this;
            return _.map(dates,function(d){return self.fromUtc(d)});
        },

        arrayToUtc:function(dates){
            var self = this;
            return _.map(dates,function(d){return self.toUtc(d)});
        },
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/DatePickerButton.js

try{
(function() {
    Capriza.Views.DatePickerButton = Capriza.Views.AbstractDatePicker.extend({
        template: "datepicker-button",

        _post: function() {
            this.setName(this.model.get("name") || " ");
            this.setIcon(this.model.get("icon"));
            var $input = this.$("input"),
                button = this.$(".value");


            button.on("click", function() {
                $input.focus();
                $input.click();
            });

            this._initWithMobiscroll();
        },

        setIcon: function(iconClass){
            $i = this.$("i");
            if (!iconClass) {
                $i.remove();
                return;
            }

            if (!$i.length) {
                $i = $("<i></i> ");
            }
            $i.attr("class", iconClass);

            if (/right/.test(this.model.get("iconDisplay"))) {
                $i.appendTo(this.$(".value"));
            } else {
                $i.prependTo(this.$(".value"));
            }
        },

        //todo: this method overrides (DELETES) the icon if there was any.. because icon is an <i> element inside the $value.
        //the reason it worked is because there is no monitoring on button texts..
        setName: function(name) {
            var buttonElement = this.$(".value")[0];
            var valueText = buttonElement.childNodes[0]==buttonElement.firstElementChild ? buttonElement.childNodes[1] : buttonElement.childNodes[0];
            if (valueText && valueText.nodeValue) {
                valueText.nodeValue = _.sanitize(name);
            } else {
                buttonElement.text(_.sanitize(name));
            }

        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/DatePickerInput.js

try{
(function() {
    Capriza.Views.DatePickerInput = Capriza.Views.AbstractDatePicker.extend({
        template: "datepicker-input",

        _post: function() {
            var self = this,
                $input = this.$("input"),
                symbolIcon = this.$("span.icon"),
                deleteIcon = this.$("button.icon");

            // when finished initialization check which icon will be displayed.
            this.alterIconsVisibility();
            deleteIcon.on("click", function() {
                $input.val("");
                self.saveDateToModel("");
            });

            symbolIcon.on("click", function() {
                $input.focus();
                $input.click();
            });

            self._initWithMobiscroll();
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/CalendarButton.js

try{
(function() {
    Capriza.Views.CalendarButton = Capriza.Views.AbstractCalendar.extend({
        template: "datepicker-button",
        
        _post: function() {
            this.setName(this.model.get("name") || " ");
            this.setIcon(this.model.get("icon"));
            var $input = this.$("input"),
                button = this.$(".value");


            button.on("click", function() {
                $input.focus();
                $input.click();
            });

            this._initWithMobiscroll();
        },

        setIcon: function(iconClass){
            $i = this.$("i");
            if (!iconClass) {
                $i.remove();
                return;
            }

            if (!$i.length) {
                $i = $("<i></i> ");
            }
            $i.attr("class", iconClass);

            if (/right/.test(this.model.get("iconDisplay"))) {
                $i.appendTo(this.$(".value"));
            } else {
                $i.prependTo(this.$(".value"));
            }
        },

        //todo: this method overrides (DELETES) the icon if there was any.. because icon is an <i> element inside the $value.
        //the reason it worked is because there is no monitoring on button texts..
        setName: function(name) {
            var buttonElement = this.$(".value")[0];
            var valueText = buttonElement.childNodes[0]==buttonElement.firstElementChild ? buttonElement.childNodes[1] : buttonElement.childNodes[0];
            if (valueText && valueText.nodeValue) {
                valueText.nodeValue = _.sanitize(name);
            } else {
                buttonElement.text(_.sanitize(name));
            }

        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/CalendarInput.js

try{
(function() {
    Capriza.Views.CalendarInput = Capriza.Views.AbstractCalendar.extend({
        template: "datepicker-input",

        _post: function() {
            var self = this,
                $input = this.$("input"),
                symbolIcon = this.$("span.icon"),
                deleteIcon = this.$("button.icon");

            // when finished initialization check which icon will be displayed.
            this.alterIconsVisibility();
            deleteIcon.on("click", function() {
                $input.val("");
                self.saveDatesToModel([]);
                self.alterIconsVisibility();
            });

            symbolIcon.on("click", function() {
                $input.focus();
                $input.click();

            });

            self._initWithMobiscroll();
            if (this.model.get('displayMode') === 'inline') {
                this.$("input").click();
            }
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Dropdown.js

try{
;(function() {

    Capriza.Views.Dropdown = Capriza.Views.TextboxBase.extend({
        template: "dropdown",

        //P0 - Must have for flag removal
        //DONE (works OOTB): disabled behaviour
        //DONE: X button
        //DONE: placeholder / no value selected
        //DONE: style sets - modal_with_input + modal_no_input + popover (things does not get primary-color)
        //DONE: attributes update order !!!
        //DONE: combobox2 ? migration (to combobox + modal=true) ? yes.
        //DONE (works OOTB): disabled options (also radiogroup)
        //DONE: check readonly
        //DONE: x button in modal input
        //DONE: make autocomplete work
        //DONE: check popupmenubox
        //DONE: fix modal with keyboard - prevent scroll
        //DONE: move state persistence up in handlers before render of page !

        //Cache related
        //DONE: textbox
        //TODO: consider expiration for cache
        //TODO: clear cache from settings menu

        //P0.5
        //DONE: test listbox as auto login control
        //DONE: client autocomplete
        //DONE: onoffswithc1/2 inheritance relevant ? no.

        //P1 - Next phase
        //TODO: handle large lists >2000 items
        //DONE: tablet support
        //DONE: transitions
        //TODO: inheritance from relevant controls
        //TODO: maxlength validation -- call from base when with input


        /* sync / async items
        *  text vs input
        *  opener
        *  autocomplete
        *  button ?
        *  label / placeholder
        *  modal / popover
        *  selected item (s)
        *  multiselect
        *
        *
        * */

        isDropdownEnabled: function(){
            return true;
        },



        // TODO: nullify setText here since inheriting from TextboxBase. The way views are updated here is by listening to change:text on the model. This should be the way that all controls bind to data changes, and when we do it we can remove this setter.
        setText: function() {}

    });


    //////////////////////////////////////// Adapters

    Capriza.Views.Dropdown._types = {};

    Capriza.Views.Dropdown._types['listbox'] = Capriza.Views.Dropdown._types['listboxmulti'] = {
        opts: {
            hasInput: false,
            multi: false,
            preventClearTextValueFromModal:true
        },

        attributesUpdateOrder: ["items", "selectedIndex", "isDisabled", "rows", "filteredSortedRows", "textValue"],

        _initialize:function(){
            if(this.options.filterable){
                this.options.modal = true;
                this.options.modalInput = true;
            }
            if(this.options.multi){
                this.options._textboxClass = "ddlistboxmulti";
                this.options.sortByHist = false;
            }
            else{
                this.options._textboxClass = "ddlistbox";
            }
        },

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var self = this;

            this.model.getItems = function(){
                var selectedIdxs = (Array.isArray(self.model.get("selectedIndex"))) ? self.model.get("selectedIndex") : [self.model.get("selectedIndex")];
                var val = "";
                //#22587 - to prevent exception when rendering dropdown without items (when inside a table that is first missing)
                var items = (self.model.get("items") || []).map(function (item, idx) {
                //var items = self.model.get("items").map(function (item, idx) {
                    var row;
                    if(typeof item ==="string"){
                        row = {text: item};
                    }
                    else{
                        row = _.extend({}, item);
                    }
                    row.idx = idx;

                    if (selectedIdxs.indexOf(idx) > -1) {
                        val = row.text;
                        row.selected = true;
                    }
                    return row;
                });

                if(selectedIdxs.length > 1) val = selectedIdxs.length + " Items selected";
                self.model.set("textValue", val);
                return items;
            };


            this.model.refreshRows();

            this.model.on("change:items", this.model.refreshRows);
            this.model.on("change:selectedIndex", this.model.refreshRows);

            this.on("selectItems", function(items){
                var val = "";

                var controlPath = "";
                var indexes = items.map(function(itm){
                    controlPath += "[data-idx='"+itm.idx+"'],";
                    val = itm.text;
                    return itm.idx;
                });
                if (controlPath){
                    controlPath = controlPath.substr(0, controlPath.length - 1);
                }
                if(indexes.length == 1 && !this.options.multi) indexes = indexes[0];
                else if(indexes.length > 1) val = indexes.length + " Items selected";
                this.model.api.setSelectedIndex(indexes);
                this.model.set("selectedIndex", indexes);
                this.model.set("textValue", val);
                this.model.saveToCache();

                try{
                    this.reportInteraction({
                        element: "DropDown",
                        interaction: "click",
                        controlPath: controlPath,
                        indexes: indexes,
                        additionalData: "select items"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Dropdown select items interaction");
                }
                Dispatcher.trigger("control/action/end",this);
            });

            if(!this.options.multi && this.options.filterable ){
                this.on("dropdown:hidden", function(){
                    self.getInput().val("");
                    self.filterAndSortRows();
                });
            }
        },

        _onEnter: function (event) {
            this.options.multi ? this.$save.click()
                : Capriza.Views.Textbox.prototype._onEnter.call(this, event);
        }
    };


    Capriza.Views.Dropdown._types['autocomplete'] = {
        opts: {
            _textboxClass: "ddautocomplete",
            hasInput: true,
            opener: false,
            modal: true,
            modalInput: true,
            hideOnEmpty:true
        },

        _initialize:function(){
            this.options.modalInput = this.options.modal;
        },

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var self = this;

            this.options.hideOnEmpty = !this.options.modal;

            this.model.getItems = function(){
                var items = (self.model.get("items") || []).map(function (item, idx) {
                    return {idx: idx, text: item};
                });

                return items;
            };

            this.model.on("change:items", function() {
                self.hideLoading();
                self.model.refreshRows();
            });
            self.model.refreshRows();

            this.model.on("change:text", function() {
                self.model.set("textValue", self.model.get("text"))
            });

            this.model.getCurrentItemsForCache = function(){
                return [{text:this.get("text")}];
            };


            this.on("uiEventListenersAdded",function(){
                this.getInput(true).on("click",function(e){//TODO: consider option: hideOnOpenerClick + hideOnInputClick
                    e.stopPropagation();
                    e.preventDefault();
                })
            });

            this.on("selectItems", function(items){
                var val = "";
                var indexes = items.map(function(itm){
                    val = itm.text;
                    return itm.idx;
                });
                if(indexes.length == 1) indexes = indexes[0];
                this.model.api.selectItem(indexes);
                this.model.set("text", val);
                this.model.saveToCache();
                Dispatcher.trigger("control/action/end",this);
            });


            function setTerm(term) {
                self.model.set("textValue", term);
                self.model.api.setText(term);
                self.saveToPageState("term", term);
                self.showLoading();
            }

            this.on("modalInputKeyUp", function(){
                setTerm(self.getInput().val());
            });

            this.on("controlInputKeyUp", function(event){
                var inputValue = self.getInput(true).val();

                if ((self.model.get("textValue") || "") != inputValue) {
                    setTerm(self.getInput(true).val());
                    if(!self.shown) {
                        var hoe = self.options.hideOnEmpty;
                        self.options.hideOnEmpty=false;
                        self.showDropdown();
                        self.options.hideOnEmpty = hoe;
                    }
                }
            });

            this.on("beforeShow",function(){
                self.saveToPageState("autocompleteShown", true);
                var tv = self.model.get("textValue") || "";
                if(tv.length > 0){
                    setTerm(tv);
                }
            });

            this.on("beforeHide",function(){
                self.saveToPageState("autocompleteShown", false);
            });

            this.on("clear:modalinput", function(){
                this.model.api.setText("");
            });

            this.on("clear:input", function(){
                self.showDropdown();
            });

            setTimeout(function(){
                if(self.loadFromPageState("autocompleteShown")){
                    self.model.refreshRows();

                    self.showDropdown();
                    self.hideLoading();
                    self.getInput().val(self.loadFromPageState("term"));
                }
            },0);
            if(!this.options.modal) {
                this.on("dropdown:shown", function () {
                    self.stopListenToChange();
                });

                this.on("dropdown:hidden", function () {
                    self.listenToChange();
                });

                this.on("shield:click", function (e) {
                    var clearRect = self.$clearIcon[0].getBoundingClientRect();
                    if (clearRect.left < e.clientX && clearRect.right > e.clientX && clearRect.top < e.clientY && clearRect.bottom > e.clientY) {
                        self.$clearIcon.click();
                        e.dontHide = true;
                        return;
                    }
                    self.changeListener();
                });
            }

            if (this.enableLocation()) {
                this.locationInput();
            }

            this.model.set("textValue", this.model.get("text"));
        }
    };


    Capriza.Views.Dropdown._types['popup'] = {
        opts: {
            _textboxClass: "ddpopup",
            hasInput: false,
            modal:false

        },

        _initialize:function(){
            if(this.options.filterable){
                this.options.modal = true;
                this.options.modalInput = true;
            }
        },

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var self = this;

            this.model.getItems = function(){
                return (self.model.get("value") || []).map(function (item, idx) {
                    var itm;
                    if(typeof item ==="string"){
                        itm = {text: item};
                    }
                    else{
                        itm = _.extend({}, item);
                    }
                    itm.idx = idx;
                    return itm;
                })
            };

            this.model.on("change:value", function() {
                self.hideLoading();
                if (self.model.get("value").length > 0) { // copied from PopupMenu.js::setValue
                    self.model.refreshRows();
                }
            });
            self.model.refreshRows();

            this.model.on("change:valueText", function() {
                if (!self.model.get("dontUpdate")) { // copied from PopupMenu.js::setValueText
                    self.model.set("textValue", self.model.get("valueText")); // YEAH I KNOW, BRAIN FUCK!!!
                }
            });
            self.model.set("textValue", self.model.get("valueText")); //BrainFuck is also needed on init ;) (regardless of "dontUpdate")

            this.on("beforeShow", function(){
                this.showLoading();
                this.model.api.openPopup();
            });

            this.on("canceling", function(){
                this.model.api.closePopup();
            });


            this.on("selectItems", function(items){
                var val = "";
                var indexes = items.map(function(itm){
                    val = itm.text;
                    return itm.idx;
                });
                if(indexes.length == 1) indexes = indexes[0];
                this.model.api.selectMenuItem(indexes);
                this.model.saveToCache();
                this.model.set("rows", []); // behaviour of async items
                if (!this.model.get("dontUpdate")) {
                    this.model.set("textValue", val);
                }
            });
        }


    };


    Capriza.Views.Dropdown._types['menu'] = {
        opts: {
            _textboxClass: "ddmenu",
            hasInput: false
        },

        _initialize:function(){
            if(this.options.filterable){
                this.options.modal = true;
                this.options.modalInput = true;
            }
        },

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var selectedIndex = this.model.get("selectedIndex");
            var val;

            this.model.getItems = function(){
                return this.get("items").map(function(item,idx){
                    var itm;
                    if(typeof item ==="string"){
                        itm = {text: item};
                    }
                    else{
                        itm = _.extend({}, item);
                    }
                    itm.idx = idx;

                    if(idx == selectedIndex){
                        val = item;
                        itm.selected = true;
                    }
                    return itm;
                })
            };
            this.model.refreshRows();
            this.model.on("change:items", this.model.refreshRows);

            if(val && !this.model.get("dontUpdate")){
                this.model.set("textValue", val);
            }

            this.on("selectItems", function(items){
                //TODO: ignore -1 in menu, needs to allow canceling in base...?
                //TODO: validate length ??
                var val = "";
                var indexes = items.map(function(itm){
                    val = itm.text;
                    return itm.idx;
                });
                if(indexes.length == 1) indexes = indexes[0];
                this.model.api.selectMenuItem(indexes);
                if(!this.model.get("dontUpdate")){
                    this.model.set("textValue", val);
                }
                this.model.saveToCache();
            });

            if(this.options.filterable){
                this.on("modal:close", function(){
                    this.model.refreshRows();
                    if(val && !this.model.get("dontUpdate")){
                        this.model.set("textValue", val);
                        try{
                            self.reportInteraction({
                                element: "TextBox",
                                interaction: "click",
                                controlPath: ".dd-close"
                            });
                        } catch(e){
                            Logger.info("[UserInteraction] Exception on report Table do drill interaction");
                        }
                    }
                });
            }
        },

        setSelectedIndex: function (index) {
            var items = this.model.get("rows");
            if (items.length <= index || index < 0) return;

            items.forEach(function (item) {
                item.selected = false;
            });

            if(items[index]) items[index].selected = true;

            this.trigger("selectItems", items[index] ? [items[index]] : []);
        }

    };


    Capriza.Views.Dropdown._types['combobox'] = {
        opts: {
            _textboxClass: "ddcombobox",
            hasInput: true,
            modal:false,
            showWhenReadOnly:true
        },

        _initialize:function(){
            if(this.options.filterable){
                this.options.modal = true;
                this.options.modalInput = true;
            }
        },

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var self = this;

            this.model.getItems = function() {
                var model = this;
                var value = (this.get("value") || []).map(function (item, idx) {
                    var itm = {idx: idx, text: item};
                    if(model.get("textValue")==item){
                        itm.selected = true;
                    }
                    return itm;
                });
                return value;
            };
            this.model.refreshRows = function(){
                var items = this.getItems();
                var cache = Capriza.CacheManager.getHistory(this);
                items = this._mergeCache(items, cache, !this.get("isReadOnly"));
                this.set("rows", items);
            };

            //this.$openerButton.on("click",function(){
            //    self.isOpener = true;
            //});
            this.model.on("change:value", function() {
                self.hideLoading();
                self.model.refreshRows();
                // TODO: should we handle empty list? we didn't in the old combobox. I just found out that in old popup we ignore empty lists... :-/
            });

            self.model.refreshRows();

            this.model.on("change:text", function() {
                self.model.set("textValue", self.model.get("text"));
                if(this.shown) self.filterAndSortRows();
            });

            this.model.getCurrentItemsForCache = function(){
                return [{text:this.get("text")}];
            };

            this.on("beforeShow", function(){
                if(!this.options.modal && !this.model.get("isReadOnly")) this.getInput(true).focus();
                this.showLoading();
                this.model.api.openPopup();
            });

            this.on("canceling", function(){
                this.model.api.closePopup();
            });

            this.on("selectItems", function(items){
                var val = "";
                var indexes = items.map(function(itm){
                    val = itm.text;
                    return itm.idx;
                });
                if (indexes.length == 1) indexes = indexes[0];
                if(indexes == undefined){//setting directly from (typed) cache
                    if(!this.model.get("isReadOnly"))this.model.api.setText(val);
                }
                else {
                    this.model.api.selectMenuItem(indexes);
                }
                this.model.set("text", val);
                this.model.saveToCache();
                Dispatcher.trigger("control/action/end",this);
            });

            //was used for filtering not in modal
            //this.getInput(true).on("input", function(){
            //    self.isOpener = false;
            //    if(!self.shown && self.filterAndSortRows())
            //    {
            //        self.showDropdown();
            //    }
            //});

            this.on("change", function(){
                setValue(this.getInput(true).val());
            });

            this.on("clear:modalinput", function(){
                self.filterAndSortRows()
            });

            this.on("clear:input", function(){
                this.model.set("text");
                self.showDropdown();
            });

            this.on("cache:updated",function(){
                self.model.refreshRows();
            });

            function setValue(value){
                self.getInput(true).val(value);
                self.model.set("text", value);
                self.model.api.setText(value);
                self.model.saveToCache();
            }

            this.on("modal:close", function(){
                if(self.options.model.get("isReadOnly")) return;
                setValue(self.getInput().val());
            });

            if(!this.options.modal){
                this.on("dropdown:shown",function(){
                    self.stopListenToChange();
                });

                this.on("dropdown:hidden",function(){
                    self.listenToChange();
                });

                this.on("shield:click", function(e){
                    var clearRect = self.$clearIcon[0].getBoundingClientRect();
                    if(clearRect.left < e.clientX && clearRect.right > e.clientX && clearRect.top < e.clientY && clearRect.bottom > e.clientY ){
                        self.$clearIcon.click();
                        e.dontHide = true;
                        return;
                    }
                    self.changeListener();
                });
            }

            this.model.set("textValue", this.model.get("text"));
        }

    };


    Capriza.Views.Dropdown._types['lookup'] = {
        opts: {
            _textboxClass: "ddlookup",
            hasInput: true,
            modal:false,
            button:true,
            opener:false,
            filterable:true,
            hideOnEmpty:true
        },
        textboxIcon: "fa fa-search",
        textboxClass: "lookup",

        _post:function(){
            Capriza.Views.Dropdown.prototype._post.apply(this,arguments);
            var self = this;


            this.model.refreshRows = function(){
                var cache = Capriza.CacheManager.getHistory(this);
                this.set("rows", cache);
                if(!cache || cache.length == 0) self.hideDropdown();
            };

            self.model.refreshRows();

            this.model.on("change:text", function() {
                self.model.set("textValue", self.model.get("text"));
            });

            this.$openerButton.css({right:"41px"});

            this.model.getCurrentItemsForCache = function(reason){
                var cacheData = this.get("cacheData");
                if(reason == "lookup:cacheNow" && cacheData && cacheData.value){
                    return [{text:cacheData.value}];
                }
                return [{text:this.get("text")}];
            };

            this.model.getAdditionalValues = function(reason){
                var cacheData = this.get("cacheData");
                if(reason == "lookup:cacheNow" && cacheData && cacheData.descriptions){
                    return cacheData.descriptions.map(function(item){
                        return {text : (item || "")};
                    });
                }
            };


            this.on("actionClicked", function(){
                this.model.api.openList();
            });

            this.on("selectItems", function(items){
                var val = items.map(function(itm){
                    return itm.text;
                })[0];
                this.model.api.setText(val);
                this.model.set("text", val);
            });

            this.getInput(true).on("input", function(){
                if(!self.shown && self.filterAndSortRows())
                {
                    self.showDropdown();
                }
            });

            this.on("change", function(){
                var value = this.getInput(true).val();
                this.model.set("text", value);
                this.model.api.setText(value);
                this.model.saveToCache();
            });

            this.on("clear:modalinput", function(){
                self.model.api.setText("");
            });

            this.on("clear:input", function(){
                self.model.set("text", "");
                self.showDropdown();
            });

            this.on("cache:updated",function(){
                self.model.refreshRows();
            });

            this.on("beforeShow", function (e) {
                if (self.model.get("rows").length == 0) {
                    e.cancel = true;
                }
            });
            if(this.model.get("cacheData") && this.model.get("cacheData").cacheNow){
                this.model.saveToCache("lookup:cacheNow");
            }

            this.on("dropdown:shown",function(){
                self.stopListenToChange();
            });

            this.on("dropdown:hidden",function(){
                self.listenToChange();
            });

            this.on("shield:click", function(e){
                var clearRect = self.$clearIcon[0].getBoundingClientRect();
                if(clearRect.left < e.clientX && clearRect.right > e.clientX && clearRect.top < e.clientY && clearRect.bottom > e.clientY ){
                    self.$clearIcon.click();
                    e.dontHide = true;
                    return;
                }
                self.changeListener();
            });

            this.model.set("textValue", this.model.get("text"));

        }

    };
    Capriza.Views.Dropdown.prototype._types = Capriza.Views.Dropdown._types;

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/ListTree.js

try{
;(function() {

function Node(data){
    this.id = data.id;
    this.label = data.label;
    this.isSelectable = data.isSelectable;
    this.hasChildren = data.hasChildren;
    this.initialSelection = data.initialSelection;
    this.selected = data.selected;
    this.parent = null;
    this.list = [];
    this.data = data.data || {};
}
function Tree(id){
    this._id = id || 0;
    this._data = {};
    this._list = [];
}
Tree.prototype={

    getNode : function(nodeId){
        return JSON.parse(JSON.stringify(this._data[nodeId]));
    },

    getChildren: function(parentId){
        var rs = [];
        var self = this;
        var list = this.getChildIds(parentId);

        for(var i = 0, len = list.length; i < len; i++){
            rs.push(self.getNode(list[i]));
        }
        return JSON.parse(JSON.stringify(rs));
    },

    getChildIds: function(parentId){
        var list = [];
        if(parentId){
            var node = this.getNode(parentId);
            if(node) list = node.list;
        } else {
            list = this._list;
        }
        return JSON.parse(JSON.stringify(list));
    },

    recreate: function(data) {
        try{
            data = JSON.parse(JSON.stringify(data));
            this._id = data.id;
            this._data = data.nodes || {};
            this._list = data.rootIds || [];
        }catch(e){
            Logger.error("Failed to recreate tree passed from the engine "+e);
        }
        return this;
    },

    stringify : function(){
        var data = {
            numOfNodes  : this.idCounter,
            id          : this._id,
            nodes       : this._data,
            rootIds     : this._list
        }
        return JSON.stringify(data);
    },

    merge : function(parentId, subTree){

        function removeBranch(id){
            var children = self.getChildIds(id);
            for(var i=0; i<children.length; i++){
                removeBranch(children[i]);
                delete self._data[children[i]];
            }
        }

        var self = this;
        subTree._list.forEach(function(id){ removeBranch(id); delete this._data[id]; }, this);

        $.extend(true, this._data, subTree._data);
    },

    toggleBreadCrumbs : function (ids){
        ids.forEach(function(id){
            var isSet = this._data[id].isBreadCrumb;
            if (isSet) this._data[id].isBreadCrumb = false;
            else this._data[id].isBreadCrumb = true;
        },this);
    },

    setBreadCrumbs : function (ids){
        ids.forEach(function(id){this._data[id].isBreadCrumb = true;},this);
    },

    getSelectedNode : function(){
        var nodes = Object.getOwnPropertyNames(this._data);
        for (var i = 0; i < nodes.length; i++){
            if (this._data[nodes[i]].selected){
                return this._data[nodes[i]].id;
            }
        }
    }
}

Capriza.Views.initWidget("list-tree", {

    displayType: "list-tree",

    _create : function(){

        var self = this;
        var mcId =  this.options.uniqueControlId;

        this.element.attr("id", mcId).addClass("list-tree ui-control");

        this.$tree = $("<div class='list'>").appendTo(this.element);

        this.$breadCrumbs = $("<div class='ui-control'>").append(
            $("<span style='float: left; margin-top: 2px; margin-right: 3px' class='expander fa fa-list-ul'>").css("cursor", "pointer").
                on("click",function(){
                    self.currentId = undefined;
                    self.clickOnBreadCrumb($(this));
                })).append(
            $("<span class='expander text' style='display'>").append("Tap to open selection options.").css("cursor", "pointer").
                on("click",function(){
                    self.currentId = undefined;
                    self.clickOnBreadCrumb($(this).prev());
                })
        ).appendTo(this.$tree);

        this.$spinner = $("<div class='spinner'>").appendTo(this.$tree);
    },

    // todo: support tree refreshes. not used now
    // engine callback on monitored value
    // reopen a tree
    setRoot : function(newRoot){
        var rootElem = this.$breadCrumbs.find(".expander");
        this.treeData = null;
        this.clickOnBreadCrumb(rootElem);
    },

    isTreeExpander : function(elem){
        return $(elem).hasClass("expander");
    },

    toggleTreeExpanderText : function(){
        var expText = this.$breadCrumbs.find(".expander.text");
        expText.toggle();
    },

    hideTreeExpanderText : function(){
        var expText = this.$breadCrumbs.find(".expander.text");
        expText.hide();
    },

    showTreeExpanderText : function(){
        var expText = this.$breadCrumbs.find(".expander.text");
        expText.show();
    },

    markTreeExpanderClosed : function(){
        var treeExpander = this.$breadCrumbs.find(".expander:first");
        treeExpander.removeClass("open");
    },

    // todo: find a better way to represent the root.
    getTreeRootId : function(){
        return undefined;
    },

    showTree : function(){
        if(!this.currentId)this.loadBranch(this.currentId);
        else{
            var rootId = this.getTreeRootId();
            this.showCurrentSelection(rootId);
            this.showBranch(this.currentId);
        }
    },

    clickOnBreadCrumb : function(bc){
        $(bc).toggleClass("open");
        var currentSelection = $(bc).nextAll().not(".expander");

        if(this.isTreeExpander($(bc))){
            currentSelection.remove();
            if($(bc).hasClass("open")){
                this.hideTreeExpanderText();
                this.showTree();
            }else {
                this.$listContent.empty();
                this.showTreeExpanderText();
            }
        }else this.loadBranch(this.currentId);
    },

    updateTreeExpanderState : function(open){
        // mark last bc as closed.
        if(!open) this.$breadCrumbs.find("span:first").removeClass("open");
        else this.$breadCrumbs.find("span:first").addClass("open");
    },

    // engine callback - branch was fetched.
    setBranch : function(updateData){
        if(!updateData) return;

        this.$spinner.removeClass("active");

        if(!this.treeData || !updateData.parentId){
            this.treeData = new Tree().recreate(updateData.items);
            this.showCurrentSelection(updateData.parentId);
            this.highlightSelectedNode();
            this.currentId = this.treeData.getSelectedNode();

        }else{
            var parentNode = this.treeData.getNode(updateData.parentId);
            if(parentNode.hasChildren){
                var newBranch = new Tree().recreate(updateData.items);
                this.treeData.merge(updateData.parentId, newBranch);
                Logger.debug("***** Client Side: Tree structure after the merge: " + this.treeData.stringify());
                this.currentId = updateData.parentId;
                this.treeData.toggleBreadCrumbs([this.currentId]);
            }
        }

        this.showBranch(this.currentId);
    },

    loadBranch : function(parentId){
        if(!this.treeData || this.treeData.getChildren(parentId).length<=0){
            this._trigger("apicall", null, { action: "fetchBranch", data: parentId });
            if(this.$listContent) this.$listContent.empty();
            this.$spinner.addClass("active");
        }
        else{
            var parentNode;
            if(parentId) parentNode = this.treeData.getNode(parentId);
            if(parentNode && parentNode.initialSelection){
                this._trigger("apicall", null, { action: "fetchBranch", data: parentId });
                this.$listContent.empty();
                this.$spinner.addClass("active");
            }
            else this.showBranch(parentId);
        }
    },

    showBranch : function(parentId){
        var self = this;

        if(this.$listContent) this.$listContent.empty();

        var listItems = this.treeData.getChildren(parentId);
        var $items = this.$listContent || $("<ul style='margin-top: 30px'>");
        _.each(listItems, function(item) {
            var $item = $("<li class='list-item' style='position:relative'>").append(
                $("<div class='link'>").
                    attr('id', item.id).
                    attr('hasChildren', item.hasChildren).
                    attr('selectable', item.isSelectable).
                    attr('initialSelection', item.initialSelection).
                    append(item.label));
            // allow drill down on the arrow, when a node is a parent
            // and is also selectable
            if(item.hasChildren){
                var $itemDrillDown =
                    $("<div style='width:10px;height:20px;position:absolute;right:0px;top:9px;'>").on("click",
                        function (e) {
                            e.stopPropagation();
                            e.preventDefault();
                            self.currentId = item.id;
                            self.updateNavigation(self.currentId, item.label, true);
                            self.loadBranch(self.currentId);
                            // reset tree expander state
                            self.markTreeExpanderClosed();
                        });
                var $rightArrow = $("<i class='fa fa-chevron-right'>");
                $itemDrillDown.append($rightArrow);
                $item.append($itemDrillDown);
            }
            // show leaf element
            else $item.find('div').addClass('has-icon');

//            else $item.find('div').append(
//                $("<div style='float:left; margin-right:8px' class='fa fa-level-up'>")
//            ).addClass('has-icon');

            $item.on("click", function(e){
                self.currentId = $(this).find('div').attr('id');
                if($(this).find('div').attr('hasChildren') === 'true' &&
                    $(this).find('div').attr('selectable') === 'false'){
                    self.updateNavigation(self.currentId, $(this).text(), true);
                    self.loadBranch(self.currentId);
                }
                else {
                    self._trigger("apicall", e, { action: "setSelectedItem", data: self.currentId });
                    self.updateNavigation(self.currentId, $(this).text(), false);
                }
            });

            $item.appendTo($items);
        });

        $items.appendTo(this.$tree);
        this.$listContent = $items;
    },

    showCurrentSelection : function(parentId){

        function addParentBreadCrumb(id){
            var children = self.treeData.getChildren(id);
            if(children && children.length>0){
                var item = children[0];
                // todo: optimize breadcrumbs indication
                if(item.initialSelection || item.isBreadCrumb){
                    self.treeData.setBreadCrumbs([item.id]);
                    self.updateNavigation(item.id, item.label, item.hasChildren);
                }
                if(!item.selected || !item.hasChildren) addParentBreadCrumb(item.id);
            }
        }
        var self = this;
        addParentBreadCrumb(parentId);
    },

    updateNavigation : function(selectedId, label, isBranch){
        var self = this;

        this.updateTreeExpanderState(false);

        if(isBranch){
            // mark last bc as closed.
            this.$breadCrumbs.find("span:last").removeClass("open").css({"color":'', 'font-size':''});

            this.$breadCrumbs.find("span:last").after(
                $("<span style='position:relative; top:-1px; margin-left: 3px; margin-right: 3px; font-weight: bold' class='link'>").
                    attr('id', selectedId).css({"cursor": "pointer"}).on("click", function(){
                        self.currentId = selectedId;
                        if($(this).next().length>0){
                            var ids = [];
                            $(this).nextAll("[id]").each(function(){ids.push($(this).attr("id"));});
                            self.treeData.toggleBreadCrumbs(ids);

                            $(this).nextAll().remove();
                        }
                        self.clickOnBreadCrumb($(this));
                }).addClass('has-icon').append(label)).after(
                $("<span style='margin-left: 3px; margin-right: 3px; font-weight: bold' class='link has-icon fa fa-chevron-right'>").css({"cursor": "pointer"}));
        }else{
            this.$breadCrumbs.find("span:last").after(
                $("<span style='position:relative; top:-1px; margin-left: 5px; font-weight: bold' class='has-icon'>").append(label)).after(
                $("<span style='position:relative; top:-1px; margin-left: 3px; font-weight: bold' class='link has-icon fa fa-chevron-right'>"));
        }

        if(!isBranch && this.$listContent) this.$listContent.empty();
    },

    highlightSelectedNode : function(){
        this.$breadCrumbs.find("span:last").css({"color":"black", 'font-size':'115%'});
    }

});
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Button.js

try{
;(function() {
    var backButtonRE = /back-button/;

    Capriza.Views.Button = Capriza.Views.UiControl.extend({

        _render: function() {
            var self = this;

            this.$el.attr("id", this.getUniqueControlId()).addClass("button");

            this.$value = $("<button class='value styleable-text'>").on("click", function(e) {
                self.onClick(e);
            }).appendTo(this.$el);

            this.setName(this.model.get("name") || " ");
            this.setIcon(this.model.get("icon"));

            if(this.hasExtraData("sensitive-action") && window.Capriza && Capriza.Capp && Capriza.Capp.touchId){
                this.checkSensitiveActionSupport();
            }

            // CapOne ADA - #14275
            var mcClass = this.model.get("mcClass");
            if (mcClass && backButtonRE.test(mcClass)) {
                this.$value.attr("aria-label", "Back");
            }

            return this.$el;
        },
        checkSensitiveActionSupport:function() {
            var _this=this;
            Capriza.Capp.touchId.isAvailable(function () {
                _this.sensitiveActionEnabled=true;
             });
        },

//        inheritedProps: ["color", "font-style", "font-weight", "line-height", "border", "box-shadow", "background-image", "background-color"],
        inheritedProps: ["color", "font-style", "font-weight", "line-height", "text-decoration", "direction", "text-align"],

        onClick: function (e) {
            Logger.debug('Buttons.js ' + this.model.get("id") + ' is clicked');
            try{
                this.reportInteraction({
                    element: "Engine Button",
                    interaction: "click"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Engine Button click interaction");
            }
            e.stopPropagation();
            if (this.model.get("disabled")) return;
            var self = this;
            if (this.sensitiveActionEnabled) {
                Capriza.Capp.touchId.verifyFingerprint("This action requires identity verification", function () {
                    self.model.api.click();
                });
            } else {
                this.model.api.click();
            }

            Dispatcher.trigger("control/action/end",this);
        },

        //todo: this method overrides (DELETES) the icon if there was any.. because icon is an <i> element inside the $value.
        //the reason it worked is because there is no monitoring on button texts..
        setName: function(name) {
            var valueText = this.$value[0].childNodes[0]==this.$value[0].firstElementChild ? this.$value[0].childNodes[1] : this.$value[0].childNodes[0];
            if (valueText && valueText.nodeValue) {
                valueText.nodeValue = _.sanitize(name);
            } else {
                this.$value.text(_.sanitize(name));
            }

        },

        setIcon: function(iconClass){
            var $i = $("i", this.$value);
            if (!iconClass) {
                $i.remove();
                return;
            }

            if (!$i.length) {
                $i = $("<i></i> ");
            }
            $i.attr("class", iconClass);

            if (/right/.test(this.model.get("iconDisplay"))) {
                $i.appendTo(this.$value);
            } else {
                $i.prependTo(this.$value);
            }
        },

        setShouldUseWebColor: function() {
            if (this.model.get("shouldUseWebColor")) {
                var style = this.model.get("style");
                style && this.$value.css(style);
            }
        }
    });

    Capriza.Views.ClientButton = Capriza.Views.Button.extend({

        _post: function() {
            var className;
            var buttonType = this.model.get('clientButtonType');
            switch(buttonType){
                case "back": {
                    className = "back-button";
                    this.$value.attr("aria-label", "back"); // CapOne ADA - #14275
                    break;
                }
                case "prev" :{
                    className = "prev-switcher";
                    Dispatcher.trigger("switcherPrev/show", this.$el);
                    break;
                }
                case "next" :{
                    className = "next-switcher";
                    Dispatcher.trigger("switcherNext/show", this.$el);
                    break;
                }
                case "cnfRestart" :{
                    className = "cnf-restart";
                    break;
                }
                case "externalLink":
                case "zappLink":
                case "phone":
                case "email":
                case "address":{
                    className = buttonType + " user-action";
                    var options = this.model.attributes;
                    if (options) {
                        this.$value[buttonType](options);
                    }
                    break;
                }
            }
            this.$el.addClass(className);
        },
        setData: function(){
            var buttonType = this.model.get('clientButtonType');
            switch(buttonType){
                case "externalLink":
                case "zappLink":
                case "phone":
                case "email":
                case "address":{
                    var options = this.model.attributes;
                    if (options) {
                        this.$value[buttonType]("setData", options);
                    }
                    break;
                }
            }
        },

        onClick: function() {
            try{
                this.reportInteraction({
                    element: (this.model.get('clientButtonType') || "bubble").capitalize() + " Button (Client)",
                    interaction: "click"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Client Button click interaction");
            }
            switch(this.model.get('clientButtonType')){
                case "back": {
                    if (!$(".viewport").hasClass("transitioning") && $('.loading-message').hasClass('hidden')) {
                        pageManager.onBackClick();
                    }
                    break;
                }

                //ToDo: should enable send stats to engine for phone
            }
        },

        // Overrides parent's method to change tabindex
        setIsDisabled: function () {
            Capriza.Views.Button.prototype.setIsDisabled.call(this);

            var n = (this.$el.is(".disabled") ? -1 : 0);

            this.$value.attr("tabindex", n);
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/OnOffSwitch.js

try{
;
(function() {

    Capriza.Views.OnOffSwitch3 = Capriza.Views.UiControl.extend({
        _render: function () {
            this.$el = $(Handlebars.templates['onoff-switch']({
                uniqueControlId: this.getUniqueControlId()
            }));
            this.setIsOn(this.model.get('isOn'));

            var self = this;

            this.$el.on('click', function (e) {
                e.preventDefault();
                self.$el.toggleClass('on');
                if (self.$el.hasClass('on')) {
                    self.model.api.setOn();
                } else {
                    self.model.api.setOff();
                }
            });

            return this.$el;
        },

        setIsOn: function (checked) {
            this.$el.toggleClass("on", !!checked)
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/File.js

try{
;(function() {
    Capriza.Views.File = Capriza.Views.UiControl.extend({
        _render: function() {
            var _this = this;
            var uniqueControlId = this.getUniqueControlId();
            var model = _.extend(this.model.toJSON(), { uniqueControlId: uniqueControlId, placeholder: this.model.get("placeholder"), icon: this.model.get("iconLabel") });
            this.$el.file(model);
            this.$el.on("file_upload", function() {
                window[uniqueControlId + 'uploadCB'] = function(result) {
                    _this.$("img").attr("src", result.imageDataURL);
                    _this.model.api.setFile(uniqueControlId + '.jpeg');
                };
                window.appData && Capriza.fileUpload(uniqueControlId + 'uploadCB', { fileName: uniqueControlId + '.jpeg', sessionId: window.appData.session_id });
            });

            this.$el.on('fileset',function(e,data){
                _this.model.api.setFile(data.fileLocation);
            });
            return this.$el;
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Panel.js

try{
/**
 * Created by omer on 7/31/14.
 */

(function() {
    Capriza.Views.Panel = Capriza.Views.Group.extend({

        $innerGroup: "",
        className:"panel",

        initialize: function() {
            Capriza.Views.Group.prototype.initialize.apply(this, arguments);
            var panelHeader = this.model.get("groupHeader");
            if (panelHeader) {
                this.createAndAddControl(panelHeader);
            }
        },

        _render: function() {

            this.$el.addClass("groupEmpty");

            if (this.model.get('isForm')) {
                this.$innerGroup = $('<form class="grouping" href="#"></form>');
            } else {
                this.$innerGroup = $('<div class="grouping"></div>');
            }

            this.$el.append(this.$innerGroup);

            this.addClasses();
            this.createMobileKeyboardFormStyle();

            this.handleDock(this.model.get('vAlign'));

            if(this.model.get('grow')) {
                this.$el.addClass('undocked-area');
            }

            if(this.model.get('dock')) {
               this.$el.addClass('floating-bar');
            }

            if(this.model.get('scroll')) {
                // TODO: ugly hack, ideally the engine will not send 'scroll' attribute on main panel when there is tabController.
                var controls = this.model.get('controls'),
                    firstChildIsTabController = controls && controls[0] && controls[0].get('type') === 'tabController';

                Logger.debug("firstChildIsTabController=" + firstChildIsTabController);

                if (!firstChildIsTabController) {
                    var self = this;

                    this.$innerGroup.addClass('scrolling-area');
                    try {
                        var controlPath = "#" + self.$el[0].id + " .grouping.scrolling-area";
                        var debounceInteractions = Utils.debounce(150, function (e) {
                            try{
                                self.reportInteraction({
                                    element: "main",
                                    interaction: "scrollTop",
                                    controlPath: controlPath,
                                    param: e && e.target && e.target.scrollTop
                                });
                            } catch(ex){
                                Logger.info("[UserInteraction] Exception on report Scroll state inner interaction");
                            }
                        });
                        this.$innerGroup.on("scroll", debounceInteractions);
                    } catch (ex){
                        Logger.info("[UserInteraction] Exception on report Scroll state outer interaction");
                    }
                }
            }

            if(this.model.get('panelType')) {
                this.$el.addClass('panel-type-' + this.model.get('panelType'));
            }

            if (this.$el.hasClass('has-dock')) {
                //var $scrollArea = this.getScrollingContainer()//$('.scrolling-area')
                var $scrollArea = this.getClosestScrollingContainer()//$('.scrolling-area')
                    , $upperBar = this.$('.dock-top'),
                    firstChild = $scrollArea.children().length && $scrollArea.children()[0];

                if ($upperBar.length > 0 && firstChild){

                    var styles = getComputedStyle(firstChild);
                    if (styles) {
                        var marginTop = styles.getPropertyValue("margin-top");

                        $scrollArea.scroll(function() {
                            if (firstChild.getBoundingClientRect().top-marginTop < $upperBar[0].getBoundingClientRect().bottom) {

                                $upperBar.addClass('scroll-shadow');

                            }
                            else {
                                $upperBar.removeClass('scroll-shadow');
                            }
                        })
                    }

                }
            }

            if (this.model.get('collapsible')) {
                this.wrapWithCollapsible();
            }

            if(this.model.get('panelType') == 'header') {
                this.$el.addClass('header');
            }

            return this.$el;
        },


        handleDock: function (vAlign) {

            this.$el.toggleClass('dock-top', this.model.get('dock') === 'top');
            this.$el.toggleClass('dock-bottom', this.model.get('dock') === 'bottom');

            setTimeout(function(){Capriza.device.fixIpadLandscape("Bottom panel added")}, 100);

        },

        /**
         * TODO - ok this is too hacky now. we need HeaderPanel.js. will do it for MED 7
         * @param otherView
         */
        replaceWith: function(otherView) {
            var isActive = this.$el.hasClass('active');
            Capriza.Views.Group.prototype.replaceWith.apply(this, arguments);
            if (this.model.get('panelType') === 'header' && !this.model.parent.get("isModal")){
                otherView.$el.toggleClass('active', isActive);
                Dispatcher.trigger("sideburger/show", otherView.$el);
            }
        },

        addControl: function(control) {
            if(control.get("missing")) {
                return;
            }
            var view = this.options.page.getView(control.get("id")), $childViewEl;

            $childViewEl = view.render();

            this.$el.removeClass("groupEmpty");

            if(control.get('type')=="panel"){
                this.$el.addClass('has-dock');
            }

            this.$innerGroup.append($childViewEl);
            if (control.get('panelType') && control.get('panelType') == 'header'){
                    this.options.page.replaceHeaderContent($childViewEl);
            }

        },

        addViewAtIndex: function(view, index) {
            this.$el.removeClass("groupEmpty");
            Capriza.Views.Group.prototype.addViewAtIndex.call(this,view, index);
        },

        prependEl: function ($view) {
            this.$innerGroup.prepend($view);
        },

        /**
         * The mobile-form keyboard has a built-in go button
         */
        createMobileKeyboardFormStyle: function (){
            if (this.model.get('isForm')) {

                Logger.debug("[Panel][wrapInForm] Wrapping textboxes in form for group: " + this.model.get('id'));
                // take the last btn in the form.
                var submitButton = $('.button > .value', this.$innerGroup).last(), self = this;
                $('.textbox', this.$innerGroup).each(function() {
                    var textboxView = $(this).data('uicontrol');
                    if (!textboxView) {
                        Logger.debug("[Panel][wrapInForm] ERROR - couldn't find the textbox view in the form");
                        return;
                    }
                    self.listenTo(textboxView, 'enterKeyPressed', function () {
                        Logger.debug("[Panel][wrapInForm] Enter key pressed ('enterKeyPressed' received), clicking on the submit button");
                        submitButton.click();
                    });
                    textboxView.setIsInForm();
                });

                this.$("form").submit(function(){ return false; });
            }

        },


        /**
         * add classes for the group according to the model
         */
        addClasses: function(){
            var direction = this.model.get('direction');
            if (direction) this.$el.addClass(direction + '-layout');

            var widthMode = this.model.get('widthMode');
            if (widthMode) this.$el.addClass('width-mode-' + widthMode);

            var vAlign = this.model.get('vAlign');
            if (vAlign) this.$el.addClass('align-grouping-' + vAlign);

            this.$el = Capriza.Views.Group.prototype._render.call(this);
        },

        setShouldUseWebColor: function() {
//            if (!this.options.ignoreILE && this.model.get("shouldUseWebColor")) {
//                this.$innerGroup.removeClass('no-bg-color');
//            } else {
//                this.$innerGroup.addClass('no-bg-color');
//            }
        },

        wrapWithCollapsible: function(){
            function collapsible(options){
                var that = this;
                this.options = options;
                this.state = options.state || "close";
                this.self = options.self;

                this.el = options.el;
                // Get the collapsible header
                this.header = options.header;
                this.header.addEventListener("click", that);

                // Get the collapsible content
                this.content = options.content;
                this.content.classList.add("collapsible-content");

                //add the arrow icon
                this.icon = setCollapsibleHeader(that.header, options.openerIcon);
                this.icon.addEventListener("click", that);


                //add the blocker
                this.blocker = setBlocker(that.el);
                this.el.appendChild(that.blocker, that.content);
                this.blocker.addEventListener("transitionend", that);
                this.blocker.addEventListener("webkitTransitionEnd", that);

                if (options.isOpen){
                    this.state = "open";
                }

                this._render();
            }

            function createCollapsibleHeader() {
                var control = this.model.get("groupHeader");
                if (control) {
                    var view = this.options.page.getView(control.id);
                    view && view.render().appendTo(this.$collapsibleHeader);
                } else {
                    this.$collapsibleHeader.append($("<div tabindex='0'></div>"));
                }
            }

            function calcTime(forHeight){
                return Math.min(Math.max(300,forHeight + 150), 900) + 'ms';
            }

            function setElementTransition(currentObj, withAnimation, duration, toPos) {
                if (currentObj.classList.contains("floating-bar")) return;
                currentObj.style.transition = withAnimation ? 'transform cubic-bezier(.21,.72,.71,.96) ' + duration : "";
                currentObj.style.transform = toPos ? "translate3d(0," + toPos + "px, 0)" : (withAnimation ? "none" : "" );
                if (withAnimation) {
                    currentObj.classList.add("animating");
                    currentObj.addEventListener("transitionend", this);
                    currentObj.addEventListener("webkitTransitionend", this);
                }
            }

            function nextElement(currentElement){
                var expectedElement = currentElement,
                    parentElement = currentElement.parentNode,
                    parentParentElement = parentElement.parentNode;
                // get the next visible element. don't move this element container.
                // for horizontal groups: all elements in the group need to move as if they where the original element
                while (parentElement !== document && parentParentElement !== document && // hard stop at document level
                ((!expectedElement.nextElementSibling && // if the next element exists continue
                  !parentElement.classList.contains("scrolling-area") &&
                  !parentParentElement.classList.contains("floating-bar") &&
                  !(parentElement.classList.contains("tab-content") && parentElement.classList.contains("active")))  // if we are at top evel continue
                || parentParentElement.classList.contains("horizontal-layout")
                )){
                    expectedElement = parentElement;
                    parentElement = parentElement.parentNode;
                    parentParentElement = parentElement.parentNode;
                    if (parentElement.classList.contains("viewport") || parentParentElement === document|| parentElement.classList.contains("horizontal-layout") || parentParentElement.classList.contains("horizontal-layout")) return false;

                }
                expectedElement = expectedElement.nextElementSibling;
                while (this.parentsList && this.parentsList.indexOf(expectedElement) > -1 && expectedElement.children.length > 0){
                    // the expected element is a container of the current element, need to drill in this container

                    if (expectedElement.classList.contains("horizontal-layout") || expectedElement.parentElement.classList.contains("horizontal-layout")) return false;
                    expectedElement = expectedElement.children[0];
                }
                if (expectedElement && expectedElement.classList.contains("floating-bar")) return null;
                return expectedElement;
            }

            function isPageElement(element){
                return element === document ||
                    element.classList.contains("scrolling-area") ||
                    element.classList.contains("floating-bar") ||
                    (element.classList.contains("horizontal-layout")  && !element.classList.contains("collapsible-container")) ||
                    element.classList.contains("tab-content");
            }

            function getTopParent(originElement){
                var parentElement = originElement.parentNode,
                    parentParentElement = parentElement.parentNode,
                    topParent = originElement,
                    parentsList = [];
                if (isPageElement(originElement) && !originElement.classList.contains("floating-bar")) return null;
                parentsList.push(parentElement);
                parentsList.push(parentParentElement);
                while(!isPageElement(parentElement) && !isPageElement(parentParentElement)){
                    topParent = parentParentElement;
                    parentElement = parentParentElement.parentNode;
                    parentParentElement = parentElement.parentNode;
                    parentsList.push(parentElement);
                    parentsList.push(parentParentElement);
                    if (originElement.classList.contains("floating-bar")) break;
                }
                this.parentsList = parentsList;
                if (isPageElement(parentParentElement)) {
                    parentElement = parentParentElement;
                }
                return {"pageParent": parentElement, "topParent" : topParent} ;
            }

            function nextElementsFromTop(pageContainer, topParent, currentElement){
                if (currentElement === topParent.nextElementSibling) return null;
                var pageElement = pageContainer || currentElement.parentNode,
                    potentialNext = currentElement ? currentElement.nextElementSibling : pageElement.children[0];
                    while (this.parentsList && this.parentsList.indexOf(potentialNext) > -1 && potentialNext.children.length) {
                        if (potentialNext.classList.contains("horizontal-layout") || potentialNext.parentElement.classList.contains("horizontal-layout")) return false;
                        potentialNext = potentialNext.children[0];
                    }
                return potentialNext;
            }

            function setElementsPosition(originObj, duration, toPos, nextOriginObj, shouldStop, nextElementFun) {
                var lastElement,
                    currentObj = originObj;
                while(currentObj && (!shouldStop || !shouldStop(nextOriginObj, currentObj))){
                    setElementTransition.call(this, currentObj, false, duration, toPos);
                    lastElement = currentObj;
                    currentObj = nextElement.call(this, currentObj);
                }
                // use to to cuase the browser to render before
                lastElement && lastElement.offsetHeight;
            }

            function elementAnimationEnd(element){
                var originIndex = element.getAttribute("originIndex");
                if (isNaN(originIndex) || !originIndex) {
                    element.style.zIndex = "";
                    element.removeAttribute("originIndex");
                } else {
                    element.style.zIndex = originIndex;
                }
                var originPos = element.getAttribute("originPos");
                if (originPos) {
                    element.style.position = originPos;
                } else {
                    element.removeAttribute("originPos");
                    element.style.position = "";
                }
                setElementTransition.call(this, element, false, 0, "");
            }

            function moveNextElements(originObj, moveUp, height, duration, viewPortBottom, from){
                // move all next element by the given height
                // to move the elements Up: on closing the collapsible, will use animation from the minus height to zero
                // to move the elements Down: on open, use animation from zero to minus height
                var currentObj = nextElement(originObj);
                var fromPos = moveUp ? (from || "") : -height,
                    toPos = moveUp ? -height : (from || "");

                //set origin
                setElementsPosition.call(this, currentObj, duration, fromPos);

                //set animation destiny
                while(currentObj && currentObj != originObj){
                    var currentZIndex = parseInt(currentObj.style.zIndex);
                    !isNaN(currentZIndex) && currentObj.setAttribute("originIndex", currentZIndex);
                    currentObj.style.zIndex = currentZIndex > 2 ? currentZIndex : 2;
                    currentObj.setAttribute("originPos", currentObj.style.position);
                    currentObj.style.position = "relative";
                    setElementTransition.call(this, currentObj, fromPos !== toPos, duration, toPos);
                    currentObj = nextElement(currentObj);
                }
                return currentObj !== false;
            }

            function movePreviousElements(originObj, $scrollingArea, moveUp, height, duration) {
                var containers = getTopParent.call(this, originObj);
                if (!containers) return; // this is floating bar
                var currentObj = nextElementsFromTop.call(this, containers.pageParent, containers.topParent);
                var toPos = "",
                    formPos = moveUp ?  height : -height;

                //set origin
                var nextOriginObj = nextElement.call(this, originObj);
                setElementsPosition.call(this, currentObj, duration, formPos, nextOriginObj, function(nextOriginObj, currentElement) {
                    return currentElement == nextOriginObj;
                });
                //set animation destiny

                var changeScroll = moveUp ? height : -height;
                changeScroll += $scrollingArea.scrollTop();
                currentObj !== false && $scrollingArea.scrollTop(changeScroll);
                while(currentObj && currentObj != nextOriginObj) {
                        var currentZIndex = parseInt(currentObj.style.zIndex);
                        !isNaN(currentZIndex) && currentObj.setAttribute("originIndex", currentZIndex);
                        currentObj.style.zIndex = currentZIndex > 2 ? currentZIndex : 2;
                        currentObj.setAttribute("originPos", currentObj.style.position);
                        currentObj.style.position = "relative";
                        setElementTransition.call(this, currentObj, true, duration, toPos);
                    currentObj = nextElementsFromTop.call(this, containers.pageParent, containers.topParent, currentObj);
                }
                return currentObj !== false;
            }

            function setCollapsibleHeader(headerContainer, openerIcon) {
                var iconSpan = document.createElement("span");
                iconSpan.classList.add("caret");
                headerContainer.appendChild(iconSpan);
                headerContainer.classList.add("collapsible-header");
                if (!openerIcon && openerIcon !== "") {
                    var animatedArrow = '<svg width="14px" height="9px" viewBox="0 0 14 9" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">' +
                        '<title>Page 1</title>' +
                        '<desc>Created with Sketch.</desc>' +
                        '<defs></defs>' +
                        '<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">' +
                        '<g id="iPhone-6-Copy" sketch:type="MSArtboardGroup" transform="translate(-341.000000, -297.000000)" fill="currentColor">' +
                        '<g id="Rectangle-2-+-Sarah-Palins-Englis-+-Page-1" sketch:type="MSLayerGroup" transform="translate(0.000000, 274.000000)">' +
                        '<path d="M351.609348,28.6093478 L346.276212,33.9424836 C346.015481,34.2026221 345.674555,34.3329877 345.333432,34.3329877 C344.992309,34.3329877 344.651383,34.2026221 344.390652,33.9424836 C343.869783,33.4226016 343.869783,32.5775959 344.390652,32.0569238 L348.780811,27.6665679 L344.390652,23.276212 C343.869783,22.75633 343.869783,21.9113243 344.390652,21.3906522 C344.911324,20.8697826 345.75554,20.8697826 346.276212,21.3906522 L351.609348,26.723788 C352.130217,27.2444601 352.130217,28.0886757 351.609348,28.6093478 L351.609348,28.6093478 Z" id="Page-1" sketch:type="MSShapeGroup" transform="translate(348.000000, 27.666494) rotate(-270.000000) translate(-348.000000, -27.666494) "></path>' +
                        '</g>' +
                        '</g>' +
                        '</g>' +
                        '</svg>';

                    iconSpan.classList.add("arrow");
                    iconSpan.innerHTML += (animatedArrow);
                } else {
                    iconSpan.classList.add("userIcon");
                    var userIconTag = document.createElement("i");
                    $(userIconTag).addClass(openerIcon);
                    iconSpan.appendChild(userIconTag);
                }
                return iconSpan;
            }

            function setBlocker(){
                var blockerDiv = document.createElement("div");
                blockerDiv.classList.add("bottomSeparator");
                return blockerDiv;
            }

            function moveBlockerBy(blocker, height, time, blockerTop, moveUp){
                var toPos = moveUp ? -1 * height : height;
                blocker.style.height = height ? height + "px" : "";
                blocker.style.top = blockerTop || "";
                blocker.offsetHeight;
                setElementTransition.call(this, blocker, !!time , time, toPos);
            }

            function getElementMargins(element) {
                var computedStyle = window.getComputedStyle(element);
                return {top: parseInt(computedStyle.getPropertyValue("margin-top").replace('px', '')) ,
                    right: parseInt(computedStyle.getPropertyValue("margin-right").replace('px', '')),
                    bottom: parseInt(computedStyle.getPropertyValue("margin-bottom").replace('px', '')),
                    left: parseInt(computedStyle.getPropertyValue("margin-left").replace('px', ''))};
            }
            function getTotalHeight(element){
                var totalHeight = element.offsetHeight;
                var margins = getElementMargins(element);
                totalHeight += margins.top + margins.bottom;
                return totalHeight;

            }
            function cleanOtherElementDom(element){
                var containers = getTopParent.call(this, element),
                    beforeElement;

                while(containers && (beforeElement = nextElementsFromTop.call(this, containers.pageParent, containers.topParent, beforeElement))){
                    elementAnimationEnd(beforeElement);
                }

                var currentObj = element;
                while(currentObj){
                    elementAnimationEnd(currentObj);
                    currentObj = nextElement.call(this, currentObj);
                }
            }
            function getOffsetTop(element, offsetParent){
                return element.getBoundingClientRect().top - offsetParent.getBoundingClientRect().top;
            }
            function closestParent(element, candidateScrollingArea) {
                var potentialScrollingArea = $(element).closest(".active .scrolling-area,.active .tab-content.active");
                if (potentialScrollingArea.length && potentialScrollingArea[0] === candidateScrollingArea[0]) {
                    return potentialScrollingArea;
                }

                return potentialScrollingArea.length && potentialScrollingArea;

            }
            function fixBlockerColor(blocker, $scrollingArea) {
                var pageStyle = window.getComputedStyle($scrollingArea.closest(".panel-type-main")[0]);
                var background = pageStyle.getPropertyValue("background-image");
                background = pageStyle.getPropertyValue("background") || (background && background !== "none" ? background : "") || pageStyle.getPropertyValue("background-color");
                if (background && background !== "none" && background.indexOf("transparent") === -1 && background.indexOf("0)") != 14) {
                    blocker.style.background = background;
                }
            }

            collapsible.prototype = {

                state: "close",

                open: function(noAnimation){
                    this.state = "open";
                    this._render(noAnimation);
                },
                close: function(noAnimation){
                    this.state = "close";
                    this._render(noAnimation);
                },
                animationOpen: function(){
                    this.state = "open";
                    this.open(false);
                },
                animationClose: function(){
                    this.state = "close";
                    this.close(false);
                },
                immediateOpen: function(){
                    this.state = "open";
                    this.open(true);
                },
                immediateClose: function(){
                    this.state = "close";
                    this.close(true);
                },

                _render: function(noAnimation){
                    noAnimation = noAnimation === undefined ? this.options.noAnimation : noAnimation;
                    if ((this.state === "open" && !this.el.classList.contains("collapsible-open")) || (this.state === "close" && this.el.classList.contains("collapsible-open"))) {
                        this.toggle(noAnimation);
                    }
                },

                handleEvent: function (e) {
                    if (e.type == 'click') {
                        // open or close the collapsible based on the collapsible-open class
                        e.stopPropagation();
                        e.preventDefault();
                        this.toggle(this.options.noAnimation);
                    } else if (e.type.indexOf('transitionend') > -1 ) {
                        e.stopPropagation();
                        e.preventDefault();
                        // finish the animation property and clean the dom
                        this.transitionEnd(e);
                    }
                },

                /* Toggle collapsible state
                 *   base on the collapsible-open class open or close the collapsible content
                 *   move the blocker to show or hide the content
                 *   move all following element up or down
                 *
                 *   special cases:
                 *       - oppening an element that is at the bottom of the view port: need to move it up to show it's content
                 *       - closing an element that will cause the page to be smaller and to jump at the end of the animation
                 */
                toggle: function(noAnimation){
                    try {
                        this.self.reportInteraction({
                            element: "Collapsible",
                            interaction: "click",
                            command: this.el.classList.contains("collapsible-open") ? "close" : "open"
                        });
                    } catch(e){
                        Logger.info("[UserInteraction] Exception on report Toggling collapsible interaction");
                    }
                    if (noAnimation) {
                        if (this.el.classList.contains("collapsible-open")){
                            this.el.classList.remove("collapsible-open");
                            this.state = "close";
                            this.self.trigger("collapsible/close");
                        } else {
                            this.el.classList.add("collapsible-open");
                            this.state = "open";
                            this.self.trigger("collapsible/open");
                        }
                        return;
                    }
                    // if there is any open or close animation ignore the toggle command
                    if (document.querySelectorAll(".animatingOpen").length || document.querySelectorAll(".animatingClose").length) return;
                    Logger.debug("Collapsible: collapsible header clicked");
                    this.self.trigger("collapsible/click");

                    var that = this,
                        elClassList = this.el && this.el.classList,
                        currentIsOpen =  elClassList.contains("collapsible-open"),
                        currentHeight = getTotalHeight(this.content),
                        elMargins = getElementMargins(this.el), //if this is open need to close
                        duration = calcTime(currentHeight),
                        //$scrollingArea = closestParent(this.el, this.self.getScrollingContainer()),// use this to fix scrolling issue both on close and on open
                        $scrollingArea = this.self.getClosestScrollingContainer(),// use this to fix scrolling issue both on close and on open
                        scrollTop = $scrollingArea.scrollTop(),
                        offsetTop = getOffsetTop(this.el, $scrollingArea[0]),
                        viewPortHeight = $scrollingArea[0].clientHeight,
                        viewPortBottom = scrollTop + viewPortHeight,
                        isScrollable = false,
                        isFloatingBar = this.el.classList.contains("floating-bar");

                    that.wrapperHeight = (that.wrapperHeight !== '0px' && that.wrapperHeight) || getTotalHeight(this.header);

                    // calculate the height between the bottom of the header and the end of the view
                    var heightBottom =  viewPortHeight - (offsetTop + that.wrapperHeight);
                    fixBlockerColor(this.blocker, $scrollingArea);

                    var borderBottom = window.getComputedStyle(this.el).getPropertyValue("border-bottom");
                    this.el.setAttribute("borderBottom", borderBottom);
                    this.el.style.borderBottom = "none";
                    var isParentHorizontal = this.el.parentNode.classList.contains("horizontal-layout") ||  this.el.parentNode.parentNode.classList.contains("horizontal-layout");
                    if (!currentIsOpen) { // open this collapsible
                        // add a flag that the collapsible is opening
                        elClassList.add("animatingOpen");
                        this.state = "open";

                        // add the down class for animation the default arrow down
                        this.icon.classList.contains("arrow") && this.icon.classList.add("down");

                        var pageHeight = $(".active .page-content").height();
                        //change current wrapper height & move top by height & change group transform
                        this.el.style.height = (currentHeight + that.wrapperHeight)+"px";
                        // mainly for page-modal - if the page size increases due to collapsible open reduce that height from the current height
                        currentHeight = currentHeight - ($(".active .page-content").height() - pageHeight);
                        var blockerTop = (that.wrapperHeight - elMargins.bottom)+"px";
                        this.blocker.style.top = blockerTop;
                        // move the back blocker down so it will display the text behind it
                        var moveUpBy = 0;

                        isScrollable = $scrollingArea[0].clientHeight <= $scrollingArea[0].scrollHeight;
                        var isBubbleJump = !$scrollingArea.parent().hasClass("panel-type-bubble") || $scrollingArea.parent().css("max-height") === ($scrollingArea.parent().height()+"px");
                        // fix case 1: show collapsible content when it's at the bottom of the view port
                        // check the distance between the bottom of the collapsible and the bottom of the view port
                        if (isScrollable && heightBottom < 80 && currentHeight > heightBottom && isBubbleJump){
                            // if it small something like 100px move the page so it will display as much of the content as possible
                            //      until the header reaches the top of the viewport
                            if (currentHeight + that.wrapperHeight > viewPortHeight && !isFloatingBar) {
                                // need to move until header reaches the top of the viewport

                                // calculate the distance between the top of the viewport and the top of the collapsible container
                                moveUpBy = offsetTop - scrollTop;
                                //  move all proceeding element up by the
                            } else {
                                // need to move just the content height that is outside the viewport
                                moveUpBy = currentHeight - heightBottom;
                            }

                            if (isFloatingBar && this.el.classList.contains("dock-bottom")) {
                                var changeScroll = moveUpBy;
                                changeScroll += $scrollingArea.scrollTop();
                                $scrollingArea.scrollTop(changeScroll);
                            }

                            movePreviousElements.call(this, this.el, $scrollingArea, true, moveUpBy, duration);
                        }

                        // move all element from this container down by the content height
                        moveNextElements.call(this, this.el, false, currentHeight - (isFloatingBar ? 0 : moveUpBy), duration, isScrollable && viewPortBottom);
                        if (!isParentHorizontal || isFloatingBar ){
                            moveBlockerBy.call(this, this.blocker,currentHeight + elMargins.bottom , duration, blockerTop);
                        } else {
                            var event = document.createEvent('Event');
                            event.initEvent('transitionEnd', true, true);

                            this.transitionEnd.call(this, event);
                        }
                        Logger.debug("collpasible: opening end");
                    } else { // close the collapsible
                        // remove the flag that mark this collpasible as open
                        elClassList.remove("collapsible-open");
                        this.state = "close";
                        // adding the flag that the collapsible is closing
                        elClassList.add("animatingClose");

                        //remove the down class so the default arrow will animate to the close position
                        this.icon.classList.contains("arrow") && this.icon.classList.remove("down");

                        // change the content to position absolute and make the el to show it. this is important for the closing animation
                        this.el.style.height = (currentHeight + that.wrapperHeight)+"px";

                        // before any content animation return to the default posion (absolute)
                        this.content.style.position = "";

                        var fixJumpHeight = 0;
                        if (!this.el.parentElement.classList.contains("horizontal-layout") && !this.el.parentElement.parentElement.classList.contains("horizontal-layout")) {
                            var nextSibling = nextElement.call(this, this.el);
                            var leftOverContent = 0;
                            if (nextSibling) {
                                var margin = getElementMargins(nextSibling);
                                leftOverContent = ($scrollingArea[0].scrollHeight - scrollTop) - (getOffsetTop(nextSibling, $scrollingArea[0]) /*nextSibling.offsetTop*/ - margin.bottom);// the minimum size for the height bottom to avoid jump
                            }

                            var remainingContentHeight = heightBottom - leftOverContent;

                            remainingContentHeight -= Math.max(0, viewPortHeight - ($scrollingArea[0].scrollHeight - currentHeight));
                            remainingContentHeight -= elMargins.top;
                            // if there is a page jump we need to start moving the following elements from based on the remaining height
                            isScrollable = $scrollingArea[0].clientHeight <= $scrollingArea[0].scrollHeight;
                            // fix case 2: hide collapsible content when it's at the bottom of the view port - will cause jump
                            // check the distance between the bottom of the collapsible-header and the bottom of the view port and compare to the rest of the content after the collapsible end
                            var fixPageJump = scrollTop > 0 && remainingContentHeight > 0;
                            if (fixPageJump) {
                                movePreviousElements.call(this, this.el, $scrollingArea, false, remainingContentHeight, duration);
                                fixJumpHeight = -remainingContentHeight;
                            }
                        }
                        // the blocker top should be at the bottom of the collapsible group so it could animate up
                        this.blocker.style.top = this.el.style.height;
                        // move the blocker up to hide the collapsible content
                        // move all element after the collapsible container up by the content height
                        var shouldMoveBlocker = moveNextElements.call(this, this.el, true, currentHeight , duration, isScrollable && viewPortHeight, fixJumpHeight) || isFloatingBar;
                        if (!isParentHorizontal || isFloatingBar ){//|| shouldMoveBlocker) {
                            moveBlockerBy.call(this, this.blocker, currentHeight, duration, this.el.style.height, true);
                        } else {
                            var event = document.createEvent('Event');
                            event.initEvent('transitionEnd', true, true);

                            this.transitionEnd.call(this, event);
                        }
                        Logger.debug("collapsible: closing end");
                    }

                    var timeoutTimer = Math.min(Math.max(500,currentHeight + 350), 1100);

                    // make sure that the dom is clean, there are some cases that one of the moving element was interupted so we take some spare time and making sure the animation end, the timeout is clear in the animationEnd function
                    this.cleaningService && clearTimeout(this.cleaningService);
                    this.cleaningService = setTimeout(function(){
                        // remove all animating
                        $(".animating").removeClass("animating");

                        var event = document.createEvent('Event');
                        event.initEvent('transitionEnd', true, true);

                        that.transitionEnd.call(that, event);
                    }, timeoutTimer);
                },

                transitionEnd: function(e){
                    var el = document.querySelector(".animatingOpen") || document.querySelector(".animatingClose"),
                        elClassList = el && el.classList,
                        target = e.target || e.srcElement || (el && el.querySelector(".bottomSeparator"));
                    if (!target) return;
                    target.classList.remove("animating");
                    target.removeEventListener(e.type, this);
                    if (!elClassList || !elClassList.contains("collapsible-container") || document.querySelector(".animating")) {
                        return;
                    }
                    Logger.debug("collapsible: moving animation end");
                    this.cleaningService && clearTimeout(this.cleaningService);
                    var blocker = this.blocker;
                    moveBlockerBy(blocker);

                    if (elClassList.contains("animatingOpen")) {
                        // clean the DOM - just leave the collapsible-open
                        elClassList.remove("animatingOpen");
                        cleanOtherElementDom.call(this, el);
                        elClassList.add("collapsible-open");
                        $(".caret.arrow.down").removeClass("down");
                        el.style.height = "";
                        this.el.style.borderBottom = "";
                        this.self.trigger("collapsible/open", this);
                        Logger.debug("collapsible: animation openning end");
                    } else if (elClassList.contains("animatingClose")) {
                        // clean the DOM - just leave the content absolute
                        elClassList.remove("animatingClose");
                        cleanOtherElementDom.call(this, el);
                        el.style.height = "";
                        this.el.style.borderBottom = "";

                        this.self.trigger("collapsible/close", this);
                        Logger.debug("collapsible: animation closing end");
                    }
                    this.self.trigger("collapsible/animationEnd", this);
                    Dispatcher.trigger("panel/change/after/collapsibleStateChanged");
                }
            };

            window.collapsible = collapsible;

            this.$el.addClass("collapsible-container");
            var openIcon = this.model.get('icon');

            this.$collapsibleHeader = $("<div tabindex='0'></div>");

            createCollapsibleHeader.call(this);
            $.capriza.fastClick(this.$collapsibleHeader[0]);
            this.$el.prepend(this.$collapsibleHeader);

            if (Capriza.device.isDesktop) {
                function headerKeydown(event) {
                    if (event.which == 32) {
                        this.click();
                        return false;
                    }
                }

                this.$collapsibleHeader.on('keydown', headerKeydown);
            }

            this.collapsible = new collapsible({el:this.$el[0],
                                                openerIcon: openIcon,
                                                header: this.$collapsibleHeader[0],
                                                content: this.$innerGroup[0],
                                                self: this});
            var self = this,
                pageModel = this.options.page.model;

            self.collapsibleId = pageModel.get("uniqueId") == undefined && pageModel.tableDrill ? pageModel.get("parentPage").drillIndex + "_"  +self.model.get("mcTemplId") : self.model.id;

            var handleCollapsibleOpen = function(e){
                self.collapsibleOpenInUiState(self.collapsibleId);
                self.saveToPageState("collapsible_"+self.collapsibleId, true);

                //inherited from uiControl, notifies the page that this control now "blocks" the page,
                //until "unblockPage" or "hide" are called
                self.shouldBehaveAsBlockingControl() && self.notifyBlockPage();
            };
            var handleCollapsibleClosed = function(e){
                self.collapsibleClosedInUiState(self.collapsibleId);
                self.saveToPageState("collapsible_"+self.collapsibleId, false);

                //notify the page the collapsible no longer "blocks" the page.
                Capriza.Views.UiControl.prototype.unblockPage.apply(self);
            };

            if (this.model.get("collapsibleOpen") || this.isCollapsibleStateOpen(self.collapsibleId)) {
                if (!this.isCollapsibleStateClosed(self.collapsibleId)) {
                    this.collapsible.immediateOpen();
                    setTimeout(handleCollapsibleOpen,16);
                } else {
                    setTimeout(handleCollapsibleClosed,16);
                }
            }
            var collapsiblePageState = this.loadFromPageState("collapsible_"+ self.collapsibleId);
            if (collapsiblePageState !== undefined){
                if (collapsiblePageState) {
                    this.collapsible.immediateOpen();
                } else {
                    this.collapsible.immediateClose();
                }
            }

            this.on("collapsible/open", handleCollapsibleOpen);
            this.on("collapsible/close", handleCollapsibleClosed);

            Dispatcher.on('mobile/setCollapsiblesAsBlocking', function(setAsBlocking){
                if (self.collapsible.state == "open"){
                    if (setAsBlocking) self.notifyBlockPage();
                    else Capriza.Views.UiControl.prototype.unblockPage.apply(self);
                }
            });

            //This method is called from the page, when the page wants to close/clear "blocking" controls
            this.unblockPage = function () {
                if (self.shouldBehaveAsBlockingControl()) {
                    self.collapsible.immediateClose();
                }
            };
        },

        //if this will return true (override) the collapsible would behave like a "blocking" control (see Designer.js->navigateToControl)
        shouldBehaveAsBlockingControl: function(){
            return false;
        },

        //
        isCollapsibleStateOpen: function(collapsibleId) {
            var uiObj = this.getUiStateAndUniqueId(true);

            return uiObj.uiState && uiObj.uiState.openCollapsibles && uiObj.uiState.openCollapsibles.indexOf(collapsibleId) > -1;
        },
        isCollapsibleStateClosed: function(collapsibleId) {
            var uiObj = this.getUiStateAndUniqueId(true);

            return uiObj.uiState && uiObj.uiState.closedCollapsibles && uiObj.uiState.closedCollapsibles.indexOf(collapsibleId) > -1;
        },

        getUiStateAndUniqueId: function(checkUIState){
            var pageModel = this.options.page.model,
                uniqueId, uiState;
            if ((!checkUIState || pageModel.get("keepUiState")) && pageModel.get("uniqueId") !== undefined) {
                uniqueId = this.options.page.model.get("uniqueId");
                uiState = Capriza.Views.uiState["page" + uniqueId] || {};
            } else if (pageModel.tableDrill && (!checkUIState || pageModel.get("parentPage").get("keepUiState"))) {
                uniqueId = pageModel.get("parentPage").get("uniqueId");
                uiState = Capriza.Views.uiState["page" + uniqueId] || {};
            }
            return {'uniqueId' :uniqueId ,'uiState' : uiState };
        },

        collapsibleOpenInUiState: function(collapsibleId) {
            var uiObj = this.getUiStateAndUniqueId();

            if (!uiObj.uiState) return;
            if (uiObj.uiState.closedCollapsibles) {
                var indexClosed = uiObj.uiState.closedCollapsibles.indexOf(collapsibleId);
                uiObj.uiState.closedCollapsibles.splice(indexClosed,1);
            }
            if (!uiObj.uiState.openCollapsibles) {
                uiObj.uiState.openCollapsibles = [];
            }
            if (uiObj.uiState.openCollapsibles.indexOf(collapsibleId) == -1) {
                uiObj.uiState.openCollapsibles.push(collapsibleId);
            }

            Capriza.Views.uiState["page" + uiObj.uniqueId] = uiObj.uiState;
        },
        collapsibleClosedInUiState: function(collapsibleId) {
            var uiObj = this.getUiStateAndUniqueId();

            if (!uiObj.uiState) return;
            if (uiObj.uiState.openCollapsibles) {
                var indexOpen = uiObj.uiState.openCollapsibles.indexOf(collapsibleId);
                uiObj.uiState.openCollapsibles.splice(indexOpen,1);
            }
            if (!uiObj.uiState.closedCollapsibles) {
                uiObj.uiState.closedCollapsibles = [];
            }
            if (uiObj.uiState.closedCollapsibles.indexOf(collapsibleId) == -1) {
                uiObj.uiState.closedCollapsibles.push(collapsibleId);
            }
            Capriza.Views.uiState["page" + uiObj.uniqueId] = uiObj.uiState;
        },

        _destroy: function() {
            var panelHeader = this.model.get("groupHeader");
            if (panelHeader) {
                this.options.page.getViews([panelHeader])[0].destroy();
            }
            Capriza.Views.Group.prototype._destroy.apply(this, arguments);
        },

        addShowMore:Utils.noop,
        setYesMore:Utils.noop
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/ClickAction.js

try{
(function(){
    /**
     * ClickAction functionality is added in the group scope (Group.js -> addClickAction())
     */
    Capriza.Views.ClickAction = Capriza.Views.UiControl.extend({
        parentView: null, //should be overriden by the group control

        initialize: function(){
            _.bindAll(this, "_onClickAction", "_addClickAction", "_removeClickAction");
            if (this._initialize) this._initialize();
        },
        _render: function(){
            if (this.model.get("isDisabled") || this.model.get("missing")) return;
            Logger.debug("[ClickAction] adding click action for control: " + this.parentView.model.get("id"));
            this._addClickAction();
        },
        setMissing: function(){
            var missing = this.model.get("missing");
            if (missing) this._removeClickAction();
            else this._addClickAction();
        },
        setIsDisabled: function(){
            var isDisabled = this.model.get("isDisabled");
            if (isDisabled) this._removeClickAction();
            else this._addClickAction();
        },
        update: function(attributes){
            this._callSetters(attributes);
        },
        _destroy: function(){
            Logger.debug("[ClickAction] destroying (removing) click action for " + this.parentView.model.get("id"));
            this._removeClickAction();
        },
        _addClickAction: function(){
            this.parentView.$el.on("click", this._onClickAction)
                .addClass("clickable").attr("data-tap-mc", this.model.get("id"));
        },
        _removeClickAction: function(){
            this.parentView.$el.off("click", this._onClickAction)
                .removeClass("clickable").removeAttr("data-tap-mc");
        },
        _onClickAction: function (e){
            Logger.debug("[ClickAction] click action clicked!");
            e.stopPropagation();
            this.model.api.click();
        }

    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Carousel.js

try{
(function() {
    
    function getImageInView(view) {
        var controls = view.model.get("controls");
        return controls && controls.filter(function(child) {
            return child.get("type") === "image";
        })[0];
    }

    Capriza.Views.Carousel = Capriza.Views.Group.extend({
        aspectRatio: 0.5625, // 16:9
        
        _render: function() {
            var $rows = $(), 
                itemCount = this.itemCount = this.model.get("controls").length,
                aspectRatio = this.model.get("aspectRatio") || this.aspectRatio,
                itemWidth = this.itemWidth = $(".viewport").width(),
                totalWidth = this.totalWidth = (itemCount+2) * itemWidth,
                height = this.height = itemWidth * aspectRatio;

            Logger.debug("carousel items=" + $rows.length + ", totalWidth=" + totalWidth + ", itemWidth=" + itemWidth + ", height=" + height);

            this.startIndex = 0; // fix Carousel issue #17842 - update not called from drag widget, so onStart isn't called.

            var lastView = this.getItemView(itemCount - 1),
                $lastItem = lastView.render().addClass("carousel-item"),
                lastImage = getImageInView(lastView),
                $lastItemClone = $lastItem.clone(true),
                firstView = this.getItemView(0),
                $firstItem = firstView.render().addClass("carousel-item"),
                firstImage = getImageInView(firstView),
                $firstItemClone = $firstItem.clone(true);
            
            $rows = $rows.add($lastItem);
            $rows = $rows.add($firstItem);
            
            firstImage.on("change:src", function(model, src) {
                $firstItemClone.find("img").attr("src", src);
            });
            
            lastImage.on("change:src", function(model, src) {
                $lastItemClone.find("img").attr("src", src);
            });
            
            for (var i=1, ii=itemCount-1; i<ii; i++) {
                $rows = $rows.add(this.getItemView(i).render().addClass("carousel-item"));
            }

            $rows = $rows.add($lastItemClone).add($firstItemClone);
            
            this.$el.addClass("carousel").attr("id", this.getUniqueControlId() || "").on("contextmenu", function() { return false; });

            $rows.css({
                "flex-basis": itemWidth,
                "-webkit-flex-basis": itemWidth,
                "height": height,
                opacity: 0
            });
            
            this.$innerContainer.append($rows).css({
                width: totalWidth
            }).drag({
                onStart: this.onStart.bind(this),
                dragCallback: this.dragCallback.bind(this),
                onCancel: this.onCancel.bind(this),
                threshold: 0.2,
                swipeRight: this.swipeRight.bind(this),
                swipeLeft: this.swipeLeft.bind(this)
            });
            
            $("img", this.$innerContainer).each(function() {
                var $item = $(this).closest(".carousel-item");
                this.addEventListener("load", function() {
                    $item.css("opacity", 1);
                }, true);
            });
            
            this.initProgress();
            
            this.showItem(0);

            return this.$el;
        },
        
        getItemView: function(index) {
            return this.options.page.getView(this.model.get("controls")[index].get("controls")[0].get("id"));
        },
        
        initInnerContainer: function() {
            return $("<div class='items'>").appendTo(this.$el);
        },
        
        initProgress: function() {
            var progressHTML = "<div class='progress'>";
            for (var i=0 , ii=this.model.get("controls").length; i<ii; i++) {
                progressHTML += "<div class='dot'></div>";
            }
            progressHTML += "</div>";
            this.$progress = $(progressHTML).appendTo(this.$el);
        },

        showItem: function(index, transition) {
            function moveCallback() {
                self.transitioning = false;
                if (index === - 1 || index === self.itemCount) {
                    self._switchItem(index === -1);
                }
            }
            
            Logger.debug("carousel showItem index=" + index + ", transition=" + transition);
            
            var x = -this.itemWidth * (index + 1), 
                self = this,
                dotIndex = (index + this.itemCount) % this.itemCount + 1;
            
            this._move(x, transition, moveCallback);
            
            $(".dot", this.$progress).removeClass("active");
            $(".dot:nth-child(" + dotIndex + ")", this.$progress).addClass("active");
        },
        
        _switchItem: function(toLast) {
            var newX;
            if (toLast) newX = -this.itemWidth * this.itemCount;
            else newX = -this.itemWidth;
            Logger.debug("carousel switching to " + (toLast ? "last" : "first") + " item: newX=" + newX);
            this._move(newX);
        },

        onStart: function() {
            Logger.debug("on start", arguments);
            this.startIndex = this.currIndex();
        },

        dragCallback: function(step, transformProp) {
//            Logger.debug("drag callback: curX=" + step.curX + ", direction=" + step.direction + ", isStarted=" + step.isStarted + ", swiping=" + step.swiping + ", toSet=" + step.toSet + ",offsetX=" + this.offsetX + ", transition=" + this.$innerContainer.css("transition"));
            
            if (this.transitioning) return;
            if (step.toSet >= 0 && step.direction === 'right') return;
            if (step.toSet <= (this.itemWidth - this.totalWidth) && step.direction === 'left') return;

            this._move(step.toSet);
        },

        onCancel: function(curItemX) {
            Logger.debug("on cancel, curItemX=" + curItemX);
            this.showItem(this.currIndex(), true);
        },

        swipeRight: function() {
            if (this.transitioning) return;
            var toIndex = this.startIndex + 1;
            Logger.debug("swipe right to index: " + toIndex);
            if (toIndex > this.itemCount) return;
            this.showItem(toIndex, true);
        },

        swipeLeft: function() {
            if (this.transitioning) return;
            var toIndex = this.startIndex - 1;
            Logger.debug("swipe left to index: " + toIndex);
            if (toIndex < -1) return;
            this.showItem(toIndex, true);
        },
        
        currIndex: function() {
            var result = Math.floor(-this.offsetX / this.itemWidth) - 1; // minus 1 is because cyclic
//            Logger.debug("currIndex: offsetX=" + this.offsetX + ", itemWidth=" + this.itemWidth + ", result=" + result);
            return result;
        },

        _move: function(x, transition, onTransitionEnd) {
//            Logger.debug("carousel move: x=" + x + ", transition=" + transition);
            var cssObj = {};
            cssObj[$.capriza.transformProperty] = "translate3d(" + x + "px, 0, 0)";
            if (transition) {
                this.transitioning = true;
                this.$innerContainer.transition(cssObj, onTransitionEnd);
            } else {
                this.$innerContainer.css(cssObj);
            }
            this.offsetX = x;
        },
        
        addPaginator: $.noop,
        addShowMore : $.noop,
        setYesMore  : $.noop
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Chart.js

try{
;(function() {
    Capriza.Views.Chart = Capriza.Views.UiControl.extend({
        // common chart methods

        _loadD3: function() {
            function loadScript(src) {
                console.log("request to load " + src);
                return new Promise(function (resolve, reject) {
                    var id = /.*\/(.+)$/.exec(src)[1]; // strip out leading path and extract only name of script (without path)

                    if (document.querySelector("#" + id + "[ready='true']")) {
                        return resolve();
                    }

                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.onload = function(event) {
                        script.setAttribute("ready","true");
                        console.log(src + ' loaded and marked!');
                        clearTimeout(didNotLoadId);
                        resolve();
                    };
                    var didNotLoadId = setTimeout(function() {
                        reject("Script was not loaded");
                    }, 5000);
                    script.type = 'text/javascript';
                    script.id = id;
                    script.src = (Capriza.baseUrl ? (Capriza.baseUrl + "/") : "") + src;
                    head.appendChild(script);
                });
            }

            // return new PromisePromise.all([
            return loadScript("vendor/d3/d3.mobile.min.js").then(function() {
                return loadScript("vendor/d3/d3-transform.js")
            }).then(function() {
                return loadScript("vendor/d3/jquery.d3widgets.js")
            });
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Gauge.js

try{
;
(function() {
    var format = function (template){
        var args = Array.prototype.slice.call(arguments, 1);
        return template.replace(/\{\{|\}\}|\{(\d+)\}/g, function (curlyBrack, index) {
            return ((curlyBrack == "{{") ? "{" : ((curlyBrack == "}}") ? "}" : args[index]));
        });
    };

    Capriza.Views.Gauge = Capriza.Views.Chart.extend({
        className : "gauge",

        _render: function () {
            var self = this;
            console.log("Gauge: _render called");

            this.$el.attr("id", this.getUniqueControlId());

            self._loadD3().then(function() {
                self.$el.append("");
                self.setValues(self.model.get("values"));
            });

            return this.$el;
        },

        setValues: function (values) {
            var self = this;

            var notReadyElement = "<p class='not-available'>Org summary not ready</p>",
                failedParsingElement = "<p class='not-available'>Failed to parse orgSummary</p>";

            console.log("*************  PAYLOAD " + values);
            try {
                if (!Array.isArray(values)) {
                    console.log("payload provided to gauge chart is not a proper array");
                    return;
                }

                var value = values.length ? values[0] : 0;

                $("svg, .not-available", self.$el).remove();

                var width = this.model.get("chartWidth") || self.$el.width(),
                    height = this.model.get("chartHeight") || 200;

                var options = {}; // potentially pass configurable options

                // self.$el.css({height: height, width: width});

                self.$el.coolGauges({
                    type: "wiperGauge",
                    options: $.extend(true, {
                        value: value, // default value in terms of range
                        height: height,
                        width: width,
                        pieAngle: 160,
                        rFactor: 0.7,
                        range: {
                            from: 0,
                            to: 1
                        },
                        fillColors: [{offset: "0", color: "rgb(30,160,180)"},{offset: "1", color: "rgb(36,196,155)"}],
                        backgroundColor: "lightgrey",
                        hand: {
                            color: "grey", // color of needle
                            baseRadius: 7, // radius of needle base
                            width: 3       // needle stroke
                        },
                        margin: {left: 10, top: 10, right: 10, bottom: 30}
                    }, options)
                });

                return self.$el;
            }
            catch(e) {
                $("svg, .not-available", self.$el).remove();
                self.$el.append(failedParsingElement);
            }

            return self.$el;
        }

    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Series.js

try{
;
(function() {
    var format = function (template){
        var args = Array.prototype.slice.call(arguments, 1);
        return template.replace(/\{\{|\}\}|\{(\d+)\}/g, function (curlyBrack, index) {
            return ((curlyBrack == "{{") ? "{" : ((curlyBrack == "}}") ? "}" : args[index]));
        });
    };

    Capriza.Views.Series = Capriza.Views.Chart.extend({
        className : "series",

        _render: function () {
            var self = this;
            console.log("Series: _render called");

            this.$el.attr("id", this.getUniqueControlId());

            self._loadD3().then(function() {
                self.$el.append("");
                self.setValues(self.model.get("values"));
            });

            return this.$el;
        },

        setValues: function (values) {
            var chartOptions,
                self = this;

            var notReadyElement = "<p class='not-available'>Org summary not ready</p>",
                failedParsingElement = "<p class='not-available'>Failed to parse orgSummary</p>";

            console.log("*************  PAYLOAD " + values);
            try {
                var tooltipFormat = self.model.get("tooltip") || "<div>Label: {LABEL}</div><div>Value: {VALUE}</div>";
                tooltipFormat = tooltipFormat.replace(/{LABEL}/g, "{0}").replace(/{VALUE}/g, "{1}");

                if (!Array.isArray(values)) {
                    console.log("payload provided to series chart is not a proper array");
                    return;
                }

                $("svg, .not-available", self.$el).remove();

                var width = this.model.get("chartWidth") || self.$el.width(),
                    height = this.model.get("chartHeight") || 200;

                var options = {}; // potentially pass configurable options

                self.$el.coolGauges({
                    type: "barChart",
                    options: $.extend(true, {
                        values: values,
                        height: height,
                        width: width,
                        gapFactor: 0.3,
                        barColor: [{offset: 0, color: "#52A4FF"}, {offset: 100, color: "#3F91EB"}],
                        margin: {left: 10, top: 1, right: 10, bottom: 1},
                        showZeros: true,
                        enterDuration: 400,
                        tooltip: {
                            formatter: function(d) {
                                // if label is number that represent unix time before 10 years and up to 10 years from now then format as date
                                var label = d.label;
                                if (typeof label == "number" && label > 1151559129707 && label < 1782711141010) {
                                    label = moment(d.label).format("MMM DD YYYY");
                                }
                                return format(tooltipFormat, label, d.x);
                            }
                        }
                    }, options)
                });

                return self.$el;
            }
            catch(e) {
                $("svg, .not-available", self.$el).remove();
                self.$el.append(failedParsingElement);
            }

            return self.$el;
        }


    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Pie.js

try{
;
(function() {
    var format = function (template){
        var args = Array.prototype.slice.call(arguments, 1);
        return template.replace(/\{\{|\}\}|\{(\d+)\}/g, function (curlyBrack, index) {
            return ((curlyBrack == "{{") ? "{" : ((curlyBrack == "}}") ? "}" : args[index]));
        });
    };

    Capriza.Views.Pie = Capriza.Views.Chart.extend({
        className : "pie",

        _render: function () {
            var self = this;
            console.log("Pie: _render called");

            this.$el.attr("id", this.getUniqueControlId());

            self._loadD3().then(function() {
                self.$el.append("");
                self.setValues(self.model.get("values"));
            });

            return this.$el;
        },

        setValues: function (values) {
            var self = this;

            var failedParsingElement = "<p class='not-available'>Failed to parse data</p>";

            console.log("*************  PAYLOAD " + values);
            try {
                var tooltipFormat = self.model.get("tooltip") || "<div>Label: {LABEL}</div><div>Value: {VALUE}</div>";
                tooltipFormat = tooltipFormat.replace(/{LABEL}/g, "{0}").replace(/{VALUE}/g, "{1}");

                if (!Array.isArray(values)) {
                    console.log("payload provided to pie chart is not a proper array");
                    return;
                }

                $("svg, .not-available", self.$el).remove();

                var width = this.model.get("chartWidth") || self.$el.width(),
                    height = this.model.get("chartHeight") || 200,
                    pieWidthRatio = this.model.get("pieWidthRatio") || 0.2,
                    fixedTooltips = this.model.get("fixedTooltips") !== undefined ? this.model.get("fixedTooltips") : true;

                var options = {}; // potentially pass configurable options

                self.$el.coolGauges({type: "donutPie", options: {
                    values: values,
                    height: height,
                    width: width,
                    strokePercentParam: pieWidthRatio,
                    labelRadiusFactor: 1.0,
                    margin: {left: 30, top: 20, right: 30, bottom: 20},
                    tooltip: {
                        fixed: fixedTooltips,
                        formatter: function(d) {
                            var label = d.label;
                            if (typeof label == "number" && label > 1151559129707 && label < 1782711141010) {
                                label = moment(d.label).format("MMM DD YYYY");
                            }
                            return format(tooltipFormat, label, d.x);
                        }
                    }
                }});

                return self.$el;
            }
            catch(e) {
                $("svg, .not-available", self.$el).remove();
                self.$el.append(failedParsingElement);
            }

            return self.$el;
        }

    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/notifications.js

try{
/**
 * Created with JetBrains WebStorm.
 * User: oriharel
 * Date: 9/30/13
 * Time: 9:09 AM
 * To change this template use File | Settings | File Templates.
 */
(function () {

    Dispatcher.on("notifications/show", function($headerView, notifListId) {

        function showNotifications(notifListId) {
            var notifList = Capriza.Model.ControlDB[notifListId];
            if (notifList.get("controls").length > 0) {
                showIcon(notifList, $headerView);
                if (notifList.get("expanded")) onNotifClick();
            }
        };

        Dispatcher.on('header/errors/show', function(notifListId){
            showNotifications(notifListId);
        });

        Dispatcher.on('header/errors/remove', function(){
            var iconDiv = $('.notif-wrap');
            iconDiv.addClass('faded-out'); // same as in showIcon()
            iconDiv.off('mousedown touchstart');
            $('header').removeClass('has-notif');
            $('.notif-div').remove();

            Dispatcher.trigger('unblockUI');
        });

        var notWrap = $('<div class="notif-wrap faded-out active"><div class="notif-icon"><div class="notif-sever"></div><div class="notif-sever-text"></div></div></div>');
        $headerView.append(notWrap);
        showNotifications(notifListId);

    });

    function registerToEvents($headerView) {
        var eventTrigger = Capriza.device.stock || Capriza.device.ios ? 'touchend' : 'mousedown';

        $(".notif-wrap", $headerView).off(eventTrigger).on(eventTrigger, onNotifClick);
    }

    function onNotifClick() {
        Dispatcher.trigger('blockUI', {
                onBlockUI: function(){
                    var $notifDiv = $('.notif-div');
                    $notifDiv.css('display', 'block');
                    $notifDiv.removeClass('hide').addClass('show');
                    $('.notif-icon').data('shown', true);
                    $('.notif-sever-text').text('X');
                },

                onUnblockUI: function(event) {
                    if (event) {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (notificationIsShown()) {
                        $('.notif-div').removeClass('bounce').addClass('bounce-back');
                        var notifIcon = $('.notif-icon');
                        notifIcon.data('shown', false);
                        $('.notif-sever-text').text(notifIcon.data('numOfNotifs'));
                    }
                },

                isUnblockOK: function() { return !$('.notif-div').hasClass('show'); }
            }
        );
    }

    function getNotifIcon(notifSeverity) {
        switch(notifSeverity) {
            case "ERROR": return "fa-exclamation-circle";
            case "WARNING": return "fa-exclamation-triangle";
            case "INFO": return "fa-info-circle";
            default: return "fa-info-circle";
        }
    }

    function getNotifsModel(notifs) {

        var notifsArray = [], errorsCounts = 0, warningsCount = 0, infoCount = 0, worstNotif = "INFO";
        var errorsText = '', warningText = '', infoText = '', firstDelim = '', secondDelim = '', multiple = "is";
        for (var i = 0; i < notifs.length; i++) {
            var notif = notifs[i].get('controls')[0];

            switch(notif.get('severity')) {
                case "ERROR": {
                    notifIcon = "icon-exclamation-sign";
                    errorsCounts++;
                    worstNotif = "ERROR";
                    errorsText = errorsCounts + ' error';
                    if (errorsCounts > 1) {
                        errorsText += 's';
                    }
                    break;
                }
                case "WARNING": {
                    notifIcon = "icon-warning-sign";
                    warningsCount++;
                    if (worstNotif != 'ERROR') {
                        worstNotif = "WARNING";
                    }
                    warningText = warningsCount + ' warning';
                    if (warningsCount > 1) {
                        warningText += 's';
                    }
                    break;
                }
                case "INFO": {
                    notifIcon = "icon-info-sign";
                    infoCount++;
                    infoText = infoCount + ' info';
                    if (infoCount > 1) {
                        infoText += 's';
                    }
                    break
                }
                default: {
                    notifIcon = "icon-info-sign";
                    infoCount++;
                    infoText = infoCount + ' info';
                    if (infoCount > 1) {
                        infoText += 's';
                    }
                    break;
                }
            }

            notifsArray.push({notifIcon: getNotifIcon(notif.get('severity')), notifText: notif.get('text')});


        }



        if (errorsCounts > 1) {
            multiple = 'are';
        }

        if (errorsCounts == 0 && warningsCount > 1) {
            multiple = 'are';
        }

        if (errorsCounts == 0 && warningsCount == 0 && infoCount > 1) {
            multiple = 'are';
        }

        var title = 'There '+multiple+' '+errorsText+' '+warningText+' '+infoText+' in this page';

        return {notifsArray: notifsArray, notifTitle: title, worstNotif: worstNotif};

    }

    function showIcon(notifList, $headerView) {

        var notifs = notifList.get('controls');
        registerToEvents($headerView);
        $('.notif-sever-text', $headerView).text(notifs.length);
        $('.notif-icon', $headerView).data('numOfNotifs', notifs.length);
        var $viewport = $('.viewport');

        var notifsModel = getNotifsModel(notifs);

        var notifSeverEl = $('.notif-sever', $headerView);

        switch(notifsModel.worstNotif) {
            case "ERROR": {
                notifSeverEl.css('border', '1px solid red');
                break;
            }
            case "WARNING": {
                notifSeverEl.css('border', '1px solid yellow');
                break;
            }
            case "INFO": {
                notifSeverEl.css('border', '1px solid green');
                break
            }
            default: {
                notifSeverEl.css('border', '1px solid green');
                break;
            }
        }


        var $notifDiv = $('.notif-div');
        if ($notifDiv.length < 1) {
            $notifDiv = $(Handlebars.templates["notifications"](notifsModel));
            $viewport.append($notifDiv);
        }

        var $notifListEl = $('.notif-list');

        $notifListEl.empty();

        notifsModel.notifsArray.forEach(function(notif) {
            $notifListEl.append($('<li class="notif-list-item"><i class="fa '+notif.notifIcon+'"></i><div class="list-item-text">'+notif.notifText+'</div></li>'))
        });

        $('.notif-title').text(notifsModel.notifTitle);

        $notifDiv.css('pointer-events', 'auto');
        $notifDiv.bind('animationend webkitAnimationEnd MSAnimationEnd oAnimationEnd', function(e) {

            if (e.originalEvent.animationName === 'slideDown') {
                $notifDiv.css('z-index', 8);
                $(this).removeClass('show').addClass('bounce');
            }

            if (e.originalEvent.animationName === 'bouncedown') {
                $notifDiv.css('z-index', 5);
                $(this).removeClass('bounce-back').addClass('hide');
            }
            if (e.originalEvent.animationName === 'slideUp') {
                $(this).css('display', 'none');
            }

        });

        $('.notif-wrap', $headerView).removeClass('faded-out');
        $headerView.addClass('has-notif');
    }

    function notificationIsShown() {
        return $('.notif-icon').data('shown');
    }

    Capriza.Views.NotificationsClass = Capriza.Views.UiControl.extend({

        removeFromPage: function() {
            Dispatcher.trigger("header/errors/remove");
        },

        addToPage: function() {
            Dispatcher.trigger("header/errors/show", this.model.get('id'));
        },

        replaceWith: function(otherView) {
            Dispatcher.trigger("header/errors/show", otherView.model.get('id'));
        },

        existsInDOM: function() {
            return $(".notif-wrap").hasClass("active");
        },

        setControls: function() {
            Dispatcher.trigger("header/errors/show", this.model.get('id'));
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Tabs.js

try{
;(function() {

    var testElement = document.createElement('div');

    var transformPrefix = "transform" in testElement.style ? "transform" : "webkitTransform";
    var transformProperty = transformPrefix === "webkitTransform" ? "-webkit-transform" : "transform";

    // Handles keyboard events for left arrow, right arrow, Home and End, and
    // simulates a click on corresponding tab header
    function tabKeyDown(event) {
        var tabHeaders = event.target.children;
        var indexMax = tabHeaders.length - 1;
        var currentIndex = $(">.active", event.target).index();

        var keyIndexMap = {37: function () {return (currentIndex - 1)},
            39: function () {return (currentIndex + 1)},
            36: function () {return 0}, 35: function () {return indexMax}};

        // get handler by key code, calculate new tab index and simulate click
        var handler = keyIndexMap[event.which];

        if (handler) {
            var i = Math.min(Math.max(0, handler()), indexMax);

            tabHeaders[i].click();
        }
    }

    Capriza.Views.TabController = Capriza.Views.Group.extend({

        initialize: function() {
            Capriza.Views.Group.prototype.initialize.apply(this, arguments);

            var self = this;

            // NOTE: excluding the designer here because a 'resize' event is triggered only when in the designer, from currentSelectedTabScrollPosition method.
            // From some reason, asking the $tabContent element for scrollTop triggers 'resize' which in turn creates an exception in the designer.
            // For reference: ticket #13689
            // EDIT: currentSelectedTabScrollPosition was removed, so without these lines this issue would be triggered from $.capriza.currentScrollPosition
            if (!window.isDesignerPreview && !window.designerLoaded) {
                $(window).on("orientationchange resize", function (e) {

                    var activeTab = self.$(".tab-content.active"),
                        curIndex = self.$(".tab-content").index(activeTab);
                    activeTab.removeClass('active');

                    var tabId = activeTab.attr("data-mc");
                    Logger.debug("Switch to tab " + tabId  + " due to resize");
                    self.setSelectedTab(tabId);
                });
            }

            Dispatcher.on('control/action/end', function(control) {
                var switchTab = control.model.get("switchTab");
                if (switchTab) {
                    Logger.debug("Switch to tab " + switchTab  + " due to clicking on " + control.model.get("id"));
                    setTimeout(function() { self.showTab(-1,switchTab, null, "control-action"); },300);
                }
            }, this);

            Dispatcher.on('textBox/inputFocused', function(control) {
                //get active tab, get visible tab
                var $currentTab = control.$el.closest(".tab-content"),
                  $activeTab = self.$tabsContainer.find(".active");
                if ($activeTab.length && $currentTab.length && $activeTab[0] !== $currentTab[0]){
                    self.$el[0].scrollLeft = 0;
                    var tabId = $currentTab.attr("data-mc");
                    Logger.debug("Switch to tab " + tabId  + " due to scroll into view of TextBox " + control.model.get("id"));
                    self.setSelectedTab(tabId);
                }
            });
        },

        _render: function(){

            this.$el.addClass("tab-controller");

            this.$headersContainer = $("<div class='tabs-headers' tabindex='0'></div>");

            if (Capriza.device.isDesktop) {
                this.$headersContainer.keydown(tabKeyDown);
                this.$headersContainer.blur(focusLost);
            }

            if (Capriza.device.isMobile && Capriza.device.ios && Capriza.device.iosVersionNumber() < 8) {
                this.$headersContainer.on("touchstart", function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                });

                this.options.page.$el.addClass('no-overflow-scroll');
            }

		    this.$el.append(this.$headersContainer);

            this.$tabsContainer = $('<div class="tabs-container"></div>');
            this.$selectedIndicator = $("<div class='selected_tab selected_tab_above'></div>");
            this.$el.append(this.$tabsContainer);


            var pctg = this.model.get('controls').length*100;
            this.$tabsContainer.css('width', pctg+'%');
		    _.each(this.model.get("controls"), this.addTabAndControls, this);

            var appendMethod = this.model.get('tabPosition') === 'bottom' ? 'prepend' : 'append';

            this.$headersContainer.children()[appendMethod](this.$selectedIndicator);
            this.$selectedIndicator = $('.selected_tab', this.$headersContainer).first();
            this.$selectedIndicator.addClass('active');

            var iconsAbove = (this.model.get("iconsPosition") == "above");
		    this.$el.toggleClass("icon-above", iconsAbove).attr("id", this.getUniqueControlId() || "");

            if (!Capriza.isRTL) {

                if (Capriza.device.stock) {
                    this.initOldSwipe();
                }
                else {
                    this.initSwipe();
                }
            }

            this.setTabPosition();

            $(".tab-content", this.$el).eq(0).addClass("active");
            $(".tab-header", this.$el).eq(0).addClass("active");

            //Todo: Remove this when there is top header section animation for all casses
            var controllerIndex = this.model.parent &&
                this.model.parent.parent &&
                this.model.parent.parent.get("controls").indexOf(this.model.parent);

            if (this.model.get('tabPosition') === 'top' && Capriza.device.isMobile && controllerIndex == 1) {
                this.setHeadersAnimation();
            }

            this.setHeadersShadow(this.$headersContainer);

            var debounceScrollEnd = _.debounce(function(){
                self.changeDisableSwipe(false);
        }, 150, false);

        var debounceInteractions = Utils.debounce(150, function (e) {
            try {
                self.reportInteraction({
                    element: "Tabs",
                    interaction: "scrollTop",
                    controlPath: "#" + e.target.id,
                    param: e.target.scrollTop
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Tabs scroll interaction");
            }
        });
        this.$('.tab-content').scroll(function(e) {
        debounceInteractions(e);
        self.changeDisableSwipe(true);
        debounceScrollEnd();
    });

    var self = this;
    if (Capriza.device.stock) {
        setTimeout(function () {
            var $groupingContainer = self.$el.parent('.grouping');
            var tabWidth = 1 / self.model.get('controls').length * 100;
            $(".tab-content", self.$el).css('width', tabWidth + '%');
            $groupingContainer.css('overflow-y', 'hidden');
        }, 0);
    }

    if (Capriza.device.chromeWebView || Capriza.device.crosswalk) {
        $('.tab-content', this.$el).css('z-index', 1);
    }


    return this.$el;
},

    setHeadersShadow: function($headersContainer) {

    //if ($tabContent.children().length && $tabContent.children()[0].getBoundingClientRect().top < $headersContainer[0].getBoundingClientRect().bottom) {
    $headersContainer.addClass("scroll-shadow");
    //}
    //else {
    //    $headersContainer.removeClass("scroll-shadow");
    //}

        },

        setHeadersAnimation: function() {
            var previousScroll = 0, upFired, downFired = true, self = this, inBounce, tick={}, tolerance = 5;

            var endScrollDebounce = _.debounce(function(){
                updateHeader.apply(this);
            }, 100);

            var updateHeader =  function(){
                var currentScroll = $(this).scrollTop(), direction;

                if (!inBounce && Math.abs(currentScroll - previousScroll) > tolerance)
                {
                    if (currentScroll > previousScroll){
                        direction = 'up';
                    } else if (currentScroll < previousScroll){
                        direction = 'down';
                    }
                }
                previousScroll = currentScroll;
                inBounce = $(this).scrollTop() < 40 || $(this).scrollTop() + $(this).innerHeight() > this.scrollHeight - 40;

                if (direction === 'up' && !upFired) {
                    self.animateHeader(true, tick);
                    upFired = true;
                    downFired = false;
                }
                else if ((currentScroll < 10 && !downFired && !tick.ticking) || (direction === 'down' && !downFired)){
                    self.animateHeader(false, tick);
                    downFired = true;
                    upFired = false;
                }
                else {
                    tick.ticking = false;
                }
            };

            this.$('.tab-content').scroll(function(e){
                endScrollDebounce.apply(this);
                if (!tick.ticking){
                    tick.ticking = true;
                    updateHeader.apply(this);
                }
            });
        },

        // handle header animation. isUp will move the header up.
        animateHeader: function(isUp, tick) {
            var y = isUp ? "-100%" : "0";
            this.$headersContainer.transition({"y": y},function(){
                if (tick) {
                    tick.ticking = false;
                }
            });
        },

        positionSelectedIndicator: function(duration) {
            var firstHeaderX = $('.tab-header', this.$el).first().position().left;
            this.$selectedIndicator.transition({'x': $('.tab-header.active', this.$el).position().left-firstHeaderX , duration: duration});
        },

        initOldSwipe: function() {
            var self = this;
            var swipeRight = function() {
                var index = self.getIndexOfActiveTab();
                var targetIndex = index+1;
                var id = self.getIdOfTabByIndex(targetIndex);
                if (targetIndex < self.model.get('controls').length) {
                    self.showTab(targetIndex, id, null, "swipe");
                }


            };

            var swipeLeft = function() {
                var index = self.getIndexOfActiveTab();
                var targetIndex = index-1;
                var id = self.getIdOfTabByIndex(targetIndex);
                if (targetIndex > -1) {
                    self.showTab(targetIndex, id, null, "swipe");
                }

            };

            this.$el.swipe({swipeRight : swipeRight, swipeLeft : swipeLeft});
            this.$el.data('swipe', true);
        },

        initSwipe: function() {
            var self = this, extraRatio, canGoLeft, canGoRight, noDrag, elRect;
            var swipeRight = function(element, velocity) {
                var index = self.getIndexOfActiveTab();
                var id = self.getIdOfTabByIndex(index+1);
                if (index+1 < self.model.get("controls").length) self.showTab(index+1, id, velocity, "swipe");

            };

            var swipeLeft = function(element, velocity) {
                var index = self.getIndexOfActiveTab();
                var id = self.getIdOfTabByIndex(index-1);
                if (index-1 >= 0) self.showTab(index-1, id, velocity, "swipe");
            };

            var onStart = function() {
                self.animateHeader(false);
                var tabsRect = self.$tabsContainer[0].getBoundingClientRect();
                elRect = self.$el[0].getBoundingClientRect();
                extraRatio = self.$selectedIndicator && (self.$selectedIndicator.width() / elRect.width);
                canGoRight = tabsRect.left < elRect.left;
                canGoLeft = elRect.width && tabsRect.right > elRect.right;
                noDrag = self.$tabsContainer.hasClass('swiping');
            };

            var dragCallback = function(step, transformProperty) {

                if (noDrag) return;
                if (self.$tabsContainer.hasClass('swiping')) return;
                if ((step.direction === 'left' && canGoLeft) || (step.direction === 'right' && canGoRight)) {
                    var toSet = step.toSet - elRect.left;
                    self.$tabsContainer[0].style[transformProperty] = 'translate3d('+toSet+'px, 0, 0)';

                    var oppoToSet = toSet*-extraRatio;
                    self.$selectedIndicator[0].style[transformProperty] = 'translate3d('+oppoToSet+'px, 0, 0)';
                }
            };

            var onCancel = function(xMoved) {
                self.changeDisableSwipe(true);
                self.$tabsContainer.addClass('swiping');
                var index = self.getIndexOfActiveTab();
                xMoved = (index * -1 * self.$el.width());
                self.$tabsContainer.transition({ x: xMoved +'px' });
                var oppoToSet = xMoved*-extraRatio;
                self.$selectedIndicator.transition({ x: oppoToSet+'px' }, function() {
                    self.changeDisableSwipe(false);
                    self.$tabsContainer.removeClass('swiping');
                });
            };

            var isSwipeDisable = function(){
                return self.disableSwipe;
            };

            this.$tabsContainer.drag({swipeRight : swipeRight,
                swipeLeft : swipeLeft,
                threshold: 0.5,
                dragCallback: dragCallback,
                onCancel: onCancel,
                onStart: onStart,
                isSwipeDisable: isSwipeDisable});
            this.$el.data('swipe', true);
        },

        changeDisableSwipe: function(disable){
            this.disableSwipe = disable;
        },

        setTabPosition: function () {
            if (this.model.get("tabPosition") == "bottom") {
                this.$headersContainer.addClass('bottom');
            }
        },

        getIndexOfActiveTab: function() {
            var result;
            $('.tab-header', this.$el).each(function(index) {
               if ($(this).hasClass('active')) {
                   result = index;
               }
            });
            return result;
        },

        getIdOfTabByIndex: function(index) {
            var result;
            $('.tab-header', this.$el).each(function(i) {
                if (i === index) {
                    result = $(this).attr('id');
                }
            });
            return result;
        },

	    addTabAndControls: function(control, index) {
		    this.addControl(control);


		    var self = this, id = control.get("id"), headerDiv = $("<div class='header-div'></div>"),
		    header = $("<div class='tab-header'></div>").toggleClass("master-tab-header", control.get("isMasterTab") == "true").attr("id", "tab-header-" + id).data("tab-id", id),
		    name = control.get("key"), icon = control.get("icon");


            $.capriza.fastClick(header[0]);

			$(".tabs-headers", this.$el).append(header);
		    header.append(headerDiv.text(name).prepend($("<div class='header-icon'></div>").addClass(icon))).on("click", function(e) {
			    e.stopPropagation();
			    e.preventDefault();
                self.showTab(index, id, null, "header-click");
            });
	    },

	    addControl: function(control) {
            if(control.get("missing")) return;
		    var view = this.options.page.getView(control.get("id"));
		    this.$tabsContainer.append(view.render());
	    },

	    setSelectedTab: function(tabId) {
            var self = this;
		    if ($("#tab-header-" + tabId).length === 0 || !this.options.page.getView(tabId)) return;
		    $(".tab-header.active, .tab-content.active", self.$el).removeClass("active");
		    $("#tab-header-" + tabId, this.$el).addClass("active");
		    var tab = this.options.page.getView(tabId).$el;
		    tab.addClass("active");

            var index = this.getIndexFromTabId(tabId);
            var targetX = this.getTargetXPctg(index);


            this.$tabsContainer[0].style[transformProperty] = 'translate3d('+targetX+'%, 0, 0)';

            var indicatorTargetX = index*100;
            self.$selectedIndicator[0].style[transformProperty] = 'translate3d('+indicatorTargetX+'%, 0, 0)';

            Logger.debug("[Tabs] setSelectedTab: tabId=" + tabId + ", indicatorTargetX=" + indicatorTargetX);

            this.saveSelectedTabToUiState(tabId);
	    },

        saveSelectedTabToUiState: function(tabId) {
            // we don't currently have page split in drill page, so doing it this way is not an issue
            var uniqueId = this.options.page.model.get("uniqueId"),
                uiState = Capriza.Views.uiState["page" + uniqueId] || {};

            uiState.selectedTab = tabId;

            Capriza.Views.uiState["page" + uniqueId] = uiState;
        },

        getSelectedTabContent: function() {
            return $('.tab-content.active', this.$el);
        },

        getIndexFromTabId: function(tabId) {
            var tab = this.$("#page" + this.options.page.model.id + tabId);
            return this.$(".tab-content").index(tab);
        },

        getTargetXPxls: function(index) {
            if (index === 0) {
                return Capriza.isRTL ? $('.tab-content', this.$el).width() : 0;
            }
            var tabWidth = $('.tab-content', this.$el).width()*index;
            return Capriza.isRTL ? tabWidth : -tabWidth;
        },


        getTargetXPctg: function(index) {
            var totalTabs = this.model.get('controls').length;

            var targetX = index/totalTabs*100;

            if (targetX > 0) targetX *= -1;
            if (Capriza.isRTL) targetX *= -1;
            return targetX;
        },

        showTab: function(index, tabId, velocity, method) {

            if (index < 0) index = this.getIndexFromTabId(tabId);

	        var targetHeader = $(this.$(".tab-header")[index]),
                targetTab = $(this.$(".tab-content")[index]),
                activeHeader = this.$(".tab-header.active"),
	            activeTab = this.$(".tab-content.active"),
                curIndex = this.$(".tab-content").index(activeTab);

            if (curIndex === index) return;

            method = method || "";
            var targetX = this.getTargetXPxls(index);

            Dispatcher.trigger("pageView/tabChange", tabId);

	        activeHeader.removeClass("active");
	        targetHeader.addClass("active");

            activeTab.removeClass("active");
            targetTab.addClass("active");

            try {
                this.reportInteraction({
                    element: "Tabs",
                    interaction: "click",
                    tabIndex: index,
                    tabId: tabId,
                    fromIndex: curIndex,
                    controlPath: "#tab-header-" + tabId + " .header-div",
                    additionalData: "Show tab using "+method
                });
            } catch (e){
                Logger.info("[UserInteraction] Exception on report Tabs navigate to tab interaction");
            }
            if (!window.isDesignerPreview) {
                var self = this;
                this.$tabsContainer.addClass('swiping');
                self.changeDisableSwipe(true);
                var duration =  velocity > 1 ? ($.fx.speeds._default / (velocity/2)) : $.fx.speeds._default;
                this.$tabsContainer.transition({ x: targetX+'px', duration: duration}, function(){
                    self.changeDisableSwipe(false);
                    $(this).removeClass('swiping');
                });

                this.positionSelectedIndicator(duration);
            }
            else {
                this.setSelectedTab(tabId);
            }



            Logger.debug("[Tabs] showTab: index=" + index + ", tabId=" + tabId +", using: "+ method);

            var id = targetHeader.attr("id");
            if (id) this.saveSelectedTabToUiState(id.replace("tab-header-", ""));
        }
        ,
        addShowMore:Utils.noop,
        setYesMore:Utils.noop
    });

    // Finds elements to focus that are placed in active tab content
    function findFocusableInTab() {
        var result = $(":enabled, [tabindex]", $(".tab-content.active")).not(
            "[tabindex=-1]");

        return result;
    }

    // Finds elements to focus that are placed after the Tab View control
    function findFocusableAfterTabs() {
        var result =
            $(":enabled, [tabindex]", $(".dock-bottom")).not("[tabindex=-1]");

        return result;
    }

    // Checks if the focus goes to an element in inactive tab, and if so, tries
    // to find another element to focus. If another element not found, the focus
    // remains in the same element.
    function focusLost(event) {
        var $hiddenTab =
            $(event.relatedTarget).parents(".tab-content:not(.active)");

        if ($hiddenTab.length) {
            var $newFocus;

            // focus lost in tab headers - go into active tab or after tabs
            // focus lost in active tab - go to headers or after tabs
            if ($(this).is(".tabs-headers")) {
                $newFocus = findFocusableInTab();
                $newFocus.length || $newFocus.add(findFocusableAfterTabs());
            } else if ($.contains($(".tab-content.active")[0], this)) {
                $newFocus =
                    $hiddenTab.index() < $(".tab-content.active").index()
                    ? $(".tabs-headers") : findFocusableAfterTabs();
            }

            // focus the found element, or stay in the same element
            ($newFocus[0] || this).focus();
        }
    }

	Capriza.Views.Tab = Capriza.Views.Group.extend({
		_render: function(){
			_.each(this.model.get("controls"), this.addControl, this);
			this.$el.addClass("tab-content vertical-layout").attr("id", this.getUniqueControlId() || "");
            var self = this;
            if (Capriza.device.isMobile) {
                function fixContainerTop(tabsHeaderHeight){
                    Dispatcher.off("Tabs/scrolled", fixContainerTop);
                    if (self.model.parent.get('tabPosition') === 'top') {
                        if (tabsHeaderHeight) {
                            self.$el.css('padding-top', tabsHeaderHeight);
                        } else {
                            Logger.error("[Tabs] Header height is zero",null, null, " for "+ self.model.get("id"));
                        }
                    }
                }
                function fixHeaderPositions(){
                    self.$el.off("scroll",fixHeaderPositions);
                    var $headers = self.$el.parent().prev();
                    $headers.css("position", "absolute");
                    Dispatcher.trigger("Tabs/scrolled", $headers.height());

                }
                this.$el.on("scroll", fixHeaderPositions);
                Dispatcher.on("Tabs/scrolled", fixContainerTop);
            }

            if (Capriza.device.isDesktop) {
                $(":enabled, [tabindex]", this.$el).blur(focusLost);
            }
			return this.$el;
		},

        addShowMore:Utils.noop,
        setYesMore:Utils.noop,
        setKey:Utils.noop
	});

    Capriza.Views.ContextPage.prototype.currentSelectedTab = function() {
        var $selectedTab = this.$(".tab-header.active");
        return $selectedTab.length === 1 ? $selectedTab.data("tab-id") : undefined;
    };

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Bubble.js

try{
(function() {
    Capriza.Views.Bubble = Capriza.Views.ClientButton.extend({

        initialize: function() {
            var self = this;

            this.onPageChange = this.onPageChange.bind(this);

            this.bubbleView =  new Capriza.Views.BubbleContent({model: this.model.get("controls")[0], page:this.options.page, button : this.$el});
            self.options.page.addView(this.model.get("controls")[0].get('id'), this.bubbleView);
            this.bubbleView.on('bubble/show', function(view){

                //inherited from uiControl, notifies the page that this control now blocks the entire page,
                //until "unblockPage" or "hideBubble" are called
                self.notifyBlockPage();

               self.trigger('bubble/show', view);
            }).on('bubble/hide', function(view){

                //notify the page the bubble no longer blocks the page.
                Capriza.Views.UiControl.prototype.unblockPage.apply(self);

                self.trigger('bubble/hide', view);
            });
        },

        _render: function() {
            var self = this;
            this.$el = Capriza.Views.ClientButton.prototype._render.call(this);
            this.$el.on("click", function() {
                var bubbleView = self.options.page.getView(self.model.get('controls')[0].get('id'));
                bubbleView.toggleBubble();
            }).addClass("bubble").attr("id", this.getUniqueControlId());
            this.bubbleView.render();
            this.setSeverity(this.model.get('severity'));
            //
            Dispatcher.on("page/change/after/callbackEnded page/controlAdded/after", this.onPageChange);

            return this.$el;
        },

        onPageChange: function() {
            Dispatcher.off("page/change/after/callbackEnded page/controlAdded/after", this.onPageChange);
            //auto show bubble only in these cases:
            //1. expanded = true
            //2. in case of notification (severity), the name shouldn't be 0 (there are at least 1 notification).
            //3. the bubble is not empty (the bubble content has controls)
            if(this.model.get('expanded') && !(this.model.get("severity") && this.model.get("name") == 0) && this.model.get("controls")[0].get("controls").length > 0) {
                //var shouldOpenImmediately = self.model.get('expanded') && e.fromPage.length > 0;
                if(this.shouldExpand()) {
                    this.bubbleView.showBubble();
                }
            }
        },

        shouldExpand: function(){
            //auto show bubble only in these cases:
            //1. expanded = true
            //2. in case of notification (severity), the name shouldn't be 0 (there are at least 1 notification).
            //3. the bubble is not empty (the bubble content has controls)
            if (Capriza.isDesginerSnapShot) return;
            return this.model.get('expanded') && !(this.model.get("severity") && this.model.get("name") == 0) && this.model.get("controls")[0].get("controls").length > 0;
        },

        _destroy: function() {
            Dispatcher.off("page/change/after/callbackEnded", this.onPageChange);

            this.bubbleView._destroy();
        },

        replaceWith: function(otherView) {
            var newEl = otherView.render();
            this.$el.replaceWith(newEl);

            if (otherView.bubbleView) this.bubbleView.replaceWith(otherView.bubbleView);

        },

        setControls : function(controls) {
            this.bubbleView.setControls(controls);
        },

        update : function(attributes){
            Capriza.Views.UiControl.prototype.update.call(this, attributes);
            if(this.shouldExpand()) {
                this.bubbleView.showBubble();
            }
        },

        setSeverity : function(severity) {
            if(severity){
                this.$el.toggleClass("notif", true);

                this.$el.toggleClass("error-count", "ERROR" == severity );
                this.$el.toggleClass("warning-count", "WARNING" == severity );
                this.$el.toggleClass("info-count", "INFO" == severity || "NONE" == severity );

                if (this.model.get('name') !== "0") {
					this.setName('');
				}
                this.setIcon('icon-notifications-bell');
            }
        },

        setName : function(name) {
            if (this.model.get('severity')){
                if (!this.model.get('canBeEmpty')) {
                    this.$el.toggleClass("hidden", this.model.get('name') == 0);
                }
                this.$el.attr('data-counter', this.model.get('name'));
                Capriza.Views.ClientButton.prototype.setName.call(this, '');
                this.setIcon('icon-notifications-bell');
            } else {
              Capriza.Views.ClientButton.prototype.setName.call(this, name);
            }

            Dispatcher.trigger("bubble/name/change", this);
        },

        getView: function(control) {
            if(control.get('type') == 'panel'){
                return new Capriza.Views.BubbleContent({model: control, page:this.options.page, button : this.$el});
            }
            return Capriza.Views.createView(control, this.options.page);
        },

        //This method is called from the page, when the page wants to close/clear "blocking" controls
        unblockPage: function(){
            this.bubbleView.hideBubble();
        }
    });

    // Pressing Escape hides the bubble
    function onKeyDown(bubbleContent, event) {
        if (event.key == "Escape") {
            bubbleContent.hideBubble();

            function f() {
                $(".value", bubbleContent.options.button).focus();
            }

            setTimeout(f, 300);
        }
    }

    function getSizeInInt(fromString) {
        return fromString ? parseInt(fromString) : 0;
    }

    Capriza.Views.BubbleContent = Capriza.Views.Panel.extend({

        className : "panel",

        initialize: function() {
            this.rendered = false;
            var self = this;
            this.options.getViewByModel = this.options.getViewByModel || this.getViewByModel;
            this.shieldClick = this.shieldClick.bind(this);
            this.arrowDefaultHeight = 12;
            if(this.model.get("controls")) {
                _.each(this.model.get("controls"), function (control) {
                    self.options.page.addView(control.get("id"), Capriza.Views.createView(control, self.options.page));
                });
            }

            Dispatcher.on('miniBrowser/show bubbles/hide page/change/beforeTransition', function(){
                if(self.$wrapper.hasClass('active')) {
                    self.hideBubble();
                }
            }, this);

            Dispatcher.on('control/action/end', function(control) {
                if (control.model.get("closeBubble") && this.$wrapper.hasClass('active') && control.model.isInControl(this.model)) {
                    Logger.debug('Closing bubble due to clicking on ' + control.model.get("id"));
                    setTimeout(function() { self.hideBubble(); },300);
                }
            }, this);
            Dispatcher.on('page/controlModified/after', this.restoreState, this);
        },

        restoreState : function(data) {
            if (this.model.isInControl(data.model) && this.loadFromPageState("showBubble")) this.showBubble();
        },

        _render: function() {
            var self = this;
            if(!this.rendered) {

                this.$el = Capriza.Views.Panel.prototype._render.apply(this, arguments);
                this.$innerGroup.addClass('scrolling-area');
                this.rendered = true;
                this.$arrow = $("<div class='arrow-wrapper'></div>");
                this.$arrowBorder = $("<div class='arrow-border'></div>");
                this.$wrapper = $("<div id='bubble-wrapper' class='bubble-content'></div>");
                this.$wrapper.append(this.$arrow).append(this.$el).append(this.$arrowBorder);
                this.$shield = $("<div class='global-shield bubble'>").append(this.$wrapper);

                // Create the debounce function to be used on window resize;
                this.debounceUpdateBubblePosition = _.debounce(this.updateBubble.bind(this), 25);

                if (Capriza.device.ios){
                    this.$blocker = $('<div class="ios-prevent-propagation-scroll"></div>');
                    this.$blocker.off('click').on('click', self.shieldClick);
                    console.log("create scroll listner");

                    this.$blocker.off('scroll').on('scroll', function (e) {
                        e.preventDefault();
                        this.scrollTop = 2;

                    });

                    this.$blocker.append($('<div style="min-height: calc(100% + 3px)"></div>'));
                    this.$shield.prepend(this.$blocker);
                    this.$wrapper.prepend(this.$blocker.clone(true));
                }

                this.$wrapper.css('position', 'absolute');

                this.onScroll = function(){
                    self.hideBubble();
                };

                if (Capriza.device.isDesktop) {
                    this.$wrapper.on("keydown", function (event) {
                        onKeyDown(self, event);
                    });
                }
            }
            return this.$el;
        },

        setMcStyle : function()  {
            Capriza.Views.UiControl.prototype.setMcStyle.call(this);
            this.setArrowStyle();
        },

        setArrowStyle : function() {
            var color = this.$wrapper.css('background-color');
            var borderColor = this.$arrow.hasClass('arrow-down') ? this.$wrapper.css('border-bottom-color') : this.$wrapper.css('border-top-color');

            if(color){
                this.$arrow.css('border-bottom-color', color);
                this.$arrow.css('border-top-color', color);
            }

            if(borderColor) {
                this.$arrowBorder.css('border-bottom-color', borderColor);
                this.$arrowBorder.css('border-top-color', borderColor);
            }
        },

        _destroy: function() {
            // Use this to detect page rotate and fix bubble position and
            window.removeEventListener("resize", this.debounceUpdateBubblePosition);
            if(this.$wrapper.hasClass('active')){
                this.$wrapper.removeClass("active");
                this.$shield.remove();
                this.saveToPageState("showBubble", true);
                var $headerOverlay = $('#header-overlay');
                $headerOverlay.removeClass('bubble');
                if (!$headerOverlay.hasClass("side-menu")) {
                    $headerOverlay.off('click');
                    $headerOverlay.removeClass('active');
                }
            }
            Dispatcher.off('page/controlModified/after', this.restoreState, this);
            Capriza.Views.Panel.prototype._destroy.apply(this, arguments);
        },

        replaceWith: function(otherView) {
            var showBubble = otherView.model.get('expanded') || this.loadFromPageState("showBubble") ||
                this.$wrapper.hasClass('active') || this.active;
            var newEl = otherView.render();
            this.$el.replaceWith(newEl);
            this.$el = newEl;
            otherView.$wrapper.append(this.$el);
            this.$shield.replaceWith(otherView.$shield);
            if(showBubble){
                otherView.showBubble();
                this.saveToPageState("showBubble", false);
            }
        },

        toggleBubble : function() {
            // don't do anything if bubble is opening or closing
            if (this.$shield.hasClass("animating")) return;
            if(this.isBubbleOpen()){
                this.hideBubble();
            } else {
                this.showBubble();

            }
        },

        isBubbleOpen : function(){
            return this.$wrapper.hasClass('active') || this.active;
        },

        setStyleSets: function() {
            if(this.model.get("styleSetIds")) this.$wrapper.addClass('ss-' + this.model.get("styleSetIds").join(" ss-"));
        },


        updateBubble: function(){
            var $realButton = $('.value', this.options.button);
            if(!window.isDesignerPreview && !window.designerLoaded) {
                if ($realButton) {
                    if ($realButton[0].scrollIntoViewIfNeeded){
                        $realButton[0].scrollIntoViewIfNeeded()
                    } else {
                        $realButton[0].scrollIntoView();
                    }
                }
            }
            this.$wrapper.width($('.active.page').width());
            this.calculateBubblePosition(true);
        },

        showBubble: function(shouldOpenImmediately) {
            Logger.debug('showBubble called');
            try{
                this.reportInteraction({
                    element: "Bubble",
                    interaction: "click"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report show bubble interaction");
            }
            if(!this.$wrapper.hasClass('active')) {
                this.active = true; // sometimes during animation we get a refresh event so we need indication bubble was visible
                this.options.button.addClass('active');
                var self = this;

                if ($('.global-shield.bubble').length == 1) {
                    this.$shield = $('.global-shield.bubble');
                } else {
                    $('.viewport').append(this.$shield);
                }

                window.addEventListener("resize", this.debounceUpdateBubblePosition);
                //this is just incase the bubble was closed while the side menu was open
                this.$shield.css("transform","");
                this.$shield.append(this.$wrapper);
                this.$wrapper.width($('.active.page').width());
                this.$shield.off('click').on('click', function (e) {
                    if ($(e.target).hasClass('global-shield')) {
                        e.preventDefault();
                        e.stopPropagation();

                        if (self.$wrapper.hasClass('bubble-content') && self.$wrapper.hasClass('active') && !self.$shield.hasClass("animating")) {
                            self.hideBubble();
                        }

                    }
                });

                this.disableScrollingPropagation();
                //this.getClosestScrollingContainer().addClass("disabled");
                //$(".tabs-headers").addClass("disabled");

                if (!$('#header-overlay').length){
                    $('.page.active').prepend($('<div id="header-overlay"/>'));
                }
                $('#header-overlay').addClass('active bubble').off('click', self.shieldClick).on('click', self.shieldClick);

                var bubbleDirection = this.calculateBubblePosition();
                this.setArrowStyle();
                self.trigger('bubble/show', self);
                this.saveToPageState("showBubble", true);

                if (shouldOpenImmediately){
                    this.$shield.addClass('active');
                } else {
                    this.$shield.off('transitionend').on('transitionend', function () {
                        Logger.debug('Bubble is shown called');
                        self.$shield.removeClass('animating');
                    });

                    this.$shield.addClass('active animating');
                }
                this.$arrowBorder.show();
                this.$arrow.show();
                if(window.isDesignerPreview || window.designerLoaded || shouldOpenImmediately){
                    self.$wrapper.addClass("active");
                } else {
                    var originX = parseInt(this.$arrow.css('left')) || (this.options.button[0].getBoundingClientRect().left + this.options.button[0].getBoundingClientRect().right)/2;
                    var originY =self.$wrapper.height();
                    if (bubbleDirection === 'bottom') originY = 0;
                    this.$wrapper.css('transform-origin', originX+"px "+ originY+"px");

                    if (!window.isDesignerPreview) {
                        this.$wrapper.addClass('open-bubble-bounce-start');
                    }

                    this.$wrapper.addClass("active");

                    this.$wrapper.one("animationend webkitAnimationEnd", function(e) {

                        if (e.originalEvent.animationName === 'openbouncestart') {
                            self.$wrapper.removeClass('open-bubble-bounce-start');
                        }

                    });
                }
                Capriza.device.isDesktop && Utils.focusContainer(this.$wrapper);
            }
        },

        shieldClick: function(e){

            if (!$("#side-menu.active"),length && e.pageX < 43 && e.pageY < 43) {
                var $sideBurder = $("#side-burger");
                if ($sideBurder.length){
                    $sideBurder.click();
                    return;
                }
            }
            if (this.isBubbleOpen() && !this.$shield.hasClass("animating")) {
                this.hideBubble();
            }
        },

        hideBubble: function(immediate) {
            if (!$("#"+this.$el[0].id).length){
                return;
            }
            try{
                this.reportInteraction({
                    element: "Bubble",
                    interaction: "click",
                    controlPath: ".global-shield.bubble.active"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report close bubble interaction");
            }
            Logger.debug('hideBubble called');
            this.active = false;
            this.options.button.removeClass('active');
            var self = this;
            this.saveToPageState("showBubble", false);

            window.removeEventListener("resize", this.debounceUpdateBubblePosition);
            function removeBubble(bubble, withAnimation) {
                Logger.debug('removeBubble called');
                bubble.$arrowBorder.hide();
                bubble.$arrow.hide();
                bubble.$wrapper.removeClass('active');
                bubble.$shield.removeClass('active animating');
                var $headerOverlay = $('#header-overlay');
                $headerOverlay.removeClass('bubble');
                if (!$headerOverlay.hasClass("side-menu")) {
                    $headerOverlay.off('click');
                    $headerOverlay.removeClass('active');
                }
                bubble.enableScrollingPropagation();

                bubble.$wrapper.css('max-height', '');
                bubble.$wrapper.removeClass('close-bubble').removeClass('open-bubble-bounce-start');

                bubble.$shield.detach();
                Dispatcher.trigger("bubble/close/end");

                self.trigger('bubble/hide', self);
            }
            if(window.isDesignerPreview || window.designerLoaded || immediate){
                removeBubble(this);
            } else {
                onHide(this);
            }

            function onHide(bubble) {

                bubble.$wrapper.one("animationend webkitAnimationEnd", function(e) {

                    if (e.originalEvent.animationName === 'close') {
                        removeBubble(bubble, true);
                    }

                });
                bubble.$shield.addClass('animating');
                bubble.$shield.removeClass('active');
                bubble.$wrapper.removeClass('open-bubble-bounce-start');

                if (!window.isDesignerPreview) {
                    bubble.$wrapper.addClass('close-bubble');
                }

            }
        },

        calculateBubblePosition : function() {
            var $realButton = $('.value', this.options.button);

            var bubbleDirection = this.layoutBubble();

            //arrow position
            var middlePoint = ($realButton.offset().left - $('.viewport').offset().left) + ($realButton.outerWidth(true) / 2); // calc middle of visual button
            var arrowLeft = middlePoint;

            // tweak left, effect only tablet because in mobile we use 100% width in tablet only 320px so we want to place bubble accordingly
            if(Capriza.device.isTablet) {
                var bubbleLeft = middlePoint - (this.$wrapper.outerWidth() / 2);
                var remainingLeft = $('.active.page')[0].getBoundingClientRect().right - bubbleLeft;

                //ToDo: need to have some margin between the page and the bubble
                // bubble exceed left
                if(bubbleLeft < 0){
                    bubbleLeft = 0;
                } else if(remainingLeft < this.$wrapper.outerWidth()) { // bubble exceed right
                    var leftOffset = this.$wrapper.outerWidth() - remainingLeft;
                    bubbleLeft -= leftOffset;
                }
                arrowLeft -= bubbleLeft;

                this.$wrapper.css('left', bubbleLeft + 'px');
                //ToDo: need to make the bubble feet the modal page width
                if ($(".active.page-modal").length){
                    arrowLeft += bubbleLeft;
                    var modalRect = $(".active.page-modal")[0].getBoundingClientRect();
                    this.$wrapper.css({'left': (Math.max(bubbleLeft,modalRect.left)  + 'px'), 'right': (modalRect.right + 'px')});
                    arrowLeft -= Math.max(bubbleLeft,modalRect.left);
                }
            } else {
                //ToDo: need to make the bubble feet the modal page width
                if ($(".active.page-modal").length){
                    var modalRect = $(".active.page-modal")[0].getBoundingClientRect();
                    this.$wrapper.css({'left': (modalRect.left + 'px'), 'right': (modalRect.right + 'px')});
                    arrowLeft -= modalRect.left;
                }
            }
            this.$arrow.css('left', arrowLeft);

            var border = this.handleBorderWidth();
            // if style has border width - handle here because it effects the arrow position
            if(border){
                arrowLeft -= border;
            }
            this.$arrowBorder.css('left', arrowLeft);

            return bubbleDirection;
        },

        layoutBubble : function() {
            var $page = $('.page.active .page-content'),
                mainTop = $page.find('.header').outerHeight(true),
                pageBounding = $page[0].getBoundingClientRect(),
                spaceBelow = pageBounding.bottom - (this.options.button.offset().top + this.options.button.outerHeight()),
                spaceAbove = this.options.button.offset().top - (pageBounding.top + mainTop);
            // reduce the border of the content and the wrapper
            var fixBorderPaddingSize = getSizeInInt(this.$wrapper.css("borderTopWidth")) + getSizeInInt(this.$wrapper.css("borderBottomWidth"));

           // If bubble can't fit below open it above
           if(!this.options.button.hasClass("notif") && spaceAbove > spaceBelow * 1.2){
               this.$wrapper.css('max-height', spaceAbove + 'px');

               this.$arrow.addClass('arrow-down');
               this.$arrowBorder.addClass('arrow-down');

               this.$wrapper.css('top', 'auto');
               // tweak bottom
               var bottom  = $('.viewport')[0].getBoundingClientRect().bottom - this.options.button.offset().top + this.arrowDefaultHeight;

               // TODO: $('.value',this.options.button) shows up too much (it was $('.real-button',this.options.button) ) - we need to refactor this code to have less copy/paste
               var margin = getSizeInInt($('.value', this.options.button).css('margin-top'));
               this.$wrapper.css('bottom', (bottom - margin) + 'px');
               this.$arrow.css('bottom', '-'+this.arrowDefaultHeight+'px');
               this.$arrow.css('top', 'auto');
               this.$arrowBorder.css('bottom', '-'+this.arrowDefaultHeight+'px');
               this.$arrowBorder.css('top', 'auto');
               this.$el.css('max-height' , (spaceAbove - this.arrowDefaultHeight - fixBorderPaddingSize)  +'px');
               return "top";
           }else {
               this.$wrapper.css('max-height', (spaceBelow - this.arrowDefaultHeight) + 'px');
               this.$wrapper.css('bottom', 'auto');
               this.$arrow.removeClass('arrow-down');
               this.$arrowBorder.removeClass('arrow-down');

               //tweak top
               var viewportTop = document.querySelector(".viewport").getBoundingClientRect().top;
               var top = this.options.button.offset().top - mainTop + this.options.button.height() + this.arrowDefaultHeight - viewportTop;

               // TODO: $('.value',this.options.button) shows up too much (it was $('.real-button',this.options.button) ) - we need to refactor this code to have less copy/paste
               var margin = getSizeInInt($('.value', this.options.button).css('margin-bottom'));
               this.$wrapper.css('top', (top - margin) + 'px');
               this.$arrow.css('top', '-'+this.arrowDefaultHeight+'px');
               this.$arrow.css('bottom', 'auto');
               this.$arrowBorder.css('top', '-'+this.arrowDefaultHeight+'px');
               this.$arrowBorder.css('bottom', 'auto');
               this.$el.css('max-height' , (spaceBelow - this.arrowDefaultHeight - fixBorderPaddingSize)  +'px');
               return "bottom";
           }
        },

        handleBorderWidth : function() {
            var borderWidth = this.$arrow.hasClass('arrow-down') ?  this.$wrapper.css('border-bottom-width') : this.$wrapper.css('border-top-width');
            var bubbleBorder =  this.$wrapper.css('border');

            if(borderWidth || bubbleBorder){
                var intWidth = bubbleBorder ? parseInt(bubbleBorder.match(/\d+/)[0]) : 1;
                var intWidthBorder = intWidth + (borderWidth ? parseInt(borderWidth.replace('px', '')) : 1);
                var width = (this.arrowDefaultHeight + intWidth) + 'px ';
                var widthBorder = (this.arrowDefaultHeight + intWidthBorder) + 'px ';
                var widthStr, widthBorderStr;

                if(!this.$arrow.hasClass('arrow-down')){
                    widthStr = '0 ' + width + width ;
                    widthBorderStr = '0 ' + widthBorder + widthBorder ;
                    //need to add the wrapper border
                    var top = parseInt(this.$arrow.css('top').replace('px','')) - intWidthBorder;
                    this.$arrowBorder.css('top', top + 'px');
                } else {
                    widthStr = width + width + '0 ';
                    widthBorderStr = widthBorder + widthBorder + '0 ';
                    //need to add the wrapper border
                    var bottom = parseInt(this.$arrow.css('bottom').replace('px','')) - intWidthBorder;
                    this.$arrowBorder.css('bottom', bottom + 'px');
                }
                this.$arrow.css('border-width', widthStr);
                this.$arrowBorder.css('border-width', widthBorderStr);
                return intWidth;
            }
        }

    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Notification.js

try{
Capriza.Views.initWidget("notification", {
    
    severity: {
        "ERROR": { icon: "times-circle", color: "red" },
        "WARNING": { icon: "exclamation-circle", color: "orange" },
        "INFO": { icon: "check-circle", color: "blue" },
        "NONE": { icon: "times", color: "green" }
    },

    _create: function(){
       this.draw();
    },

    draw: function(){
        var severity = this.options.severity || "ERROR";
        var $icon = $("<i class='fa'></i>").addClass("fa-" + this.severity[severity].icon).css({ "color": this.severity[severity].color, "margin-right": "10px" });
        this.element.html(this.options.text || "").prepend($icon);
    },

    setText: function(){
        this.draw();
    },

    setSeverity: function(){
        this.draw();
    }

});

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/RadioGroup.js

try{
;(function () {
    Capriza.Views.RadioGroup = Capriza.Views.UiControl.extend({
        _render: function () {
            this.$el.attr("id", this.getUniqueControlId()).addClass("radiogroup");

            this.setItems(this.model.get("items") || []);

            return this.$el;
        },

        setItems: function(items) {
            var self = this;

            $('.radio-button', self.$el).remove();

            items.forEach(function (item, index) {
                var $itemEl = $("<div class='radio-button'></div>").attr("el-index", index).on("click", function (e) {
                    var $el = $(this);
                    self.updateSelected($el.attr("el-index"));
                    $('.radio-button', self.$el).removeClass("selected");
                    $el.addClass("selected");
                }).appendTo(self.$el);

                if (item.options) {
                    for (var option in item.options) {
                        $itemEl.attr(option, item.options[option]);
                    }
                }

                $itemEl.css({"width": (90 / items.length) + '%'});

                $itemEl.toggleClass("disabled", !!item.disabled);

                $('<span class="styleable-text first-text">' + item.text + '</span>').appendTo($itemEl);
                if (item.text2) {
                    $('<span class="styleable-text second-text">' + item.text2 + '</span>').appendTo($itemEl);
                }
                if (item.text3) {
                    $('<span class="styleable-text third-text">' + item.text3 + '</span>').appendTo($itemEl);
                }
            });
        },

        getSelectedIndex: function () {
            return $('.radio-button.selected', this.$el).attr("el-index");
        },

        setSelectedIndex: function (index) {
            $('.radio-button', this.$el).each(function () {
                var $item = this;
                if ($item.getAttribute("el-index") == index) {
                    $item.classList.add("selected");
                }
                else {
                    $item.classList.remove("selected");
                }
            });
        },

        _post: function () {
            var selectedIndex = this.model.get("selectedIndex");
            this.setSelectedIndex(selectedIndex);
        },
        
        updateSelected: function (selectedIndex) {
            this.model.api.setSelectedIndex(selectedIndex);
        }
    });

    Capriza.Views.ClientRadioGroup = Capriza.Views.RadioGroup.extend({
        updateSelected: function (selectedIndex) {
            var selectedItem = $('.radio-button[el-index="' + selectedIndex + '"]', this.$el);
            Dispatcher.trigger("radioGroup/selectionChanged", {selected: selectedItem, mc: this.model.get("id")});
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/RotatingTablePanel.js

try{
;(function () {
    Capriza.Views.RotatingTablePanel = Capriza.Views.Panel.extend({
        _post: function () {
            _.bindAll(this, "refreshSelectedColumn", "updateSelectedColumn");

            this.$el.addClass("rotating-table-panel");

            var radioGroup = this.getRadioGroup();

            radioGroup.$el.sticky();

            Dispatcher.on("radioGroup/selectionChanged", this.updateSelectedColumn);

            radioGroup.setSelectedIndex(0);

            document.addEventListener('DOMNodeInserted', this.refreshSelectedColumn);
        },

        _destroy: function () {
            Dispatcher.off("radioGroup/selectionChanged", this.updateSelectedColumn);
            document.removeEventListener('DOMNodeInserted', this.refreshSelectedColumn);
        },

        refreshSelectedColumn: function () {
            var radioGroup = this.getRadioGroup();
            if (!radioGroup) return;
            radioGroup.updateSelected(radioGroup.getSelectedIndex());
        },

        updateSelectedColumn: function (props) {
            var radioGroup = this.getRadioGroup();
            var radioGroupMcId = radioGroup.model.id;

            if (radioGroupMcId !== props.mc) return;

            var rotatingColumnIds = this.model.get("rotatingColumnIds") || [];
            var selectedColumnId = props.selected.attr("columnMcId");
            var selectedPlaceholderId = props.selected.attr("placeholderMcId");
            var columnsToHide = rotatingColumnIds.filter(function (column) {
                return column.id !== selectedColumnId && column.placeholderId !== selectedPlaceholderId;
            });

            this.hideColumns(columnsToHide);
            this.showColumns([selectedColumnId, selectedPlaceholderId]);
        },

        getRadioGroup: function () {
            var controls = this.options.page.getViews(this.model.get("controls") || []);
            return controls[0];
        },

        getTable: function () {
            var controls = this.options.page.getViews(this.model.get("controls") || []);
            return controls[1];
        },

        hideColumns: function (columns) {
            columns.forEach(function (column) {
                $(".table [data-mctemplid='" + column.id + "']", this.$el).toggleClass("hiddenColumn", true);
                $(".table [data-mctemplid='" + column.placeholderId + "']", this.$el).toggleClass("hiddenColumn", true);
            });
        },

        showColumns: function (columns) {
            columns.forEach(function (columnMcId) {
                $(".table [data-mctemplid='" + columnMcId + "']", this.$el).toggleClass("hiddenColumn", false);
            });
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Mapping.js

try{
;(function() {
    Capriza.Views.modelToView = {
        group: Capriza.Views.Group,
        textbox: Capriza.Views.Textbox,
        passwordbox: Capriza.Views.Passwordbox,
        checkbox: Capriza.Views.Checkbox,
        logincheckbox: Capriza.Views.LoginCheckbox,
        datepickerInput: Capriza.Views.DatePickerInput,
        calendarInput: Capriza.Views.CalendarInput,
        datepickerButton: Capriza.Views.DatePickerButton,
        calendarButton: Capriza.Views.CalendarButton,
        button: Capriza.Views.Button,
        lookup: Capriza.Views.Dropdown,
        listbox: Capriza.Views.Dropdown,
        listboxmulti: Capriza.Views.Dropdown,
        popup: Capriza.Views.Dropdown,
        menu: Capriza.Views.Dropdown,
        link: Capriza.Views.Link,
        combobox: Capriza.Views.Dropdown,
        autocomplete: Capriza.Views.Dropdown,
        content: Capriza.Views.Content,
        table: Capriza.Views.Table,
        tabular: Capriza.Views.Tabular,
        main: Capriza.Views.Panel,
        file: Capriza.Views.File,
        image: Capriza.Views.Image,
        image_link: Capriza.Views.ImageLink,
        panel: Capriza.Views.Panel,
        swipeActions: Capriza.Views.Panel,
        onoffswitch3: Capriza.Views.OnOffSwitch3,
	    tabController: Capriza.Views.TabController,
	    tab: Capriza.Views.Tab,
        bubble: Capriza.Views.Bubble,
        clientbutton: Capriza.Views.ClientButton,
        clientlink: Capriza.Views.ClientLink,
        box: Capriza.Views.Content,
        carousel: Capriza.Views.Carousel,
        gauge: Capriza.Views.Gauge,
        series: Capriza.Views.Series,
        pie: Capriza.Views.Pie,
        clickAction: Capriza.Views.ClickAction,
        rotatingTablePanel : Capriza.Views.RotatingTablePanel,
        radioGroup: Capriza.Views.RadioGroup,
        clientRadiogroup: Capriza.Views.ClientRadioGroup
    };

    Capriza.Views.getViewByModel = function(model) {
        var type = Capriza.Views.modelToView[model.get('type')];
        if (type) return type;

        if (model.get("controls")) {
            return Capriza.Views.GenericCollection;
        } else {
            return Capriza.Views.GenericView;
        }
    };
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/views/Unimessage.js

try{
/**
 * Created by Lev Weingarten on 8/2/2016.
 */
;(function () {
    // default offsets of unimessage
    var defaultPosition = {right: 15, bottom: 15, left: 15};

    Capriza.Views.Unimessage = Backbone.View.extend({
        tagName: "div",
        className: "unimessage",
        events: {"click .um-action>.mainAction": "actionButtonClicked",
                 "click .um-action>.extraAction": "extraActionButtonClicked"},

        // Renders Unimessage element
        render: function () {
            var model = this.model;
            function showElement(isVisible, cssName){
                $element.toggleClass(cssName, isVisible);
                isVisible && $element.removeClass("um-hasOnlyIcon");
            }
            var $element = this.$el.addClass("with-animation");
            $element.html(Handlebars.templates.unimessage(model.toJSON()));

            $element.removeClass(function (index, css) {
                return (css.match (/(^|\s)um-type-\S+/g) || []).join(' ');
            });
            $element.addClass("um-hasOnlyIcon um-type-" + model.get("type"));

            showElement(!!model.get("messageText"), "um-hasMessage");
            showElement(!!model.get("detailText"), "um-hasDetail");
            showElement(!!model.get("action"), "um-hasAction");
            if (model.get("type") == "progress"){
                $element.addClass("icon-animation");
            } else {
                $element.removeClass("um-hasOnlyIcon");
            }
            if (model.get("inSplash")){
                $element.addClass("splash-message");
            } else {
                $element.removeClass("splash-message");
            }
            // store a reference to View object
            $element.data("view", this);

            return this;
        },

        // Shows Unimessage
        show: function () {
            var $v = this.render(),
                self = this;
            if (!$v || $v.length == 0){
                return;
            }
            $v = $v.$el;
            Logger.debug("[Loading-Message] Unimessage text: " + this.model.get("messageText") + ", type: "+ this.model.get("type"));

            if (!$v.hasClass("visible")){
                $v.appendTo("#cprz");
                $v.addClass("visible");
            }

            return this;
        },

        update: function(options, immediateShow){
            // If there is no el or the el was removed or is invisible don't update
            if (this.isHidden()){
                return;
            }
            this.model.set(options);
            if (immediateShow) {
                this.show();
            }
            return this;
        },

        // Hides and removes Unimessage
        hide: function (immediateHide) {
            Utils.unimessageTimeout && clearTimeout(Utils.unimessageTimeout);
            Logger.debug("[Loading-Message] Unimessage hide: " + this.model.get("messageText") + ", type: "+ this.model.get("type"));

            if (immediateHide){
                this.$el.remove();
            } else {
                this.$el.on(Utils.transitionEnd, this.onHideEnd.bind(this));
                this.$el.removeClass("visible");
                // add after animation end
                this.hideTimeout = setTimeout(this.onHideEnd.bind(this), 500);
            }
        },
        isHidden: function(){
            return !this.$el.length || (this.$el[0].compareDocumentPosition(document) & Node.DOCUMENT_POSITION_DISCONNECTED) || !this.$el.hasClass("visible")
        },

        onHideEnd: function(){
            this.hideTimeout && clearTimeout(this.hideTimeout);
            this.$el.remove();
        },

        // Calls model action
        actionButtonClicked: function () {
            var ac = this.model.get("action");
            ac();
        },
        // Calls model action
        extraActionButtonClicked: function () {
            var ac = this.model.get("extraAction");
            ac();
        }
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/PasscodeWidget.js

try{
/*!
 * jQuery UI Widget-factory plugin boilerplate (for 1.8/9+)
 * Author: @addyosmani
 * Further changes: @peolanha
 * Licensed under the MIT license
 */

;
(function ($, window, document, undefined) {

	const DEFAULT_MAX_ATTEMPTS = 5;
	var countAttempts = 0;

    $.widget("capriza.passcode", {


        //Options to be used as defaults
        options: {
            mandatory: false,
            policy: "",
            title: 'Enter Passcode',
            verifyPasscode: "",
            digits: 4,
            create:false,
            interval: 0,
	        attempts : DEFAULT_MAX_ATTEMPTS
        },


        _template: function () {
            return  $('<div> ' +
                '           <div class="top-header">      ' +
                '         <button>' +
                '<i class="icon-remove-sign icon-2x"></i>' +
                '</button>' +
                '</div>  ' +
                ' <h1>                Enter Passcode                </h1>       ' +
                '     <input type="tel" class="numeric-keyboard"> <div class="focus-changer"></div><input type="password" class="passcode-view">        ' +
                '       <div class="to-go">                4 digits left                </div>     ' +
                '           <div class="policy">                </div>          ' +
                '      </div>')
        },

        _create: function () {
            var $template = this._template();

            this.$togo = $template.find('.to-go');
            this.$numericKeyboardInput = $template.find('.numeric-keyboard');
            this.$focusChanger = $template.find('.focus-changer');
            this.$inputView = $template.find('.passcode-view');
            this.element.append($template);
            var _this = this;

            function changeFocusToNumeric() {
                _this.$numericKeyboardInput.focus();
                _this.trackInput();
            }

            _this.$focusChanger.one('click', changeFocusToNumeric);

            this.$numericKeyboardInput.blur(function(){
                _this.$focusChanger.one('click', changeFocusToNumeric);
                console.log('numeric-keyboard is blurred');
                _this.stopTrackingInput();
            });

            this.$inputView.focus(function(){_this.$numericKeyboardInput.focus()});
        },

        reset: function () {
            this.$numericKeyboardInput.val('');
	        this.$inputView.val('');
	        this.$togo.text(this.options.digits + " digits left");
        },

        trackInput: function(){
            var _this = this;
            this.interval = setInterval(function(){
                if (_this.$inputView.val().length != _this.$numericKeyboardInput.val().length) {
                    var stars = "";
                    for (var i = 0; i < _this.$numericKeyboardInput.val().length; i++) {
                        stars+='*';
                    }

                    _this.$inputView.val(stars);
                    _this.updateToGo();
                    if (_this.howManyToGo() === 0) {
                        _this.onInputEnds();
                    }
                }
            }, 16);
        },

        stopTrackingInput: function(){
            clearInterval(this.interval);
        },

        updateToGo: function(){
            var toGo = this.howManyToGo();

            if (toGo > 0) {
                if (toGo == 1) {
                    this.$togo.text(toGo + " digit left");
                } else {
                    this.$togo.text(toGo + " digits left");
                }
            }
        },

        howManyToGo: function(){
            return this.options.digits - this.$numericKeyboardInput.val().length;
        },

        onInputEnds: function(){
            var passcode = this.$numericKeyboardInput.val();

            if (this.options.verifyPasscode) {

                if (this.options.verifyPasscode == passcode) {
	                countAttempts = 0;
                    Utils.savePasscode(SharedUtils.readCookie('userId'), passcode);
                    Dispatcher.trigger('passcode/hide');

                    this.$numericKeyboardInput.blur();

                } else {
                    this._mismatchHandler();

                }

            } else {
                this.options.origTitle = this.options.title;
                this._setOptions({title: 'Verify Passcode', verifyPasscode: passcode});
            }
        },

        _mismatchHandler:function(){
            var mismatchOptions={'title': this.options.origTitle || this.options.title};
            if(this.options.create){
	            countAttempts = 0;
                mismatchOptions.verifyPasscode="";
            }
            else {
	            this.reset();
	            if (semver.gte(_urlParams.cordova, "11.0.0")){
		            countAttempts++;
		            var self = this;
		            if (countAttempts < self.options.attempts) {
			            setTimeout(function () {
				            navigator.notification.alert(countAttempts + " of " + self.options.attempts + " attempts, please try again.", function(){}, "Incorrect Passcode");
			            }, 0);
		            }
		            else {
			            setTimeout(function () {
				            navigator.notification.alert("You have been logged out due to too many failed attempts.", function(){
					            countAttempts = 0;
					            Capriza.Capp.messenger.emit("passcodeFail");
				            },"Incorrect Password");
			            }, 0);
		            }
	            }
	            else {
		            setTimeout(function () {
		                navigator.notification.alert("Passcode mismatch, please try again.", function(){}, "Incorrect Passcode");
		            }, 0);
	            }
            }

            this._setOptions(mismatchOptions);
        },
        _setOptions: function (options) {

            this.options = $.extend(this.options, options);
            this._superApply(arguments);
        },
//        Respond to any changes the user makes to the
//        option method
        _setOption: function (key, value) {


            switch (key) {
                case 'title':
                    this.element.find('h1').text(value);
                    break;
                case 'mandatory':
                    if (value) {
                        this.element.find('.top-header button').hide();
                    } else {
                        this.element.find('.top-header button').show();
                    }
                    break;
                case 'policy':
                    if (value) {
                        this.element.find('.policy').text(this.options.policy);
                    }


                    break;
                case 'verifyPasscode':

                    this.reset();

                    break;
            }


            this._superApply(arguments);
        }
    });

})(jQuery, window, document);
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Passcode.js

try{
(function () {
    Dispatcher.on("runner/run", function (appData) {
        var _this = new Capriza.Views.PasscodeView();
        _this.render();
    });

    Capriza.Views.PasscodeView = Backbone.View.extend({
        id: 'passcode-page',
//        className: 'page',
        //... is a list tag.
        // Cache the template function for a single item.
//        template: Handlebars.templates.passcode,
//      className: 'zapp',
        // The DOM events specific to an item.
        reset: function (options) {
            options = _.extend({
                verifyPasscode: ""
            }, options);
            var localPasscode = Utils.loadPasscode(SharedUtils.readCookie('userId'));
            if (localPasscode) {
                this.$el.passcode({'verifyPasscode': localPasscode});
            }
            else if (options.verifyPasscode) {
                this.$el.passcode({'verifyPasscode': options.verifyPasscode});
            }
        },

        events: {
//            'click .top-header button': function (e) {
//                Dispatcher.trigger('passcode/hide');
//            }
        },

        initialize: function () {
            _.bindAll(this);
            Dispatcher.on('passcode/show', this.show);
            Dispatcher.on('passcode/hide', this.hide);
            this.render();
        },

        render: function () {
            this.$el.passcode().appendTo(".viewport");
            this.$el.css({y: "100%"});
            return this;
        },
        show: function (options) {
            var _this = this;
            this.reset(options);
            $(document.activeElement).blur();
            this.$el.prop('disabled', false);
            $('input',this.$el).prop('disabled', false);
            this.$el.addClass('active transitioning');
            this.$el.transition({y: 0}, function () {
                _this.$el.removeClass('transitioning');
            });
        },
        hide: function () {
            this.reset();
            this.$el.addClass("transitioning");
            var _this = this;
            this.$el.transition({y: "100%"}, function () {
                _this.$el.removeClass('active transitioning');
                $('.passcode-view').val("");
            });
        }
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/handlebars-helpers.js

Handlebars.registerHelper('prettyDate', function (object) {
    return new Handlebars.SafeString(
        humaneDate(object)
    );
});

Handlebars.registerHelper("i18n", function (textKey) {
    var result = Capriza.translator.getText(textKey);

    return result;
});


//! Source: javascripts/Debug.js

try{
(function () {

    if (_urlParams.debug || location.hash.indexOf("local;") > -1) window.debugMode = true;

    if (!window.debugMode) return;

    var debug=window.debug = $.extend({}, window.debug);


//    intercept Dispatcher trigger
    var debugKeyHolder = {};
    var originalTrigger = Dispatcher.trigger;

    // Dispatcher.trigger = function () {
    //     var blacklist = ["uiControl/rendered"];
    //     var whitelist = ["app/loaded ", "app/init", "runner/run", "runner/appStarted", "mobile/active"];

    //     if (_urlParams.debug) {
    //         if (whitelist.indexOf(arguments[0]) > -1) {
    //             logger.error(arguments[0]);
    //         }
    //         else if (blacklist.indexOf(arguments[0]) == -1) {
    //             logger.log(arguments[0]);
    //         }
    //     }
    //     if (_urlParams.debug && blacklist.indexOf(arguments[0]) == -1) {
    //         take(arguments[0]);

    //         var key = arguments[0];
    //         var app = {};
    //         if (window.appData) {
    //             app = {
    //                 id: appData.app.id,
    //                 name: appData.app.name,
    //                 token: appData.app.token,
    //                 sessionId: appData.session_id
    //             }
    //         }

    //         logger.debug(JSON.stringify({event: key, time: new Date(), app: app}))

    //     }

    //     originalTrigger.apply(this, arguments);
    // };
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Router.js

try{
;(function() {
    window.Router = (function() {
        var AppRouter = Backbone.Router.extend({
            routes: {}
        });

        return new AppRouter();
    })();

    Dispatcher.trigger("router/created");
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Login.js

try{
(function () {
    var runCount=0;
    var takeLogin;
    Dispatcher.on("login/show", function () {
        if(!takeLogin){
            takeLogin = take("loginEvent", {async: true, manualSend: true});
        }

        if (!view) {
            view = new LoginView({ model: Capriza.loginModel });
        }
        view.render();

    });
    var view;


    var LoginView = Capriza.Views.PageView.extend({
        id: "login-page",
        className: "cover-page ignores-header",
        ignoresHeader: true,
        animate: !!Capriza.device.android,
        events: {
            "click button": "doLogin",
            "keypress input": "almostDoLogin"
        },

        _render: function () {

            var templateData = {
                title: "Capriza Login", // this.model.get("title"),
                socialLogin: true,
                linkedinUrl: Config.apiUrl + "/auth/linkedin",
                linkedinIconUrl: Config.apiUrl + "/images/authbuttons/linkedin_64.png"
            };

            Dispatcher.trigger("header/hide");

            this.$el.html($(Handlebars.templates['login-page'](templateData)));

            if (this.animate) {
                $.capriza.changePage(this.$el, { transition: "slide", notInStack: true });
            } else {
                $.capriza.changePage(this.$el, { transition: "none", notInStack: true });
            }

            this.$el.find("form").submit(function () {
                return false;
            });
            return this;
        },

        leave: function () {

            if (this.animate) {
                $.capriza.backPage({ transition: "slide", fromPage: this.$el, notInStack: true });
            } else {
                $.capriza.backPage({ transition: "none", fromPage: this.$el, notInStack: true });
            }

            Dispatcher.trigger("header/show");
        },

        cleanup: function () {
            this.$("input").val("");
            this.$(".error-message").text("");
        },

        doLogin: function () {
            this.$el.find("form").find("input").blur();
            //$.capriza.showLoadingCenter();
            var _this = this;
            Api.login({
                email: this.$("#login-email").val(),
                password: this.$("#login-password").val(),

                complete: function () {
                    //$.capriza.hideLoadingCenter();
                },

                success: function (resp) {
                    _this.model.set("user", resp["user"]);
                    _this.cleanup();
                    _this.leave();

                        if(runCount==0){
                            Runner.runSession();
                            runCount++;
                        }
                    takeLogin();
                },

                failure: function (resp) {
                    var errorCode = resp.error_codes && resp.error_codes[0];
                    if (errorCode == errorCodes.AUTH_NOT_CONFIRMED.id) {
                        Dispatcher.trigger("confirmation/show");
                        _this.cleanup();
                        _this.leave();
                    } else {
                        _this.$(".error-message").text(resp["errors"]);
                        _this.model.set("user", null);
                    }


                }
            });
        },

        almostDoLogin: function (e) {
            if (e.keyCode == 13)
                this.doLogin();
        }

    });

    Capriza.Model.Login = Backbone.Model.extend({

        initialize: function () {
          this.set("user", { pending: true });
          this.checkToken();
        },

        checkToken: function () {
            var _this = this;
            Api.login({
                success: function (resp) {
                    _this.set("user", resp["user"]);
                },

                failure: function (resp) {
                    _this.set("user", null);
                }
            });
        }

    });

})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Confirmation.js

try{
(function () {
    Dispatcher.on("confirmation/show", function () {

        if (!view) {
            view = new ConfirmationView({model: Capriza.loginModel});
        }
        view.render();

    });
    var view;

    var ConfirmationView = Capriza.Views.PageView.extend({
        id:"confirmation-page",
        className:"cover-page ignores-header",
        ignoresHeader:true,
        animate:!!Capriza.device.android,
        events:{
            "click button":function(){Utils.reload()}
        },

        _render:function () {

            Dispatcher.trigger("header/hide");
            //$.capriza.hideLoadingCenter();

            this.$el.html(Handlebars.templates['confirmation-page']());

            if (this.animate) {
                $.capriza.changePage(this.$el, { transition: "slide", notInStack: true });
            } else {
                $.capriza.changePage(this.$el, { transition: "none", notInStack: true });
            }

            return this;
        },

        leave:function () {

            if (this.animate) {
                $.capriza.backPage({ transition: "slide", fromPage: this.$el, notInStack: true });
            } else {
                $.capriza.backPage({ transition: "none", fromPage: this.$el, notInStack: true });
            }

            Dispatcher.trigger("header/show");
        }


    });

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Message.js

try{
(function () {
//    Dispatcher.on("message/show", function (options) {
//
//
//        _this.options = $.extend({}, {
//            pageId:"message-page",
//            topHeader: '',
//            bottomHeader: '',
//            message: '',
//            buttonText: 'Okay',
//            buttonStyle: '',
//            buttonAction:function(){},
//            renderAction:function(){}
//
//        }, options);
//
//        if (!view) {
//            view = new MessageView({});
//        }
//        view.render(options);
//
//
//    });


    var view;
    var _this = this;

    var MessageView = Capriza.Views.PageView.extend({

        id: "message-page",
        className: "cover-page ignores-header",
        ignoresHeader: true,
        animate: !!Capriza.device.android,
        events: {

        },

        _render: function () {

            Dispatcher.trigger("header/hide");

            this.$el.html(Handlebars.templates['message-page'](_this.options));
            this.$el.find("button").click(_this.options.buttonAction);

            if (this.animate) {
                $.capriza.changePage(this.$el, { transition: "slide", notInStack: true });
            } else {
                $.capriza.changePage(this.$el, { transition: "none", notInStack: true });
            }
            _this.options.renderAction();
            return this;
        },

        leave: function () {

            if (this.animate) {
                $.capriza.backPage({ transition: "slide", fromPage: this.$el, notInStack: true });
            } else {
                $.capriza.backPage({ transition: "none", fromPage: this.$el, notInStack: true });
            }

            Dispatcher.trigger("header/show");

        }


    });

})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/ErrorPage.js

try{
(function() {
    var NoPrivateRuntimeView = Capriza.Views.PageView.extend({
        _render: function() {
            this.$el.attr("id", "no-private-runtime-page");
            this.addContent(Handlebars.templates["noPrivateRuntime"]);
        }
    });

    var view;

    Dispatcher.on("runner/noPrivateRuntime", function() {
        view || (view = new NoPrivateRuntimeView());
        view.render().show();
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Identity.js

try{
(function() {
    if (Utils.caprizaMode === "ShellMode") return;

    function hideLoadingMessage(){
        Utils.hideLoading();
        Utils.hideUnimessages();
    }

    Dispatcher.on("identity/host/logout",function(host){
        var msg = Capriza.translator.getText("signingOut");
        setTimeout(function(){Utils.reload(msg)}, 0);
        Dispatcher.on('identity/host/logout/dataRemoved', function(){Utils.reload(msg)});
    });

    function prepareAndShowHeader(parent) {

        if (!this.$headerEl){
            this.$headerEl = $(".page.active .panel-type-header.header");
            if (!this.$headerEl.length) {
                var zappName = window.appData && window.appData.app_name;
                this.$headerEl = $('<div class="panel horizontal-layout has-dock group dock-top floating-bar panel-type-header header ui-control ss-dss_global ss-dss_header ss-dss_grouping_grow ss-dss_primBgCol active"></div>');
                this.$headerEl.append($('<div class="content ui-control ss-dss_global ss-dss_no_margin_child_content ss-dss_header_any ss-dss_header_square"><div class="value"></div></div>'));
                this.$headerEl.append($('<div class="content ui-control ss-dss_global ss-dss_no_margin_child_content ss-dss_primBgCol_content ss-dss_header_any ss-dss_text_overflow ss-dss_grow ss-dss_center_grow"><div class="value">' + zappName + '</div></div>'));
                this.$headerEl.append($('<div class="panel groupEmpty horizontal-layout group panel-type-inTemplate ui-control ss-dss_global ss-dss_no_margin_child_panel ss-dss_primBgCol_panel ss-dss_header_space ss-dss_header_any"> <div class="grouping"></div></div>'));
                this.$headerEl.append($('<div class="content ui-control ss-dss_global ss-dss_no_margin_child_content ss-dss_primBgCol_content ss-dss_header_any ss-dss_header_square"> <div class="value"></div></div>'));
                parent.prepend(this.$headerEl);
            }
        }
        Dispatcher.trigger('sideburger/show', this.$headerEl);
    }

    Capriza.IdentityWidget = {};
    Capriza.IdentityWidget.Base = {

        initialize: function(identityPageView, identityData) {
            this.pageView = identityPageView;
            this.data = identityData;
        },

        create: function(control) {
            var childEl = this._create(control);

            this.appendToPage(childEl);

        },

        appendToPage: function($elToAppend) {
            this.pageView.$(".fields").append($elToAppend);
        },

        getTextValueForID: function(controlId) {

            var controlIndex;

            if (!this.data.get('usernameMapping')) return;

            for (var i = 0; i < this.data.get('usernameMapping').length; i++){
                if (this.data.get('usernameMapping')[i] === controlId) {
                    controlIndex = i;
                }
            }

            if (controlIndex === 0){
                return this.data.get('username');
            }
            else if (controlIndex === 1) {
                return this.data.get('username2');
            }
            else if (controlIndex === 2) {
                return this.data.get('username3');
            }
            else {
                return '';
            }


        }
    };
    Capriza.IdentityWidget.Image = _.extend({

        _create: function(control) {
            this.pageView.$('#identity-image').attr('src', control.get('src'));
        },

        update: function(control) {
            this.create(control);
        }
    }, Capriza.IdentityWidget.Base);

    Capriza.IdentityWidget.Textbox = _.extend({

        _create: function(control) {

            var controlId = control.get('id'), currValue = this.getTextValueForID(controlId) || control.get('text');

            var templateData = {
                klass: "labeled",
                id: controlId,
                name: control.get('name'),
                value: currValue
            };

            return $(Handlebars.templates["identity-textbox"](templateData));
        },

        update: function(control) {
            //Add update code here
        }
    }, Capriza.IdentityWidget.Base);

    Capriza.IdentityWidget.Password = _.extend({

        _create: function(control) {

            var controlId = control.get('id'), currValue = this.data.get('password') || control.get('text');

            var templateData = {
                klass: "labeled",
                id: controlId,
                name: control.get('name'),
                value: currValue
            };

            return $(Handlebars.templates["identity-passwordbox"](templateData));
        },

        update: function(control) {
            //Add update code here
        }
    }, Capriza.IdentityWidget.Base);

    Capriza.IdentityWidget.Listbox = _.extend({

        _create: function(control) {

            var controlId = control.get('id'), currValue = this.data.listbox;

            var templateData = {
                klass: "labeled",
                id: controlId,
                name: control.get('name'),
                options: Object.keys(control.get('items')).map(function(key) {

                    return {
                        optionText: control.get('items')[key],
                        optionValue: key,
                        selected: key=== currValue && currValue.toString() ? 'selected': '' };
                })
            };

            return $(Handlebars.templates["identity-listbox"](templateData));
        },

        update: function(control) {

            var optionsHTML = "";

            _.each(control.get('items'), function(key, i) {

                optionsHTML += "<option value="+i+">"+key+"</option>";
            });

            this.pageView.$('#'+control.get('id')).html(optionsHTML);

        }
    }, Capriza.IdentityWidget.Base);

    Capriza.IdentityWidget.Content = _.extend({

        _create: function(control) {

            var currValue = $(control.get('value')).text();

            var templateData = {
                value: currValue
            };

            return $(Handlebars.templates["identity-content"](templateData));
        },

        update: function(control) {
            //Add update code here
        }
    }, Capriza.IdentityWidget.Base);

    Capriza.IdentityWidget.Link = _.extend(Capriza.IdentityWidget.Base, {

        _create: function(control) {

            var $el = $('<div class="ui-control"></div>');

            $el.link(control.toJSON()).on('link_click', function(){
                control.api['click'];
            });

            return $el;

        },

        appendToPage: function($elToAppend) {
            this.pageView.$("form").append($elToAppend);
        },

        update: function(control) {
            //Add update code here
        }
    });



    Dispatcher.on("app/init", function() {

        Capriza.Model.IdentityPage = Capriza.Model.Page.extend({
            initialize: function() {
                var self = this;
                var presentationControl = this.get('presentationControl');

                var controls = presentationControl && presentationControl.controls;
                if (controls) {
                    _.each(controls, function(jsonControl) {
                        var control = Capriza.Model.Control.getById(jsonControl.get('id'));
                        control && control.addPage(self);
                    });
                }

            },

            controlChanged: function(control) {

                this.trigger("identityPage/controlChanged", control);

            }
        });

        /**
         * Override the default implementation of returning an empty object (as defined in capriza-api-1.0.0.js)
         */
        Capriza.getIdentity = function(callback, event) {

            window.appData = (window.appData || {});
            appData.identity=event;
            Capriza.LoginManager.loggedInHosts[event.host] = false;
            Capriza.LoginManager.credentialsSavedForHosts[event.host] = false;
            var credentials = Capriza.LoginManager.getSavedCredentialsForType(Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS ,event.host);
            if (credentials && credentials.password && !event.prevInvalid && event.host && appData.xkcd && !event.canLogin && event.count <= 1) {
                Capriza.splashRenderAuthMessage && Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.authenticating), {fontColor: '#000000', isError: false});
                Capriza.LoginManager.credentialsSavedForHosts[event.host] = true;
                Dispatcher.trigger('splash/setTimeout');
                callback(credentials, true);

            } else {

                if (event.presentationControl) {

                    //just for the sake of initialization...
                    var root = new Capriza.Model.Control(event.presentationControl);
                }

                var page = new Capriza.Model.IdentityPage(event);

                if (view) {
                    Capriza.clearIdentity();
                }
                window.scrollTo(0,0);

                view = new IdentityView({ onsubmit: callback, allowSave: true, model: page });
                view.render();

                prepareAndShowHeader(view.$el);
                view.show();

            }

            Dispatcher.off("loading/stop", hideLoadingMessage).on("loading/stop", hideLoadingMessage);
        };

        Capriza.clearIdentity = function() {
            if (view) {
                view.destroy();
                view = undefined;
            }
        }
    });

    var IdentityView = Capriza.Views.PageView.extend({
        id: "identity-page",
        events:{
            "keypress form":function(e){
                if(e.keyCode==13)
                {
                    $("#identity-page").find("input, select, textarea").blur();
                    $("#identity-submit-btn").click();
                    return false;
                }
            }
        },
        fullScreen: true,
        bounce: false,
        identityWidgets: {},

        initialize: function() {

            _.bindAll(this, "_goBack", "destroy");

            this.initIdentityWidgets();

            var self = this;
            this.listenTo(this.model, "identityPage/controlChanged", function(control) {

                self.identityWidgets[control.get('type')].update(control);

            });
        },

        initIdentityWidgets: function() {

            this.identityWidgets['image'] = Capriza.IdentityWidget.Image;
            this.identityWidgets['textbox'] = Capriza.IdentityWidget.Textbox;
            this.identityWidgets['passwordbox'] = Capriza.IdentityWidget.Password;
            this.identityWidgets['listbox'] = Capriza.IdentityWidget.Listbox;
            this.identityWidgets['content'] = Capriza.IdentityWidget.Content;
            this.identityWidgets['link'] = Capriza.IdentityWidget.Link;

            var self = this;
            _.each(this.identityWidgets, function(widget) {
                widget.initialize(self, self.model);
            });
        },

        _render: function() {

            var data = this.model;
            this.$el.addClass("identity");

            if (data.get('presentationControl')) {
                return this._renderWithPresentationControls();
            }
            else {
                return this._renderIdentity();
            }

        },

        _renderIdentity: function() {
            var _this = this;

            var templateData = {
                noPlaceholder: Capriza.device.ios6,
                icon: appData.icon_url
            };

            this.$el.append(Handlebars.templates['identity-page'](templateData));

            Capriza.device.isTablet && this.$el.addClass("tablet");

            this.createAndInsertFieldElement('identity-username0', {type:'textbox', name:'Username'});
            this.createAndInsertFieldElement('identity-password', {type:'passwordbox', name:'Password'});

            this.$username = this.$("#identity-username0").val(this.model.get('username') || "");
            this.$password = this.$("#identity-password").val(this.model.get('password') || "");


            this.$shouldSave = this.$("#identity-check");
            this.$signin = this.$("#identity-submit-btn");

            this.$signin.realButton({ name: "Sign In" });

            if (_urlParams.demo || this.model.get('canLogin')) {
                setTimeout(function () {
                    _this.$username.val("demo@capriza.com");
                    _this.$("#identity-password").val("********");
                }, 0);

                this.$("#identity-submit-btn").remove();
                this.$("#identity-demo-submit-btn").css("display","block");
                this.$("#identity-demo-submit-btn").realButton({ name:"Sign In with Demo Account" });
                this.$("#identity-demo-submit-btn").on("click", function (e) {

                    _this.options.onsubmit && _this.options.onsubmit({ });


//                    _this.clear();
                    _this.leave();
                });

                if (!window.devMode) {

                    //seek attention
                    setTimeout(function () {
                        _this.$("#identity-demo-submit-btn").toggleClass("animated tada")
                    }, 2000);
                    _this.attentionSeekInterval = setInterval(function () {
                        _this.$("#identity-demo-submit-btn").toggleClass("animated tada")
                    }, 4000);
                }


            }


            /**
             * NOTE: this could have been implemented by having the submit logic inside the "submit" handler (instead of the click on submit)
             * However, if the submit handler is used, then the browser validates that the input type="email" actually has an email.
             * So if the type isn't really email then the validation is unnecessary. Hell, even if it's email you don't want the browser to do the
             * UI for the validation. So maybe it shouldn't be email. Anyway, not using the submit handler, but rather the click on the submit button
             * (along with the keypress handler on the form - see above)
             */
            this.$("form").submit(function () {
                return false;
            });

            this.$signin.on("click", function(e) {
                var username = _this.$username.val();
                var password = _this.$password.val();
                var saveCredentials = _this.$shouldSave.prop("checked");

                //force login to demo account if necessary

                if (username == "demo@capriza.com" && _this.options.data.canLogin) {
                    _this.options.onsubmit && _this.options.onsubmit({ });
                } else {
                    _this.options.onsubmit && _this.options.onsubmit({ username:username, password:password }, saveCredentials);
                }



                if (saveCredentials) {
                    if(appData.remember_passwords){
                        Capriza.LoginManager.saveCredentialsForType({ username:username, password:password }, Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS, _this.model.get('host'));

                    }else{
                        Capriza.LoginManager.saveCredentialsForType({ username:username}, Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS, _this.model.get('host'));
                    }
                } else {
                    Capriza.LoginManager.clearCredentialsForHost(_this.model.get('host'));
                }
//                _this.clear();
                _this.setFlash("");
                _this.leave();
            });
        },

        _renderWithPresentationControls: function() {
//            this.processControls();
            var _this = this;

            var templateData = {
                noPlaceholder: Capriza.device.ios6,
                icon: appData.icon_url
            };

            this.$el.append(Handlebars.templates['identity-page'](templateData));

            Capriza.device.isTablet && this.$el.addClass("tablet");

            this.model.get('presentationControl').controls.forEach(function(control){


                if (control.get('type') !== 'image') {
                    _this.$("#identity-image").addClass('hidden')
                }

                if (control.get('type') === "passwordbox") {
                    _this.passwordControl = control;
                }

                var identWidget = _this.identityWidgets[control.get('type')];

                //The reason this might be undefined, is sometimes we get a control which is hard coded in the UI and
                //the data from the presentationControl is ignored. this why we didn't even init a widget for it.
                if (identWidget) {
                    identWidget.create(control);
                }
            });

            Dispatcher.once("page/change/beforeTransition", function() {
                _this.$(".field.labeled").each(function() {
                    var label = $("label", this), field = $(this);
                    logger.log("label=" + label[0].getBoundingClientRect().width + ", field=" + field.width());
                    if (label.width() > (field.width() / 2)) {
                        field.addClass("vertical");
                    } else {
//                        $(".value", field).css("margin-left", label.width() + 15);
                    }
                });
            });



//            this.$username = this.$("#identity-username0").val(data.username || "");
//            this.$password = this.$("#identity-password").val(data.password || "");

            this.$shouldSave = this.$("#identity-check");
            this.$signin = this.$("#identity-submit-btn");

            this.$signin.realButton({ name: "Sign In" });


            if (_urlParams.demo || this.model.get('canLogin')) {
                setTimeout(function () {
                    _this.$username.val("demo@capriza.com");
                    _this.$("#identity-password").val("********");
                }, 0);

                this.$("#identity-demo-submit-btn").css("display","block");
                this.$("#identity-demo-submit-btn").realButton({ name:"Sign In with Demo Account" });
                this.$("#identity-demo-submit-btn").on("click", function (e) {

                    _this.options.onsubmit && _this.options.onsubmit({ });


//                    _this.clear();
                    _this.setFlash("");
                    _this.leave();
                });

                if (!window.devMode) {

                    //seek attention
                    setTimeout(function () {
                        _this.$("#identity-demo-submit-btn").toggleClass("animated tada")
                    }, 2000);
                    _this.attentionSeekInterval = setInterval(function () {
                        _this.$("#identity-demo-submit-btn").toggleClass("animated tada")
                    }, 4000);
                }


            }

            this.$("form").submit(function () {
                return false
            });

            this.$signin.on("click", function(e) {
                var username = _this.getInputValue(_this.model.get('usernameMapping')[0]);
                var password = _this.getInputValue(_this.passwordControl.id);
                var saveCredentials = _this.$shouldSave.prop("checked");

                //force login to demo account if necessary

                if (username == "demo@capriza.com" && _this.model.get('canLogin')) {
                    _this.options.onsubmit && _this.options.onsubmit({ });
                } else {
                    _this.options.onsubmit && _this.options.onsubmit({
                        username:_this.getInputValue(_this.model.get('usernameMapping')[0]),
                        password:password,
                        username2:_this.getInputValue(_this.model.get('usernameMapping')[1]),
                        username3:_this.getInputValue(_this.model.get('usernameMapping')[2]),
                        listbox: $('select', '#identity-page').prop("selectedIndex")
                    }, saveCredentials);
                }



                if (saveCredentials) {
                    if(appData.remember_passwords){
                        Capriza.LoginManager.saveCredentialsForType({
                            username:_this.getInputValue(_this.model.get('usernameMapping')[0]),
                            password:password,
                            username2:_this.getInputValue(_this.model.get('usernameMapping')[1]),
                            username3:_this.getInputValue(_this.model.get('usernameMapping')[2]),
                            listbox: $('select', '#identity-page').prop("selectedIndex")
                        }, Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS, _this.model.get('host'));

                    }else{
                        Capriza.LoginManager.saveCredentialsForType({ username:_this.getInputValue(_this.model.get('usernameMapping')[0]),
                            username2:_this.getInputValue(_this.model.get('usernameMapping')[1]),
                            username3:_this.getInputValue(_this.model.get('usernameMapping')[2]),
                            listbox: $('select', '#identity-page').prop("selectedIndex")}, Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS, _this.model.get('host'));
                    }

                } else {
                    Capriza.LoginManager.clearCredentialsForHost(_this.model.get('host'));
                }

                _this.setFlash("");
                _this.leave();
            });
        },

        getInputValue: function(mcId) {

            return this.$("#"+mcId).val();
        },

        createAndInsertFieldElement: function(id, inputControl) {

            var klass = /(textbox|listbox|passwordbox)/.test(inputControl.type) ? "labeled" : "", data = this.model;

            var currValue = inputControl.type === "content" ? $(inputControl.value).text() : undefined;

            if (inputControl.type === "textbox") {
                var controlId = inputControl.id;
                currValue = this.getTextValueForID(controlId);
            }

            if (inputControl.type === "listbox") {
                currValue = data.listbox
            }

            if (inputControl.type === "passwordbox") {
                currValue = data.password
            }

            var templateData = {
                klass: klass,
                id: id,
                name: inputControl.name,
                value: currValue,
                options: inputControl.type === "listbox" ? Object.keys(inputControl.items).map(function(key) {

                    return {
                        optionText: inputControl.items[key],
                        optionValue: key,
                        selected: key=== currValue && currValue.toString() ? 'selected': '' };
                }) : undefined
            };

            var fieldElement = $(Handlebars.templates["identity-" + inputControl.type](templateData));

            if (inputControl.type === "content") {
                this.$(".fields").before(fieldElement);
            }
            else if (inputControl.type === "textbox" || inputControl.type === "passwordbox" || inputControl.type === "listbox") {
                this.$(".fields").append(fieldElement);
            }
            else {
                this.$(".fields").after(fieldElement);
            }


        },

        getTextValueForID: function(controlId) {

            var controlIndex, data = this.model;

            if (!data.get('usernameMapping')) return;

            for (var i = 0; i < data.get('usernameMapping').length; i++){
                if (data.get('usernameMapping')[i] === controlId) {
                    controlIndex = i;
                }
            }

            if (controlIndex === 0){
                return data.get('username');
            }
            else if (controlIndex === 1) {
                return data.get('username2');
            }
            else if (controlIndex === 2) {
                return data.get('username3');
            }
            else {
                return '';
            }


        },

        show: function() {
            var data = this.model, self = this;
            Dispatcher.trigger("identity/show", {timeFromAccessURL: data.get('timeFromAccessURL')});
            //$.capriza.hideLoadingCenter();
            appData.identityShow = true;
            if (data.get('host') && appData.xkcd) {
                var decrypted = Capriza.LoginManager.getSavedCredentialsForType(Capriza.LoginManager.credentialsTypes.LOGIN1_KEYS, data.get('host'));
                if (decrypted) {
                    this.$username.val(decrypted.username);
                    if(decrypted.password){
                        this.$password.val(decrypted.password);
                    }
                    if (decrypted.username2){
                        this.$("#identity-username2").val(decrypted.username2);
                    }
                    if (decrypted.username3){
                        this.$("#identity-username3").val(decrypted.username3);
                    }
                    this.$shouldSave.prop("checked", true);
                }
            }


            var $shouldSave = this.$(".field.shouldSave");
            if (this.options.allowSave) {
                $shouldSave.removeClass("hidden");
                var config = window.appData && window.appData.config;
                if (!config || config && !config.dontSaveCredentialsByDefault){
                    self.$shouldSave.prop('checked', true);
                }
            } else {
                $shouldSave.addClass("hidden");
            }

            if(this.options.allowSave && !appData.remember_passwords){
                $shouldSave.find("label").text("Save username on this device");
            }

            this.setTitle(appData.app_name);
            this.setHost(data.get('host'));

            if (data.get('prevInvalid')) {
                this.$el.addClass("has-error");
                this.setFlash(Capriza.translator.getText(Capriza.translator.ids.incorrect));
                Capriza.LoginManager.credentialsSavedForHosts[data.get('host')] = false;
            }

            $('#splash-message').empty();
            $('.field').removeClass('disabled');

            $.capriza.changePage(this.$el, { transition: "slideup", prevPageNoTransition: true });

            if(Capriza.device.android2){
                Capriza.reflow();
            }
        },

        leave: function() {

            clearInterval(this.attentionSeekInterval);

            Capriza.splashRenderAuthMessage(Capriza.translator.getText(Capriza.translator.ids.loading));

            $('.field').addClass('disabled');

            var _this = this;

            Dispatcher.on("mobile/active login/show confirmation/show mobile/error", this._goBack);

            Dispatcher.on("page/beforeChange", this.destroy);
        },

        _goBack: function(){
            $.capriza.backPage({ transition: "slideup", prevPageNoTransition: true });
            this.clear();
            $('.field').removeClass('disabled');
            $('#splash-message').empty().removeClass('active');
            Utils.hideUnimessages();
        },

        setTitle: function(title) {
            this.$("header h1").text(title || "");
        },

        setHost: function(host) {
            this.$(".identity-host").text(host || "");
        },

        setFlash: function(text) {
            this.$(".identity-flash").text(text || "");
        },

        clear: function() {
            this.$('.value input').val("");
            this.$shouldSave.prop("checked", false).removeClass("hidden");
            this.setTitle("");
            this.setFlash("");
        },

        destroy: function(){
            Capriza.Views.PageView.prototype.destroy.call(this);
            Dispatcher.off("mobile/active login/show confirmation/show mobile/error", this._goBack);
            Dispatcher.off("page/beforeChange", this.destroy);
            view = undefined;
        }
    });

    var view;
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/CompatMode.js

try{
;(function() {

    if (!Capriza.compatMode) return;
//    function block(e) {
//        if (e.target !== Capriza.OneMomentPlease.$el[0] && !$.contains(Capriza.OneMomentPlease.$el[0], e.target)) {
//            Capriza.OneMomentPlease.show();
//        }
//        e.preventDefault();
//        e.stopPropagation();
//    }
//
//    Capriza.OneMomentPlease.blockUI = function() {
//        $(".viewport")[0].addEventListener("touchstart", block, true);
//    };
//
//    Capriza.OneMomentPlease.unblockUI = function() {
//        $(".viewport")[0].removeEventListener("touchstart", block, true);
//    };


    function setMinHeight() {
//        $(".viewport, .cover-page").css("min-height", window.innerHeight);
        $("body").css({height:"auto"});
        $("html").css({height:"auto"});
    }

    Dispatcher.on("app/init", function() {
        $(".viewport").addClass("compat-mode");
        setMinHeight();
        $.capriza.usePageAnimation = false;
//        $.capriza.currentScrollPosition = function() {
//            return window.pageYOffset;
//        };


        /*
        Save and restore scrolling positions
         */
       /* Dispatcher.on("page/beforeChange page/back/before", function(data) {

            // at this point, the "from-page" is visible, and this is the last point in time we can take the scroll position for it.
            // the "to-page" is not visible yet, so we have to wait for "page/change/beforeTransition" until we can scorll to the target position.

            var activePageView = $.capriza.activePage.data("pageView");
            if (!activePageView) return;

            activePageView.scrollPosition = $.capriza.currentScrollPosition();

            Dispatcher.once("page/change/beforeTransition", function() {
                var pageView = data.toPage.data("pageView");
                var scrollPosition = pageView.scrollPosition;
                if (scrollPosition) {
                    pageView.scrollTo(0, scrollPosition);
                } else {
                    pageView.scrollTo(0,0);
                }
            });

        });
*/
     /*   Capriza.Views.PageView.prototype.scrollTo = function(x, y) {
            window.scrollTo(x, y);
        };*/


//        $(window).on("orientationchange resize", function (e) {
//            setMinHeight();
//            setTimeout(function() {
//                setMinHeight();
//            }, 100);
//        });
//
//        Dispatcher.on("login/show", function() {
//            setTimeout(setMinHeight, 0);
//        });
    });
})();
}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/AppInstall.js

try{
(function () {
    Dispatcher.on('app/init', function () {
        if (!(Capriza.device.ios && (window.appData && appData.config && appData.config.addToHome))) return;

        var add2homeKey = appData.app_token + "add2homeClosed";
        Dispatcher.on("mobile/active identity/show", function () {
            setTimeout(function () {

                if (ClientCache.getItem(appData.app_token + "add2homeClosed")) {
                    return;
                }
                addToHome.show();
            }, 10000);
        });
        $(document).on("touchstart", "#addToHomeScreen", function () {
            addToHome.close();
            ClientCache.setItem(add2homeKey, true);
        });
        $(document).on("click", ".addToHomeClose", function () {
            ClientCache.setItem(add2homeKey, true);
        });
    });
})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/Instrumentation.js

try{
;(function() {

    if (window.isDesignerPreview) return;

    var appId;
    var Event = function(category, action, label, props) {

        var identity = JSON.parse(localStorage.getItem('unique_token'));
        var identityValue = identity ? identity.value : '';

        props=props || {};


        props.urlParams=_urlParams;
        props.appId = props.appId || appId;


        return {
            type    : 'events',
            source  : 'htmlClient',
            category : category,
            action: action,
            label: label,
            identity: identityValue,
            sessionId: ComManager.sessionId(),
            props: props
        };
    };

    var LaunchEvent = function(app) {
        var source = ((Capriza.isPhonegap || Capriza.cordova) ? "native" : (Capriza.device.isMobile ? "mobile-html" : "web-html"));

        var props = {
            appId: app.app_id,
            appName: app.app_name,
            source: source,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            connectionType: navigator.connection && navigator.connection.type
        };

        if (navigator.standalone) {
            props.standalone = navigator.standalone;
        }

        var identity = JSON.parse(localStorage.getItem('unique_token'));
        Capriza.runId = (identity ? String(identity.value).slice(0,3) : "aaa") + ":" + Date.now();

        return Event('runs', 'run', Capriza.runId, props);
    };

    var PerfEvent = function(options) {
        Logger.debug('PerfEvent Started');
        var props = {
            measures: take.toJSON(),
            transport: ComManager.transport
        };

        $.extend(props, options);

        return Event('performance', 'sample', Capriza.runId, props);
    };

    var TraceEvent = function(data) {
        return Event('instrumentation', 'events', Capriza.runId, data);
    };

    function sendStats(events, sync) {
        var data = _.isArray(events) ? events : [events];

        var stats = {
            version : '1.1',
            data: data
        };

        var statsStr = JSON.stringify(stats);

//        console.log('sending '+statsStr+' to '+Config.napiUrl+'/api/stats/events');
        if (window.devMode) return;

        $.ajax({
            type: 'POST',
            url: Config.napiUrl+"/stats/events",
            data: statsStr,
            contentType: 'application/json',
            dataType: 'json',
            async: !sync
        });
    }

//    Capriza.runId = (identity ? identity.slice(0,3) : "aaa") + ":" + Date.now();

    /****************************************/
    /*** Chapter 1: "I have run this app" ***/
    /****************************************/

    Dispatcher.on("runner/run", function(app) {
        appId = app.app_id;
        sendStats(LaunchEvent(app));
    });



    /************************************************************************/
    /*** Chapter 2: "This is the time that it took for this app to start" ***/
    /************************************************************************/

// Take two minute to send performance stats on app launch.
    var timeoutDelay = 120000;
    var launchTimeout = setTimeout(function() {
        launchTimeout = undefined;
        take("timeout");
        sendStats(PerfEvent({startReason: "timeout"}));
    }, timeoutDelay);

    Dispatcher.on('application/firstContext identity/show', function(data){
        if (!window.Capriza.firstMobilePageTime){
            window.Capriza.firstMobilePageTime = Date.now();
            take("firstMobilePage");
        }
        take('firstVisiblePage');
        var firstVisiblePageTime = take.firstVisiblePage-take.start;
        var appCache = window.applicationCache;

        Logger.debug('first visible page, engineFirstVisiblePage = ' + data.timeFromAccessURL+
            ', firstRun: '+!!Capriza.firstRun+
            ', firstVisiblePage: '+firstVisiblePageTime+
            ', appCacheStatus: '+appCache.status);

        Capriza.appStarted = true;
        clearTimeout(launchTimeout);
        launchTimeout = undefined;
        sendStats(PerfEvent({startReason: take.startReason, engineFirstVisiblePage: data.timeFromAccessURL, firstRun: Capriza.firstRun, appCacheStatus: appCache.status}));

        if (shouldShowTime()) {
            setTimeout(showTimeMsg, 4000);
        }

    });

    window.addEventListener("unload", function() {
        if (launchTimeout && !Capriza.appStarted) {
            take("unload");
            sendStats(PerfEvent({startReason: "unload"}), true);
        }
    });

    /************************************************************************/
    /*** Chapter 3: "" ***/
    /************************************************************************/


    var events = [
         "social/cmenu/clicked"
        ,"social/facebook/clicked"
        ,"social/twitter/clicked"
        ,"extension/loaded"
    ];

    var eventHappenings = [];

    _.each(events, function(event) {
        Dispatcher.on(event, function(data) {
            eventHappenings.push({ type: event, data: data });
        });
    });

    setInterval(function() {
        if (eventHappenings.length > 0) {
            sendStats(eventHappenings.map(function(event) {
                return TraceEvent(event);
            }));
            eventHappenings = [];
        }
    }, 60000);


    function shouldShowTime() {
        return !isTimeMsgDisabled() && isMsgEnv();
    }

    function isTimeMsgDisabled() {
        return window.appData && window.appData.config ? window.appData.config.disableTimeMsg : false;
    }

    function isMsgEnv() {
        //return window.location.host.indexOf("zappdev") > -1;
        return false;
    }

    function showTimeMsg() {
        if ($('.mvp.active').length > 0) return;
        var timeToFirstPage = parseFloat((take.firstPage - take.start) / 1000).toFixed(2);
        Logger.debug('showing time message');
        Dispatcher.trigger('message/showCustom', {message: "First page took " + timeToFirstPage + "s to load", shouldShowLoadingIndicator: false});
        setTimeout(function () {
            Dispatcher.trigger('dialog/hide')
        }, 4000);
    }


})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/SideMenu.js

try{
/**
 * Created by maayankeenan on 2/16/15.
 */
(function() {
    var eventTrigger = "click";//Capriza.device.isMobile ? "touchend" : "click";
    var constAnimTimeDiff = 200;
    var menu;
    var isInitialized;
    Dispatcher.on("app/init", function() {

        //if (!window.appData && !window.isDesignerPreview) {
        //    Logger.debug('Side menu requires api connection');
        //    return;
        //}

        Dispatcher.on('sideburger/hide', function() {
            $('.viewport').addClass('no-settings');
        });

        var noMenuByFlag = window.appData && window.appData.config && window.appData.config.destroyGears;

        if(noMenuByFlag) {
            $('.viewport').addClass('no-settings');
            return;
        }
    });

    Dispatcher.on("sideburger/show", function($header) {
        var $sideburger = $("#side-burger",".page.active, .page.disabled");
        if($header.find('#side-burger').length == 0){
            $sideburger = $('<div id="side-burger" class="side-burger" role="button" aria-label="Open Side Menu"><i class="icon-sideburger"></i></div>');
            $header.prepend($sideburger);
        }

        var $headerOverlay = $("#header-overlay");
        if ($headerOverlay.length && !$headerOverlay.hasClass(".side-menu")){
            $("#side-menu").removeClass("active open transitioning").addClass("close");
        }

        var menu = $('#side-menu').data('pageView');

        function beforeToggle() {
            $sideburger = $("#side-burger",".page.active, .page.disabled");
            menu.toggleMenu("click");
        }

        if (menu && $sideburger.length) {
            $sideburger[0].addEventListener('click', beforeToggle);
        }
    });

    Capriza.Views.SideMenu = Backbone.View.extend({
        tagName: "div",
        id: 'side-menu',

        initialize : function() {
            var self = this;
            _.bindAll(this, "toggleMenu", "overlayToggleEnd");

            this.$viewportOverlay = $('<div id="viewport-overlay"></div>').appendTo($('.viewport'));

            this.isSignoutActive = false;

            Dispatcher.on("identity/addSignOut", function () {
                self.isSignoutActive = true;
                self.configureMenu();
            });

            Dispatcher.on("identity/removeSignOut", function () {
                self.isSignoutActive = false;
                self.configureMenu();
            });

            Dispatcher.on('page/change/beforeTransition', function() {
                if (self.$el.hasClass('open')) {
                    self.toggleMenu("page-change");
                }
            });

            Dispatcher.on("appName/change", function() {
                self.$("#settings-title>.inner-text").text(Utils.getAppName());
            });

            Dispatcher.on("app/online", this.connectionStatusChanged, this);
            Dispatcher.on("app/offline", this.connectionStatusChanged, this);

            this.blockDisplay  = function(e) {
                e.preventDefault();
                e.stopPropagation();
                self.toggleMenu("block-display");
            };
        },

        render : function() {
            var html =
                Handlebars.templates.sidemenu({appName: Utils.getAppName()});

            this.$el = $(html);
            $('.viewport').append(this.$el);
            this.initSettingsMenu();
            this.initButtonsLogic();
            this.configureMenu();
            this.initDrag();
            this.heroMode();
        },

        refreshSignOut: function(){
            var html =
                Handlebars.templates.sidemenu({appName: Utils.getAppName()}),
                zappSignOut = this.$el.find("#settings-sign-out"),
                templateSignOut = $(html).find("#settings-sign-out");
            if (!zappSignOut.length || !templateSignOut.length) return;
            zappSignOut.text(templateSignOut.text());
        },

        initSettingsMenu : function() {
            if (!Capriza.device.firefox) {
                var $v = this.$(".settings-item-icon[data-icon]");
                $v.each(function(item){
                    $(this).attr({role:"button",'aria-label': this.nextElementSibling.innerText});
                });
                $v.on("touchstart touchend", function () {
                    $(this).toggleClass(
                        this.dataset.icon + " " + this.dataset.iconActive);
                });
            }

            if(!Capriza.isStore) {
                this.$('.settings-profile').css('display', 'none');
            } else {
                this.setPersonalInfo();
            }
        },

        setPersonalInfo: function(){
            var _this = this;
            window.Capriza.avatarAPI.getUserImage(function(src){
                if (!src) return;

                _this.$('.avatar-container').css({"display":"block"})[0].src = src;
                _this.$('.profile-pic i').hide();
            });

            _this.$('.settings-profile .settings-item-title').text(ClientCache.getItem("userEmail"));
        },

        initButtonsLogic  : function() {
            //var constAnimationFinished = constAnimTimeDiff * 2,
            var sendFeedback = $("#settings-send-feedback"),
                feedbackPage = undefined;

            sendFeedback.on(eventTrigger, function(e){
                feedbackPage = feedbackPage || new Capriza.Views.SideMenu.FeedbackPage();
                try{
                    Utils.reportInteraction({
                        element: "Feedback (Side Menu)",
                        interaction: "Send Feedback",
                        controlPath: "#settings-send-feedback>div"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Side menu send feedback interaction");
                }
                e.preventDefault();
                feedbackPage.$el.addClass('transitioning');
                executeFunc(function(){
                    feedbackPage.render();
                    feedbackPage.$el.removeClass('transitioning');
                    self.toggleMenu("feedback");
                });
            });

            var closeApp = $("#settings-close-zapp");
            $.capriza.fastClick(closeApp[0]);
            var self = this;
            closeApp.on(eventTrigger, function(){
                try{
                    Utils.reportInteraction({
                        element: "Close Zapp (Side Menu)",
                        interaction: "Close Zapp",
                        controlPath: "#settings-close-zapp>div"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Side menu Close app interaction");
                }

                self.toggleMenu();

                // First close the side menu, than exist the zapp. we don't wait for the side menu animation to end because closing the zapp taking longer than the animation
                // (if this is not the case in the future just listen to Dispatcher.on('sidemenu/animationended')
                Dispatcher.trigger('app/close');

            });

            var signOut = $("#settings-sign-out");
            signOut.on(eventTrigger, function(){
                try{
                    Utils.reportInteraction({
                        element: "Sign Out (Side Menu)",
                        interaction: "click",
                        controlPath: "#settings-sign-out>div"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Side menu signout interaction");
                }
                executeFunc(function() {
                    Dispatcher.trigger("identity/host/logout");
                    self.toggleMenu("signout");
                });
            });

            var settingsPage = new Capriza.Views.SettingsPage();

            var zappSettings = $("#settings-zapp-settings");
            zappSettings.on(eventTrigger, function () {
                try{
                    Utils.reportInteraction({
                        element: "Settings (Side Menu)",
                        interaction: "Open Settings",
                        controlPath: "#settings-zapp-settings>div"
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Side menu settings interaction");
                }
                settingsPage.$el.addClass('transitioning');
                executeFunc(function () {
                    settingsPage.render();
                    settingsPage.$el.removeClass('transitioning');
                    self.toggleMenu("settings");
                });
            });

            function executeFunc(func){
                if (!self.$el.hasClass('transitioning')){
                    window.setTimeout(function(){
                        func();
                    }, 1);
                }
            }

            // $('.settings-item', this.$el).on(eventTrigger, this.toggleMenu);
        },
        overlayToggleEnd: function(e){
            clearTimeout(this.clearTransitionTimeout);
            Dispatcher.trigger("sidemenu/transitionEnd");
            this.$el.removeClass("sidemenu-transitioning");
            this.$el[0].style["transition-duration"] = "";
            this.$el[0].style["transition-timing-function"] = "";
            $("#viewport-overlay").removeClass("transitioning");
            $('.side-burger').removeClass('clicked');
            Dispatcher.trigger('sidemenu/animationended');
        },

        toggleMenu : function(method) {
            var container = $('.viewport .page.active .header');
            if (container.hasClass('no-settings')) return;

            //bad code - no choice for now...
            $('#start-page').remove();
            if (container.hasClass('no-settings')) return;
            method = method || "click";
            Logger.debug("[SideMenu] Toggling side menu using "+ method);
            var shouldOpenSideMenu = !this.$el.hasClass("sidemenu-opened");
            this.$el.off(Utils.transitionEnd, this.overlayToggleEnd).on(Utils.transitionEnd, this.overlayToggleEnd);
            this.$el.addClass("sidemenu-transitioning");
            //this.$viewportOverlay.addClass("transitioning");
            this.clearTransitionTimeout = setTimeout(self.overlayToggleEnd, 400);
            if (shouldOpenSideMenu){
                try{
                    Utils.reportInteraction({
                        element: "SideMenu",
                        interaction: "click",
                        controlPath: "#side-burger .icon-sideburger",
                        additionalData: "open side menu using "+method
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Open side menu interaction");
                }
                this.$el.removeClass("close");
                this.$el.addClass("active sidemenu-opened");
                this.$viewportOverlay.on(eventTrigger, this.blockDisplay);
                Utils.viewportOverlayForElement("side-menu");
            } else {
                try{
                    Utils.reportInteraction({
                        element: "SideMenu",
                        interaction: "click",
                        controlPath: "#viewport-overlay.active.side-menu",
                        additionalData: "closing side menu using "+method
                    });
                } catch(e){
                    Logger.info("[UserInteraction] Exception on report Closing side menu interaction");
                }
                this.$el.removeClass("active sidemenu-opened");
                this.$el.addClass("close");
                this.$viewportOverlay.off(eventTrigger, this.blockDisplay);
                Utils.removeViewportOverlayForElement("side-menu");
            }
            this.$el[0].style.transform = "";
            document.getElementById("viewport-overlay").style["background-color"] = "";
        },

        configureMenu : function() {
            var closeZapp = $("#settings-close-zapp", this.$el),
                signOut = $("#settings-sign-out", this.$el),
                sendFeedback = $("#settings-send-feedback", this.$el),
                noFeedbackByFlag = window.appData && window.appData.config && window.appData.config.destroyFeedback;

            if (noFeedbackByFlag) {
                sendFeedback.addClass('inactive');
            }

            if (Capriza.isStore){
                closeZapp.removeClass('inactive');
            } else {
                closeZapp.addClass('inactive');
            }

            if(window.isDesignerPreview){
                closeZapp.attr('disabled', true);
                sendFeedback.attr('disabled', true);
            }

            if (this.isSignoutActive) {
                this.refreshSignOut();
                signOut.removeClass('inactive');
            } else {
                signOut.addClass('inactive');
            }
            this.connectionStatusChanged();

            var container = $('.viewport .page.active .header').addClass('no-settings');
            var areThereActiveItems = $('.settings-item:not(.inactive, .settings-profile)').length > 0;

            areThereActiveItems ? container.removeClass('no-settings') : container.addClass('no-settings');
        },

        // Enables/disables network-dependant items in SideBar
        connectionStatusChanged: function () {
            var isOnline = Capriza.Connection ? Capriza.Connection.isOnline
                : Utils.isNavigatorOnline();

            isOnline ? this.$(".network-dependant").removeAttr("disabled")
                : this.$(".network-dependant").attr("disabled", true);

            if (window.isDesignerPreview) {
                $("#settings-send-feedback").attr("disabled", true);
            }
        },

        prepareForDrag : function(step){
            Logger.debug("side menu - prepare for drag");
            if (this.$el.hasClass("sidemenu-transitioning") || !step || !step.pageX) return;
            if ((!this.$el.hasClass("sidemenu-opened") && step.pageX < 40 && step.direction == "right") ||
                (this.$el.hasClass("sidemenu-opened") && step.pageX < (this.$el.width()+50) && step.direction == "left")){
                //just in case the user is focus on an input field need to blur in order to dissmiss the keyboard
                document.activeElement.blur();
                Logger.debug("side menu - set dragging");
                this.$el.addClass("dragging");
            }
        },
        cancelDrag: function(curItemX, element, step, transformProperty){
            Logger.debug("side menu - cancel dragging");


            this.$el.removeClass("dragging");
            this.clearTransitionTimeout = setTimeout(this.overlayToggleEnd, 400);
            this.$el.off(Utils.transitionEnd, this.overlayToggleEnd).on(Utils.transitionEnd, this.overlayToggleEnd);
            //this.$el[0].style["transition-timing-function"] = "cubic-bezier(0,0,0.1,1.2)";

            this.$el.addClass("sidemenu-transitioning");
            //this.$viewportOverlay.addClass("transitioning");
            this.$el.removeClass("dragging");
            this.$el[0].style[transformProperty] = "";
            //this.$viewportOverlay[0].style["background-color"] = "";
        },
        draggingMethod: function(step,transformProperty){
            if (this.$el.hasClass("dragging")){
                var elWidth = this.$el.width();
                if (elWidth < step.pageX){
                    step.pageX = elWidth;
                }
                this.$el[0].style[transformProperty] = "translate3d("+step.pageX+"px,0,0)";
                // 0.36 is the final opacity for the viewport-overlay from _header.scss
                //if (!Capriza.device.android) {
                //    var opacity = (step.pageX / elWidth);
                //    this.$viewportOverlay[0].style["background-color"] = "rgba(0,0,0," + (opacity * 0.36) + ")";
                //}
            }
        },
        swipingRight: function(element, velocity, distance){
            if (this.$el.hasClass("sidemenu-opened")){
                this.swipingMethod(element, velocity, distance);
            } else {
                this.cancelDrag(null, null, null, $.capriza.transformProperty);
            }
        },
        swipingLeft: function(element, velocity, distance){
            if (!this.$el.hasClass("sidemenu-opened")){
                this.swipingMethod(element, velocity, distance);
            } else {
                this.cancelDrag(null, null, null, $.capriza.transformProperty);
            }
        },
        swipingMethod: function(element, velocity, distance){
            if (this.$el.hasClass("dragging")){
                this.$el.removeClass("dragging");
                //var duration = 450 / (this.$el.width() / (this.$el.width() - distance)); // remaining distance
                //if ( velocity > 0.1) {
                //    duration *= ((1-velocity) + 0.4);
                //}
                //this.$el[0].style["transition-duration"] = duration + "ms" ;
                //this.$el[0].style["transition-timing-function"] = "cubic-bezier(0,0,0.1,1.1)";
                this.toggleMenu("swipe");
            }
        },
        disableDrag : function(){
            return this.$el.hasClass("sidemenu-transitioning");
        },

        initDrag : function() {
            var self = this;
            var shouldCompleteAction = function(velocity, curXAbs){
                var threshold = 0.4;
                Logger.log("should complete action - velocity: "+ velocity+", curxAbs: " +curXAbs);
                return (velocity > 0.3 || curXAbs >= self.$el.width()*threshold);
            };

            var dragOptions = {
                swipeRight : this.swipingRight.bind(this),
                swipeLeft : this.swipingLeft.bind(this),
                shouldCompelteAction: shouldCompleteAction.bind(this),
                dragCallback: this.draggingMethod.bind(this),
                onCancel: this.cancelDrag.bind(this),
                onStart: this.prepareForDrag.bind(this),
                isSwipeDisable: this.disableDrag.bind(this)
            };

            $(".viewport").drag(dragOptions);
        },

        initSwipe : function() {
            var self = this;
            console.log('side menu initSwipe started');
            var canGoLeft, canGoRight, noDrag;
            var swipeLeft  = function() {
                if(noDrag || !canGoRight) return;
                self.toggleMenu("swipe");
            };

            var swipeRight  = function() {
                if(noDrag || !canGoLeft) return;
                self.toggleMenu("swipe");
            };

            var onStart = function() {
                if ($('.page.active').length) {
                    canGoRight = self.$el.hasClass('close') && $('.page.active').position().left < self.$el.width();
                    canGoLeft = self.$el.hasClass('open') && $('.page.active').position().left > 0;
                    noDrag = $('.page.active').hasClass('swiping') || self.$el.hasClass('transitioning');
                }

            };

            var swipeOptions = {swipeRight: swipeRight, swipeLeft: swipeLeft,
                onStart: onStart};

            $(".context-page.active").swipe(swipeOptions);

            Dispatcher.on('page/change/after', function (options) {
                $(options.toPage, '.page.active').swipe(swipeOptions);
            });
        },
        heroModeOn: function(){
            try{
                Utils.reportInteraction({
                    element: "Hero Mode (Side Menu)",
                    interaction: "On",
                    controlPath: "#hero-mode"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Side menu hero mode on interaction");
            }
            Logger.info("[Side-Menu] Hero Mode is on");
            this.$el.addClass("hero-on");
            Capriza.heroMode.on = true;
            Dispatcher.trigger("heroMode/on");
        },
        heroModeOff: function(){
            try{
                Utils.reportInteraction({
                    element: "Hero Mode (Side Menu)",
                    interaction: "Off",
                    controlPath: "#hero-mode"
                });
            } catch(e){
                Logger.info("[UserInteraction] Exception on report Side menu hero mode off interaction");
            }
            Logger.info("[Side-Menu] Hero Mode is off");
            Capriza.heroMode.counter = 0;
            Capriza.heroMode.on = false;
            this.$el.removeClass("hero-on");
            Dispatcher.trigger("heroMode/off");
        },
        heroMode: function(){
            Logger.debug("[Side-Menu] Preprare Hero Mode");
            Capriza.heroMode = {};
            Capriza.heroMode.counter = 0;
            if (Capriza.zappInfo && Capriza.zappInfo.med_version){
                $("#med-ver", "#zapp-details").text(Capriza.zappInfo.med_version);
                $("#zapp-ver", "#zapp-details").text(Capriza.zappInfo.u_app_version);
            }
            var self = this;
            var eventToListen = Capriza.device.isMobile ? "touchstart" : "click";
            this.$el.on(eventToListen, function(e){
                var page = (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0]) || e;
                if (page && page.pageX < 75 && page.pageY < 75){
                    if (++Capriza.heroMode.counter == 3 ){
                        self.heroModeOn();
                    } if (Capriza.heroMode.counter == 6){
                        self.heroModeOff();
                    }
                }
            });
            $.capriza.fastClick($("#settings-reload-zapp").on(eventTrigger, function(){
                Logger.info("[Side-Menu] Reload from side menu reload (Hero Mode)");
                Utils.reload();
            })[0]);

        }

    });

    Capriza.Views.SideMenu.init = function() {
        if(!isInitialized) {
            var menu = new Capriza.Views.SideMenu();
            menu.render();
            menu.$el.data('pageView', menu);
            isInitialized = true;

            $("#side-burger",".page.active, .page.disabled").on('click', menu.toggleMenu);
        }
    };


    (function(){
        function closeZapp(data){
            $.capriza.showLoadingMsg(true);
            Dispatcher.trigger("app/beforeClose");
            var param = {fromZapp:true};
            if (data && typeof data === "object") {
                $.extend(param, data);
            }
            setTimeout(function(){location.assign(_urlParams.storeUrl+"#?"+ $.param(param))}, 20);
        }

        Dispatcher.on("app/close", function(data){
            if ($('#passcode-page').hasClass('active')) {
                Dispatcher.on("passcode/hide", function(){
                    closeZapp(data);
                });
            } else {
                closeZapp(data);
            }
        });
    }());

    Capriza.Views.SideMenu.FeedbackPage = Backbone.View.extend({
        id: "feedback-page",
        tagName: "div",
        className: "page ignores-header",

        initialize: function () {
            _.bindAll(this, "back", "done", '_leave');
            var options = {
                talkToUs: Capriza.translator.getText(Capriza.translator.ids.talkToUs),
                includeInfo: Capriza.translator.getText(Capriza.translator.ids.includeInfo),
                helpUsScreenshot: Capriza.translator.getText(Capriza.translator.ids.helpUsScreenshot),
                describeIssue: Capriza.translator.getText(Capriza.translator.ids.describeIssue)
            };
            this.$el.append(Handlebars.templates["send-feedback"](options)).appendTo(".viewport");
            var navLeft = $("#cancel-feedback", this.$el),
                navRight = $("#send-feedback", this.$el);

            navLeft.on('click', this.back);
            navRight.on('click', this.done);
            Dispatcher.on('feedback/close', this._leave);
        },

        render: function () {
            var _this = this;
            _this.$el.addClass("slideup in active");
            _this.$el.one("animationend webkitAnimationEnd", function () {
                _this.$el.removeClass("slideup in");
                $(".nonmobile-wrap").removeClass("transitioning");
                if (Capriza.heroMode && Capriza.heroMode.on){
                    _this.$("textarea").val("#rnd #hero ")
                } else if (_this.$("textarea").val() == "#rnd #hero "){
                    _this.$("textarea").val("");
                }
                if (!Capriza.device.isMobile) {
                    _this.$("textarea").focus();
                }
                Dispatcher.trigger('sidemenu/feedback/open');
            });
            $(".nonmobile-wrap").addClass("transitioning");

            if (Capriza.device.stock){
                var textarea = $('textarea', this.$el);
                textarea.height(this.$el.height() - textarea.position().top - 88);
            }
        },

        back: function () {
            this._leave();
        },

        done: function () {

            var textArea = this.$("textarea");
            var message = textArea.val();
            this.$el.find('textarea').val('');

            this._leave();

            setTimeout(function () {
                var feedbackOptions = {collectLogs: $('#feedback-allow-logs').prop('checked')};
                Utils.showUnimessage({type: "progress", messageText: Capriza.translator.getText("sendingFeedback")}, false, true, false, 4500);

                Capriza.Feedback.send(message, feedbackOptions)
                    .fail(_.bind(Utils.updateUnimessage, this, {type: "error", messageText: Capriza.translator.getText("feedbackProblem")}, null, true, true, 3500))//feedbackProblem -  "Problem sending feedback, please try again."
                    .done(_.bind(Utils.updateUnimessage, this, {type: "", messageText: Capriza.translator.getText("feedbackSent")}, null, true, true, 3500)); //feedbackSent replace "Feedback received, thanks."
            }, 500);
        },

        _leave: function () {
            var _this = this;
            _this.$el.addClass("slideup reverse out");
            _this.$el.one("animationend webkitAnimationEnd", function () {
                _this.$el.removeClass("slideup reverse out active");
                $(".nonmobile-wrap").removeClass("transitioning");
                Dispatcher.trigger('sidemenu/feedback/close');
            });
            $(".nonmobile-wrap").addClass("transitioning");
        }
    });
}());

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/EntryPoint.js

try{
;
(function () {

    window.Dispatcher.on("app/loaded", function () {

        Logger.debug('entry point starts with ua '+navigator.userAgent+' location '+window.location);
        if (navigator.connection && navigator.connection.type) {
            Logger.debug('Connection type is '+navigator.connection.type);
        }
        Capriza.start = function () {
//            console.log('Capriza starts');
            if (!window.appData) {
//                console.log('app data is null');
                return;
            }

            if (!window.appData.error_codes) {
                logger.log('run normally');
                Runner.run({ authenticate: false });
            } else {
                if (window.appData.error_codes[0] == errorCodes.RUNTIME_NO_USER.id) {
                    logger.log('need to first authenticate');
                    Runner.run({ authenticate: true });
                }

                else {
                    var errorCode = window.appData.error_codes[0];
                    var errorObj = window.errorCodes.getErrorObjForId(errorCode);

                    if (errorObj && errorObj.message) {
                        Dispatcher.trigger("mobile/error", errorObj.message);
                    }
                    else {
                        Dispatcher.trigger("mobile/error",window.appData)
                    }
                }
            }
        };


        $.capriza.viewportHeight = function () {
            return Capriza.fullScreen ? window.innerHeight : $(".viewport").height();
        };


        if (Capriza.device.stock) $(".viewport").addClass("stock");

        //Capriza.loadingCenter = $("<div>").loadingCenter();
        Dispatcher.trigger("app/init");

        // initialize first page

        if ($('.context-page.active').length === 0 && $('#start-page').length === 0) {
            $.capriza.activePage = $([]);
            var startPage = new Capriza.Views.PageView({ id: "start-page" }).render();
            startPage.show({ transition: "none" });
        }



        if (Utils.caprizaMode === "ShellMode") {
            $("<div>").loadingShellMode();
        } else {
            //$("<div>").loadingHeader();
        }


        $(document).on("beforepagechange", function () {
            $.capriza.hideLoadingMsg();
        });

        var self;

        $(document)
            .on("mousedown touchstart", ".clickable", function() {
                self = this;
                $(".scrolling-area").one("scroll.onclickablescroll", function() {
                    self.classList.add("clicked-canceled");
                });
                this.classList.add("clicked");
            })
            .on("mousemove touchmove", ".clickable", function(e) {
                this.classList.remove("clicked");
            })
            .on("mouseup touchend touchcancel", ".clickable", function() {
                $(".scrolling-area").off(".onclickablescrol");
                this.classList.remove("clicked");
                this.classList.remove("clicked-canceled");
            });


        //android keyboard focus fix
        if (!Capriza.device.ios) {
            $(document).on("change", "select", function (e) {
                $(e.currentTarget).blur();
            });

            $(document).on("keypress", "input", function (e) {
                if (e.keyCode == 13) {
                    $(e.currentTarget).blur();
                }
            });
        }

//        console.log('about to capriza start');

        Capriza.start();


    });



    window.Dispatcher.on("identity/capriza/logout", function () {
        $.getJSON(Config.apiUrl + "/catalog/auth/logout.json")
            .error(function (msg) {
                Logger.error("error while logging out: " + msg);

            }).complete(function () {
                Utils.reload();
            });
    });




})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/new/Handlers.js

try{
;(function () {
    Capriza.EngineApi.Handlers = {
        newPage: function (response) {

            Logger.debug('handlers newPage started');

            var transition = Capriza.Model.firstContext ? undefined : "none";

            Dispatcher.trigger('header/errors/remove');
            Dispatcher.trigger('login/after', response.page);

            var page = response.page.login ? new Capriza.Model.LoginPage(response.page) : response.cached ? new Capriza.Model.MVPage(response.page) : new Capriza.Model.ContextPage(response.page);
            if (response.page.login && Capriza.LoginManager.tryToPerformAutoLogin(page, transition)) return;

            var currPageView = $.capriza.activePage && $.capriza.activePage.data("pageView") && $.capriza.activePage.data("pageView");
            var currPageModel = currPageView && currPageView.model;
            Logger.debug('[Handlers newPage] page model compare started');
            var isSamePage = currPageModel && Capriza.Model.ContextPage.compare(page, currPageModel);
            Logger.debug('[Handlers newPage] page model compare ended');

            page.mvp = response.cached;
            page.mvppp = response.mvppp;
            var pageView = response.page.login ? new Capriza.Views.LoginPage({model: page}) :
                page.mvp ? new Capriza.Views.MVPageView({model: page}) :
                    response.page.cnf ? new Capriza.Views.CNFPageView({model: page}) :
                        new Capriza.Views.ContextPage({model: page});

            Logger.debug('[Handlers newPage] pageView created');
            if (isSamePage) {
                if(currPageView.state) {pageView.state = currPageView.state;}
            }

            Logger.debug('[Handlers newPage] going to render pageView');
            pageView = pageView.render();

            var uniqueId = page.get("uniqueId"), uiState = Capriza.Views.uiState, pageUiState = uiState["page" + uniqueId];
            take("pageInfo", {
                    type: "pageInfo",
                    uniqueId: uniqueId,
                    mvp: page.mvp,
                    login: response.page.login,
                    cnf: response.page.cnf,
                    duration: Capriza.EngineApi.Handlers.calcPageDuration(),
                    name: response.page.name,
                    source: 'pageInfo'
                }
            );

            var tabController;

            if (pageUiState) {
                Logger.debug("[newPage] uiState for page uniqueId=" + uniqueId + ": " + JSON.stringify(_.omit(pageUiState, "page")));
            } else {
                Logger.debug("[newPage] no uiState for page uniqueId=" + uniqueId);
            }

            if (page.get("keepUiState") && pageUiState) {
                if (pageUiState.drillId) {
                    if (page.containsControl(pageUiState.tableId)) {
                        Logger.debug("[newPage] keeping UI state for drill page");
                        pageView.show({transition: "none"});
                        pageView.getView(pageUiState.tableId).keepInDrill(pageUiState.drillId, pageUiState.drillIndex);
                        delete pageUiState.drillId;
                        delete pageUiState.tableId;
                        return;

                    } else {
                        Logger.debug("[newPage] NOT keeping UI state for drill page");
                        delete pageUiState.drillId;
                        delete pageUiState.tableId;

                    }
                } else {

                    if (pageUiState.selectedTab !== undefined) {

                        Logger.debug("[newPage] might keep UI state for tab, if I find it");
                        // when deleting pageSplit, the model of the body already contains controls without the tabController, so we need to check:
                        tabController = Utils.findFirstOfType(Capriza.Model.Control.getById(page.get("root")[0]), 'tabController');
                        if (tabController) {
                            Logger.debug("[newPage] keeping UI state for tab");
                            pageView.getView(tabController.get("id")).setSelectedTab(pageUiState.selectedTab);
                        }

                        if (pageUiState.scrollPosition) {
                            Logger.debug("[newPage] keeping UI state for scroll position (in tab)");
                            Dispatcher.once("page/change/beforeTransition", function () {
                                setTimeout(function () {
                                    Logger.debug("[newPage] actually keeping UI state for scroll position");
                                    pageView.getView(tabController.get("id")).getSelectedTabContent()[0].scrollTop = pageUiState.scrollPosition;
                                    delete pageUiState.scrollPosition;
                                    delete pageUiState.page;
                                }, 0);
                            });

                        }
                    }
                    else if (pageUiState.scrollPosition) {
                        if (Capriza.Model.ContextPage.compare(pageUiState.page, page)) {

                            Logger.debug("[newPage] keeping UI state for scroll position (not in tab, passed compare)");
                            Dispatcher.once("page/change/beforeTransition", function () {
                                setTimeout(function () {
                                    pageView.scrollTo(0, pageUiState.scrollPosition);
                                    delete pageUiState.scrollPosition;
                                    delete pageUiState.page;
                                }, 0);
                            });

                        } else {
                            Logger.debug("[newPage] NOT keeping UI state for scroll position (not in tab, didn't pass compare)");
                            delete pageUiState.scrollPosition;
                            delete pageUiState.page;

                        }
                    }
                }
            }

            // check if this is the same context, and if so maintain the same scroll position
            if (currPageModel) {
                if (isSamePage) {
                    var currScrollPosition = $.capriza.currentScrollPosition();
                    Logger.debug("[newPage] got new page with the same context and controls (currScrollPosition=" + currScrollPosition + ")");
                    transition = "none";
                    Dispatcher.once("page/change/beforeTransition", function (e) {
                        Logger.debug("[newPage] keeping UI state for scroll position (same page)");
                        if (e.toPage.data("pageView") === pageView) {
                            pageView.scrollTo(0, currScrollPosition);
                        }
                    });

                    //TODO: we should definately refactor these +-40 lines!
                    tabController = Utils.findFirstOfType(Capriza.Model.Control.getById(page.get("root")[0]), 'tabController');
                    if (tabController && pageUiState && pageUiState.selectedTab) {
                        Logger.debug("[newPage] keeping UI state for tab (same page)");
                        pageView.getView(tabController.get("id")).setSelectedTab(pageUiState.selectedTab);
                    }
                }

                if (currPageModel.tableDrill && page.get("keepUiState")) {

                    Logger.debug('[newPage] current page is in drill');

                    var rowControlId = currPageModel.get("rowControlId"), tableId = currPageModel.get("tableId");

                    var tableIdInArray = Capriza.Model.Control.getById(page.get("root")[0]).getTablesInGroup();

                    if (tableIdInArray.indexOf(tableId) > -1) {

                        Logger.debug('[newPage] pushing the newpage and keeping in drill');

                        $.capriza.pages.push(pageView.$el);
                        pageView.getView(tableId).keepInDrill(rowControlId, currPageModel.get('parentPage').drillIndex);

                        return;
                    }
                }
            }

            // in case of a cdialog keep the new page, but don't show it
            if ($.capriza.activePage && $.capriza.activePage.hasClass('cdialog')) {
                $.capriza.pages.push(pageView.$el);
            } else {

                if (Utils.isCachedMVPShown()) {
                    Dispatcher.trigger('mvp/newContentReady', {newOnlinePageView: pageView});
                }
                else {
                    pageView.show({transition: transition});
                }

            }
        },

        modelId: function (response) {
            //Logger.debug("got model Id with: " + response.modelId);
            //Capriza.StateManager.setModelId(response.modelId);
        },

        loadState: function(response) {
            Capriza.StateManager.isSynced = true;

            Dispatcher.trigger("blueprint/removeNewVersionMessage");

            var structureUpdated, newStateStatus;
            if (response.structure) {
                structureUpdated = Capriza.EngineApi.Handlers.addStructure(response);
            }
            var currPageView = $.capriza.activePage && $.capriza.activePage.data("pageView"),
                isCahcedBlueprintShown = Utils.isCachedBlueprintShown(),
                modifiedState = response.state;

            if (!currPageView && $.capriza.activePage &&
                (
                    ($.capriza.activePage.prop("id") && $.capriza.activePage.prop("id").indexOf("dialog") === 0 ) ||
                    $.capriza.activePage.hasClass("mini-browser")
                )){
                if ($.capriza.pages.length < 2){
                    Logger.debug("loadState error - a prompt dialog or mini-browser is displayed and no active page was found.");
                }
                else{
                    currPageView = $.capriza.pages[$.capriza.pages.length - 2].data("pageView");
                }
            }

            checkForSuccessfulLogin(response);

            Capriza.StateManager.restoreDisabled(response.state); // whether it's new state or update state, every control in the state that was ever synthetically disabled should now be restored.

            if (currPageView && currPageView.model && currPageView.model.get("contextId") == response.state.ctxId && !structureUpdated) {
                modifiedState = isCahcedBlueprintShown ? Capriza.EngineApi.Handlers._updateMissingInState(response.state) : modifiedState;
                Capriza.EngineApi.Handlers._updateState(modifiedState);
                isCahcedBlueprintShown && Dispatcher.trigger("blueprint/newContentReady");
                Capriza.StateManager.isCachedBlueprintShown = false;
            }
            else {
                Capriza.EngineApi.Handlers._newState(response);
            }

            //the location of this function should be after addStructure and before update/new State because
            //in case of a zapp without login, we need the structure saved to know if it is a login page, and to determine of we are
            //readyForCache before saveState
            setRequiresLogin(response);
            Capriza.Model.State.saveState(modifiedState.ctxId, modifiedState);

            //First page that is not login should be set as the MVP.
            Capriza.StateManager.checkIfShouldBeMVP(response.state && response.state.ctxId);

            Dispatcher.trigger("blueprint/stateLoaded");
        },

        //for first time run of _updateState when blueprint is shown, we need to set controls that are displayed
        //although no state have been received for them as MISSING
        _updateMissingInState: function (state){

            //go through all controls in the structure that are not in the state, that are not missing
            //and hide them (convert them to missing = true)
            var struct = Capriza.StateManager.structs[state.ctxId];
            var modifiedState = state;
            function updateMissingControlsRecursive(control) {
                if (control.controls)
                    control.controls.forEach(updateMissingControlsRecursive);

                var currentModel = Capriza.Model.Control.getById(control.id);
                //if:
                // 1. the structure of the control is missing = true (the control is not mandatory)
                // 2. and the control does not exist in the state (the first state after blueprint sync) ==> it should be MISSING
                // 3. and the control is not currently missing.
                // 5. and the control is not current an "alt" for a missing control.
                //then: make it "missing" / "alt"
                if (control.missing && currentModel && !state.controls[control.id] && !currentModel.get("missing") && !currentModel.get("altDisplayed")){
                    modifiedState.controls[control.id] = {missing: true};
                }
            }

            updateMissingControlsRecursive(struct);
            return modifiedState;
        },

        _updateState: function (state) {
            var removed = [];
            var addedAndModified = []; //together because of control order priority
            var isRecordMode = (window.isDesignerPreview || window.designerLoaded) && $("html").attr("designer-state") === "simplify";

            var page = Capriza.Model.PageDB[state.ctxId];
            var sortedControlIds = sortStateControls (state);

            sortedControlIds.forEach(function (ctrlId) {
                var control = _.extend({id: ctrlId}, state.controls[ctrlId]);
                var currentModel = Capriza.Model.Control.getById(ctrlId);
                control.isPageUpdate = false;

                if(!currentModel) {
                    Logger.debug('Update state - no control found for id: ' + ctrlId);
                    return;
                }

                if(currentModel.get("type") === "table" || currentModel.get("type") === "tabular") {
                    if(control.phase || control.controls) {
                        control.isPageUpdate = true;
                    } else if(currentModel.get("phase") > 0) {
                        control.phase = undefined;
                        control.isPageUpdate = true;
                    }
                }

                // TODO: if !currentModel -> exception/error
                if (isRecordMode) {
                    var isPhantomStateChanged = false;
                    // in record mode - setting missing/not missing doesn't delete the control - should only display it as phantom/not
                    if (control.missing && !currentModel.get("isPhantom")) {
                        isPhantomStateChanged = true;
                        currentModel.set("isPhantom", true);
                        delete control.missing;
                    } else if (currentModel.get("isPhantom")) {
                        isPhantomStateChanged = true;
                        currentModel.set("isPhantom", undefined);
                    }

                    if (Object.keys(control).length > 1) {
                        addedAndModified.push({processingType: 'modified', control: control});
                    }
                    if (isPhantomStateChanged) {
                        _.each(currentModel.pages, function (page) {
                            page.trigger("page/controlModified", ctrlId);
                        });
                    }
                } else {
                    if (control.missing) {
                        if (currentModel && !currentModel.missing) {
                            if(currentModel.get("alt")) {
                                var newControl = _.extend({}, currentModel.get("alt"), {isPageUpdate: true, altDisplayed: true});
                                addedAndModified.push({processingType: 'modified', control: newControl});
                            } else {
                                removed.push(control);
                            }
                        }
                        else {
                            //already hidden
                            //TODO: update the state in anycase ?
                        }
                    }
                    else {

                        //if the control is curretly missing and re-appearing
                        if (currentModel && currentModel.get("missing") && !currentModel.get('altDisplayed')) {
                            var mergedStructureState = _.extend({}, Capriza.StateManager.getStructureForControl(state.ctxId, control.id), control),
                                newControl = JSON.parse(JSON.stringify(mergedStructureState)); //copy in order not to change to original structure or state
                            delete newControl.missing;
                            addedAndModified.push({processingType: 'added', control: newControl});
                        }
                        else{
                            if (currentModel && currentModel.get('altDisplayed')) {
                                //if it has an "alt" stub control, this should be a pageUpdate in order to remove the stub and re-render the control.
                                control.isPageUpdate = true;
                            }
                            addedAndModified.push({processingType: 'modified', control: control});
                        }
                    }
                }
            });

            if (addedAndModified.length > 0) {

                addedAndModified.forEach(function(controlToProcess){

                    var processingType = controlToProcess.processingType,
                        control = controlToProcess.control;

                    if (processingType == "modified") { //modified:
                        if (control.isPageUpdate) {
                            var id = control.id,
                                oldModel = Capriza.Model.Control.getById(id),
                                mergedStructureState = _.extend({}, Capriza.StateManager.getStructureForControl(state.ctxId, control.id), control),
                                newControl = JSON.parse(JSON.stringify(mergedStructureState)), //copy in order not to change to original structure or state
                                newModel = new Capriza.Model.Control(newControl, {parent: oldModel.parent});
                            //if the new state is not missing, the attr may not be in the structure at all, so we need to "hard" set it.
                            newModel.set('missing', control.missing);
                            if (!control.missing && newModel.get('isPhantom')) newModel.unset('isPhantom', {silent: true});

                            //for tables "missing" has no meaning, "missing" is stated by table.controls = [];
                            //if (newModel.get("type") === "table" || newModel.get("type") === "tabular") newModel.unset("missing", {silent: true});

                            newModel.addPage(oldModel.pages);
                            _.each(newModel.pages, function (page) {
                                page.trigger("page/controlModified", id);
                            });
                        }
                        else {
                            var controlUpdatesMsg = {
                                    mobileControls: [{id: control.id, data: control}]
                                };
                            Capriza.EngineApi.Handlers.controlUpdates(controlUpdatesMsg);
                        }
                    }

                    else { //added
                        var model = Capriza.Model.Control.getById(control.id);
                        var controls = control.controls;
                        delete control.id;
                        delete control.controls;
                        model.set("missing", undefined);
                        model.set(control, {silent: true});
                        //TODO: if !indexToAdd() - > exception/error
                        model.pages[0].trigger("page/controlAdded", model.get("id"), model.parent.get("id"), indexToAdd(model));
                        controls && model.setControls(controls);
                    }

                });
            }

            if (removed.length > 0) {
                removed.forEach(function (ctrl) {
                    var model = Capriza.Model.Control.getById(ctrl.id);
                    model.set("missing", true);
                });
            }

            //#22182 - after all the updates, call page/update/after to call checkLastControl on the page, instead for every control update
            //         in order to allow the table to refresh first.
            //         There was a problem when the table (in MVP) was cached with yesMore = true, but in fact after sync, its actually yesMore=false.
            //         During the update of other control (e.g. back button), the checkLastControl called, and triggered getMoreItems.
            page.trigger("page/update/after");

            var eventData = {pageView: $.capriza.activePage.data("pageView")};
            Dispatcher.trigger("page/update/after", eventData);
        },

        newStateWithStructure: function (pageState, response) {
            response = response || {}; // TODO: better. response might not contain anything, all data on the pageState
            //"newPage"
            //TODO: refactor this to not use old newPage but a new refactored alternative !

            Logger.debug('handlers loading new state');

            var transition = Capriza.Model.firstContext ? undefined : "none";

            Dispatcher.trigger('header/errors/remove');

            var pageModel = response.blueprint ? new Capriza.Model.BlueprintPage(pageState) : new Capriza.Model.ContextPage(pageState);

            //if mvp page is shown, and we have recieved a new state that is not the login page or a failed login
            Utils.isCachedBlueprintShown() && Dispatcher.trigger("blueprint/newContentReady");

            var currPageView = $.capriza.activePage && $.capriza.activePage.data("pageView") && $.capriza.activePage.data("pageView");
            var currPageModel = currPageView && currPageView.model;

            pageModel.blueprint = response.blueprint;

            var pageView = pageState.login ? new Capriza.Views.LoginPage({model: pageModel}) :
                pageModel.mvp ? new Capriza.Views.MVPageView({model: pageModel}) :
                    pageState.cnf ? new Capriza.Views.CNFPageView({model: pageModel}) :
                        pageModel.blueprint ? new Capriza.Views.BlueprintPageView({model: pageModel}) :
                            new Capriza.Views.ContextPage({model: pageModel});

            pageView = pageView.render();
            if (response.blueprint) pageView.$el.addClass("blueprint");

            var uniqueId = pageModel.get("uniqueId"), uiState = Capriza.Views.uiState, pageUiState = uiState["page" + uniqueId];
            take("pageInfo", {
                    type: "pageInfo",
                    uniqueId: uniqueId,
                    mvp: pageModel.mvp,
                    login: pageState.login,
                    cnf: pageState.cnf,
                    duration: Capriza.EngineApi.Handlers.calcPageDuration(),
                    name: pageState.name
                }
            );

            if (pageModel.get("keepUiState") && pageUiState) {
                if (pageUiState.drillId) {
                    if (pageModel.containsControl(pageUiState.tableId)) {
                        Logger.debug("[newPage] keeping UI state for drill page");
                        pageView.show({transition: "none"});
                        pageView.getView(pageUiState.tableId).keepInDrill(pageUiState.drillId, pageUiState.drillIndex);
                        delete pageUiState.drillId;
                        delete pageUiState.tableId;
                        return;

                    } else {
                        Logger.debug("[newPage] NOT keeping UI state for drill page");
                        delete pageUiState.drillId;
                        delete pageUiState.tableId;

                    }
                } else {

                    if (pageUiState.selectedTab !== undefined) {

                        Logger.debug("[newPage] might keep UI state for tab, if I find it");
                        // when deleting pageSplit, the model of the body already contains controls without the tabController, so we need to check:
                        tabController = Utils.findFirstOfType(Capriza.Model.Control.getById(pageModel.get("root")[0]), 'tabController');
                        if (tabController) {
                            Logger.debug("[newPage] keeping UI state for tab");
                            pageView.getView(tabController.get("id")).setSelectedTab(pageUiState.selectedTab);
                        }

                        if (pageUiState.scrollPosition) {
                            Logger.debug("[newPage] keeping UI state for scroll position (in tab)");
                            Dispatcher.once("page/change/beforeTransition", function () {
                                setTimeout(function () {
                                    Logger.debug("[newPage] actually keeping UI state for scroll position");
                                    pageView.getView(tabController.get("id")).getSelectedTabContent()[0].scrollTop = pageUiState.scrollPosition;
                                    delete pageUiState.scrollPosition;
                                    delete pageUiState.page;
                                }, 0);
                            });

                        }
                    }
                    else if (pageUiState.scrollPosition) {
                        if (Capriza.Model.ContextPage.compare(pageUiState.page, pageModel)) {

                            Logger.debug("[newPage] keeping UI state for scroll position (not in tab, passed compare)");
                            Dispatcher.once("page/change/beforeTransition", function () {
                                setTimeout(function () {
                                    pageView.scrollTo(0, pageUiState.scrollPosition);
                                    delete pageUiState.scrollPosition;
                                    delete pageUiState.page;
                                }, 0);
                            });

                        } else {
                            Logger.debug("[newPage] NOT keeping UI state for scroll position (not in tab, didn't pass compare)");
                            delete pageUiState.scrollPosition;
                            delete pageUiState.page;

                        }
                    }
                }
            }


            if (currPageModel && currPageModel.tableDrill && pageModel.get("keepUiState")) {

                Logger.debug('[newPage] current page is in drill');

                var rowControlId = currPageModel.get("rowControlId"), tableId = currPageModel.get("tableId");

                var tableIdInArray = Capriza.Model.Control.getById(pageModel.get("root")[0]).getTablesInGroup();

                if (tableIdInArray.indexOf(tableId) > -1) {

                    Logger.debug('[newPage] pushing the newpage and keeping in drill');

                    $.capriza.pages.push(pageView.$el);
                    pageView.getView(tableId).keepInDrill(rowControlId, currPageModel.get('parentPage').drillIndex);

                    return;
                }
            }

            // in case of a cdialog keep the new page, but don't show it
            if ($.capriza.activePage && $.capriza.activePage.hasClass('cdialog')) {
                $.capriza.pages.push(pageView.$el);
            } else {
                pageView.show({transition: transition});
            }
        },

        _newState: function (response) {
            var state = response.state;
            //Check if the newState is for a login page and we already have a state saved for the login page.
            //In that case, it is possible that the auto-login had failed, and we receive an update in the login page.
            //Need to merge the new state with the former login state - #20264 (otherwise button labels are lost)
            if (Capriza.StateManager.structs[state.ctxId] && Capriza.StateManager.structs[state.ctxId].login && Capriza.StateManager.states[state.ctxId]){
                Logger.debug("[Blueprint] Received another state for Login page as new state, merging with former state");
                state = Capriza.StateManager.mergeStates(Capriza.StateManager.states[state.ctxId].default, state);
            }
            var pageState = Capriza.StateManager.mergeStructureState({state: state, structure: response.structure && response.structure[0]});
            if (pageState.login)
                processLoginMessage(pageState, response);
            else {
                this.newStateWithStructure(pageState, response);
                Capriza.StateManager.isCachedBlueprintShown = false;
            }
        },

        addStructure: function (response) {
            //check first if we already have these structure, becuase of #19570, in android the background run doesn't
            //save the allStruct and modelId in the localStorage. So we could have a situation where we have a structure that is not
            //in allStructs, meaning after mobile-engine sync, the structure would be sent to the mobile again. In that case
            //we need to ignore it.
            var newStructures = ignoreExistingStructures(response.structure);

            Capriza.StateManager.addStructure(newStructures);

            return newStructures.length > 0;
        },

        changeStruct: function (response) {
            Capriza.StateManager.updateStructure(response);
            var isRecordMode = (window.isDesignerPreview || window.designerLoaded) && $("html").attr("designer-state") === "simplify";

            var removed = response.removed || [],
                added = response.added ? Object.keys(response.added).map(function (mcIdKey) {
                    var addedObj = response.added[mcIdKey],
                        result = {
                            id: mcIdKey,
                            index: addedObj.index,
                            parent: addedObj.parent,
                            control: _.extend(addedObj.struct, addedObj.state)
                        };
                    // When a control is optional we get missing in the struct, but visibility missing is in the state
                    if (addedObj.state && result.control.missing) {
                        result.control.missing = addedObj.state.missing;
                    }
                    if (isRecordMode && result.control.missing) {
                        result.control.isPhantom = true;
                    }
                    return result;
                }) : [],
                modified = response.modified ? Object.keys(response.modified).map(function (mcIdKey) {
                    var modifiedObj = response.modified[mcIdKey];
                    var result = {id: mcIdKey, control: _.extend(modifiedObj.struct, modifiedObj.state)};
                    if (modifiedObj.state && result.control.missing) {
                        result.control.missing = modifiedObj.state.missing;
                    }
                    if (isRecordMode && modifiedObj.struct.missing && (!modifiedObj.state || modifiedObj.state.missing)) {
                        result.control.isPhantom = true;
                    }
                    return result;
                }) : [],
                pageModel = Capriza.Model.ContextPage.getByContextId(response.ctxId), // TODO: getByContextId hypothetically should return an array of pages
                eventData = {
                    added: added.map(function (addedObj) {
                        return addedObj.id;
                    }),
                    removed: removed,
                    modified: modified.map(function (modifiedControl) {
                        return modifiedControl.id
                    }),
                    response: response // TODO: check response.cached because someone is listening!!!
                };

            if (!pageModel) {
                Logger.error("pageUpdate for non existing contextId", undefined, "pageUpdateOfMissingPage", "contextId: " + response.ctxId);
            }

            Dispatcher.trigger("page/update/before", eventData);

            if (pageModel) {
                pageModel.trigger("page/update/before", eventData);
            }

            _.each(removed, function (controlId) {
                var model = Capriza.Model.Control.getById(controlId);
                if (model) {
                    model.removeFromParent();
                }

                if (pageModel.get("backControl") && (pageModel.get("backControl").id === controlId)) {
                    pageModel.unset("backControl");
                    Dispatcher.trigger("backButton/hide");
                }
            });

            _.each(added, function (addedObj) {
                var index = addedObj.index;
                var control = addedObj.control;
                var parentId = addedObj.parent;

                var existingModel = Capriza.Model.Control.getById(control.id);
                if (existingModel && existingModel.pages.indexOf(pageModel) > -1) {
                    // todo: handle case of added for control that is already present and currently phantom
                    if (existingModel.get('isPhantom')) {
                        modified.push(control);
                    }
                    else {
                        return;
                    }
                }
                else {
                    var parent = Capriza.Model.Control.getById(parentId),
                        model = new Capriza.Model.Control(control, {parent: parent});

                    parent.get("controls").splice(index, 0, model);

                    model.addPage(pageModel);
                    pageModel.trigger("page/controlAdded", model.get("id"), parentId, index);
                }


            });

            _.each(modified, function (modifiedObj) {
                var id = modifiedObj.id,
                    oldModel = Capriza.Model.Control.getById(id),
                    newModel = new Capriza.Model.Control(modifiedObj.control, {parent: oldModel.parent});

                newModel.addPage(oldModel.pages);
                _.each(newModel.pages, function (page) {
                    page.trigger("page/controlModified", id);
                });
            });

            pageModel && pageModel.trigger("page/update/after");
            eventData.pageView = $.capriza.activePage.data("pageView");
            Dispatcher.trigger("page/update/after", eventData);
        },

        calcPageDuration: function () {

            var currDuration = Date.now() - Capriza.pageTimer;
            return currDuration;
        },

        pageUpdate: function (response) {
            var removed = response.removed || null,
                added = response.added ? response.added.sort(function (x, y) {
                    return x.index > y.index ? 1 : (x.index < y.index ? -1 : 0)
                }) : [],
                modified = response.modified || null,

            // TODO: getByContextId hypothetically should return an array of pages
                pageModel = Capriza.Model.ContextPage.getByContextId(response.contextId),

                eventData = {
                    added: added.map(function (addedObj) {
                        return addedObj.control.id;
                    }),
                    removed: removed.map(function (removedObj) {
                        return removedObj.controlId;
                    }),
                    modified: modified.map(function (modifiedControl) {
                        return modifiedControl.id
                    }),
                    response: response
                };

            if (!pageModel) {
                Logger.error("pageUpdate for non existing contextId", undefined, "pageUpdateOfMissingPage", "contextId: " + response.contextId)
            }

            Dispatcher.trigger("page/update/before", eventData);

            if (pageModel) {
                pageModel.trigger("page/update/before", eventData);
            }

            _.each(removed, function (removedObj) {
                var controlId = removedObj.controlId;
                var model = Capriza.Model.Control.getById(controlId);
                if (model) {
                    model.removeFromParent();
                }

                if (pageModel.get("backControl") && (pageModel.get("backControl").id === removedObj.controlId)) {
                    pageModel.unset("backControl");
                    Dispatcher.trigger("backButton/hide");
                }
            });

            _.each(added, function (addedObj) {
                var index = addedObj.index;
                var control = addedObj.control;
                var parentId = addedObj.parent;

                var existingModel = Capriza.Model.Control.getById(control.id);
                if (existingModel && existingModel.pages.indexOf(pageModel) > -1) {
                    if (existingModel.get('isPhantom')) {
                        modified.push(control);
                    }
                    else {
                        return;
                    }
                }
                else {
                    var parent = Capriza.Model.Control.getById(parentId),
                        model = new Capriza.Model.Control(control, {parent: parent});

                    if (parent){
                        parent.get("controls").splice(index, 0, model);

                        model.addPage(pageModel);
                        pageModel.trigger("page/controlAdded", model.get("id"), parentId, index);
                    } else {
                        Logger.error("No parent control on Handle Page update, parentId: " + parentId + ", for controlId: "+ control.id);
                    }
                }
            });

            _.each(modified, function (modifiedControl) {
                var id = modifiedControl.id,
                    oldModel = Capriza.Model.Control.getById(id),
                    newModel = new Capriza.Model.Control(modifiedControl, {parent: oldModel.parent});

                newModel.addPage(oldModel.pages);
                _.each(newModel.pages, function (page) {
                    page.trigger("page/controlModified", id);
                });
            });

            pageModel && pageModel.trigger("page/update/after");

            eventData.pageView = $.capriza.activePage.data("pageView");
            Dispatcher.trigger("page/update/after", eventData);
        },

        controlUpdates: function (response) {
            Dispatcher.trigger("control/updates/before", response);

            pageManager.updateControls(response.mobileControls);
            Dispatcher.trigger("control/updates", response.mobileControls, response);
            //Capriza.updateControls(response);
        },

        modalDialog: function (response) {
            Dispatcher.trigger("blueprint/removeNewVersionMessage");
            pageManager.generateDialog(response);
            checkForSuccessfulLogin(response);
        },

        obsoleteEvent: function() {},

        loading: function (response) {
            Capriza.isLoading = true;

            var options = {
                message: response.message,
                maxAutomations: response.maxAutomations
            };
            if (response.stopBlocking !== true){
                Dispatcher.trigger("loading/start", options);
            }
            else Dispatcher.trigger("loading/stopBlocking");

            if (Capriza.designerMode && Capriza.designerMode === "simplify") return;

            if (Capriza.splashing) {
                if (response.message) {
                    Capriza.splashRenderAuthMessage(response.message, options);
                    Dispatcher.trigger("loading/automationMessage");

                }
            } else if (!Capriza.inDummyLoadingPage) {
                pageManager.showLoadingMsg(options);
            }
        },

        error: function (response) {
            Logger.debug('handling error');
            Dispatcher.trigger("blueprint/removeNewVersionMessage");
            pageManager.generateErrorPage(response);
        },


        contextNotFound: function (response) {
            Logger.tag("handlingCNF");
            Dispatcher.trigger("blueprint/removeNewVersionMessage");
            Dispatcher.trigger("application/contextNotFound", response);
            Capriza.EngineApi.Handlers.newPage(response);
            checkForSuccessfulLogin(response);
        },

        fatal: function (response) {
            Dispatcher.trigger("blueprint/removeNewVersionMessage");
            if (Capriza.splashing) {
                Dispatcher.trigger('splash/clearTimeout');
            }
            Dispatcher.trigger("application/fatalError");
            Logger.debug('fatal error occured');
            var options = {id: "fatal-error"};

            var closeZapp = $("#settings-close-zapp");
            if (Capriza.isStore) {
                closeZapp.removeClass('inactive');
            }

            var pm = new Capriza.Model.Page(options);
            var pv = new Capriza.Views.PageView({model: pm}).render();
            var messageContent;

            if (window.isDesignerPreview) {
                messageContent = "Please start over or go back to dashboard and try again";
            } else {
                messageContent = "Please exit and try again";
            }

            pv.addContent($(Handlebars.templates['cnfPage']({'title': response.reason, 'content': messageContent})));
            pv.show();

        },

        getIdentity: function (response) {
            Logger.debug('handling getIdentity ' + Date.now());
            Dispatcher.trigger("blueprint/removeNewVersionMessage");
            function sendIdentity(identity, saveCredentials) {
                pageManager.sendIdentity(identity, response.host, saveCredentials);
            }

            Dispatcher.trigger('page/loginPage');
            Capriza.getIdentity(sendIdentity, response);

            checkForSuccessfulLogin(response);
            setRequiresLogin(response);
        },

        moreItems: function (response) {
            Logger.debug('handling moreItems');
            var control = Capriza.Model.Control.getById(response.controlId);
            var controls = response.controls.map(function (c) {
                return new Capriza.Model.Control(c, {parent: control, pages: control.pages});
            });
            control.attributes.controls = control.attributes.controls.concat(controls);
            control.set("yesMore", response.yesMore);
            _.each(control.pages, function (page) {
                page.trigger("page/moreItems", control, response.startIndex);
            });
        },

        zappRedirect: function (response) {
            Logger.debug('handling zappRedirect');
            ComManager.redirect(response.zappId);
        },

        download: function (response) {
            pageManager.downloadFile(response);
            checkForSuccessfulLogin(response);
        },

        snapshot: function (response) {
            logger.info("runtime feedback sent");
        },

        css: function (response) {
            $("style#custom-css").remove();
            response.css && $("<style id='custom-css'>").text(response.css).appendTo("head");
        },

        stopLoading: function () {
            // the main.js controller takes off the loading on any response that is not 'loading' (unless stopBlocking == false)
        },

        cookies: function (response) {
            var cookies = JSON.parse(ClientCache.getItem("authCookies") || "[]");
            response.cookies.remove.forEach(function (expr) {
                var re = new RegExp(expr);
                cookies = cookies.filter(function (cookie) {
                    return !re.test(cookie.name);
                });
            });

            response.cookies.add.forEach(function (newCookie) {
                for (var i = 0; i < cookies.length; ++i) {
                    var oldCookie = cookies[i];
                    if (oldCookie.name == newCookie.name && oldCookie.host == newCookie.host && oldCookie.path == newCookie.path
                        && oldCookie.isDomain == newCookie.isDomain && oldCookie.isSecure == newCookie.isSecure) {
                        oldCookie.value = newCookie.value;
                        return;
                    }
                }
                cookies.push(newCookie);
            });
            ClientCache.setItem("authCookies", JSON.stringify(cookies));
            var cookiesMap = JSON.parse(ClientCache.getItem("authCookiesZappMap") || "{}");
            cookiesMap[location.pathname] = response.cookies.active;
            ClientCache.setItem("authCookiesZappMap", JSON.stringify(cookiesMap));
        },

        offlineEnd: function (response) {

            Capriza.Views.MVPageView.reportToWrapper('background/mvpCached', response);
        },

        caching: function (response) {
            response.cacheMobileControls.forEach(function (mcObj) {

                //var mcId = mcObj.mcId; // mcObj is {"mcId":"mc1634","interacted":true}
                //var model = Capriza.Model.Control.getById(mcId);
                //if(model && model.saveToCache){
                //    model.saveToCache();
                //}
            });
        },

        dataStoreWrite: function (data) {
            if (!window.isDesignerPreview) {
                Dispatcher.trigger('mobile/setToZappDB', {key: 'dataStore', value: data.data});
                Logger.debug('received dataStoreWrite: ' + JSON.stringify(data));
            }
            else {
                Logger.debug('ignoring dataStoreWrite in designer');
            }

        },

        closeSession: function () {
            Logger.debug('received closeSession. doing nothing.');
            Dispatcher.trigger('mobile/closeSessionReceived');
        },

        locale: function (data) {
            var locale = data.locale;
            Logger.debug('received locale: ' + locale);
            Capriza.translator.init(locale);
        },

        tiles: function (data) {
            Logger.debug('received tiles ' + JSON.stringify(data));
            Dispatcher.trigger('mobile/setToZappDB', {key: 'tiles', value: data.data});
        },

        invalidRTParams: function (data) {
            Logger.debug('received invalidRTParams ' + JSON.stringify(data));
            Dispatcher.trigger('rtParams/invalid', data);
        },

        ack: function (data) {
            Logger.debug('received ack ' + JSON.stringify(data));
            Dispatcher.trigger("message/ack", data);
        }
    };

    Capriza.EngineApi.Handlers.Utils = {};

    /**
     Process a new login message (an update on an existing, rendered login page should be handled by _updateState)
     */
    function processLoginMessage(pageState, response){

        var loginModel = new Capriza.Model.LoginPage(pageState);
        Logger.debug("[processLoginMessage] received a message for a login page");

        //if we are in the process of auto login, and this update is a "failed" auto-login,
        //if we are not in auto-login that has failed, try to perform auto login.
        //if that failed (e.g. we have no creds), trigger auto-login failed to render the login page, and return true.
        if ((Capriza.LoginManager.autoLoginPerformed == loginModel.get("contextId") && isFailedAutoLogin(response)) ||
            !Capriza.LoginManager.tryToPerformAutoLogin(loginModel)){
            Logger.debug("[processLoginMessage] triggering login/auto/failed");
            Dispatcher.trigger("login/auto/failed", loginModel);
            Utils.isCachedBlueprintShown() && Dispatcher.trigger("blueprint/newContentReady");
        }
    }

    /**
     This function determines whether or not this zapp requires login (readyForBackground, cachedMVP).
     For the background run - to know if the zapp is ready for background run (currently in terms of credentials).
     For Cached MVP - should the cached mvp page saved or not:
        1. There is no login in the zapp.
        2. There is a login (one or more), and these were successful (not pending), and the credentials were saved!
     */
    function setRequiresLogin(response){
        if (!response) return;

        var loginRequiredInTheZapp, loginIsPending, credentialsAreSavedForHosts, credentialsAreSavedForContexts, credentialsAreSaved;

        loginRequiredInTheZapp = Capriza.LoginManager.isLoginRequired();
        loginIsPending = Capriza.LoginManager.isLoginPending();
        //check if credentials are saved:
        //need to check both for hosts and for contexts - consider NTLM (only host, no context), on the other hand, consider 2 login pages with the same host (host saved, 2nd context is not)
        credentialsAreSavedForHosts = !_.some(Capriza.LoginManager.credentialsSavedForHosts, function(credentialsSavedForHost){return !credentialsSavedForHost});
        credentialsAreSavedForContexts = !_.some(Capriza.LoginManager.credentialsSavedForContexts, function(credentialsSavedForContext){return !credentialsSavedForContext});
        credentialsAreSaved = credentialsAreSavedForHosts && credentialsAreSavedForContexts;

        //determine if the Zapp is ready (in terms of credentials) for background run and to cache the MVP page.
        //either login is not required, or (if the login is required), it's not pending, and the all the required credentials are saved
        var ready = !loginRequiredInTheZapp || (!loginIsPending && credentialsAreSaved);
        Logger.info("[setRequiresLogin] zapp readyness for background and cached MVP: " + ready);
        Dispatcher.trigger("mobile/setToZappDB", {key: 'readyForBackground', value: ready});
        Capriza.StateManager.readyForCaching = ready;
    }

    /**
     This function determines if this message from the Engine is considered as a login success (of the pending login).
     This update will be considered a success (assuming there is a pending login) in the following cases:
        1. resultType == 'download'
        2. This message is NTLM (getIdentity), and the pending login is a regular (context) login.
        3. This message is NTLM (getIdentity), and the pending login is also an NTLM but for a DIFFERENT host.
        4. This is a loadState message, while the pending login is NTLM.
        5. This is a loadState message, while the pending login is a regular (context) login,
           for a different context, that is not marked as "loginFailed" page.

     If this Engine message is considered a successful login, an mobile/login/success event is triggered.
     Otherwise, nothing happens.
     */
    function checkForSuccessfulLogin(response){
        var loginSuccessful;

        if (!Capriza.LoginManager.isLoginRequired()) {
            Logger.info ("[checkForSuccessfulLogin] Zapp currently does not require login");
            return;
        }

        if (Capriza.LoginManager.isLoginPending()) { //if there is no login pending, meaning all hosts are logged in-to successfully

            Logger.debug("[checkForSuccessfulLogin] Zapp requires login and it is pending..");

            //for download messageTypes, assuming successful login
            if ( response.resultType == "download" ) {
                loginSuccessful = true;
                Logger.debug("[checkForSuccessfulLogin] Got " + response.resultType + " while login pending, assuming successful login");
            }
            else if (response.resultType == "getIdentity") {
                //check if there is a context pending (regular login, not NTLM), ASSUMPTION: only one "false" (pending) context at a time
                var contextPending = Capriza.LoginManager.getContextPendingLogin(),
                    ntlmForDifferentHost = Capriza.LoginManager.getHostPendingLogin() != response.host;
                //if there is a context pending (regular login pending), this means it was a success.
                if (contextPending) {
                    loginSuccessful = true;
                    Logger.debug("[checkForSuccessfulLogin] Received getIdentity while context login is pending, setting the former as a successful login");
                }
                if (!contextPending && ntlmForDifferentHost) {
                    loginSuccessful = true;
                    Logger.debug("[checkForSuccessfulLogin] Received getIdentity while a previous NTLM login is pending, since this is for a different host, setting the former as a successful login");
                }
            }
            else if (response.resultType == "loadState") {
                var contextPending = Capriza.LoginManager.getContextPendingLogin();
                if (!contextPending) {
                    loginSuccessful = true;
                    Logger.debug("[checkForSuccessfulLogin] Received loadState when login is pending with no context (NTLM), setting the former as successful");
                }
                else if (contextPending != response.state.ctxId) { // if the current message is for a different context (than the pending login one).
                    //this could be either the next page in the Zapp => login success; or a login failed page => failed login
                    var currentStructure = Capriza.StateManager.structs[response.state.ctxId];
                    loginSuccessful = !currentStructure.failedLogin;
                    Logger.debug("[checkForSuccessfulLogin] Received loadState for a different context (failedLogin flag = '"+ currentStructure.failedLogin +"') while login is pending, setting the former as " + (loginSuccessful ? 'successful' : 'failed') + " login");
                }
            }
        }

        //Does this update considered as login success?
        if (loginSuccessful) {
            Dispatcher.trigger("mobile/login/success");
        }
    }

    /**
     * Sorts the controls of the state according to the position in the structure hierarchy.
     * The higher the control is in the hierarchy of the structure (container), the earlier it will be in the sorted array.
     */
    function sortStateControls(state){
        if (!state || !state.controls) return [];

        var ids = Object.keys(state.controls);
        if (ids.length == 1) return ids;

        var sortedStructureControls = Capriza.StateManager.getStructureControlsSorted(state.ctxId);
        var sortedControlIds = ids.sort(function(c1, c2){
            return sortedStructureControls.indexOf(c1) - sortedStructureControls.indexOf(c2);
        });

        return sortedControlIds;
    }

    function indexToAdd(model) {
        var idxI = 0, idxRet;
        model.parent.get("controls").forEach(function (ctrl) {
            if (ctrl.get("id") == model.get("id")) {
                idxRet = idxI;
            }
            else if (!ctrl.get("missing")) {
                idxI++;
            }
        });
        return idxRet;
    }

    function ignoreExistingStructures(structures){
        if (!structures) return;

        if (!window.isDesignerPreview && !window.designerLoaded)
             return structures.filter(function(struct){
                 return !Capriza.StateManager.structs[struct.contextId]});

        return structures;
    }

    function isFailedAutoLogin(response){
        var whiteListProps = ['lastMsgId'];

        //go through all the controls in the received state, and look for one that has un-skippable update ==> failed login
        var loginFailed = _.some(response.state.controls, function(controlState, controlId){
            var controlStruct = Capriza.StateManager.getStructureForControl(response.state.ctxId, controlId);

            if (!controlStruct) {
                Logger.debug("[isFailedLogin] ERROR: structure for control '" + controlId + "' in context '" + response.state.ctxId + "' not found.");
                return;
            }
            if (!controlStruct.autoLoginSkipUpdates){
                Logger.debug("[isFailedLogin] got update on control without autoLoginSkipUpdates --> failed login (id = '" + controlId + "')");
                return true;
            }
            else { //there shouldn't be even one prop that cannot be skipped
                return _.some(controlState, function(propValue, propName){
                    var updateCannotBeSkipped = whiteListProps.indexOf(propName) == -1 && controlStruct.autoLoginSkipUpdates.indexOf(propName) == -1;
                    if (updateCannotBeSkipped){
                        Logger.debug("[isFailedLogin] found a control update that cannot be skipped. controlId: " + controlId + ", updated property: " + propName + "='" + propValue + "'");
                        return true;
                    }
                    return false;
                });
            }
        });

        Logger.debug("[isFailedAutoLogin] checking for failed auto login: " + loginFailed);
        return loginFailed;
    }

    //for unit tests
    Capriza.EngineApi.Handlers.Utils.checkForSuccessfulLogin = checkForSuccessfulLogin;
    Capriza.EngineApi.Handlers.Utils.setRequiresLogin = setRequiresLogin;
    Capriza.EngineApi.Handlers.Utils.sortStateControls = sortStateControls;
    Capriza.EngineApi.Handlers.Utils.ignoreExistingStructures = ignoreExistingStructures;
    Capriza.EngineApi.Handlers.Utils.isFailedLogin = isFailedAutoLogin;

})();

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/main.js

try{
/**
 * Created by JetBrains WebStorm.
 * User: ycarmel
 * Date: 9/7/11
 * Time: 11:46 PM
 */

(function () {

    window.handleResponse = function (response) {
        try {
            if (!response.op || response.op == 'ROUTE') {

                Dispatcher.trigger("engine/message", response);

                if (response.resultType !== 'loading' && !Capriza.firstPage) {
					Capriza.firstPage = true;
					take("firstPage");
					take.startReason = response.resultType;
                }
                logger.log('handling '+response.resultType);

                if (!window.isDesignerPreview && response.mvp && !Utils.isInDevMode() && !Utils.isInDashboard()) {
                    var responseClone = $.extend(true, {}, response);
                }


                var handler = Capriza.EngineApi.Handlers[response.resultType];

                if (handler) {
                    handler(response);
                } else {
                    pageManager.generateErrorPage({reason: 'Received unknown result type: '+response.resultType});
                }

                Dispatcher.trigger('engine/message/after', response);


            } else if (response.op == 'SERVER_MESSAGE') {//SERVER_MESSAGE is only pre close socket messages.
                ComManager.serverMessageEndSent = true;
                pageManager.generateErrorPage({nonFatal:true, reason:response.content});
                ComManager.onEndMessageReceived();
                Dispatcher.trigger("handleResponseError", response);
            }
        } catch (e) {
            pageManager.handleException(e);
        }
    };

    function send(operation, event) {
        try {
            setTimeout(function () {
                pageManager.handleRequest(operation, event);
            }, 0);
        } catch (e) {
            pageManager.handleException(e);
        }
    }

    pageManager.handleException = function (e) {
        var ex = e || {};
        try {
            ex.errorType = 'unhandledException';
            ex.stack = e.stack; //stack and message are getters and not real properties so it is not serialized automatically.
            ex.errorMessage = e.message;
            Logger.error("Unhandled exception occurred", ex, 'unhandledException');
        } catch (exInner) {
        }
        throw e;
    };


    pageManager.triggerEvent = function (event) {
        pageManager.addMobId(event);
        send('ROUTE', event);
    };

    Capriza.mcLastMobId = {};

    pageManager.addMobId = function(event){
        if(event.type !== "bulk" ) {
            event.msgId = "mob" + pageManager.actionCounter++;
            if (event.type == "mcAction") Capriza.mcLastMobId[event.controlId] = event.msgId;
        }
        return event;
    };

    pageManager.handleRequest = function (operation, event) {
        if (window.ComManager) {
            window.ComManager.send(operation, event);
        }

    };

    pageManager.showLoadingMsg = function (options) {
        if ((Utils.isCachedMVPShown("mvppp") || Utils.wasCachedMVPShown()) && Utils.isUnimessageShown()) return;
        if(Utils.isCachedBlueprintShown()) return;
        $.capriza.showLoadingMsg(undefined, options); // NOTE: sending true means isClient, which isn't really the case, but we changed implementation so that also server side loading will show the spinner for a 1.5sec

    };

    pageManager.hideLoadingMsg = function () {
        $.capriza.hideLoadingMsg();

    };

    pageManager.sendIdentity = function (identity, host, saveCredentials) {
        Logger.debug('sending login (identity) now '+Date.now());

        var identityMsg = {type:"identity", identity:identity, host:host, encrypt:true};
        Capriza.LoginManager.addMessageForBulk(identityMsg);
        saveCredentials && Capriza.LoginManager.writeCredentialsToFile();
        pageManager.triggerEvent(identityMsg);
    };


    window._handleResponse = function(response) {
        window.handleResponse(JSON.parse(response));
    };

    window.previewModeSetup = function (handler) {
        Capriza.previewMode = true;
        pageManager.handleRequest = function (operation, event) {
            handler.hr(event, _handleResponse);
        };

        ComManager.connectionInit(send);
    };

    window.setUserSession = function (data) {
        data.userSessionData = true;
        pageManager.triggerEvent(data);
    };



//    debug
    var debug=window.debug = $.extend({}, window.debug);
    debug.responses = [];
    debug.actions = [];
    debug.records = [];
    debug.interactions = [];


    //    used for monitoring purposes, sent updated on every action
    pageManager.actionCounter=0;

    var originalHandleResponse = window.handleResponse;

    window.handleResponse = function () {
        var engineResponse = $.extend(true,{},arguments[0]);

        engineResponse.timestamp = Date.now();
        var self = this, origArg = arguments;

        if (Capriza.messageQueue){
            Logger.info ("[main.js] Engine message received. Saving it to a queue (not processing it). messageType: " + engineResponse.resultType);
            Capriza.messageQueue.push (
                new Utils.QueueTask({
                    name: 'handleResponse-' + engineResponse.resultType,
                    async: false,
                    taskFunction: function(){runWrappedHandleResponse.apply(self, origArg)}
                })
            );
        }
        else runWrappedHandleResponse.apply(this, arguments);

    };

    function runWrappedHandleResponse(){
        var engineResponse = $.extend(true,{},arguments[0]),
            profileEvent;
        if (Capriza.Profiler && Capriza.Profiler.on) {
            profileEvent = new Capriza.Profiler.ProfileEvent({direction: "eng-mob",async:true});
            profileEvent.eventData = Utils.flattenObject(engineResponse);
            profileEvent.data.msgId = engineResponse.msgId;
        }
        engineResponse.timestamp = Date.now();
        debug.responses.push(engineResponse);
        debug.records.push(engineResponse);
        originalHandleResponse.apply(this, arguments);

        if (Capriza.Profiler && Capriza.Profiler.on) {
            profileEvent.end && profileEvent.end();
        }
    }

    var originalTriggerEvent = pageManager.triggerEvent;

    pageManager.triggerEvent = function () {
        var mobileAction = $.extend(true,{},arguments[0]);

        if(mobileAction.encrypt){
            if(mobileAction.identity){
                _.each(mobileAction.identity,function(value,key){mobileAction.identity[key]="******"})
            }else{
                mobileAction = {
                    type:"mcAction",
                    controlId: mobileAction.controlId,
                    contextId: mobileAction.contextId,
                    action: mobileAction.action,
                    value:"$$Encrypted$$",
                    auto: mobileAction.auto
                };
            }

        }
        mobileAction.timestamp = Date.now();


        if (Capriza.Profiler && Capriza.Profiler.on) {
            var profileEvent = new Capriza.Profiler.ProfileEvent({direction: "mob-eng",async:true});

            profileEvent.eventData = Utils.flattenObject(mobileAction);


            profileEvent.data.msgId = "mob" + pageManager.actionCounter;


        }

        debug.actions.push(mobileAction);
        debug.records.push(mobileAction);


        originalTriggerEvent.apply(this, arguments)
    };

    // protecting from appcache not updated (TODO: dor to fix)
    if (window.takeJSExecute) window.takeJSExecute("jsExecuteEnd");

    function holdEngineMessages(){
        //create the message queue:
        Capriza.messageQueue = new Utils.Queue('messageQueue');
        var queueTask = new Utils.QueueTask({
            name: 'mobile/handlers/stop',
            async: true,
            taskFunction: function(finishCallback){
                //wait for the handlers to resume
                Dispatcher.once ("mobile/handlers/resume", function(){
                    //once the handlers are resumed, start processing all the messages in the queue, and when it is finished
                    //(the 'empty' event), remove the queue
                    Logger.info("[main.js] received mobile/handlers/resume event, start to process the messages");
                    Capriza.messageQueue.on('empty', function(){
                        Logger.info("[main.js] messageQueue has emptied, deleting the queue");
                        Capriza.messageQueue = null;
                    });
                    finishCallback && finishCallback();
                });
            }
        });

        Capriza.messageQueue.push (queueTask);
    }

    //currently on once is supported
    Dispatcher.once("mobile/handlers/stop", holdEngineMessages);
})();


}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};

//! Source: javascripts/BackButtonManager.js

try{
/**
 * Created by Bar on 12/30/13.
 * Manage the native back button
 */

(function(){
    function init(){

        // Versions of browsers supported:
        // IE >= 10
        // FF >= 4
        // Chrome >= 5
        // Safari >= 5
        // Opera >= 11.5
        // iOS >= 5
        // Blackberry >= 7
        // Android: 2.2 2.3 4.2 4.3 4.4
        var isPlatformSupportPushState = !!(window.history && window.history.pushState);
        var isFlag = window.appData && window.appData.config.androidBackButtonDisabled;
        if (!Capriza.device.android || !isPlatformSupportPushState || isFlag) return;

        // when running in non-local environments we get to this line of code after the has been already loaded.
        if (document.readyState != "complete") {

            // In some browsers popstate is triggered when the browser finishes loading. So adding setTimeout(0) solves this
            window.addEventListener("load", function() {
                setTimeout(enableBackButton, 0)
            });
        } else {
            setTimeout(enableBackButton, 0);
        }

        Logger.debug("Android back button is active");
    }

    /**
     * Let the user use the native back button
     */
    function enableBackButton() {

        /**
         * adds the custom history entry.
         * When there the stack contains at least one Capriza state, the browser will remain in the zapp even though
         * any native backbutton is clicked
         */
        function addHistory() {
            Logger.debug("BB history added");
            var prefixUrlIndex = document.URL.lastIndexOf('/');
            window.history.pushState({capriza: "stackManagement"}, "Capriza", document.URL.substring(prefixUrlIndex + 1));
        }

        function exit(){
            if(Capriza.isAppZapp) {
                window.close();
            }
            else if (Capriza.isPhonegap){
                Dispatcher.trigger("app/close"); // use the logic of close zapp button
            } else {
                window.removeEventListener("popstate", onNativeBackButtonClicked);
                window.history.go(-2);
            }
        }

        function isDialogPage(){
            return $.capriza.activePage && $.capriza.activePage.hasClass('cdialog') && $.capriza.activePage.hasClass('confirm');
        }

        function isMobiscrollDialogOpen(){
            var isOpen = false;
            Object.keys($.mobiscroll.instances).forEach(function(inst){
                isOpen = isOpen || $.mobiscroll.instances[inst].isVisible();
            });
            return isOpen;
        }

        function isBubbleOpen(){
            return $('.bubble-content.active').length > 0;
        }

        function isCnfPage(){
            return $.capriza.activePage && $.capriza.activePage.attr('id') === 'context-not-found';
        }

        function isDropdownPopoverOpen(){
            return $(".popover-dropdown.active, .modal-dropdown.active").length > 0;
        }

        function isFeedbackPage(){
            return $('#feedback-page').hasClass('active');
        }

        function isFeedbackPageInTransit(){
            return $('#feedback-page').hasClass('transitioning');
        }

        function isBackButtonVisible(){
            return $('.back-button.active').length > 0;
        }

        function isUIBlocked(){
            return $("#viewport-overlay").hasClass('active') && !$("#viewport-overlay").hasClass("side-menu");
        }

        function clickOnBackButton(){
            $('.back-button.active').click();
        }

        function clickOnCNFBackButton(){
            $("#cnf-back").click();
        }

        function clickOnDialogCancelButton(){
            $('.real-button.dialog-cancel', $.capriza.activePage).click();
        }

        function closeMobiscrollDialog(){
            Object.keys($.mobiscroll.instances).forEach(function(inst){
                $.mobiscroll.instances[inst].cancel();
            });
        }

        function isConfirmMessage(){
            return $(".confirmer").length;
        }
        function closeConfirmMessage() {
            var $confirmMessageClose = $(".confirmer-button.confirmer-btn2 button",".confirmer");
            if ($confirmMessageClose.length){
                $confirmMessageClose.click();
            }
        }


        function isSettingPage() {
            var $settingPage = $("#settings-page");
            return $settingPage.length;
        }
        function closeSettingPage() {
            var $settingPageClose = $(".settings-header button","#settings-page");
            if ($settingPageClose.length){
                $settingPageClose.click();
            }
        }

        function isContextMenuOpen() {
            var $contextMenu = $(".extra-action");
            return $contextMenu.length;
        }

        function closeContextMenu() {
            var $contextMenuShield = $(".global-shield.extra-actions");
            if ($contextMenuShield.length){
                $contextMenuShield.click();
            }
        }

        function isSideMenuOpen() {
            var $sideMenu = $("#side-menu");
            return $sideMenu.hasClass("active") && $sideMenu.hasClass("sidemenu-opened");
        }

        function closeSideMenu() {
            var $sideMenu = $("#side-menu"),
                sideMenuView = $sideMenu.data("pageView");
            sideMenuView && sideMenuView.toggleMenu();
        }

        function closePopupDialog() {
            var $popover = $(".popover-dropdown.active, .modal-dropdown.active"),
                mcId = $popover.data("popover-mc") || $popover.data("modal-mc"),
                pageView = $.capriza.activePage.data("pageView"),
                popoverView = pageView.getView(mcId);

            popoverView.hideDropdown(true);
        }

        function clickOnCancelFeedback(){
            Dispatcher.trigger('feedback/close');
        }

        function unblockUI(){
            Dispatcher.trigger('unblockUI');
        }

        function isExistSingleActivePage(){

            // taken from SpecHelper
            var activePage = $(".page.active:not(#feedback-page)");
            return activePage.length === 1 && !(activePage.hasClass("in") || activePage.hasClass("out") || activePage.hasClass("pre"))
        }

        function isLoadingMessageAppears(){
            return !$('.loading-message').hasClass('hidden');
        }

        function isSplashScreen(){
            return $("#new-splash").length > 0;
        }

        function isPasscodeActive(){
            return $("#passcode-page").hasClass('active');
        }

        var lastWarnDate;
        var hasWarned = false;
        function warnAboutExit(){
            hasWarned = true;
            lastWarnDate = new Date();
            Dispatcher.trigger('dialog/show', {
                //msg: 'Press again to exit',
                msg: Capriza.translator.getText(Capriza.translator.ids.pressAgain),
                refreshButton: false
            });

            setTimeout(function(){
                hasWarned = false;
                Dispatcher.trigger('dialog/hide');
            }, 1250);
        }

        function hasWarnedAboutExit(){
            return hasWarned;
        }

        /**
         * pop state is triggered by the browser's back button or Android's back button
         */
        function onNativeBackButtonClicked(e) {

            Logger.debug('onNativeBackButtonClicked with '+ e.type);

            var $mcBackButton = $('.active .back-button').find('button');
            if (!Capriza.isPhonegap) addHistory();

            if (isPasscodeActive()) {
                Logger.debug('BB - Passcode in open. User has to fill the passcode.');
            }
            //else if(!Capriza.canUnblockUI()){
            //    Logger.debug('BB - ignored, the UI cannot be unblocked');
            //}
            else if(isFeedbackPageInTransit()){
                Logger.debug('BB - ignored, feedback in transition');
            }
            else if (isSplashScreen()){
                Logger.debug('BB - ignored, splash screen is on');
            }
            else if (isConfirmMessage()){
                Logger.debug('BB - confirmation message is displayed, click on cancel');
                closeConfirmMessage();
            }
            else if (isSettingPage()){
                Logger.debug('BB - setting page is open, click on done');
                closeSettingPage();
            }
            else if(isContextMenuOpen()){
                Logger.debug('BB - ui is blocked - unblock it (popup context menu is open)');
                closeContextMenu();
            }
            else if(isUIBlocked()){
                Logger.debug('BB - ui is blocked - unblock it (settings or notification menu is open, close them)');
                unblockUI();
            }
            else if(isSideMenuOpen()){
                Logger.debug('BB - Side menu is open, close it');
                closeSideMenu();
            }
            else if(isFeedbackPage()){
                Logger.debug('BB - current page is feedback, click the cancel button to return');
                clickOnCancelFeedback();
            }
            else if (!isExistSingleActivePage()){
                Logger.debug('BB - ignored,  the number of active pages doesnt equal to one');
            }
            else if(isLoadingMessageAppears()){
                if (hasWarnedAboutExit()) {
                    Logger.debug('BB - exit app.');
                    exit();
                } else {
                    Logger.debug('BB - ignored, loading message appears');
                }
            }
            else if(isMobiscrollDialogOpen()){
                Logger.debug('BB - mobiscroll dialog is open, closing it');
                closeMobiscrollDialog();
            }
            else if(isDropdownPopoverOpen()){
                Logger.debug('BB - Dropdown Popup is open, clicking on shield to close popup');
                closePopupDialog();
            }
            else if(isBubbleOpen()){
                Logger.debug('BB - bubble is open, closing it');
                Dispatcher.trigger('bubbles/hide')
            }
            else if (isBackButtonVisible()){
                Logger.debug('BB - regular back button is visible, using its functionality');
                clickOnBackButton();
            }
            else if (isDialogPage()){
                Logger.debug('BB - Current page is dialog, clicking on cancel button');
                clickOnDialogCancelButton();
            }
            else if(isCnfPage()){
                Logger.debug('BB - Current page is CNF, clicking on back button');
                clickOnCNFBackButton();
            }
            else if($mcBackButton.length > 0){
                $mcBackButton.click();
            }
            else {
                Logger.debug('BB - show warning before closing zapp');
                warnAboutExit();
            }
        }

        // The idea is to add stack entry when the page contains custom back button, and to remove it if it doesn't
        if (Capriza.isPhonegap || Capriza.cordova){
            document.addEventListener("backbutton", onNativeBackButtonClicked, false);
        } else {
            window.addEventListener("popstate", onNativeBackButtonClicked);
        }

        Dispatcher.on("app/beforeClose", function(){
            if (Capriza.isPhonegap || Capriza.cordova) {

                // In case that event listener had been removed before the store was loaded,
                // the BB will be "free" and the user will be able to mess around with the stack
                setTimeout(function(){
                    document.removeEventListener("backbutton", onNativeBackButtonClicked);
                }, 5000);
            }
        });

        addHistory();
    }

    init();
}());

}catch(e){window && window.logger ? logger.error('#error #uncaught message: '+ (e.message || e)+' Stack: '+e.stack) : console.error(e+' Stack: '+e.stack); 
};